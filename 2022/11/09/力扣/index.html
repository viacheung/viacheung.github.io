<!DOCTYPE html>
<html>
	<head>
		
<title>力扣-</title>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="shortcut icon" type="image/x-icon" href="/image/favicon.ico">

<link rel="stylesheet" href="/css/index.css">


<meta name="keywords" content="算法,魔方,开发">
<meta name="description" content="总结技术，撰写心得，分享生活">


<script src="/js/jquery.min.js"></script>


<script src="/js/index.js"></script>


<script src="/js/fancybox.umd.js"></script>


<script src="/js/fancybox-images.js"></script>


<script src="/js/gitalk.min.js"></script>


<script src="/js/hljs.min.js"></script>
 
<script>hljs.initHighlightingOnLoad();</script>

	<meta name="generator" content="Hexo 6.1.0"></head>

	<body>
		
	<div class="header">
		<div class="header-top" id="header-top">
			<div class="h-left">
				<a href="/">
					<img src="/image/logo.png" alt="Quiet">
				</a>
			</div>
			<div class="h-right">
				<ul>
					
						
								<li>
									<a href="/">
										首页
									</a>
									<span class="dot"></span>
								</li>
								
									
						
								<li>
									<a href="/archives">
										存档
									</a>
									<span class="dot"></span>
								</li>
								
									
						
								<li>
									<a href="/categories">
										分类
									</a>
									<span class="dot"></span>
								</li>
								
									
						
								<li>
									<a href="/tags">
										标签
									</a>
									<span class="dot"></span>
								</li>
								
									
						
								<li>
									<a href="/links">
										友链
									</a>
									<span class="dot"></span>
								</li>
								
									
						
								<li>
									<a href="/about">
										关于我
									</a>
									<span class="dot"></span>
								</li>
								
									
				</ul>
			</div>
			<div class="h-right-close">
				<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24">
					<path fill="none" d="M0 0h24v24H0z" />
					<path d="M3 4h18v2H3V4zm0 7h18v2H3v-2zm0 7h18v2H3v-2z" fill="rgba(68,68,68,1)" />
				</svg>
			</div>
		</div>
	</div>
	<div class="sidebar">
    <div class="topo">
        <h2>weiyang</h2>
    </div>
    <ul>
        
        <li>
            <a href="/">首页</a>
        </li>
        
        <li>
            <a href="/archives">存档</a>
        </li>
        
        <li>
            <a href="/categories">分类</a>
        </li>
        
        <li>
            <a href="/tags">标签</a>
        </li>
        
        <li>
            <a href="/links">友链</a>
        </li>
        
        <li>
            <a href="/about">关于我</a>
        </li>
        
    </ul>
    <div class="my_foot">
        
        <a href="https://github.com/viacheung">
            <img src="https://cdn.jsdelivr.net/gh/duogongneng/MyBlogImg/imggithub.png" alt="Quiet主题">
        </a>
        
        <a href="https://blog.csdn.net/qq_47897934?spm=1000.2115.3001.5343">
            <img src="https://bce.bdstatic.com/portal/img/customer/case/csdn/logo_c76b3044.png" alt="Quiet主题">
        </a>
        
        <a href="https://www.zhihu.com/people/qi-yi-shao-nu-de-meng-29-3">
            <img src="https://photo.16pic.com/00/56/07/16pic_5607016_b.jpg" alt="Quiet主题">
        </a>
        
    </div>
</div>
<div class='shelter'>
</div>
<style>
    .shelter{
        background-color: #333;
        opacity:0.5;
        cursor: pointer;
        display: none; 
        position: fixed;
        left: 0;
        top: 0; 
        right: 0;
        bottom: 0;
        z-index: 1998;
    }
    .sidebar {
        width: 0;
        height: 100%;
        position: fixed;
        top: 0;
        right: 0;
        bottom: 0;
        background: #fff;
        z-index: 1999;
        text-align: center;
        box-shadow: -6px 0 20px rgba(98, 94, 94, .815)
    }

    .topo {
        width: 100%;
        height: 200px;
        background: url(https://api.ixiaowai.cn/gqapi/gqapi.php) no-repeat;
        background-size: 100% 100%;
        position: relative;
        display: flex;
        align-items: flex-end
    }

    .topo h2 {
        color: #fff;
        z-index: 1;
        position: relative;
        margin: 0 0 10px 10px;
        font-size: 1.2em;
        box-sizing: border-box
    }

    .topo:before {
        content: '';
        background-image: url(/image/pattern.png);
        background-repeat: repeat;
        height: 100%;
        left: 0;
        position: absolute;
        top: 0;
        width: 100%;
        z-index: 1
    }

    .sidebar ul {
        width: 100%;
        margin-top: 50px
    }

    .sidebar ul li {
        height: 50px;
        list-style: none;
        font-size: 1.2em;
        text-align: right;
        margin-right: 10px
    }

    .sidebar ul li a {
        display: grid;
        color: #5d606a;
        text-overflow: ellipsis;
        width: 100%;
        text-decoration: none
    }

    .my_foot {
        width: 100%;
        padding: 10px;
        margin-bottom: 10px;
        position: absolute;
        bottom: 0
    }

    .my_foot a {
        text-decoration: none;
        margin-right: 10px;
        display: inline-block
    }

    .my_foot a img {
        width: 30px;
        height: 30px
    }
</style>

<script>
    $( function () {
	$( '.h-right-close>svg' )
		.click( function () {
			$( '.sidebar' )
				.animate( {
					width: "66%"
				}, 500 );
			$( '.shelter' )
				.fadeIn( "slow" )
		} );
	$( '.shelter' )
		.click( function ( e ) {
			$( '.sidebar' )
				.animate( {
					width: "0"
				}, 500 );
			$( '.shelter' )
				.fadeOut( "slow" )
		} )
} )

</script>

<div class="post">
    <div class="post-header-background post-header-img"
    style="background: url('https://api.ixiaowai.cn/gqapi/gqapi.php')" 
>
    <div class="post-header-background-content">
        <ul class="post-header-tag">
            
        </ul>
        
        <h1>力扣</h1>
        <div class="post-header-info">
            <div class="post-header-info-author">
                
                    <svg t="1604839279282" class="icon" viewBox="0 0 1024 1024" version="1.1"
                        xmlns="http://www.w3.org/2000/svg" p-id="2901" width="20" height="20">
                        <path
                            d="M513 956.3c-247.7 0-448-200.3-448-448S265.3 66.2 513 66.2s448 200.3 448 448-200.3 442.1-448 442.1z m0-830.9c-212.2 0-388.8 170.7-388.8 388.8C124.2 726.3 294.9 903 513 903c212.2 0 388.8-170.7 388.8-388.8S725.2 125.4 513 125.4z m0 430.2c-94.2 0-170.7-76.5-170.7-170.7S418.8 207.8 513 207.8s170.7 76.5 170.7 170.7S607.2 555.6 513 555.6z m0-289.1c-64.6 0-112 52.8-112 112s47.4 117.9 112 117.9 112-52.8 112-112-47.4-117.9-112-117.9z m0 689.8c-135.7 0-259-58.7-341.9-158.9l-11.8-17.8 11.8-17.8c76.5-117.9 206.2-188.5 347.8-188.5 135.7 0 265 64.6 341.9 182.6l11.8 17.8-11.8 17.8C778 897.1 648.7 956.3 513 956.3zM230.3 773.2C300.9 849.7 406.9 897 513 897c112 0 218.1-47.4 288.6-129.8-70.5-88.2-170.7-135.6-282.7-135.6s-218.1 53.3-288.6 141.6z"
                            p-id="2902" fill="#ffffff"></path>
                    </svg>
                    
                <span class="post-header-info-author-text"> <a href="../../about">weiyang</a></span>
                <div class="post-header-info-author-categories">
                    
                </div>
                <p>2022-11-09 23:27:03</p>
            </div>
        </div>
    </div>
</div>
    <div class="post-content" id="content">
  
  <div id="article" class="post-content-info">
    

    <h1 id="java基础"><a href="#java基础" class="headerlink" title="java基础"></a>java基础</h1><h2 id="代码写法"><a href="#代码写法" class="headerlink" title="代码写法"></a>代码写法</h2><p>while（条件）; 如果没有结构体那么需要写分号。</p>
<h2 id="和-的区别"><a href="#和-的区别" class="headerlink" title="|和||的区别"></a><strong>|和||的区别</strong></h2><p>||会短路</p>
<h2 id="数组初始化内容"><a href="#数组初始化内容" class="headerlink" title="数组初始化内容"></a>数组初始化内容</h2><p>int float double : 0</p>
<p>boolean: false</p>
<p>String : null</p>
<p>char : 空格</p>
<h2 id="求长度三剑客"><a href="#求长度三剑客" class="headerlink" title="求长度三剑客"></a>求长度三剑客</h2><img src="/.xyz//image-20220919155428203.png" alt="image-20220919155428203" style="zoom:50%;">

<h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><p><strong>转Int</strong></p>
<p>Integer.valueOf()和Integer.parseInt()</p>
<p>valueOf(String)方法会返回Integer类的对象，而parseInt(String)方法返回原始的int值。</p>
<p>xx.valueOf(a) 把a转为xx类型； xx.valueOf(a，0，n) 表示把a转为xx类型，同时取下标从0开始的n个数据；</p>
<p><strong>判断字符串相等</strong></p>
<p>1、&#x3D;&#x3D;              引用</p>
<p>2、.equals()    内容   （用这个）</p>
<h2 id="List系列"><a href="#List系列" class="headerlink" title="List系列"></a>List系列</h2><p><a href="https://zhuanlan.zhihu.com/p/181428633">ArrayList</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/182470738">LinkedList</a></p>
<h2 id="Queue系列"><a href="#Queue系列" class="headerlink" title="Queue系列"></a>Queue系列</h2><ul>
<li><p><strong>ArrayDeque</strong></p>
<p>ArrayDeque 是 Java 集合中<strong>双端队列</strong>的<strong>数组实现</strong>，双端队列的链表实现（<strong>LinkedList</strong>）我们在前几篇文章中讲过了。</p>
<p>ArrayDeque 几乎没有容量限制，设计为<strong>线程不安全的</strong>，<strong>禁止 null 元素</strong>。</p>
<p>ArrayDeque 作为<strong>栈</strong>使用时<strong>比 Stack 类效率要高</strong>，作为<strong>队列</strong>使用时<strong>比 LinkedList 要快</strong>。</p>
</li>
</ul>
<h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h3><p>ArrayList 类是一个可以动态修改的数组，与普通数组的区别就是它是没有固定大小的限制，我们可以添加或删除元素。</p>
<p><strong>添加元素</strong></p>
<p>ArrayList 类提供了很多有用的方法，添加元素到 ArrayList 可以使用 add() 方法:</p>
<p><strong>访问元素</strong></p>
<p>访问  ArrayList 中的元素可以使用 <strong>get()</strong> 方法</p>
<p><strong>修改元素</strong></p>
<p>如果要修改  ArrayList 中的元素可以使用 <strong>set()</strong> 方法：</p>
<p><strong>删除元素</strong></p>
<p>如果要删除  ArrayList 中的元素可以使用 <strong>remove()</strong> 方法：</p>
<p><strong>计算大小</strong></p>
<p>如果要计算  ArrayList 中的元素数量可以使用 <strong>size()</strong> 方法：</p>
<p><strong>判断相等</strong>  </p>
<p>.equals方法</p>
<h3 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h3><p>可以把他当作队列 数组 栈来看待，因此不用单独记忆其api</p>
<h3 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h3><p>不允许有重复元素  允许有 null 值  是无序的  不是线程安全的</p>
<p>同样  add() remove()   size()  </p>
<p> contains() 方法来判断元素是否存在于集合当中</p>
<p>检查数字是否在哈希集合中需要 O(1)O(1)O(1) 的时间，而对于其他数据结构，则需要 O(n)O(n)O(n) 的时间。选择正确的数据结构是解决这些问题的关键部分。</p>
<h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><p>散列表，存储的内容是键值对(key-value)映射。</p>
<p>实现了 Map 接口，根据键的 HashCode 值存储数据，具有很快的访问速度，最多允许一条记录的键为 null，不支持线程同步。</p>
<p>无序的，即不会记录插入的顺序。</p>
<p><strong>api:</strong></p>
<p>添加键值对(key-value)可以使用 put() 方法:</p>
<p> get(key) 方法来获取 key 对应的 value:</p>
<p>我们可以使用 remove(key) 方法来删除 key 对应的键值对(key-value):</p>
<p> <strong>size()</strong> 方法：</p>
<p>isEmpty()   containKey()   containValue()   entrySet()   keySet()    values()</p>
<p>Map的<strong>entrySet()方法</strong>返回一个实现Map.Entry接口的对象集合。集合中每个对象都是底层Map中一个特定的键&#x2F;值对。通过这个集合的迭代器，获得每一个条目(唯一获取方式)的键或值并对值进行更改。Map.Entry中的常用方法如下所示：</p>
<pre><code>    (1) Object getKey(): 返回条目的关键字
</code></pre>
<p>　　(2) Object getValue(): 返回条目的值<br>　　(3) Object setValue(Object value): 将相关映像中的值改为value，并且返回旧值</p>
<p>Trie树</p>
<p>「前缀树」又叫「字典树」或「单词查找树」</p>
<p>「前缀树」的应用场景：给定一个字符串集合构建一棵前缀树，然后给一个字符串，判断前缀树中是否存在该字符串或者该字符串的前缀</p>
<p><strong>分析</strong></p>
<p>一般而言，字符串的集合都是仅由小写字母构成，所以本文章都是基于该情况展开分析！</p>
<p>字符串集合：[them, zip, team, the, app, that]。这个样例的前缀树长什么样呢？</p>
<img src="/.xyz//1657540498-HHnzlV-1.svg" alt="1.svg" style="zoom: 67%;">

<p>由于都是小写字母，所以对于每个节点，均有 26 个孩子节点，上图中没有画出来，省略了而已…，但是要记住：每个节点均有 26 个孩子节点</p>
<p>还有一个点要明确：节点仅仅表示从根节点到本节点的路径构成的字符串是否有效而已</p>
<p>对于上图中橙色的节点，均为有效节点，即：从根节点到橙色节点的路径构成的字符串均在集合中</p>
<pre><code class="txt">如果现在要看目标字符串 te 是否存在，分两步：
首先看看表示 te 字符串的路径是否存在，这个例子是存在的
其次看看该路径的终点处的节点是否有效，很遗憾，此处为白色，无效
所以前缀 te 不存在！！
</code></pre>
<p><strong>构建前缀树  插入字符串 查找前缀过程</strong></p>
<pre><code class="java">class Trie &#123;
    //结点定义
    class TrieNode &#123;
        boolean val;
        TrieNode[] children = new TrieNode[26];
    &#125;
    //根节点定义
    private TrieNode root;
    //根节点初始化
    public Trie() &#123;
        root = new TrieNode();
    &#125;

    public void insert(String word) &#123;
        TrieNode p = root;
        for (char c : word.toCharArray()) &#123;
            int i = c - &#39;a&#39;;
            if (p.children[i] == null) p.children[i] = new TrieNode();
            p = p.children[i];
        &#125;
        p.val = true;
    &#125;
    //查询
    public boolean search(String word) &#123;
        TrieNode p = root;
        for (char c : word.toCharArray()) &#123;
            int i = c - &#39;a&#39;;
            if (p.children[i] == null) return false;
            p = p.children[i];
        &#125;
        return p.val;//成功，返回值（看看此处存不存在值）
    &#125;
    //查询前缀
    public boolean startsWith(String prefix) &#123;
        TrieNode p = root;
        for (char c : prefix.toCharArray()) &#123;
            int i = c - &#39;a&#39;;
            if (p.children[i] == null) return false;
            p = p.children[i];
        &#125;
        return true;//和查询一样的思路，只是返回的是true而已
    &#125;

&#125;
</code></pre>
<pre><code class="java">//官方解法
class Trie &#123;
    private Trie[] children;//定义两个成员变量
    private boolean isEnd;//

    public Trie() &#123;
        //两个成员变量
        children = new Trie[26];
        isEnd = false;
    &#125;
    //构建
    public void insert(String word) &#123;
        Trie node = this;
        for (int i = 0; i &lt; word.length(); i++) &#123;
            char ch = word.charAt(i);
            int index = ch - &#39;a&#39;;//转化为数字，从左边往右边a到z
            if (node.children[index] == null) &#123;
                node.children[index] = new Trie();//如果为空的话构建
            &#125;
            node = node.children[index];//向下移动
        &#125;
        node.isEnd = true;//置为true
    &#125;
    
    public boolean search(String word) &#123;
        Trie node = searchPrefix(word);
        return node != null &amp;&amp; node.isEnd;//需要既是非Null，也得是最后一个(isend为true)
    &#125;
    
    public boolean startsWith(String prefix) &#123;
        return searchPrefix(prefix) != null;//看查到的node结点是否存在就行，因为是前缀，不用管Isend
    &#125;
    //查前缀
    private Trie searchPrefix(String prefix) &#123;
        Trie node = this;//指向当前对象的指针  可以理解为指向trie的根部节点
        for (int i = 0; i &lt; prefix.length(); i++) &#123;
            char ch = prefix.charAt(i);
            int index = ch - &#39;a&#39;;
            if (node.children[index] == null) &#123;
                return null;//发现其中一个为null就肯定查询失败
            &#125;
            node = node.children[index];
        &#125;
        return node;//返回最后一个Node，此时还没判断是否为Null,此时路径没问题
    &#125;
&#125;
</code></pre>
<p>时间复杂度：O(∣S∣)，其中 ∣S∣是每次插入或查询的字符串的长度。</p>
<p>空间复杂度：O(∣T∣⋅Σ)，其中 ∣T∣为所有插入字符串的长度之和，Σ 为字符集的大小，本题 Σ&#x3D;26</p>
<p>官方题解的for可以用增强for循环</p>
<h1 id="图"><a href="#图" class="headerlink" title="图"></a>图</h1><h2 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h2><p><strong>无向图</strong></p>
<p>分析1：无向图的邻接矩阵是对称的；<br> 分析2：顶点i的度&#x3D;第i行（列）中1的个数；<br> <strong>特别：完全图的邻接矩阵中，对角元素为0，其余1。</strong></p>
<p><a href="https://blog.csdn.net/diviner_s/article/details/106978910">https://blog.csdn.net/diviner_s/article/details/106978910</a></p>
<p><strong>有向图</strong></p>
<p>行列出入</p>
<p>在有向图的邻接矩阵中，<br>第i行含义：以结点vi为尾的弧（即出度边）；<br>第i列含义：以结点vi为头的弧（即入度边）。<br>分析1：有向图的邻接矩阵可能是不对称的；<br>分析2：顶点的出度 &#x3D; 第 i 行元素之和<br>             顶点的入度 &#x3D; 第 i 列元素之和<br>             顶点的度 &#x3D; 第 i 行元素之和 + 第 i 列元素之和</p>
<h2 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h2><h3 id="课程表问题"><a href="#课程表问题" class="headerlink" title="课程表问题"></a><strong>课程表问题</strong></h3>

<pre><code class="txt">示例：
输入：numCourses = 4, prerequisites = [[1,0],[2,0],[3,1],[3,2]]
输出：[0,2,1,3]
解释：总共有 4 门课程。要学习课程 3，你应该先完成课程 1 和课程 2。并且课程 1 和课程 2 都应该排在课程 0 之后。
因此，一个正确的课程顺序是 [0,1,2,3] 。另一个正确的排序是 [0,2,1,3] 。
</code></pre>
<p><strong>拓扑排序定义</strong>：给定一个包含 n个节点的有向图 G，我们给出它的节点编号的一种排列，如果满足：对于图 G中的任意一条有向边 (u,v)，u在排列中都出现在 v的前面。</p>
<p><strong>推导结论：</strong>1. 不可有环  2. 拓扑排序不止一种</p>
<p><strong>解题：</strong></p>
<p><strong>BFS</strong></p>
<p>考虑拓扑排序中最前面的节点入度为0，它没有先修课程要求。将此节点加入答案中后，移除它的所有出边，如果某个相邻节点变成了「没有任何入边的节点」，那么就代表着这门课可以开始学习了。按照这样的流程，我们不断地将没有入边的节点加入答案，直到答案中包含所有的节点（得到了一种拓扑排序）或者不存在没有入边的节点（图中包含环）。</p>
<p>我们使用一个队列来进行广度优先搜索。在广度优先搜索的每一步中，我们取出队首的节点 u，我们将 u 放入答案中；移除 u 的所有出边，也就是将 u的所有相邻节点的入度减少 1。如果某个相邻节点 v 的入度变为 0，那么我们就将 v放入队列中。在广度优先搜索的过程结束后。如果答案中包含了这 n 个节点，那么我们就找到了一种拓扑排序（从队列队首取出的结点构成的排序），否则说明图中存在环，也就不存在拓扑排序了。</p>
<pre><code class="java">class Solution &#123;
    // 存储有向图
    List&lt;List&lt;Integer&gt;&gt; edges;
    // 存储每个节点的入度
    int[] indeg;
    // 存储答案
    int[] result;
    // 答案下标
    int index;

    public int[] findOrder(int numCourses, int[][] prerequisites) &#123;
        edges = new ArrayList&lt;List&lt;Integer&gt;&gt;();
        //初始化edges，下标从0到numcourses-1
        for (int i = 0; i &lt; numCourses; ++i) &#123;
            edges.add(new ArrayList&lt;Integer&gt;());
        &#125;
        //初始化
        indeg = new int[numCourses];
        result = new int[numCourses];
        index = 0;
        //把每个Info的后面一位数当下标，前面一位数当值
        for (int[] info : prerequisites) &#123;
            edges.get(info[1]).add(info[0]);
            ++indeg[info[0]];//对应入度表修改
        &#125;

        Queue&lt;Integer&gt; queue = new LinkedList&lt;Integer&gt;();
        // 将所有入度为 0 的节点放入队列中
        for (int i = 0; i &lt; numCourses; ++i) &#123;
            if (indeg[i] == 0) &#123;
                queue.offer(i);//添加到队列
            &#125;
        &#125;

        while (!queue.isEmpty()) &#123;
            // 从队首取出一个节点
            int u = queue.poll();
            // 放入答案中
            result[index++] = u;
            for (int v: edges.get(u)) &#123;
                //这个结点指向的另一个结点的入度要减1
                --indeg[v];
                // 如果相邻节点 v 的入度为 0，就可以选 v 对应的课程了
                if (indeg[v] == 0) &#123;
                    queue.offer(v);
                &#125;
            &#125;
        &#125;
        //理论上课程数要和下标一致，不一致说明有环或是其他情况
        if (index != numCourses) &#123;
            return new int[0];
        &#125;
        return result;
    &#125;
&#125;
</code></pre>
<p>以前面示例作为例子，画个图理解一下</p>
<img src="/.xyz//image-20220915160038236.png" alt="image-20220915160038236" style="zoom:50%;">

<p>这道题是课程二，让我们返回拓扑排序，课程一问题让我们返回是否能修完所有课程，无非就是return的不一样罢了。    </p>
<pre><code class="java">return visited == numCourses;
</code></pre>
<p><strong>DFS</strong></p>
<p>真不想看了，二刷的时候再说吧</p>
<h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><p><strong>api</strong></p>
<p>add         增加一个元索                      如果队列已满，则抛出一个IIIegaISlabEepeplian异常<br><strong>offer</strong>       添加一个元素并返回true        如果队列已满，则返回false</p>
<p>remove   移除并返回队列头部的元素     如果队列为空，则抛出一个NoSuchElementException异常<br><strong>poll</strong>         移除并返问队列头部的元素     如果队列为空，则返回null</p>
<p><strong>peek</strong>       返回队列头部的元素              如果队列为空，则返回null<br>element  返回队列头部的元素              如果队列为空，则抛出一个NoSuchElementException异常</p>
<p><strong>put</strong>         添加一个元素                       如果队列满，则阻塞<br><strong>take</strong>        移除并返回队列头部的元素</p>
<p>刷leetcode优先使用加粗的方法</p>
<p>java里面用什么表示队列呢？</p>
<p>答案是LinkedList</p>
<p>LinkedList同时实现了<strong>List接口和Deque对口</strong>，也就是收它既可以看作一个顺序容器，又可以看作一个队列（Queue），<strong>同时又可以看作一个栈（stack）</strong>，这样看来，linkedList简直就是无敌的，当你需要使用栈或者队列时，可以考虑用LinkedList,一方面是因为Java官方已经声明不建议使用Stack类，更遗憾的是，Java里根本没有一个叫做Queue的类（只是一个接口的名字）。关于栈或队列，现在首选是<strong>ArrayDeque，它有着比LinkedList（当作栈或队列使用时）更好的性能。</strong></p>
<h3 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h3><h4 id="滑动窗口最大值"><a href="#滑动窗口最大值" class="headerlink" title="滑动窗口最大值"></a>滑动窗口最大值</h4><p>给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。    返回 滑动窗口中的最大值 。</p>
<p>这个动图不错</p>
<p><a href="https://leetcode.cn/problems/sliding-window-maximum/solution/dong-hua-yan-shi-dan-diao-dui-lie-239hua-hc5u/">https://leetcode.cn/problems/sliding-window-maximum/solution/dong-hua-yan-shi-dan-diao-dui-lie-239hua-hc5u/</a></p>
<img src="/.xyz//begegxp0nc69gltu.gif" alt="BFS 遍历的过程（动图）" style="zoom:33%;">

<pre><code class="java">class Solution &#123;
    public int[] maxSlidingWindow(int[] nums, int k) &#123;
        int n = nums.length;
        Deque&lt;Integer&gt; deque = new LinkedList&lt;Integer&gt;();
        for (int i = 0; i &lt; k; ++i) &#123;
            //peek是获取但不删除  poll返回＋删除
            //保证递减
            while (!deque.isEmpty() &amp;&amp; nums[i] &gt;= nums[deque.peekLast()]) &#123;
                deque.pollLast();
            &#125;
            deque.offerLast(i);//添加元素的下标到队尾中
        &#125;

        int[] ans = new int[n - k + 1];//想象k=1就清晰了（K为1窗口为1）
        ans[0] = nums[deque.peekFirst()];//注意deque.peekFirst()只是数组下标,把值放进去需要nums[]
        for (int i = k; i &lt; n; ++i) &#123;
            while (!deque.isEmpty() &amp;&amp; nums[i] &gt;= nums[deque.peekLast()]) &#123;
                deque.pollLast();//遇到下一个数比队尾数大就一直出队列
            &#125;
            deque.offerLast(i);//然后那个大的数进去
            //保证窗口是K,因为有可能后面很多元素都递减，超过k个元素进队列了，所以每次都要判断队首是否超边界，超了就poll
            //依然想象k为1，i现在已经进来了，只能有一个元素，那么i-1就是窗口的左边一个元素
            while (deque.peekFirst() &lt;= i - k) &#123;
                deque.pollFirst();
            &#125;
            ans[i - k + 1] = nums[deque.peekFirst()];//队首元素存进去   //依然想象k=1  
        &#125;
        return ans;
    &#125;
&#125;
</code></pre>
<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h2 id="API、经验"><a href="#API、经验" class="headerlink" title="API、经验"></a>API、经验</h2><h4 id="填充数组"><a href="#填充数组" class="headerlink" title="填充数组"></a><strong>填充数组</strong></h4><pre><code class="java">一维数组
boolean[] a1 = new boolean[5];
    Arrays.fill( a1,true );
Arrays.fill( a1,3,4,false);//下标3变为false 左开右闭
二维数组  把一维数组当作一个对象
 int[][] map=new int[4][5];
   int[] ten=new int[10];
   Arrays.fill(ten, -1);
   Arrays.fill(map,ten);  //成功
</code></pre>
<h4 id="判断数组相等"><a href="#判断数组相等" class="headerlink" title="判断数组相等"></a><strong>判断数组相等</strong></h4><p>Arrays.equals（a,b)</p>
<h4 id="边界条件"><a href="#边界条件" class="headerlink" title="边界条件"></a>边界条件</h4><p>数组可以为空也可以长度为0，都要考虑</p>
<pre><code class="java">if(nums==null||nums.length==0)&#123;
    return 0;
&#125;
</code></pre>
<h4 id="新建包含一定元素的可变数组"><a href="#新建包含一定元素的可变数组" class="headerlink" title="新建包含一定元素的可变数组"></a>新建包含一定元素的可变数组</h4><pre><code class="java">int[] ans=new int[]&#123;1,1,1&#125;;

Arrays.asList(nums[i],nums[j],nums[k]);
</code></pre>
<h2 id="59-螺旋矩阵-II"><a href="#59-螺旋矩阵-II" class="headerlink" title="59 螺旋矩阵 II"></a>59 螺旋矩阵 II</h2><p>给你一个正整数 <code>n</code> ，生成一个包含 <code>1</code> 到 <code>n2</code> 所有元素，且元素按顺时针顺序螺旋排列的 <code>n x n</code> 正方形矩阵 <code>matrix</code>  	</p>




<pre><code class="java">class Solution &#123;
    public int[][] generateMatrix(int n) &#123;
        int l = 0, r = n - 1, t = 0, b = n - 1;
        int[][] mat = new int[n][n];
        int num = 1, tar = n * n;
        while(num &lt;= tar)&#123;
            //先mat[t][i] = num  再num++
            for(int i = l; i &lt;= r; i++) mat[t][i] = num++; // left to right.
            //for循环外面做t++
            t++;
            for(int i = t; i &lt;= b; i++) mat[i][r] = num++; // top to bottom.
            r--;
            for(int i = r; i &gt;= l; i--) mat[b][i] = num++; // right to left.
            b--;
            for(int i = b; i &gt;= t; i--) mat[i][l] = num++; // bottom to top.
            l++;
        &#125;
        return mat;
    &#125;
&#125;
</code></pre>
<h2 id="最短无序连续子数组"><a href="#最短无序连续子数组" class="headerlink" title="最短无序连续子数组"></a>最短无序连续子数组</h2><p>给你一个整数数组 nums ，你需要找出一个 连续子数组 ，如果对这个子数组进行升序排序，那么整个数组都会变为升序排序。</p>
<p>请你找出符合题意的 最短 子数组，并输出它的长度。</p>
<pre><code class="java">class Solution &#123;
    public int findUnsortedSubarray(int[] nums) &#123;
        int n = nums.length;
        int max = Integer.MIN_VALUE, min = Integer.MAX_VALUE;
        int left = 0, right = 0;
        //找到排序的入口
        //注意数组越界
        for(int i = 1; i &lt; n; i++)&#123;
            if(nums[i] &lt; nums[i - 1])&#123;
                left = i - 1;//记录严格升序的最后一个元素
                break;
            &#125;
        &#125;
        //找到排序的出口
        for(int i = n - 1; i &gt; 0; i--)&#123;
            if(nums[i] &lt; nums[i - 1])&#123;
                right = i;//记录严格升序的第一个元素
                break;
            &#125;
        &#125;
        //找到最大最小值
        for(int i = left; i &lt;= right; i++)&#123;
            max = Math.max(nums[i], max);
            min = Math.min(nums[i], min);
        &#125;
        //l向左扩展，r向右扩展
        //找到比Min小的 因为max min 已经是在l-r里面产生，因此需要从l-1 r+1开始比较
        while(left &gt; 0 &amp;&amp; nums[left - 1] &gt; min) left --;
        //找到比max大的
        while(right &lt; n - 1 &amp;&amp; nums[right + 1] &lt; max) right ++;
        if(left == right) return 0;//决定了我的初始l r的取值就得是0 0
        return right - left + 1;
    &#125;
&#125;	
</code></pre>
<h2 id="寻找重复数"><a href="#寻找重复数" class="headerlink" title="寻找重复数"></a>寻找重复数</h2><p>给定一个包含 n + 1 个整数的数组 nums ，其数字都在 [1, n] 范围内（包括 1 和 n），可知至少存在一个重复的整数。</p>
<p>假设 nums 只有 一个重复的整数 ，返回 这个重复的数 。</p>
<p>你设计的解决方案必须 不修改 数组 nums 且只用常量级 O(1) 的额外空间。</p>
<p><strong>快慢指针(floyd判圈算法)</strong></p>


<p><strong>结论：不管是什么数据结构，用上快慢指针，快慢指针相遇之后，把slow放起点，两个指针同时移动，必然于入环点相遇，也就是答案，包括之前的环形链表II</strong></p>
<pre><code class="java">class Solution &#123;
    public int findDuplicate(int[] nums) &#123;
        int slow = 0, fast = 0;
        //不用单独建环，思路就是环的思想，数组里面快慢指针不能像像链表那样next next.next，但我们想象有i-&gt;nums[i]的边，也就与链表无异了,即  nums[slow]   nums[nums[fast]]
        do &#123;
            slow = nums[slow];
            fast = nums[nums[fast]];
        &#125; while (slow != fast);//特别注意 这里有个分号
        slow = 0;//相遇之后的骚操作   
        while (slow != fast) &#123;
            slow = nums[slow];
            fast = nums[fast];
        &#125;
        //此时slow和fast相等 因此重复元素必然就是slow 直接返回即可
        return slow;
    &#125;
&#125;
</code></pre>
<h2 id="移动零"><a href="#移动零" class="headerlink" title="移动零"></a>移动零</h2><pre><code>输入: nums = [0,1,0,3,12]
输出: [1,3,12,0,0]
</code></pre>
<p>我的思路：双指针，左右指针都指向数组最左侧，左指针找到第一个为0的数字，右指针往右找到第一个非0数字，交换，注意边界条件，很Tm烦人</p>
<pre><code class="java">class Solution &#123;
    public void moveZeroes(int[] nums) &#123;
        int n=nums.length,left=0,right=0;
        //left到倒数第二个的时候已经没必要继续下去
        while(left&lt;n-1)&#123;
            if(nums[left]==0)&#123;
                right=left+1; 
                while(right&lt;n&amp;&amp;nums[right]==0)&#123;
                    right++;
                    //有可能right=n-1且nums[n-1]=0，防止right出界 swap函数数组越界
                    if(right&gt;=n) return;
                &#125;
                swap(nums,left,right);
            &#125;
            left++;
        &#125;

    &#125;
    public void swap(int[] nums,int i,int j)&#123;
            int tmp=nums[i];
            nums[i]=nums[j];
            nums[j]=tmp;
    &#125;
&#125;
</code></pre>
<h2 id="除自身以外数组的乘积"><a href="#除自身以外数组的乘积" class="headerlink" title="除自身以外数组的乘积"></a>除自身以外数组的乘积</h2><p>题目：给你一个整数数组 <code>nums</code>，返回 <em>数组 <code>answer</code> ，其中 <code>answer[i]</code> 等于 <code>nums</code> 中除 <code>nums[i]</code> 之外其余各元素的乘积</em> 。</p>
<p>给定两个概念，L数组 R数组</p>
<p><code>L[i]</code> 代表的是 <code>i</code> 左侧所有数字的乘积，<code>R[i]</code> 代表的是 <code>i</code> 右侧所有数字的乘积。</p>
<img src="/.xyz//image-20220920154818329.png" alt="image-20220920154818329" style="zoom: 67%;">

<p>改进算法：空间复杂度 O(1) 的方法</p>
<img src="/.xyz//image-20220920154907687.png" alt="image-20220920154907687" style="zoom: 67%;">

<pre><code class="java">//我的代码
class Solution &#123;
    public int[] productExceptSelf(int[] nums) &#123;
        int[] answer=new int[nums.length];
        int L=1;
        answer[0]=1;//显而易见
        //L数组
        for(int i=1;i&lt;nums.length;i++)&#123;
            answer[i]=nums[i-1]*L;
            L=L*nums[i-1];
        &#125;
        //i=num.length-1不用变
        int R=1;
        for(int i=nums.length-2;i&gt;=0;i--)&#123;
            R=R*nums[i+1];
            answer[i]=answer[i]*R;
        &#125;
        return answer;
    &#125;
&#125;
</code></pre>
<h2 id="滚动数组"><a href="#滚动数组" class="headerlink" title="滚动数组"></a>滚动数组</h2><p>结果只和前两个数据有关系，可以采用滚动数组，复杂度可以从O（n)降低到O（1）；</p>
<h2 id="多数元素"><a href="#多数元素" class="headerlink" title="多数元素"></a>多数元素</h2><p>给定一个大小为 n 的数组 nums ，返回其中的多数元素。多数元素是指在数组中出现次数 大于 ⌊ n&#x2F;2 ⌋ 的元素。</p>
<p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p>
<img src="/.xyz//image-20220917190606201.png" alt="image-20220917190606201" style="zoom: 67%;">

<pre><code class="java">class Solution &#123;
    private Map&lt;Integer, Integer&gt; countNums(int[] nums) &#123;
        Map&lt;Integer, Integer&gt; counts = new HashMap&lt;Integer, Integer&gt;();
        for (int num : nums) &#123;
            //不包含设为1 包含就加一
            if (!counts.containsKey(num)) &#123;
                counts.put(num, 1);
            &#125; else &#123;
                counts.put(num, counts.get(num) + 1);
            &#125;
        &#125;
        return counts;
    &#125;

    public int majorityElement(int[] nums) &#123;
        Map&lt;Integer, Integer&gt; counts = countNums(nums);

        Map.Entry&lt;Integer, Integer&gt; majorityEntry = null;//定义一下
        for (Map.Entry&lt;Integer, Integer&gt; entry : counts.entrySet()) &#123;
            //打擂台，挑选出value最大的entry作为majorityEntry
            //这里要加majorityEntry == null的原因是防止出现NullPointerException，majorityEntry为Null时， majorityEntry.getValue()无法执行
            if (majorityEntry == null || entry.getValue() &gt; majorityEntry.getValue()) &#123;
                majorityEntry = entry;
            &#125;
        &#125;

        return majorityEntry.getKey();
    &#125;
&#125;
</code></pre>


<p>但这个复杂度是nlog(n)</p>
<h2 id="搜索二维矩阵"><a href="#搜索二维矩阵" class="headerlink" title="搜索二维矩阵"></a>搜索二维矩阵</h2><p>编写一个高效的算法来搜索 m x n 矩阵 matrix 中的一个目标值 target 。该矩阵具有以下特性：</p>
<p>每行的元素从左到右升序排列。   每列的元素从上到下升序排列。</p>
<img src="/.xyz//searchgrid2.jpg" alt="img" style="zoom:50%;">

<p><strong>方法一</strong></p>
<p>直接查找 复杂度O（mn）</p>
<pre><code class="java">class Solution &#123;
    public boolean searchMatrix(int[][] matrix, int target) &#123;
        for (int[] row : matrix) &#123;
            for (int element : row) &#123;
                if (element == target) &#123;
                    return true;
                &#125;
            &#125;
        &#125;
        return false;
    &#125;
&#125;
</code></pre>
<p><strong>方法二：</strong></p>
<p>二分</p>
<pre><code class="java">class Solution &#123;
    public boolean searchMatrix(int[][] matrix, int target) &#123;
        for (int[] row : matrix) &#123;
            int index = search(row, target);
            if (index &gt;= 0) &#123;
                return true;
            &#125;
        &#125;
        return false;
    &#125;

    public int search(int[] nums, int target) &#123;
        int low = 0, high = nums.length - 1;
        while (low &lt;= high) &#123;
            int mid = (high - low) / 2 + low;
            int num = nums[mid];
            if (num == target) &#123;
                return mid;
            &#125; else if (num &gt; target) &#123;
                high = mid - 1;
            &#125; else &#123;
                low = mid + 1;
            &#125;
        &#125;
        return -1;
    &#125;
&#125;
</code></pre>
<p><strong>方法三（掌握这个）</strong></p>
<img src="/.xyz//image-20220921123558099.png" alt="image-20220921123558099" style="zoom: 80%;">

<p>我的理解：必须从右上角开始搜索，保证我搜索到的元素在行是最大值，在列是小值，因此如果我元素大于target，则列的最小值大于target（整个列都大于target），列–；小于target，则列的最大值小于target(整个行小于target)，行++</p>
<pre><code class="java">class Solution &#123;
    public boolean searchMatrix(int[][] matrix, int target) &#123;
        int m = matrix.length, n = matrix[0].length;
        int x = 0, y = n - 1;
        while (x &lt; m &amp;&amp; y &gt;= 0) &#123;
            if (matrix[x][y] == target) &#123;
                return true;
            &#125;
            if (matrix[x][y] &gt; target) &#123;
                --y;
            &#125; else &#123;
                ++x;
            &#125;
        &#125;
        return false;
    &#125;
&#125;
</code></pre>
<h1 id="空间时间复杂度"><a href="#空间时间复杂度" class="headerlink" title="空间时间复杂度"></a>空间时间复杂度</h1><img src="/.xyz//image-20221001122257963.png" alt="image-20221001122257963" style="zoom:50%;">

<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><p>利于记忆</p>
<p><a href="https://juejin.cn/post/6844903845227659271">https://juejin.cn/post/6844903845227659271</a></p>
<p>可视化</p>
<p><a href="https://regexper.com/">https://regexper.com/</a></p>
<p>String是直接+</p>
<pre><code class="java">1、return s.substring(n, s.length()) + s.substring(0, n);
2、
String res = &quot;&quot;;
res += s.charAt(i % s.length())
</code></pre>
<p>StringBulider是append</p>
<pre><code class="java">StringBuilder res = new StringBuilder();
res.append(s.charAt(i % s.length()));
return res.toString();
</code></pre>
<p>append和+的区别：</p>
<p><strong>append</strong>:StringBuilder是可变对象，每轮遍历拼接字符时，只是向列表尾部添加一个新的字符元素。最终拼接转化为字符串时，系统 <strong>仅申请一次内存</strong> 。(√)</p>
<p>**+**：字符串是 “不可变对象” 。因此，每轮遍历拼接字符时，都需要新建一个字符串；因此，系统 <strong>需申请 N 次内存</strong> ，数据量较大时效率低下。</p>
<h2 id="重复的子字符串"><a href="#重复的子字符串" class="headerlink" title="重复的子字符串"></a>重复的子字符串</h2><p>给定一个非空的字符串 <code>s</code> ，检查是否可以通过由它的一个子串重复多次构成。</p>
<p><strong>方法一：枚举</strong></p>
<pre><code class="java">class Solution &#123;
    public boolean repeatedSubstringPattern(String s) &#123;
        // return (s+s).indexOf(s,1) != s.length();
        // 如果一个长度为 n 的字符串 s 可以由它的一个长度为 n′ 的子串 s′ 重复多次构成
        // n&#39;范围 1到n/2     且n′必须要被n整除
        int n=s.length();
        for(int i=1;i&lt;=n/2;i++)&#123;
            if(n%i==0)&#123;
                boolean ans=true;
                for(int j=i;j&lt;n;j++)&#123;
                    if(s.charAt(j)!=s.charAt(j-i))&#123;
                        ans=false;
                        break;
                    &#125;
                &#125;
                if(ans) return ans;
            &#125;
        &#125;
        return false;
    &#125;
&#125;
</code></pre>
<p><strong>方法二：字符串匹配</strong></p>
<img src="/.xyz//image-20221023224136692.png" alt="image-20221023224136692" style="zoom:80%;">

<pre><code class="java">class Solution &#123;
    public boolean repeatedSubstringPattern(String s) &#123;
     // (s + s).indexOf(s, 1) : 返回从 1 位置开始查找指定字符s在字符串s+s中第一次出现处的索引，如果此字符串中没有这样的字符，则返回 -1。
        return (s + s).indexOf(s, 1) != s.length();
    &#125;
&#125;
</code></pre>
<p><strong>方法三 ： KMP</strong></p>
<h2 id="28-实现-strStr"><a href="#28-实现-strStr" class="headerlink" title="28. 实现 strStr()"></a>28. 实现 strStr()</h2><p>给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串的第一个匹配项的下标（下标从 0 开始）。如果 needle 不是 haystack 的一部分，则返回  -1 </p>
<p><strong>暴力</strong></p>
<pre><code class="java">class Solution &#123;
    public int strStr(String haystack, String needle) &#123;
        // haystack 原串    needle匹配串
        int h=haystack.length();
        int n=needle.length();
        for(int i=0;i&lt;=h-n;i++)&#123;
            int a=0,b=i;
            while(a&lt;n &amp;&amp; haystack.charAt(b)==needle.charAt(a))&#123;
                a++;
                b++;
            &#125;
            if(a==n) return i;
        &#125;
        return -1;
    &#125;
&#125;
</code></pre>
<h3 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h3><p>图和代码略有不符 理解即可</p>
<img src="/.xyz//image-20221023164358460.png" alt="image-20221023164358460" style="zoom: 80%;">



<p>我的理解：</p>
<p>next数组可以理解为最长相等前缀所处的位置，j所指向的位置也可以理解为最长相等前缀所处的位置</p>
<p>构建：首先i j所指位置如果相等， next[i] &#x3D; j，二者都向后移动，如果不相等，回退，找相等的时候再赋值，如果一直不相等，next[i] &#x3D; 0;然后i继续往后移动 </p>
<p>匹配：和构建过程一样，不同的是1、对原串进行迭代 2、每次循环后判断j是否等于匹配串长度</p>
<pre><code class="java">class Solution &#123;
    public int strStr(String haystack, String needle) &#123;
        // KMP算法：如果已经匹配的字符串包含相同的前缀和后缀，遇到下一个不匹配的位置时，指向needle的指针跳转到前缀的后一个位置，还是不匹配的话，再往前跳转后继续比较；先构造一个next数组来记录needle指针跳转的位置
        int n=haystack.length(), m=needle.length();
        if(m==0) return 0;
        // 先构造next数组，next数组中的元素表示当前两个元素不匹配时，needle指针要跳转的位置
        // haystack: [a, b, e, a, b, a, b, e, a, b, f]
        // needle:   [a, b, e, a, b, f]
        // next:     [0, 0, 0, 1, 2, 0]
        我的理解 Next的意思就是如果下一个位置不匹配的话 我可以靠到位置几再进行匹配
         int[] next = new int[m];
        for(int i=1,j=0; i&lt;m; i++)&#123;
              // 匹配不成功的话，j = next(j-1)
            while(j&gt;0 &amp;&amp; needle.charAt(i)!=needle.charAt(j)) j = next[j-1]; 
           // 一直和前一位置的值比较，直到遇到相等的字符或者j=0；j通过next[j-1]来回退
            // 匹配成功的话，先让 j++
            if(needle.charAt(i)==needle.charAt(j)) j++;
            // 更新 next[i]，结束本次循环，i++
            next[i] = j;//因为i最后再移动，所以最后再更新
        &#125;
        // 利用next数组进行跳转匹配，不再需要回退haystack的指针i
        for(int i=0,j=0; i&lt;n; i++)&#123;
            // 匹配不成功，needle指针j回退并继续比较
            while(j&gt;0 &amp;&amp; haystack.charAt(i)!=needle.charAt(j)) j = next[j-1];  
            if(haystack.charAt(i)==needle.charAt(j)) j++;
            //匹配成功的话，先让 j++，结束本次循环后 i++
            // 整一段匹配成功，直接返回下标
            if(j==m) return i - m + 1;
        &#125;
        return -1;
    &#125;
&#125;
</code></pre>
<h2 id="左旋转字符串"><a href="#左旋转字符串" class="headerlink" title="左旋转字符串"></a>左旋转字符串</h2><p>字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串”abcdefg”和数字2，该函数将返回左旋转两位得到的结果”cdefgab”</p>
<p><strong>方法一：字符串切片</strong></p>
<pre><code>return s.substring(n, s.length()) + s.substring(0, n);
</code></pre>
<p><strong>方法二：列表遍历拼接</strong>（若面试规定不允许使用 <strong>切片函数</strong> ，则使用此方法）</p>
<pre><code class="java">class Solution &#123;
    public String reverseLeftWords(String s, int n) &#123;
        StringBuilder res = new StringBuilder();
        for(int i = n; i &lt; n + s.length(); i++)
            res.append(s.charAt(i % s.length()));
        return res.toString();
    &#125;
&#125;//利用求余运算，可以简化代码
</code></pre>
<p><strong>方法三：字符串遍历拼接</strong>(不用StringBulider)</p>
<pre><code class="java">class Solution &#123;
    public String reverseLeftWords(String s, int n) &#123;
        String res = &quot;&quot;;
        for(int i = n; i &lt; s.length(); i++)
            res += s.charAt(i);
        for(int i = 0; i &lt; n; i++)
            res += s.charAt(i);
        return res;
    &#125;
&#125;
</code></pre>
<h2 id="翻转字符串里的单词"><a href="#翻转字符串里的单词" class="headerlink" title="翻转字符串里的单词"></a>翻转字符串里的单词</h2><p><img src="/.xyz//image-20221019213126600.png" alt="image-20221019213126600" style="zoom:80%;">、</p>
<pre><code class="java">class Solution &#123;
    public String reverseWords(String s) &#123;
        // 除去开头和末尾的空白字符
        s = s.trim();
        // 正则匹配连续的空白字符作为分隔符分割
        List&lt;String&gt; wordList = Arrays.asList(s.split(&quot;\\s+&quot;));
        Collections.reverse(wordList);
        return String.join(&quot; &quot;, wordList);//用啥连接这些
    &#125;
&#125;
</code></pre>
<img src="/.xyz//image-20221019214203980.png" alt="image-20221019214203980" style="zoom:67%;">



<h2 id="替换空格"><a href="#替换空格" class="headerlink" title="替换空格"></a>替换空格</h2><pre><code class="java">   return s.replace(&quot; &quot;, &quot;%20&quot;);//第一种，直接api
</code></pre>
<pre><code class="java">//第二种 循环
class Solution &#123;
    public String replaceSpace(String s) &#123;
        StringBuilder sb=new StringBuilder();
        for(char c:s.toCharArray())&#123;
            if(c==&#39; &#39;)&#123;
                sb.append(&quot;%20&quot;);
            &#125;else&#123;
                sb.append(c);
            &#125;
        &#125;
        return sb.toString();
    &#125;
&#125;
</code></pre>
<h2 id="反转字符串"><a href="#反转字符串" class="headerlink" title="反转字符串"></a>反转字符串</h2><p>双指针：</p>
<pre><code class="java">class Solution &#123;
    public void reverseString(char[] s) &#123;
        int l=0,r=s.length-1;
        while(l&lt;r)&#123;
            char temp=s[l];
            s[l]=s[r];
            s[r]=temp;
            l++;
            r--;
        &#125;
    &#125;
&#125;
</code></pre>
<h2 id="反转字符串II"><a href="#反转字符串II" class="headerlink" title="反转字符串II"></a>反转字符串II</h2><p>给定一个字符串 s 和一个整数 k，从字符串开头算起，每计数至 2k 个字符，就反转这 2k 字符中的前 k 个字符。</p>
<p>如果剩余字符少于 k 个，则将剩余字符全部反转。<br>如果剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符，其余字符保持原样。</p>
<pre><code class="java">class Solution &#123;
    public String reverseStr(String s, int k) &#123;
        char[] str=s.toCharArray();
        for(int i=0;i&lt;s.length();i+=2*k)&#123;
            reverse(str,i,Math.min(s.length()-1,i+k-1));
        &#125;
        return new String(str);
    &#125;
    public void reverse(char[] str,int l,int r)&#123;
        while(l&lt;r)&#123;
            char temp=str[l];
            str[l]=str[r];
            str[r]=temp;
            l++;
            r--;
        &#125;
    &#125;
&#125;
</code></pre>
<h2 id="回文子串"><a href="#回文子串" class="headerlink" title="回文子串"></a>回文子串</h2><p>给你一个字符串 s ，请你统计并返回这个字符串中 回文子串 的数目。回文字符串 是正着读和倒过来读一样的字符串。子字符串 是字符串中的由连续字符组成的一个序列。具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。</p>
<p>中心拓展：</p>
<img src="/.xyz//image-20221018211634458.png" alt="image-20221018211634458" style="zoom:80%;">

<pre><code class="java">class Solution &#123;
    public int countSubstrings(String s) &#123;
        int n = s.length();
        int count = 0;
        for(int i = 0; i&lt; 2*n-1; i++)&#123;
            int l = i / 2,r = i / 2 + i % 2;
            while(l &gt;= 0 &amp;&amp; r &lt; n &amp;&amp; s.charAt(l) == s.charAt(r))&#123;
                count++;
                l--;
                r++;
            &#125;
        &#125;
        return count;
    &#125;
&#125;
</code></pre>
<h2 id="438寻找字母异位词"><a href="#438寻找字母异位词" class="headerlink" title="438寻找字母异位词"></a>438寻找字母异位词</h2><p>给定两个字符串 s 和 p，找到 s 中所有 p 的 异位词 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。</p>
<p>异位词 指由相同字母重排列形成的字符串（包括相同的字符串）。</p>
<img src="/.xyz//image-20221006155802666.png" alt="image-20221006155802666" style="zoom:67%;">

<pre><code class="java">class Solution &#123;
    public List&lt;Integer&gt; findAnagrams(String s, String p) &#123;
        int sLen = s.length(), pLen = p.length();
        
        if (sLen &lt; pLen) &#123;
            return new ArrayList&lt;Integer&gt;();
        &#125;
        
        List&lt;Integer&gt; ans = new ArrayList&lt;Integer&gt;();
        int[] sCount = new int[26];
        int[] pCount = new int[26];
        //初始滑动窗口内记录各字母数目
        for (int i = 0; i &lt; pLen; ++i) &#123;
            ++sCount[s.charAt(i) - &#39;a&#39;];
            ++pCount[p.charAt(i) - &#39;a&#39;];
        &#125;
        //判断数组是否相等
        if (Arrays.equals(sCount, pCount)) &#123;
            ans.add(0);
        &#125;
        //左出右进 scount要变 
        for (int i = 0; i &lt; sLen - pLen; ++i) &#123;
            --sCount[s.charAt(i) - &#39;a&#39;];
            ++sCount[s.charAt(i + pLen) - &#39;a&#39;];
            //再判断
            if (Arrays.equals(sCount, pCount)) &#123;
                ans.add(i + 1);
            &#125;
        &#125;

        return ans;
    &#125;
&#125;
</code></pre>


<pre><code class="java">class Solution &#123;
    public List&lt;Integer&gt; findAnagrams(String s, String p) &#123;
        int sLen = s.length(), pLen = p.length();

        if (sLen &lt; pLen) &#123;
            return new ArrayList&lt;Integer&gt;();
        &#125;

        List&lt;Integer&gt; ans = new ArrayList&lt;Integer&gt;();
        int[] count = new int[26];
        //初始滑动窗口
        for (int i = 0; i &lt; pLen; ++i) &#123;
            ++count[s.charAt(i) - &#39;a&#39;];
            --count[p.charAt(i) - &#39;a&#39;];
        &#125;
        //count代表滑动窗口中每种字母的数量与字符串p中每种字母的数量差值
        //differ代表当前窗口与p不同字母个数
        int differ = 0;
        for (int j = 0; j &lt; 26; ++j) &#123;
            if (count[j] != 0) &#123;
                ++differ;
            &#125;
        &#125;

        if (differ == 0) &#123;
            ans.add(0);
        &#125;

        for (int i = 0; i &lt; sLen - pLen; ++i) &#123;
            //因为是要去除一个元素，且count是滑动窗口里面的s减去p ，去除元素只会让count减少，因此只有1-&gt;0 或者0-&gt;-1才能让differ变化
            if (count[s.charAt(i) - &#39;a&#39;] == 1) &#123;  //1-&gt;0  --differ
                --differ;
            &#125; else if (count[s.charAt(i) - &#39;a&#39;] == 0) &#123;  //0-&gt;1   ++differ
                ++differ;
            &#125;
            --count[s.charAt(i) - &#39;a&#39;];
            //因为是要增加一个元素，且count是滑动窗口里面的s减去p ，增加元素只会让count增加，因此只有-1-&gt;0 或者0-&gt;1才能让differ变化
            if (count[s.charAt(i + pLen) - &#39;a&#39;] == -1) &#123;  // -1-&gt;0  --differ
                --differ;
            &#125; else if (count[s.charAt(i + pLen) - &#39;a&#39;] == 0) &#123;  // 0-&gt;1   ++differ
                ++differ;
            &#125;
            ++count[s.charAt(i + pLen) - &#39;a&#39;];
            
            if (differ == 0) &#123;
                ans.add(i + 1);
            &#125;
        &#125;

        return ans;
    &#125;
&#125;
</code></pre>
<h3 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h3><p>滑动窗口总结：</p>
<p>初始化滑动窗口</p>
<p>开始滑动</p>
<h2 id="字符串解码"><a href="#字符串解码" class="headerlink" title="字符串解码"></a>字符串解码</h2><pre><code>输入：s = &quot;3[a2[c]]&quot;
输出：&quot;accaccacc&quot;
</code></pre>
<p><strong>解法一：辅助栈法</strong></p>
<img src="/.xyz//image-20221001100508616.png" alt="image-20221001100508616" style="zoom: 80%;">

<img src="/.xyz//ezgif-5-e7185c1cac.gif" alt="[video-to-gif output image]">

<p>举例：3 [ a 2 [ c ] ]  </p>
<p>维护两个stack 前一个是数字  后一个res   </p>
<p>3：muti&#x3D;3</p>
<p>[ :  分别把3和”” 入栈，(3,””)  并把res和muti置为空</p>
<p>a: res&#x3D;a</p>
<p>2: muti &#x3D;2</p>
<p>]: 出栈，res&#x3D;””+3*res</p>
<p>我的理解：维护一个数字栈和字母栈 左括号前把东西记录进muti和res，出现左括号就muti res清空，清空这个很秒，首先后面的括号也要用res和muti作为临时存储 ，其次我情空但是然后后面入了数字栈和字母栈 所以res依然保留着，出现右括号就计算当前括号的res </p>
<pre><code class="java">class Solution &#123;
    public String decodeString(String s) &#123;
        StringBuilder res = new StringBuilder();
        int multi = 0;
        LinkedList&lt;Integer&gt; stack_multi = new LinkedList&lt;&gt;();
        LinkedList&lt;String&gt; stack_res = new LinkedList&lt;&gt;();
        for(Character c : s.toCharArray()) &#123;
            if(c == &#39;[&#39;) &#123;
                stack_multi.addLast(multi);//放到尾部
                stack_res.addLast(res.toString());
                //这俩置为0和空
                multi = 0;
                res = new StringBuilder();
            &#125;
            else if(c == &#39;]&#39;) &#123;
                StringBuilder tmp = new StringBuilder();
                int cur_multi = stack_multi.removeLast();
                for(int i = 0; i &lt; cur_multi; i++) tmp.append(res);
                res = new StringBuilder(stack_res.removeLast() + tmp);
            &#125;
            else if(c &gt;= &#39;0&#39; &amp;&amp; c &lt;= &#39;9&#39;) multi = multi * 10 + Integer.parseInt(c + &quot;&quot;);//防止有连续的数字
            else res.append(c);
        &#125;
        return res.toString();
    &#125;
&#125;
</code></pre>
<pre><code class="java">for(int i=0;i&lt;muti_stack.pop();i++)&#123;
    tmp.append(res);
&#125;
这样写会报错的原因是每次循环后muti_stack.pop()都会执行一次，最终导致EmptyStackException
正确方法是用一个变量保存它
</code></pre>
<h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><h2 id="前言-1"><a href="#前言-1" class="headerlink" title="前言"></a>前言</h2><pre><code class="java">Stack&lt;T&gt; stack = new Stack&lt;&gt;();
stack.push
stack.pop
</code></pre>
<pre><code>也可以用Linkedlist来实现，Deque&lt;Integer&gt; stack = new LinkedList&lt;Integer&gt;();

peek()方法用于从此Stack中返回顶部元素，并且它不删除就检索元素

不同点:peek 不改变栈的值(不删除栈顶的值),pop会把栈顶的值删除。
deque两种实现：
    java.util.LinkedList
    java.util.ArrayDeque
</code></pre>
<h2 id="用栈实现队列"><a href="#用栈实现队列" class="headerlink" title="用栈实现队列"></a>用栈实现队列</h2><p>void push(int x) 将元素 x 推到队列的末尾<br>int pop() 从队列的开头移除并返回元素<br>int peek() 返回队列开头的元素z<br>boolean empty() 如果队列为空，返回 true ；否则，返回 false</p>
<p><strong>方法一：双栈</strong></p>
<p>思路</p>
<p>将一个栈当作输入栈，用于压入 pushpush 传入的数据；另一个栈当作输出栈，用于 poppop 和 peekpeek 操作。</p>
<p>每次 poppop 或 peekpeek 时，若输出栈为空则将输入栈的全部数据依次弹出并压入输出栈，这样输出栈从栈顶往栈底的顺序就是队列从队首往队尾的顺序。</p>
<pre><code class="java">class MyQueue &#123;
    Deque&lt;Integer&gt; inStack;
    Deque&lt;Integer&gt; outStack;

    public MyQueue() &#123;
        inStack = new ArrayDeque&lt;Integer&gt;();
        outStack = new ArrayDeque&lt;Integer&gt;();
    &#125;

    public void push(int x) &#123;
        inStack.push(x);
    &#125;

    public int pop() &#123;
        if (outStack.isEmpty()) &#123;
            in2out();
        &#125;
        return outStack.pop();
    &#125;

    public int peek() &#123;
        if (outStack.isEmpty()) &#123;
            in2out();
        &#125;
        return outStack.peek();
    &#125;

    public boolean empty() &#123;
        return inStack.isEmpty() &amp;&amp; outStack.isEmpty();
    &#125;

    private void in2out() &#123;
        while (!inStack.isEmpty()) &#123;
            outStack.push(inStack.pop());
        &#125;
    &#125;
&#125;
</code></pre>
<h2 id="队列实现栈"><a href="#队列实现栈" class="headerlink" title="队列实现栈"></a>队列实现栈</h2><p><strong>方法一：两个队列</strong></p>
<p>queue只负责存储元素，入栈时候，入queue2,然后queue1元素进queue2，然后12换</p>
<p>其余操作都是对queu1进行判断就可</p>


<pre><code class="java">/** Push element x onto stack. */
    public void push(int x) &#123;
        queue2.offer(x);
        while (!queue1.isEmpty()) &#123;
            queue2.offer(queue1.poll());
        &#125;
        Queue&lt;Integer&gt; temp = queue1;
        queue1 = queue2;
        queue2 = temp;
    &#125;
</code></pre>
<p><strong>方法二：一个队列</strong></p>
<p>入栈的时候，先入栈，然后记录栈内元素，执行 queue.offer(queue.poll())即可 	其余操作直接判断即可</p>


<pre><code class="java">    /** Push element x onto stack. */
    public void push(int x) &#123;
        int n = queue.size();
        queue.offer(x);
        for (int i = 0; i &lt; n; i++) &#123;
            queue.offer(queue.poll());
        &#125;
    &#125;
</code></pre>
<h2 id="有效的括号"><a href="#有效的括号" class="headerlink" title="有效的括号"></a>有效的括号</h2><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串 s ，判断字符串是否有效。</p>
<p>有效字符串需满足：</p>
<p>左括号必须用相同类型的右括号闭合。<br>左括号必须以正确的顺序闭合。<br>每个右括号都有一个对应的相同类型的左括号。</p>
<pre><code class="cpp">public boolean isValid(String s) &#123;
        Stack&lt;Character&gt; stack = new Stack&lt;&gt;();
        char[] charArray = s.toCharArray();

        for (char ch : charArray) &#123;
            //如果是左括号则直接入栈
            if (ch == &#39;(&#39; || ch == &#39;&#123;&#39; || ch == &#39;[&#39;) &#123;
                stack.push(ch);
            &#125; else &#123;
               //如果是右括号，并且此时栈不为空
                if (!stack.isEmpty()) &#123;
                    if (ch == &#39;)&#39;) &#123;
                        if (stack.pop() != &#39;(&#39;)
                            return false;
                    &#125; else if (ch == &#39;&#125;&#39;) &#123;
                        if (stack.pop() != &#39;&#123;&#39;)
                            return false;
                    &#125; else &#123;
                        if (stack.pop() != &#39;[&#39;)
                            return false;
                    &#125;
                &#125;
                else&#123; //此时栈为空，但却来了个右括号，也直接返回false
                    return false;
                &#125;
            &#125;
        &#125;
        return stack.isEmpty();
    &#125;
</code></pre>
<h2 id="删除字符串中的所有相邻重复项"><a href="#删除字符串中的所有相邻重复项" class="headerlink" title="删除字符串中的所有相邻重复项"></a>删除字符串中的所有相邻重复项</h2><p><strong>栈的思想</strong></p>
<p>给出由小写字母组成的字符串 S，重复项删除操作会选择两个相邻且相同的字母，并删除它们。</p>
<p>在 S 上反复执行重复项删除操作，直到无法继续删除。  在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。</p>
<p><strong>方法一：String上面操作</strong></p>
<pre><code class="java">    public String removeDuplicates(String s) &#123;
        char[] charArray=s.toCharArray();
        int top=-1;//空栈的时候栈顶下标是-1
        for(int i=0;i&lt;s.length();i++)&#123;
            if(top&lt;0||charArray[i]!=charArray[top])&#123;
                //起到一个覆盖作用
                charArray[++top]=charArray[i];
            &#125;else&#123;
                top--;
            &#125;
        &#125;
        return String.valueOf(charArray,0,top+1);
    &#125;
</code></pre>
<p><strong>方法二：StringBuffer&#x2F;StringBuilder</strong></p>
<pre><code class="java">    public String removeDuplicates(String s) &#123;
    StringBuffer sb=new StringBuffer();
    int top=-1;
    for(char ch:s.toCharArray())&#123;
        if(top&lt;0||ch!=sb.charAt(top))&#123;
            sb.append(ch);
            top++;
        &#125;else&#123;
            sb.deleteCharAt(top--);
        &#125;
    &#125;
    return String.valueOf(sb);//或者toString
    &#125;
</code></pre>
<h2 id="逆波兰表达式"><a href="#逆波兰表达式" class="headerlink" title="逆波兰表达式"></a>逆波兰表达式</h2><pre><code>输入：tokens = [&quot;2&quot;,&quot;1&quot;,&quot;+&quot;,&quot;3&quot;,&quot;*&quot;]
输出：9
解释：该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) = 9
</code></pre>
<p><strong>栈思想</strong></p>
<pre><code class="java">class Solution &#123;
    public int evalRPN(String[] tokens) &#123;
       Deque&lt;Integer&gt; deque=new LinkedList&lt;&gt;();
       int n=tokens.length;
       for(int i=0;i&lt;n;i++)&#123;
           String token=tokens[i];
           if(isNumber(token))&#123;
               deque.push(Integer.parseInt(token));
           &#125;else&#123;
                int num2=deque.pop();
                int num1=deque.pop();
                switch(token)&#123;
                    case &quot;+&quot;:
                    deque.push(num1+num2);
                    break;

                    case &quot;-&quot;:
                    deque.push(num1-num2);
                    break;

                    case &quot;*&quot;:
                    deque.push(num1*num2);
                    break;

                    case &quot;/&quot;:
                    deque.push(num1/num2);
                    break;
                    default:
                &#125;
           &#125;
       &#125;
       return deque.pop();
    &#125;
    public boolean isNumber(String token)&#123;
        return !(&quot;+&quot;.equals(token)||&quot;-&quot;.equals(token)||&quot;*&quot;.equals(token)||&quot;/&quot;.equals(token));
    &#125;
&#125;
</code></pre>
<h2 id="最小栈"><a href="#最小栈" class="headerlink" title="最小栈"></a>最小栈</h2><p><strong>题目:</strong></p>


<pre><code class="java">class MinStack &#123;
        Deque&lt;Integer&gt; xstack;
        Deque&lt;Integer&gt; minstack;

        //构造最小栈  minstack里面放最大值
        public MinStack() &#123;
            xstack = new LinkedList&lt;Integer&gt;();
            minstack = new LinkedList&lt;Integer&gt;();
            minstack.push(Integer.MAX_VALUE);
        &#125;

        public void push(int val) &#123;
            xstack.push(val);
            minstack.push(Math.min(minstack.peek(), val));
        &#125;

        public void pop() &#123;
            xstack.pop();
            minstack.pop();
        &#125;

        public int top() &#123;
            return xstack.peek();
        &#125;

        public int getMin() &#123;
            return minstack.peek();
        &#125;
    &#125;
</code></pre>
<h2 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h2><p>用法 : 判别是否需要使用单调栈，如果需要找到左边或者右边第一个比当前位置的数大或者小，则可以考虑使用单调栈；单调栈的题目如矩形米面积等等</p>
<h3 id="每日温度"><a href="#每日温度" class="headerlink" title="每日温度"></a>每日温度</h3><p>给定一个整数数组 <code>temperatures</code> ，表示每天的温度，返回一个数组 <code>answer</code> ，其中 <code>answer[i]</code> 是指对于第 <code>i</code> 天，下一个更高温度出现在几天后。如果气温在这之后都不会升高，请在该位置用 <code>0</code> 来代替。</p>


<p>维护一个存储下标的单调栈，从栈底到栈顶的下标对应的温度列表中的温度依次递减。如果一个下标在单调栈里，则表示尚未找到下一次温度更高的下标。</p>
<p>正向遍历温度列表。对于温度列表中的每个元素 temperatures[i]，如果栈为空，则直接将 i 进栈，如果栈不为空，则比较栈顶元素 prevIndex 对应的温度 temperatures[prevIndex] 和当前温度 temperatures[i]，如果 temperatures[i] &gt; temperatures[prevIndex]，则将 prevIndex 移除，并将 prevIndex 对应的等待天数赋为 i - prevIndex，重复上述操作直到栈为空或者栈顶元素对应的温度小于等于当前温度，然后将 i 进栈。</p>
<p>因此只有栈不为空且栈顶元素对应的温度大于当前温度，才可以一直移除prevIndex并计算，所以这就是while循环的条件</p>
<p>最终解法：</p>
<pre><code class="java">class Solution &#123;
    public int[] dailyTemperatures(int[] temperatures) &#123;
        int n = temperatures.length;
        int[] ans = new int[n];
        Deque&lt;Integer&gt; deque = new LinkedList&lt;Integer&gt;();
        for (int i = 0; i &lt; n; i++) &#123;
            int temperature = temperatures[i];
            while (!deque.isEmpty() &amp;&amp; temperature &gt; temperatures[deque.peek()]) &#123;
                //栈顶数字
                int topNum = deque.pop();
                ans[topNum] = i - topNum;
            &#125;
            deque.push(i);
        &#125;
        return ans;

    &#125;
&#125;
//总结：《反着维护》 求下一个最高 那我就维护一个单调减的栈当出现大于栈顶的元素  直接输出栈顶的元素下一个最高温度是几天后   
</code></pre>
<p>我自己写的暴力：</p>
<pre><code class="java">class Solution &#123;
    public int[] dailyTemperatures(int[] temperatures) &#123;
        int n=temperatures.length;
        int[] res=new int[n];
        for(int i=0;i&lt;n;i++)&#123;
            int j=i+1;
            //更高温度必须严格大于
            while(j&lt;n&amp;&amp;temperatures[j]&lt;=temperatures[i])&#123;
                j++;
            &#125;
            if(j==n)&#123;
                //要么是最后一个元素要么是最大元素，反正最后都会到下标为n这个位置
                res[i]=0;
            &#125;else&#123;
                res[i]=j-i;
            &#125;
        &#125;
        return res;
    &#125;
&#125;
</code></pre>
<h1 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h1><h2 id="赎金信"><a href="#赎金信" class="headerlink" title="赎金信"></a>赎金信</h2><p>给你两个字符串：ransomNote 和 magazine ，判断 ransomNote 能不能由 magazine 里面的字符构成。</p>
<p>如果可以，返回 true ；否则返回 false 。</p>
<p>magazine 中的每个字符只能在 ransomNote 中使用一次。</p>
<p><strong>官方题解</strong></p>
<img src="/.xyz//image-20221017202244463.png" alt="image-20221017202244463" style="zoom:67%;">

<p><strong>我的题解</strong></p>
<pre><code class="java">class Solution &#123;
    //我的思路：先magazine存kv，然后ransomNote找如果没key或者value为0直接返回false，否则magazine对应v-1
    public boolean canConstruct(String ransomNote, String magazine) &#123;
        Map&lt;Character,Integer&gt; map=new HashMap&lt;&gt;();
        for(char c:magazine.toCharArray())&#123;
            map.put(c,map.getOrDefault(c,0)+1);
        &#125;
        for(char d:ransomNote.toCharArray())&#123;  
            if(!map.containsKey(d)||map.get(d)==0)&#123;
                return false;
            &#125;else&#123;
                map.put(d,map.get(d)-1);
            &#125;
        &#125;
        return true;
    &#125;
&#125;
</code></pre>
<h2 id="四数相加II"><a href="#四数相加II" class="headerlink" title="四数相加II"></a>四数相加II</h2><p>给你四个整数数组 <code>nums1</code>、<code>nums2</code>、<code>nums3</code> 和 <code>nums4</code> ，数组长度都是 <code>n</code> ，请你计算有多少个元组 <code>(i, j, k, l)</code> 能满足：</p>
<ul>
<li><code>0 &lt;= i, j, k, l &lt; n</code></li>
<li><code>nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0</code></li>
</ul>


<pre><code class="java">class Solution &#123;
    public int fourSumCount(int[] A, int[] B, int[] C, int[] D) &#123;
        Map&lt;Integer, Integer&gt; countAB = new HashMap&lt;Integer, Integer&gt;();
        for (int u : A) &#123;
            for (int v : B) &#123;
                countAB.put(u + v, countAB.getOrDefault(u + v, 0) + 1);
            &#125;
        &#125;
        int ans = 0;
        for (int u : C) &#123;
            for (int v : D) &#123;
                if (countAB.containsKey(-u - v)) &#123;
                    ans += countAB.get(-u - v);
                &#125;
            &#125;
        &#125;
        return ans;
    &#125;
&#125;
</code></pre>
<h2 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a>1. 两数之和</h2><p><strong>方法一：</strong> <strong>暴力</strong></p>
<p>最容易想到的方法是枚举数组中的每一个数 <code>x</code>，寻找数组中是否存在 <code>target - x</code>。  时间复杂度：O(N2)</p>
<p><strong>方法二（优先）：哈希表</strong></p>
<p>注意到方法一的时间复杂度较高的原因是寻找 target - x 的时间复杂度过高。因此，我们需要一种更优秀的方法，能够快速寻找数组中是否存在目标元素。如果存在，我们需要找出它的索引。</p>
<p>使用哈希表，可以将寻找 target - x 的时间复杂度降低到从 O(N) 降低到 O(1)。</p>
<p>这样我们创建一个哈希表，对于每一个 x，我们首先查询哈希表中是否存在 target - x，然后将 x 插入到哈希表中，即可保证不会让 x 和自己匹配。</p>
<pre><code class="java">class Solution &#123;
    public int[] twoSum(int[] nums, int target) &#123;
        Map&lt;Integer, Integer&gt; hashtable = new HashMap&lt;Integer, Integer&gt;();
        for (int i = 0; i &lt; nums.length; ++i) &#123;
            if (hashtable.containsKey(target - nums[i])) &#123;
                return new int[]&#123;hashtable.get(target - nums[i]), i&#125;;
            &#125;
            hashtable.put(nums[i], i);
        &#125;
        return new int[0];
    &#125;
&#125;
</code></pre>
<h2 id="202-快乐数"><a href="#202-快乐数" class="headerlink" title="202. 快乐数"></a>202. 快乐数</h2><p>编写一个算法来判断一个数 n 是不是快乐数。</p>
<p>「快乐数」 定义为：</p>
<p>对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。<br>然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。<br>如果这个过程 结果为 1，那么这个数就是快乐数。</p>
<p><strong>方法一</strong></p>
<img src="/.xyz//image-20221016165323827.png" alt="image-20221016165323827" style="zoom: 80%;">



<pre><code class="java">class Solution &#123;
    private int getNext(int n) &#123;
        int totalSum = 0;
        while (n &gt; 0) &#123;
            int d = n % 10;
            n = n / 10;
            totalSum += d * d;
        &#125;
        return totalSum;
    &#125;

    public boolean isHappy(int n) &#123;
        Set&lt;Integer&gt; seen = new HashSet&lt;&gt;();
        while (n != 1 &amp;&amp; !seen.contains(n)) &#123;
            seen.add(n);
            n = getNext(n);
        &#125;
        return n == 1;
    &#125;
&#125;
</code></pre>
<p><strong>方法二</strong></p>




<pre><code class="java">class Solution &#123;
     public int getNext(int n) &#123;
        int totalSum = 0;
        while (n &gt; 0) &#123;
            int d = n % 10;
            n = n / 10;
            totalSum += d * d;
        &#125;
        return totalSum;
    &#125;

    public boolean isHappy(int n) &#123;
        int slowRunner = n;
        int fastRunner = n;
        while (fastRunner != 1 &amp;&amp; slowRunner != fastRunner) &#123;
            slowRunner = getNext(slowRunner);
            fastRunner = getNext(getNext(fastRunner));
        &#125;
        return fastRunner == 1;
    &#125;
&#125;
</code></pre>
<h2 id="349-两个数组的交集"><a href="#349-两个数组的交集" class="headerlink" title="349. 两个数组的交集"></a>349. 两个数组的交集</h2><p>给定两个数组 <code>nums1</code> 和 <code>nums2</code> ，返回 <em>它们的交集</em> 。输出结果中的每个元素一定是 <strong>唯一</strong> 的。我们可以 <strong>不考虑输出结果的顺序</strong> 。</p>
<p>我自己的解法</p>
<pre><code class="java">class Solution &#123;
    public int[] intersection(int[] nums1, int[] nums2) &#123;
        int n=nums1.length;
        int m=nums2.length;
        Set&lt;Integer&gt; hashSet=new HashSet&lt;&gt;();
        Set&lt;Integer&gt; mergeSet=new HashSet&lt;&gt;();
        //利用Set无重复元素的特点 把nums1进行去重
        for(int i=0;i&lt;n;i++)&#123;
            hashSet.add(nums1[i]);
        &#125;
        //判断hashSet里面有么有nums2,有的话把nums2放到Set结果里面
        for(int i=0;i&lt;m;i++)&#123;
            if(hashSet.contains(nums2[i]))&#123;
                mergeSet.add(nums2[i]);
            &#125;
        &#125;
        //Set转int[]
        int[] res=new int[mergeSet.size()];
        int i=0;
        for(int num:mergeSet)&#123;
            res[i++]=num;
        &#125;
        return res;
    &#125;
&#125;
</code></pre>
<h2 id="242-有效的字母异位词"><a href="#242-有效的字母异位词" class="headerlink" title="242.有效的字母异位词"></a>242.有效的字母异位词</h2><p>给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。</p>
<p>注意：若 s 和 t 中每个字符出现的次数都相同，则称 s 和 t 互为字母异位词。</p>




<h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><h2 id="前言-2"><a href="#前言-2" class="headerlink" title="前言"></a>前言</h2><p>常用方法：dummyNode空结点  、双指针、快慢指针</p>
<p>链表好多都可以用递归或者迭代，递归简洁不好想，递归好理解</p>
<p>ListNode是由自己定义的java中的链表对象</p>


<p>类结构如下</p>
<pre><code class="java">public class ListNode &#123;
       int val;
       ListNode next;
       public ListNode(int x) &#123;
            val = x;
       &#125;
&#125;
</code></pre>
<pre><code class="java">class Solution &#123;
    public ListNode removeElements(ListNode head, int val) &#123;
        ListNode dumyNode=new ListNode();
        dumyNode.next=head;
        ListNode cur=dumyNode;
        while(cur.next!=null)&#123;
            if(cur.next.val==val)&#123;
                cur.next=cur.next.next;
            &#125;else&#123;
                cur=cur.next;
            &#125;
        &#125;
        return dumyNode.next;
    &#125;
&#125;
</code></pre>
<h2 id="删除链表的倒数第-N-个结点"><a href="#删除链表的倒数第-N-个结点" class="headerlink" title="删除链表的倒数第 N 个结点"></a>删除链表的倒数第 N 个结点</h2><p>给你一个链表，删除链表的倒数第 <code>n</code> 个结点，并且返回链表的头结点。</p>
<p>方法一：一种容易想到的方法是，我们首先从头节点开始对链表进行一次遍历，得到链表的长度 L。随后我们再从头节点开始对链表进行一次遍历，当遍历到第 L−n+1 个节点时，它就是我们需要删除的节点。</p>
<p>方法二：我们也可以在遍历链表的同时将所有节点依次入栈。根据栈「先进后出」的原则，我们弹出栈的第 n 个节点就是需要删除的节点，并且目前栈顶的节点就是待删除节点的前驱节点。这样一来，删除操作就变得十分方便了。</p>


<pre><code class="java">ListNode dummy = new ListNode(0, head);//val为0 下一个结点为head
</code></pre>
<pre><code class="java">//我喜欢方法三
class Solution &#123;
    public ListNode removeNthFromEnd(ListNode head, int n) &#123;
        ListNode dummy = new ListNode(0, head);
        ListNode first = head;
        ListNode second = dummy;
        for (int i = 0; i &lt; n; ++i) &#123;
            first = first.next;
        &#125;
        while (first != null) &#123;
            first = first.next;
            second = second.next;
        &#125;
        second.next = second.next.next;
        ListNode ans = dummy.next;
        return ans;
    &#125;
&#125;
</code></pre>
<h2 id="两两交换链表中的节点24"><a href="#两两交换链表中的节点24" class="headerlink" title="两两交换链表中的节点24"></a>两两交换链表中的节点24</h2><p>给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。</p>
<img src="/.xyz//image-20221015163411413.png" alt="image-20221015163411413" style="zoom: 80%;">

<pre><code class="java">class Solution &#123;
    public ListNode swapPairs(ListNode head) &#123;
        if (head == null || head.next == null) &#123;
            return head;
        &#125;
        ListNode newHead = head.next;
        head.next = swapPairs(newHead.next);
        newHead.next = head;
        return newHead;
    &#125;
&#125;
</code></pre>
<img src="/.xyz//image-20221015163434779.png" alt="image-20221015163434779" style="zoom:80%;">

<pre><code class="java">class Solution &#123;
    public ListNode swapPairs(ListNode head) &#123;
        ListNode dummyHead = new ListNode(0);
        dummyHead.next = head;
        ListNode temp = dummyHead;
        //判断条件 后面没有结点或者只有一个就不用换
        while (temp.next != null &amp;&amp; temp.next.next != null) &#123;
            ListNode node1 = temp.next;
            ListNode node2 = temp.next.next;
            temp.next = node2;
            node1.next = node2.next;
            node2.next = node1;
            temp = node1;
        &#125;
        return dummyHead.next;
    &#125;
&#125;
</code></pre>
<h2 id="移除链表元素203"><a href="#移除链表元素203" class="headerlink" title="移除链表元素203"></a>移除链表元素203</h2><p>给你一个链表的头节点 <code>head</code> 和一个整数 <code>val</code> ，请你删除链表中所有满足 <code>Node.val == val</code> 的节点，并返回 <strong>新的头节点</strong> 。</p>
<img src="/.xyz//image-20221014152913347.png" alt="image-20221014152913347" style="zoom:67%;">

<pre><code class="java">class Solution &#123;
    public ListNode removeElements(ListNode head, int val) &#123;
        ListNode dumyNode=new ListNode();
        dumyNode.next=head;
        ListNode cur=dumyNode;
        while(cur.next!=null)&#123;
            if(cur.next.val==val)&#123;
                cur.next=cur.next.next;
            &#125;else&#123;
                cur=cur.next;
            &#125;
        &#125;
        return dumyNode.next;
    &#125;
&#125;
</code></pre>
<p>优先方法二，比较好理解。</p>
<img src="/.xyz//image-20221014152957745.png" alt="image-20221014152957745" style="zoom: 67%;">

<h2 id="设计链表"><a href="#设计链表" class="headerlink" title="设计链表"></a>设计链表</h2>

<p><strong>单链表</strong></p>
<pre><code class="java">class MyLinkedList &#123;
    //用哨兵节点（值为0）当作头结点(但不是真的头结点)
    int size;
    ListNode head;
    public MyLinkedList() &#123;
        size=0;
        head=new ListNode(0);
    &#125;
    
    public int get(int index) &#123;
        if(index&lt;0||index&gt;=size)&#123;
            return -1;
        &#125;
        ListNode cur=head;
        for(int i=0;i&lt;=index;i++)&#123;
            cur=cur.next;
        &#125;
        return cur.val;
    &#125;
    
    public void addAtHead(int val) &#123;
        addAtIndex(0,val);
    &#125;
    
    public void addAtTail(int val) &#123;
        addAtIndex(size,val);
    &#125;
    
    public void addAtIndex(int index, int val) &#123;
        if(index&gt;size)&#123;
            return;
        &#125;
        //小于0设为0
        index=index&lt;0?0:index;
        ListNode tar=new ListNode(val);
        ListNode cur=head;
        for(int i=0;i&lt;index;i++)&#123;
            cur=cur.next;
        &#125;
        tar.next=cur.next;
        cur.next=tar;
        size++;
    &#125;
    
    public void deleteAtIndex(int index) &#123;
        if(index&lt;0||index&gt;=size)&#123;
            return;
        &#125;
        ListNode cur=head;
        for(int i=0;i&lt;index;i++)&#123;
            cur=cur.next;
        &#125;
        cur.next=cur.next.next;
        size--;
    &#125;
&#125;
</code></pre>
<p>双链表就不写辣</p>
<h2 id="回文链表"><a href="#回文链表" class="headerlink" title="回文链表"></a>回文链表</h2><p><strong>方法一：将值复制到数组中后用双指针法</strong></p>
<p>一共为两个步骤：</p>
<ol>
<li>复制链表值到数组列表中。</li>
<li>使用双指针法判断是否为回文。node_1.val &#x3D;&#x3D; node_2.val</li>
</ol>
<p><strong>方法二：快慢指针</strong></p>
<ol>
<li>找到前半部分链表的尾节点。</li>
<li>根据前半部分分链表尾结点，反转后半部分链表。</li>
<li>判断是否回文。</li>
<li>恢复链表（再把步骤二做一次）。</li>
<li>返回结果。</li>
</ol>
<h2 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h2><p>最简单的不考虑复杂度的话，利用<strong>外部空间</strong></p>
<p>先申请一个动态扩容的数组或者容器，比如 ArrayList 这样的。然后不断遍历链表，将链表中的元素添加到这个容器中。再利用容器自身的 API，反转整个容器，这样就达到反转的效果了。最后同时遍历容器和链表，将链表中的值改为容器中的值。因为此时容器的值是：</p>
<p>5 4 3 2 1</p>
<p>链表按这个顺序重新被设置一边，就达到要求啦。</p>
<p><strong>一、迭代</strong>（好理解一点）</p>
<p>两个指针，cur和pre，pre先指向Null，cur指向head，然后遍历cur，每次迭代到cur，用一个tmp存储cur的下一结点，然后cur的Next指向pre，pre前进一位（pre指向cur，cur指向tmp）</p>
<p><strong>代码</strong></p>
<pre><code class="java">class Solution &#123;
    public ListNode reverseList(ListNode head) &#123;
        //申请节点，pre和 cur，pre指向null
        ListNode pre = null;
        ListNode cur = head;
        ListNode tmp = null;
        while(cur!=null) &#123;
            //记录当前节点的下一个节点
            tmp = cur.next;
            //然后将当前节点指向pre
            cur.next = pre;
            //pre和cur节点都前进一位
            pre = cur;
            cur = tmp;
        &#125;
        return pre;
    &#125;
&#125;
</code></pre>
<p><strong>二、递归（不好理解）</strong></p>
<p>递归的两个条件：</p>
<pre><code>终止条件是当前节点或者下一个节点==null
在函数内部，改变节点的指向，也就是 head 的下一个节点指向 head 递归函数那句
</code></pre>
<p>head.next.next &#x3D; head</p>
<p>很不好理解，其实就是 head 的下一个节点指向head。<br>递归函数中每次返回的 cur 其实只最后一个节点，在递归函数内部，改变的是当前节点的指向。<br>动画演示如下：</p>


<p>我的理解：先一直执行ListNode cur &#x3D; reverseList(head.next)，一直到head为4的时候，if里面成立（head.next&#x3D;&#x3D;null），跳出，此时cur为5，但是是在4这个结点的递归里面，因此head为4，所以head.next.next 就是5-&gt;4；防止链表循环（因为已经形成了一个环了），需要将head.next设置为空，然后返回cur，因为每层递归函数都返回cur。</p>
<pre><code class="java">class Solution &#123;
    public ListNode reverseList(ListNode head) &#123;
        //递归终止条件是当前为空，或者下一个节点为空
        if(head==null || head.next==null) &#123;
            return head;
        &#125;
        //这里的cur就是最后一个节点
        ListNode cur = reverseList(head.next);
        //这里请配合动画演示理解
        //如果链表是 1-&gt;2-&gt;3-&gt;4-&gt;5，那么此时的cur就是5
        //而head是4，head的下一个是5，下下一个是空
        //所以head.next.next 就是5-&gt;4
        head.next.next = head;
        //防止链表循环，需要将head.next设置为空
        head.next = null;
        //每层递归函数都返回cur，也就是最后一个节点
        return cur;
    &#125;
&#125;
</code></pre>
<h2 id="环形链表I"><a href="#环形链表I" class="headerlink" title="环形链表I"></a>环形链表I</h2><img src="/.xyz//image-20221015175612893.png" alt="image-20221015175612893" style="zoom: 80%;">

<p><strong>方法一：哈希表</strong></p>
<p>最容易想到的方法是遍历所有节点，每次遍历到一个节点时，判断该节点此前是否被访问过。</p>
<p>具体地，我们可以使用哈希表来存储所有已经访问过的节点。每次我们到达一个节点，如果该节点已经存在于哈希表中，则说明该链表是环形链表，否则就将该节点加入哈希表中。重复这一过程，直到我们遍历完整个链表即可。</p>
<pre><code class="java">public class Solution &#123;
    public boolean hasCycle(ListNode head) &#123;
        Set&lt;ListNode&gt; seen = new HashSet&lt;ListNode&gt;();
        while (head != null) &#123;
            if (!seen.add(head)) &#123;
                return true;
            &#125;
            head = head.next;
        &#125;
        return false;
    &#125;
&#125;
</code></pre>
<p><strong>方法二：快慢指针</strong>（龟兔赛跑）</p>
<p>本方法需要读者对「Floyd 判圈算法」（又称龟兔赛跑算法）有所了解。</p>
<p>假想「乌龟」和「兔子」在链表上移动，「兔子」跑得快，「乌龟」跑得慢。当「乌龟」和「兔子」从链表上的同一个节点开始移动时，如果该链表中没有环，那么「兔子」将一直处于「乌龟」的前方；如果该链表中有环，那么「兔子」会先于「乌龟」进入环，并且一直在环内移动。等到「乌龟」进入环时，由于「兔子」的速度快，它一定会在某个时刻与乌龟相遇，即套了「乌龟」若干圈。</p>
<p>我们可以根据上述思路来解决本题。具体地，我们定义两个指针，一快一慢。慢指针每次只移动一步，而快指针每次移动两步。初始时，慢指针在位置 head，而快指针在位置 head.next。这样一来，如果在移动的过程中，快指针反过来追上慢指针，就说明该链表为环形链表。否则快指针将到达链表尾部，该链表不为环形链表。</p>
<p><strong>细节</strong></p>
<p>为什么我们要规定初始时慢指针在位置 head，快指针在位置 head.next，而不是两个指针都在位置 head（即与「乌龟」和「兔子」中的叙述相同）？</p>
<p>观察下面的代码，我们使用的是 while 循环，循环条件先于循环体。由于循环条件一定是判断快慢指针是否重合，如果我们将两个指针初始都置于 head，那么 while 循环就不会执行。因此，我们可以假想一个在 head 之前的虚拟节点，慢指针从虚拟节点移动一步到达 head，快指针从虚拟节点移动两步到达 head.next，这样我们就可以使用 while 循环了。</p>
<p>当然，我们也可以使用 do-while 循环。此时，我们就可以把快慢指针的初始值都置为 head。</p>
<pre><code class="java">public class Solution &#123;
    public boolean hasCycle(ListNode head) &#123;
        if (head == null || head.next == null) &#123;
            return false;
        &#125;
        ListNode slow = head;
        ListNode fast = head.next;
        while (slow != fast) &#123;
            if (fast == null || fast.next == null) &#123;
                return false;
            &#125;
            slow = slow.next;
            fast = fast.next.next;
        &#125;
        return true;
    &#125;
&#125;
</code></pre>
<h2 id="环形链表II"><a href="#环形链表II" class="headerlink" title="环形链表II"></a>环形链表II</h2><p>给定一个链表的头节点  <code>head</code> ，返回链表开始入环的第一个节点。 <em>如果链表无环，则返回 <code>null</code>。</em></p>
<p>方法一 哈希</p>
<pre><code class="java">public class Solution &#123;
    public ListNode detectCycle(ListNode head) &#123;
        Set&lt;ListNode&gt; seen=new HashSet&lt;&gt;();
        while(head!=null)&#123;
            //用contains也可
            if(seen.add(head))&#123;
                head=head.next;
            &#125;else&#123;
                return head;
            &#125;
        &#125;
        return null;
    &#125;
&#125;
</code></pre>
<p>方法二</p>
<img src="/.xyz//image-20221015181031942.png" alt="image-20221015181031942" style="zoom:80%;">

<p>环形链表和龟兔赛跑很像，也是相遇后，再有一个指针从头开始和slow一起移动，最后相遇即为结果</p>
<pre><code class="java">public class Solution &#123;
    public ListNode detectCycle(ListNode head) &#123;
        if (head == null) &#123;
            return null;
        &#125;
        ListNode slow = head, fast = head;
        while (fast != null) &#123;
            slow = slow.next;
            if (fast.next != null) &#123;
                fast = fast.next.next;
            &#125; else &#123;
                return null;
            &#125;
            if (fast == slow) &#123;
                ListNode ptr = head;
                while (ptr != slow) &#123;
                    ptr = ptr.next;
                    slow = slow.next;
                &#125;
                return ptr;
            &#125;
        &#125;
        return null;
    &#125;
&#125;
</code></pre>
<p>弗洛伊德循环查找算法结论：</p>
<p>1、如果有环，兔子乌龟(兔子和乌龟可以不在一个位置出发，这个要看具体情况)必定会相遇（判断是否有环，循环问题，链表、快乐数）</p>
<p>2、如果有环，兔子乌龟同时同位置出发，相遇后，再有一个指针从头开始和slow一起移动，最后在入环点相遇。</p>
<h2 id="相交链表"><a href="#相交链表" class="headerlink" title="相交链表"></a>相交链表</h2><p>给你两个单链表的头节点 <code>headA</code> 和 <code>headB</code> ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 <code>null</code> </p>
<img src="/.xyz//160_statement.png" alt="img" style="zoom:50%;">



<img src="/.xyz//image-20220910174724580.png" alt="image-20220910174724580" style="zoom: 67%;">

<img src="/.xyz//image-20221015175222441.png" alt="image-20221015175222441" style="zoom:67%;">

<pre><code class="java">public ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123;
    if (headA == null || headB == null) return null;
    ListNode pA = headA, pB = headB;
    while (pA != pB) &#123;
        pA = pA == null ? headB : pA.next;
        pB = pB == null ? headA : pB.next;
    &#125;
    return pA;
&#125;
总结：当某个结点为空就去另一个链表的头节点，直到两者相遇，管他为空还是在一个结点处
</code></pre>
<p>还有一种基本的方法，就是构造一个哈希表，先把A链表的结点都存进去，然后遍历B链表，当某个节点在A里面有则返回之；</p>
<h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><h2 id="根据身高重建队列"><a href="#根据身高重建队列" class="headerlink" title="根据身高重建队列"></a>根据身高重建队列</h2><p><strong>题目：</strong></p>




<p>所以接下来只要按照K值将他插入相应的位置就可以了。 解释： 因为前面的每个人身高都比它大， 但是他前面只能有 K 个人大于等于它的身高，所以他只能放在第K个位置。</p>
<p>请问为什么 [6,1]插入第1的位置，这时[7,1]就往后移一位了 – 为什么这里可以后移一位呢？</p>
<p>我的回答：因为先插进去的比后插进去的个子高 ，7&gt;6，[6,1]必须在1这个位置，否则k就要变，所以 [7,1]往后移一位， 那[7,1]往后移一位对[7,1]有影响吗，没有！排[6,1]后面，我的1还是1，因为你比我矮！</p>
<pre><code class="java">class Solution &#123;
    public int[][] reconstructQueue(int[][] people) &#123;
        Arrays.sort(people, new Comparator&lt;int[]&gt;() &#123;
            public int compare(int[] person1, int[] person2) &#123;
                if (person1[0] != person2[0]) &#123;
                    return person2[0] - person1[0];
                &#125; else &#123;
                    return person1[1] - person2[1];
                &#125;
            &#125;
        &#125;);
        List&lt;int[]&gt; ans = new ArrayList&lt;int[]&gt;();
        for (int[] person : people) &#123;
            ans.add(person[1], person);
        &#125;
        //集合转数组
        return ans.toArray(new int[ans.size()][]);//开辟二维数组空间 同时指定其中一维的长度  另一维不用指定
    &#125;
&#125;
</code></pre>
<h2 id="前-K-个高频元素"><a href="#前-K-个高频元素" class="headerlink" title="前 K 个高频元素"></a>前 K 个高频元素</h2><ul>
<li><p><input checked disabled type="checkbox"> 
借助 哈希表 来建立数字和其出现次数的映射，遍历一遍数组统计元素的频率</p>
</li>
<li><p><input checked disabled type="checkbox"> 
维护一个元素数目为 k 的最小堆</p>
</li>
<li><p><input checked disabled type="checkbox"> 
每次都将新的元素与堆顶元素（堆中频率最小的元素）进行比较</p>
</li>
<li><p><input checked disabled type="checkbox"> 
如果新的元素的频率比堆顶端的元素大，则弹出堆顶端的元素，将新的元素添加进堆中</p>
</li>
<li><p><input checked disabled type="checkbox"> 
最终，堆中的 k个元素即为前 k个高频元素</p>
<img src="/.xyz//2b27b1db106a53abe239c5be8e49a800522ab2f6637940cb556bcfe1232ff333-file_1561712388055" alt="img" style="zoom:50%;">



<p>&#96;&#96;&#96;java<br>class Solution {<br>public int[] topKFrequent(int[] nums, int k) {<br>    Map&lt;Integer, Integer&gt; occurrences &#x3D; new HashMap&lt;Integer, Integer&gt;();<br>    for (int num : nums) {<br>        occurrences.put(num, occurrences.getOrDefault(num, 0) + 1);<br>    }<br><br>    &#x2F;&#x2F; int[] 的第一个元素代表数组的值，第二个元素代表了该值出现的次数<br>    PriorityQueue&lt;int[]&gt; queue &#x3D; new PriorityQueue&lt;int[]&gt;(new Comparator&lt;int[]&gt;() {<br>        public int compare(int[] m, int[] n) {<br>            return m[1] - n[1];&#x2F;&#x2F;升序  和方法参数位置一致就是升序<br>        }<br>    });&#x2F;&#x2F;注意这里有分号<br>    &#x2F;&#x2F;.entrySet 把HashMap转成集合   Map.Entry是类名 记住就行<br>    &#x2F;&#x2F;poll peek 都是队首 peek不出来 poll出来<br>    for (Map.Entry&lt;Integer, Integer&gt; entry : occurrences.entrySet()) {<br>        int num &#x3D; entry.getKey(), count &#x3D; entry.getValue();<br>        if (queue.size() &#x3D;&#x3D; k) {<br>            if (queue.peek()[1] &lt; count) {<br>                queue.poll();<br>                queue.offer(new int[]{num, count});<br>            }<br>        } else {<br>            queue.offer(new int[]{num, count});<br>        }<br>    }<br>    int[] ret &#x3D; new int[k];<br>    for (int i &#x3D; 0; i &lt; k; ++i) {<br>        ret[i] &#x3D; queue.poll()[0];<br>    }<br>    return ret;<br>}</p>
</li>
</ul>
<p>}</p>
<pre><code>


## 数组中第K个最大元素

### 快速排序

原始：

https://blog.csdn.net/weixin_43586713/article/details/119820797

```java
//凯杰推荐解法
class Solution &#123;
  public int findKthLargest(int[] nums, int k) &#123;
      return quick_select(0,nums.length - 1, k, nums);//注意这里直接return即可
  &#125;
  public int quick_select(int l, int r, int k, int[] nums) &#123;
      if (l &gt;= r) return nums[l];
      int i = l - 1, j = r + 1, x = nums[(l + r) &gt;&gt; 1];//piovt是中间数字，i j选l-1 r+1，感觉是因为后面的++i和==j
      while (i &lt; j) &#123;
          while (nums[++i] &lt; x);//先加加再交换
          while (nums[--j] &gt; x);
          if (i &lt; j) swap(nums,i,j);//在左边找个比pivot大的，右边找个比vilot小的，换
      &#125;
      //递归
      int cmp = r - j;//pivot右边长度   r-(i+1)+1
      if (cmp &gt;= k) return quick_select(j + 1, r, k, nums);//如果大于的话，则所找的数字必然在后半数组，否则在前面
      return quick_select(l, j, k - cmp, nums);//从后往前排，后半数组是前cmp个数，那么只需要在前半数组里面找到第k-cmp大的数就行
  &#125;
  public void swap(int[] a, int i, int j) &#123;
      int temp = a[i];
      a[i] = a[j];
      a[j] = temp;
  &#125;
&#125;
</code></pre>
<h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p><a href="https://blog.csdn.net/weixin_51609435/article/details/122982075">https://blog.csdn.net/weixin_51609435/article/details/122982075</a></p>
<p>堆排序算法的步骤：</p>
<ol>
<li><p>把无序数组构建成二叉堆。</p>
</li>
<li><p>循环删除堆顶元素，移到集合尾部，调节堆产生新的堆顶。</p>
</li>
</ol>
<p>当我们删除一个最大堆的堆顶（并不是完全删除，而是替换到最后面），经过自我调节，第二大的元素就会被交换上来，成为最大堆的新堆顶。</p>
<p>正如上图所示，当我们删除值为9的堆顶节点，经过调节，值为6的新节点就会顶替上来；当我们删除值为6的堆顶节点，经过调节，值为5的新节点就会顶替上来…….</p>
<p>由于二叉堆的这个特性，我们每一次删除旧堆顶，调整后的新堆顶都是大小仅次于旧堆顶的节点。那么我们只要反复删除堆顶，反复调节二叉堆，所得到的集合就成为了一个有序集合，</p>
<p>堆排序是不稳定的排序，空间复杂度为O(1),平均的时间复杂度为O(nlogn),最坏情况下也稳定在O(nlogn) </p>
<p>注意:升序用大根堆，降序就用小根堆(默认为升序)</p>
<p><strong>题目：数组中第K个最大元素</strong></p>
<pre><code class="java">class Solution &#123;
   //堆排序
    public int[] sortArray(int[] nums) &#123;
        //建立初始大根堆
        buildMaxHeap(nums);
 
        //调整大根堆
        for(int i=nums.length-1;i&gt;0;i--)&#123;
            //将大根堆顶与最后一个元素交换，通过不断交换，最后得到一个升序数组
            swap(nums,0,i);
            // 调整剩余数组，使其满足大顶堆
            maxHeapify(nums, 0, i);
        &#125;
        return nums;
    &#125;
    //建立初始大根堆
    public void buildMaxHeap(int[] nums)&#123;
        //从第一个非叶子节点开始  调整好再调上一个
        for(int i=nums.length/2-1;i&gt;=0;i--)&#123;
            //调整每一个子树为大根堆
            maxHeapify(nums,i,nums.length);
        &#125;
    &#125;
    //调整大根堆，第二个参数为堆顶，第三个参数为，参与调整的最后一个数的下标+1
    public void maxHeapify(int[] nums,int i,int heapSize)&#123;
        //左子树
        int l=2*i+1;
        //右子树
        int r=l+1;
        //记录根结点、左子树结点、右子树结点三者中的最大值下标
        int largest=i;
        // 与左子树结点比较
        if(l&lt;heapSize &amp;&amp; nums[l]&gt;nums[largest])&#123;
            largest=l;
        &#125;
        // 与右子树结点比较
        if(r&lt;heapSize &amp;&amp; nums[r]&gt;nums[largest])&#123;
            largest=r;
        &#125;
        if(largest!=i)&#123;
            // 将最大值交换为根结点
            swap(nums,i,largest);
            // 再次调整交换数字后的大顶堆  因为调整完后下面还有调整
            maxHeapify(nums,largest,heapSize);
        &#125;
    &#125;
    //交换
    public void swap(int[] nums,int i,int j)&#123;
        int temp=nums[i];
        nums[i]=nums[j];
        nums[j]=temp;   
    &#125;    
&#125;
</code></pre>
<h2 id="排序链表"><a href="#排序链表" class="headerlink" title="排序链表"></a>排序链表</h2><p>要求使用插入排序的方法对链表进行排序，插入排序的时间复杂度是 O(n^2))，其中 n是链表的长度。这道题考虑时间复杂度更低的排序算法。题目的进阶问题要求达到 O(nlog⁡n) 的时间复杂度和 O(1) 的空间复杂度，时间复杂度是 O(nlog⁡n)的排序算法包括归并排序、堆排序和快速排序（快速排序的最差时间复杂度是 O(n^2），其中最适合链表的排序算法是归并排序。</p>
<p>归并排序基于分治算法。最容易想到的实现方式是自顶向下的递归实现，考虑到递归调用的栈空间，自顶向下归并排序的空间复杂度是 O(log⁡n)。如果要达到 O(1) 的空间复杂度，则需要使用自底向上的实现方式。<br><strong>方法一：自顶向下归并排序</strong></p>
<p>对链表自顶向下归并排序的过程如下。</p>
<ol>
<li><p>找到链表的中点，以中点为分界，将链表拆分成两个子链表。寻找链表的中点可以使用快慢指针的做法，快指针每次移动 22步，慢指针每次移动 1 步，当快指针到达链表末尾时，慢指针指向的链表节点即为链表的中点。</p>
</li>
<li><p>对两个子链表分别排序。</p>
</li>
<li><p>将两个排序后的子链表合并，得到完整的排序后的链表。可以使用<strong>「21. 合并两个有序链表」</strong>的做法，将两个有序的子链表进行合并。</p>
</li>
</ol>
<p>上述过程可以通过递归实现。递归的终止条件是链表的节点个数小于或等于 1，即当链表为空或者链表只包含 1 个节点时，不需要对链表进行拆分和排序。</p>
<pre><code class="java">class Solution &#123;
    public ListNode sortList(ListNode head) &#123;
//       这题官方写的不是很好理解，个人觉得背一下就行。 要说解释的话，是因为如果sortlist（）的参数head和tail是相邻结点时，他直接把tail给舍去了，
//       那他是怎么处理这tail节点呢，就是通过把tail传进另一个sortlist()当head形参。
        //方法一：自顶向下归并排序
        return sortList(head,null);
    &#125;
    public ListNode sortList(ListNode head,ListNode tail)&#123;
        if(head==null)&#123;
            return head;
        &#125;
        if(head.next==tail)&#123;
            head.next=null;
            return head;
        &#125;
        ListNode fast=head,slow=head;//快慢指针
        while(fast!=tail)&#123;
            slow=slow.next;
            fast=fast.next;
            if(fast!=tail)&#123;
                fast=fast.next;
            &#125;
        &#125;
        ListNode mid=slow;
        ListNode list1=sortList(head,mid);
        ListNode list2=sortList(mid,tail);
        ListNode sorted=merge(list1,list2);
        return sorted;
    &#125;
    //
    public ListNode merge(ListNode head1,ListNode head2)&#123;
        ListNode dummyNode=new ListNode(0);//空结点
        ListNode temp=dummyNode,temp1=head1,temp2=head2;//可理解为指针
        while (temp1!=null&amp;&amp;temp2!=null)&#123;
            if(temp1.val&lt;=temp2.val)&#123;
                temp.next=temp1;
                temp1=temp1.next;
            &#125;else&#123;
                temp.next=temp2;
                temp2=temp2.next;
            &#125;
            temp=temp.next;
        &#125;
        //跳出循环，至少有一个结点为空了
        if(temp1!=null)&#123;
            temp.next=temp1;
        &#125;else if(temp2!=null)&#123;
            temp.next=temp2;
        &#125;
        return dummyNode.next;//因为dummyNode是个空结点

    &#125;
</code></pre>
<h1 id="小知识"><a href="#小知识" class="headerlink" title="小知识"></a>小知识</h1><p><strong>StringBuilder&amp;StringBuffer&amp;&amp;String</strong></p>
<p>  StringBuilder类也代表可变字符串对象。实际上，StringBuilder和StringBuffer基本相似，两个类的构造器和方法也基本相同。不同的是：<u>StringBuffer是线程安全的，而StringBuilder则没有实现线程安全功能</u>，所以性能略高。</p>
<p>一旦通过StringBuffer生成了最终想要的字符串，就可以调用它的toString()方法将其转换为一个String对象。</p>
<p>  String类是不可变类，即一旦一个String对象被创建以后，包含在这个对象中的字符序列是不可改变的，直至这个对象被销毁。</p>
<pre><code>String a = &quot;123&quot;;
a = &quot;456&quot;;
// 打印出来的a为456
System.out.println(a)
</code></pre>
<img src="https://img-blog.csdnimg.cn/20190616102116187.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NzeHlwcg==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom: 50%;">

<p>可以看出来，再次给a赋值时，并不是对原来堆中实例对象进行重新赋值，而是生成一个新的实例对象，并且指向“456”这个字符串，a则指向最新生成的实例对象，之前的实例对象仍然存在，如果没有被再次引用，则会被垃圾回收。</p>
<p><strong>Map.getOrDefault(Object key, V defaultValue)</strong></p>
<p>Map.getOrDefault(Object key, V defaultValue)方法的作用是：<br>   当Map<a href="https://so.csdn.net/so/search?q=%E9%9B%86%E5%90%88&spm=1001.2101.3001.7020">集合</a>中有这个key时，就使用这个key值；<br>   如果没有就使用默认值defaultValue。</p>
<pre><code class="java">HashMap&lt;String, String&gt; map = new HashMap&lt;&gt;();
map.put(&quot;name&quot;, &quot;cookie&quot;);
map.put(&quot;age&quot;, &quot;18&quot;);
map.put(&quot;sex&quot;, &quot;女&quot;);
String name = map.getOrDefault(&quot;name&quot;, &quot;random&quot;);
System.out.println(name);// cookie，map中存在name,获得name对应的value
int score = map.getOrDefault(&quot;score&quot;, 80);
System.out.println(score);// 80，map中不存在score,使用默认值80
</code></pre>
<p><strong>双目移位运算符 &gt;&gt;1 和 &#x2F;2 哪个更快?</strong></p>
<p>速度很可能是一样快。建议，不要使用移位代替乘除。</p>
<p><strong>Stack.peek()和Stack.pop()的区别</strong></p>
<ol>
<li>Stack.peek()</li>
</ol>
<pre><code>peek()函数返回栈顶的元素，但不弹出该栈顶元素。
</code></pre>
<ol start="2">
<li>Stack.pop()</li>
</ol>
<pre><code class="java">pop()函数返回栈顶的元素，并且将该栈顶元素出栈。
</code></pre>
<p>Map集合中不应该利用get()方法来判断是否存在某个键，而应该利用containsKey()方法来判断</p>
<p>LinkedList 是一个继承于AbstractSequentialList的双向链表。它也可以被当作堆栈、队列或双端队列进行操作</p>
<p><strong>交换和反转</strong></p>
<pre><code class="java">public void swap(int[] nums, int i, int j) &#123;
    int temp = nums[i];
    nums[i] = nums[j];
    nums[j] = temp;
&#125;

public void reverse(int[] nums, int start) &#123;
    int left = start, right = nums.length - 1;
    while (left &lt; right) &#123;
        swap(nums, left, right);
        left++;
        right--;
    &#125;
&#125;
</code></pre>
<p><strong>new String()和toString()的区别</strong></p>
<p>str.toString是调用了该对象的类的toString方法。一般是返回这么一个String：[class name]@[hashCode]。<br>new String(str)是使用java虚拟机默认的编码格式，将这个字节数组转换为对应的字符。若虚拟机默认的编码格式是ISO-8859-1，按照ascii编码表即可得到字节对应的字符。<br>new String（）一般用在将字节数组转为字符串的时候<br>toString()一般用在输出某个对象的时候</p>
<p>问题（来源于leetcode）：</p>
<pre><code class="java">给你一个字符串数组，请你将 字母异位词 组合在一起。可以按任意顺序返回结果列表。 
class Solution &#123;
    public List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123;
        Map&lt;String, List&lt;String&gt;&gt; map=new HashMap&lt;String, List&lt;String&gt;&gt;();
        for(String str:strs)&#123;
            char[] array=str.toCharArray();
            Arrays.sort(array);//传数组 先排序
//            String key=array.toString();不能用这个？？？
            String key=new String(array);
            List&lt;String&gt; list=map.getOrDefault(key,new ArrayList&lt;String&gt;());
            list.add(str);
            map.put(key,list);
        &#125;
        return new ArrayList&lt;List&lt;String&gt;&gt;(map.values());
</code></pre>
<p>测试：</p>
<pre><code class="java">char[] array=&#123;&#39;a&#39;,&#39;b&#39;&#125;;
String key = array.toString();//[C@1d56ce6a   地址 每次地址都不一样 key当然也不会一样 因此会有这样如下测试结果
System.out.println(key);
String key2 = new String(array);//ab    值
System.out.println(key2);
</code></pre>
<p><img src="/.xyz//.assets%5Cimage-20220519114000686.png" alt="image-20220519114000686"></p>
<p><strong>关于Array和List的区别</strong></p>
<p>1.Array连续  List不连续 因此定义时需要指定Array长度</p>
<p>2.查找Array 插入List</p>
<h1 id="BFS-amp-DFS"><a href="#BFS-amp-DFS" class="headerlink" title="BFS&amp;DFS"></a>BFS&amp;DFS</h1><p>DFS 遍历使用递归：</p>
<pre><code>void dfs(TreeNode root) &#123;
    if (root == null) &#123;
        return;
    &#125;
    dfs(root.left);//递归到最后一层最左边节点，左右节点为空，return出来，到最后一层第二个节点
    dfs(root.right);
&#125;
</code></pre>
<p>BFS 遍历使用队列数据结构：</p>
<pre><code>void bfs(TreeNode root) &#123;
    Queue&lt;TreeNode&gt; queue = new ArrayDeque&lt;&gt;();
    queue.add(root);
    while (!queue.isEmpty()) &#123;
        TreeNode node = queue.poll(); // Java 的 pop 写作 poll()
        if (node.left != null) &#123;
            queue.add(node.left);//队列先进后出，所以是按层往外扩，一直从左往右遍历
        &#125;
        if (node.right != null) &#123;
            queue.add(node.right);
        &#125;
    &#125;
&#125;
</code></pre>
<img src="/.xyz//fdcd3bd27f4008948084f6ec86b58535e71f66862bd89a34bd6fe4cc42d68e89-16578569951531.gif" alt="DFS 与 BFS 对比" style="zoom:25%;">
**BFS 的应用一：层序遍历**

<pre><code>给定一个二叉树，返回其按层序遍历得到的节点值。 层序遍历即逐层地、从左到右访问所有结点。
</code></pre>
<p>层序遍历要求的输入结果和 BFS 是不同的。层序遍历要求我们区分每一层，也就是返回一个二维数组。而 BFS 的遍历结果是一个一维数组，无法区分每一层。</p>
<img src="/.xyz//fd1d63037d0e2f787d2140fee406e109094a4f66ab0837a7273f8b371eef8096.jpg" alt="BFS 遍历与层序遍历的输出结果不同" style="zoom:33%;">

<p>截取 BFS 遍历过程中的某个时刻：</p>
<img src="/.xyz//4529bf559c6a2d84d550eebaee027c3b7ae25069e4ec91f27b29a4c6358d6662.gif" alt="BFS 遍历的过程（动图）" style="zoom:33%;">

<p>BFS 遍历中某个时刻队列的状态</p>
<img src="/.xyz//9f178b56ff1c94388d893f2fb48e9e77e186aba7cfd7483637776359062d68b8.jpg" alt="BFS 遍历中某个时刻队列的状态" style="zoom:33%;">

<p>可以看到，此时队列中的结点是 3、4、5，分别来自第 1 层和第 2 层。这个时候，第 1 层的结点还没出完，第 2 层的结点就进来了，而且两层的结点在队列中紧挨在一起，我们无法区分队列中的结点来自哪一层。</p>
<p>因此，我们需要稍微修改一下代码，在每一层遍历开始前，先记录队列中的结点数量 n（也就是这一层的结点数量），然后一口气处理完这一层的 n 个结点。</p>
<pre><code class="java">// 二叉树的层序遍历
void bfs(TreeNode root) &#123;
    Queue&lt;TreeNode&gt; queue = new ArrayDeque&lt;&gt;();
    queue.add(root);
    while (!queue.isEmpty()) &#123;
        int n = queue.size();
        for (int i = 0; i &lt; n; i++) &#123; 
            // 变量 i 无实际意义，只是为了循环 n 次
            TreeNode node = queue.poll();
            if (node.left != null) &#123;
                queue.add(node.left);
            &#125;
            if (node.right != null) &#123;
                queue.add(node.right);
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<p>这样，我们就将 BFS 遍历改造成了层序遍历。在遍历的过程中，结点进队列和出队列的过程为：</p>
<img src="/.xyz//94cd1fa999df0276f1dae77a9cca83f4cabda9e2e0b8571cd9550a8ee3545f56.gif" alt="img" style="zoom:33%;">

<p>可以看到，在 while 循环的每一轮中，都是将当前层的所有结点出队列，再将下一层的所有结点入队列，这样就实现了层序遍历。</p>
<p>最终我们得到的题解代码为：</p>
<pre><code class="java">public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;
    List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();

    Queue&lt;TreeNode&gt; queue = new ArrayDeque&lt;&gt;();
    if (root != null) &#123;
        queue.add(root);
    &#125;
    while (!queue.isEmpty()) &#123;
        int n = queue.size();
        List&lt;Integer&gt; level = new ArrayList&lt;&gt;();
        for (int i = 0; i &lt; n; i++) &#123; 
            TreeNode node = queue.poll();
            level.add(node.val);//level放每一层的值
            if (node.left != null) &#123;
                queue.add(node.left);
            &#125;
            if (node.right != null) &#123;
                queue.add(node.right);
            &#125;
        &#125;
        res.add(level);
    &#125;

    return res;
&#125;
</code></pre>
<h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><h2 id="相关知识"><a href="#相关知识" class="headerlink" title="相关知识"></a>相关知识</h2><p>完全二叉树： 从满二叉树最后一个结点往前删除</p>
<p>二叉搜索树：左小右大 带数值</p>
<p>平衡二叉搜索树：AVL 高度差值小于2</p>
<p>存储方式：数组 链式   <strong>如果父节点的数组下标是 i，那么它的左孩子就是 i * 2 + 1，右孩子就是 i * 2 + 2。</strong></p>
<p>遍历方式：深度：前中后  迭代 递归  栈</p>
<p>​				    广度  层次   迭代   队列</p>
<p>定义：</p>
<pre><code class="java">public class TreeNode &#123;
    int val;
      TreeNode left;
      TreeNode right;
      TreeNode() &#123;&#125;
      TreeNode(int val) &#123; this.val = val; &#125;
      TreeNode(int val, TreeNode left, TreeNode right) &#123;
            this.val = val;
            this.left = left;
            this.right = right;
      &#125;
&#125;
</code></pre>
<p>二叉排序<a href="http://data.biancheng.net/view/313.html">树</a>（Binary Sort Tree，简称 BST ）又叫二叉查找树和二叉搜索树，是一种实现动态查找表的树形存储结构。</p>
<ul>
<li><p>节点的左子树仅包含键 <strong>小于</strong> 节点键的节点。</p>
</li>
<li><p>节点的右子树仅包含键 <strong>大于</strong> 节点键的节点。</p>
</li>
<li><p>左右子树也必须是二叉搜索树。</p>
<p><strong>递归思路：</strong></p>
</li>
</ul>
<ol>
<li><p><strong>确定递归函数的参数和返回值：</strong> 确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数， 并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。</p>
</li>
<li><p><strong>确定终止条件：</strong> 写完了递归算法,  运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对，操作系统也是用一个栈的结构来保存每一层递归的信息，如果递归没有终止，操作系统的内存栈必然就会溢出。</p>
</li>
<li><p><strong>确定单层递归的逻辑：</strong> 确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程。</p>
</li>
</ol>
<h2 id="对称二叉树"><a href="#对称二叉树" class="headerlink" title="对称二叉树"></a>对称二叉树</h2><p>给你一个二叉树的根节点 <code>root</code> ， 检查它是否轴对称。</p>
<p>我们可以实现这样一个递归函数，通过「同步移动」两个指针的方法来遍历这棵树，pp 指针和 qq 指针一开始都指向这棵树的根，随后 pp 右移时，qq 左移，pp 左移时，qq 右移。每次检查当前 pp 和 qq 节点的值是否相等，如果相等再判断左右子树是否对称。</p>
<pre><code class="java">class Solution &#123;
    public boolean isSymmetric(TreeNode root) &#123;
        return check(root, root);
    &#125;

    public boolean check(TreeNode p, TreeNode q) &#123;
        if (p == null &amp;&amp; q == null) &#123;
            return true;
        &#125;
        if (p == null || q == null) &#123;
            return false;
        &#125;
        return p.val == q.val &amp;&amp; check(p.left, q.right) &amp;&amp; check(p.right, q.left);
    &#125;
&#125;
</code></pre>
<h2 id="二叉树的最大深度"><a href="#二叉树的最大深度" class="headerlink" title="二叉树的最大深度"></a>二叉树的最大深度</h2><p>给定一个二叉树，找出其最大深度。    二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p>
<pre><code class="java">class Solution &#123;
    public int maxDepth(TreeNode root) &#123;
        if (root == null) &#123;
            return 0;
        &#125; else &#123;
            int leftHeight = maxDepth(root.left);
            int rightHeight = maxDepth(root.right);
            return Math.max(leftHeight, rightHeight) + 1;
        &#125;
    &#125;
&#125;

//return root == null ? 0 : Math.max(this.maxDepth(root.left), this.maxDepth(root.right)) + 1;
    
</code></pre>
<h2 id="二叉树最小深度"><a href="#二叉树最小深度" class="headerlink" title="二叉树最小深度"></a>二叉树最小深度</h2><p>给定一个二叉树，找出其最小深度。</p>
<p>最小深度是从根节点到最近叶子节点的最短路径上的节点数量。（注意这里 和求最大深度不一样）</p>
<img src="/.xyz//20210203155800503.png" alt="111.二叉树的最小深度" style="zoom:33%;">

<pre><code class="java">class Solution &#123;
    public int minDepth(TreeNode root) &#123;
        if (root == null) return 0;
        //这两个else if 很重要 就是为了防止出现上图所示情况
        else if (root.left == null) return minDepth(root.right) + 1;
        else if (root.right == null) return minDepth(root.left) + 1;
        else return Math.min(minDepth(root.left), minDepth(root.right)) + 1;
    &#125;
&#125;
</code></pre>
<h2 id="完全二叉树的节点个数"><a href="#完全二叉树的节点个数" class="headerlink" title="完全二叉树的节点个数"></a>完全二叉树的节点个数</h2><p>给你一棵 <strong>完全二叉树</strong> 的根节点 <code>root</code> ，求出该树的节点个数。</p>
<img src="/.xyz//image-20221029171009163.png" alt="image-20221029171009163" style="zoom: 70%;">



<pre><code class="java">class Solution &#123;
    public int countNodes(TreeNode root) &#123;
        if(root == null) &#123;
            return 0;
        &#125;
        int left = countNodes(root.left);
        int right = countNodes(root.right);
        
        return left+right+1;
        
    &#125;
&#125;
</code></pre>
<p>遍历树来统计节点是一种时间复杂度为 <code>O(n)</code> 的简单解决方案。你可以设计一个更快的算法吗</p>
<pre><code class="java">class Solution &#123;
    public int countNodes(TreeNode root) &#123;
        if (root == null) &#123;
            return 0;
        &#125;
        int level = 0;
        TreeNode node = root;
        //去最下左结点  记录下结点和层数
        while (node.left != null) &#123;
            level++;
            node = node.left;
        &#125;
        //          2^level
        //当 0≤i&lt;h 时，第 i层包含 2^i 个节点，最底层包含的节点数最少为 1，最多为 2^h。
        int low = 1 &lt;&lt; level, high = (1 &lt;&lt; (level + 1)) - 1;
        while (low &lt; high) &#123;
            // 这一句一用就会超时  原因是防止溢出，可能出现两者相加超过int表示范围
            int mid = (high - low + 1) / 2 + low;
            if (exists(root, level, mid)) &#123;
                low = mid;
            &#125; else &#123;
                high = mid - 1;
            &#125;
        &#125;
        return low;
    &#125;
    bits:1000-&gt; 100&gt; 10 &gt;1
    k:1100 右 左 左   
    public boolean exists(TreeNode root, int level, int k) &#123;
        int bits = 1 &lt;&lt; (level - 1);
        TreeNode node = root;
        while (node != null &amp;&amp; bits &gt; 0) &#123;
            if ((bits &amp; k) == 0) &#123;
                node = node.left;
            &#125; else &#123;
                node = node.right;
            &#125;
            bits &gt;&gt;= 1;
        &#125;
        return node != null;
    &#125;
&#125;
</code></pre>
<h2 id="二叉树的所有路径"><a href="#二叉树的所有路径" class="headerlink" title="二叉树的所有路径"></a>二叉树的所有路径</h2><p>给你一个二叉树的根节点 <code>root</code> ，按 <strong>任意顺序</strong> ，返回所有从根节点到叶子节点的路径。</p>
<p><strong>叶子节点</strong> 是指没有子节点的节点。</p>
<pre><code class="java">//我写的
class Solution &#123;
    List&lt;String&gt; ans=new ArrayList&lt;&gt;();
    public List&lt;String&gt; binaryTreePaths(TreeNode root) &#123;
        StringBuilder sb=new StringBuilder();
        dfs(root,sb);
        return ans;
    &#125;
    public void dfs(TreeNode root, StringBuilder sb)&#123;
        if(root==null) return;
        if(sb.length()==0)&#123;
            sb.append(root.val);
        &#125;else&#123;
            sb.append(&quot;-&gt;&quot;).append(root.val);
        &#125;
        if(root.left==null&amp;&amp;root.right==null)&#123;
            ans.add(sb.toString());
            return;
        &#125;
        //注意这里 一定要new StringBuilder 递归左子树之后再传入右子树的sb已经变成左子树的路径了，因此不能用sb了，而应该把前面sb的值copy来
        dfs(root.left,new StringBuilder(sb)); 
        dfs(root.right,new StringBuilder(sb));

    &#125;
&#125;
</code></pre>
<pre><code class="java">        //还有一种方法，就是回溯。
    private void dfs(TreeNode root, StringBuilder cur, List&lt;String&gt; paths) &#123;
        if (root == null) return;
        if (root.left == null &amp;&amp; root.right == null) &#123;
            paths.add(cur.toString() + root.val);
            return;
        &#125;
        int sz = cur.length();
        cur.append(root.val).append(&quot;-&gt;&quot;);
        dfs(root.left, cur);
        dfs(root.right, cur);
        cur.delete(sz, cur.length());//在这里已经定义了dfs的回溯，因此dfs(root.left, cur);执行完毕就已经是回溯的了，也就不会影响        dfs(root.right, cur);的路径了！ 完美！
    &#125;
</code></pre>
<h2 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h2><p>给定一个二叉树，判断它是否是高度平衡的二叉树。</p>
<p>本题中，一棵高度平衡二叉树定义为：一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1 。</p>
<p><strong>方法一：自顶向下的递归</strong></p>


<pre><code class="java">class Solution &#123;
    public boolean isBalanced(TreeNode root) &#123;
        if(root==null) return true;
        //这个&amp;&amp;开始没想到 根节点高度满足还需要后面节点也都是如此  
        return Math.abs(getDepth(root.right)-getDepth(root.left))&lt;2&amp;&amp;isBalanced(root.right)&amp;&amp;isBalanced(root.left);
    &#125;
    public int getDepth(TreeNode root)&#123;
        if(root==null) return 0;
        return Math.max(getDepth(root.left),getDepth(root.right))+1;
    &#125;
&#125;
O(n^2)
</code></pre>


<pre><code class="java">class Solution &#123;
    public boolean isBalanced(TreeNode root) &#123;
        return height(root) &gt;= 0;
    &#125;

    public int height(TreeNode root) &#123;
        if (root == null) &#123;
            return 0;
        &#125;
        int leftHeight = height(root.left);
        int rightHeight = height(root.right);
        if (leftHeight == -1 || rightHeight == -1 || Math.abs(leftHeight - rightHeight) &gt; 1) &#123;
            return -1;
        &#125; else &#123;
            return Math.max(leftHeight, rightHeight) + 1;
        &#125;
    &#125;
&#125;
O(n)
    自底向上的递归就是及时止损 自顶向下的递归就是不管三七二十一先把所有的高度算一遍
</code></pre>
<h2 id="左叶子之和"><a href="#左叶子之和" class="headerlink" title="左叶子之和"></a>左叶子之和</h2><pre><code class="java">//我的题解 我选择用自己的
class Solution &#123;
    int ans=0;
    public int sumOfLeftLeaves(TreeNode root) &#123;
        dfs(root);
        return ans;
    &#125;
    public void dfs(TreeNode root)&#123;
        //出口
        if(root==null||(root.left==null&amp;&amp;root.right==null)) return;
        //左节点存在且为叶节点
        if(root.left!=null&amp;&amp;root.left.left==null&amp;&amp;root.left.right==null)&#123;
            ans+=root.left.val;
        &#125;
        //递归到左右节点
        dfs(root.left);
        dfs(root.right);
    &#125;
&#125;
</code></pre>
<h2 id="找树左下角的值"><a href="#找树左下角的值" class="headerlink" title="找树左下角的值"></a>找树左下角的值</h2><p>给定一个二叉树的 <strong>根节点</strong> <code>root</code>，请找出该二叉树的 <strong>最底层 最左边</strong> 节点的值。</p>
<p>假设二叉树中至少有一个节点。</p>
<pre><code class="java">class Solution &#123;
    //维护当前树高度和值
    int curval=0;
    int curheight=0;
    public int findBottomLeftValue(TreeNode root) &#123;
        dfs(root,0);
        return curval;
    &#125;
    public void dfs(TreeNode root,int height)&#123;
        if(root==null) return;
        height++;//向下递归一层加一
        if(height&gt;curheight)&#123;
            curheight=height;
            curval=root.val;
        &#125;
        //因为是先左后右 相同高度左边结点优先遍历到
        //这个想法没问题 但是int数据表示范围32位有限 出现内存溢出 所以还是Left在前
        
        // if(height==curheight)&#123;
        //     Math.min(curval,root.val);
        // &#125;
        dfs(root.left,height);
        dfs(root.right,height);

    &#125;
&#125;
</code></pre>
<h2 id="路径总和"><a href="#路径总和" class="headerlink" title="路径总和"></a>路径总和</h2><p>给你二叉树的根节点 <code>root</code> 和一个表示目标和的整数 <code>targetSum</code> 。判断该树中是否存在 <strong>根节点到叶子节点</strong> 的路径，这条路径上所有节点值相加等于目标和 <code>targetSum</code> 。如果存在，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>
<pre><code class="java">class Solution &#123;
   //有待改进 需要剪枝。。。 因为就算找到targetSum==0 递归还在继续
    boolean ans=false;
    public boolean hasPathSum(TreeNode root, int targetSum) &#123;
        dfs(root,targetSum);
        return ans;
    &#125;
    public void dfs(TreeNode root,int targetSum)&#123;
        if(root==null) return;
        targetSum=targetSum-root.val;
        if(root.left==null&amp;&amp;root.right==null)&#123;
            if(targetSum==0)&#123;
                ans=true;
                return;
            &#125;
        &#125;
        dfs(root.left,targetSum);
        dfs(root.right,targetSum);
    &#125;
&#125;
</code></pre>
<p>官方题解：</p>
<pre><code class="java">class Solution &#123;
    public boolean hasPathSum(TreeNode root, int sum) &#123;
        if (root == null) &#123;
            return false;
        &#125;
        if (root.left == null &amp;&amp; root.right == null) &#123;
            return sum == root.val;
        &#125;
        return hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val);
    &#125;
&#125;
</code></pre>
<h2 id="从中序与后序遍历序列构造二叉树"><a href="#从中序与后序遍历序列构造二叉树" class="headerlink" title="从中序与后序遍历序列构造二叉树"></a>从中序与后序遍历序列构造二叉树</h2><p>给定两个整数数组 <code>inorder</code> 和 <code>postorder</code> ，其中 <code>inorder</code> 是二叉树的中序遍历， <code>postorder</code> 是同一棵树的后序遍历，请你构造并返回这颗 <em>二叉树</em> 。</p>
<pre><code class="java">class Solution &#123;
    int post_idx;
    int[] postorder;
    int[] inorder;
    Map&lt;Integer, Integer&gt; idx_map = new HashMap&lt;Integer, Integer&gt;();
    
    public TreeNode buildTree(int[] inorder, int[] postorder) &#123;
        this.postorder = postorder;
        this.inorder = inorder;
        // 从后序遍历的最后一个元素开始
        post_idx = postorder.length - 1;

        // 建立（元素，下标）键值对的哈希表
        int idx = 0;
        for (Integer val : inorder) &#123;
            idx_map.put(val, idx++);
        &#125;
        
        return helper(0, inorder.length - 1);
    &#125;
    
    public TreeNode helper(int in_left, int in_right) &#123;
        // 如果这里没有节点构造二叉树了，就结束
        if (in_left &gt; in_right) &#123;
            return null;
        &#125;

        // 选择 post_idx 位置的元素作为当前子树根节点
        int root_val = postorder[post_idx];
        TreeNode root = new TreeNode(root_val);
        // 根据 root 所在位置分成左右两棵子树
        int index = idx_map.get(root_val);
        // 下标减一
        post_idx--;
        // 构造右子树
        root.right = helper(index + 1, in_right);
        // 构造左子树
        root.left = helper(in_left, index - 1);
        return root;
    &#125;

&#125;
</code></pre>
<h2 id="最大二叉树"><a href="#最大二叉树" class="headerlink" title="最大二叉树"></a>最大二叉树</h2><p>给定一个不重复的整数数组 <code>nums</code> 。 <strong>最大二叉树</strong> 可以用下面的算法从 <code>nums</code> 递归地构建:</p>
<ol>
<li>创建一个根节点，其值为 <code>nums</code> 中的最大值。</li>
<li>递归地在最大值 <strong>左边</strong> 的 <strong>子数组前缀上</strong> 构建左子树。</li>
<li>递归地在最大值 <strong>右边</strong> 的 <strong>子数组后缀上</strong> 构建右子树。</li>
</ol>
<p>返回 <em><code>nums</code> 构建的</em> *<strong>最大二叉树*</strong> 。</p>
<p><strong>递归</strong></p>
<pre><code class="java">//我最初的解法
class Solution &#123;
    int[] nums;
    public TreeNode constructMaximumBinaryTree(int[] nums) &#123;
        this.nums=nums;
        return buildTreee(0,nums.length-1);
    &#125;
    public TreeNode buildTreee(int left,int right)&#123;
        if(left&gt;right) return null;
        int index=getMaxNumIndex(left,right);
        TreeNode root=new TreeNode(nums[index]);
        root.left=buildTreee(left,index-1);
        root.right=buildTreee(index+1,right);
        return root;
    &#125;
    public int getMaxNumIndex(int left,int right)&#123;
        int max=Integer.MIN_VALUE;
        int index=0;
        for(int i=left;i&lt;=right;i++)&#123;
            if(nums[i]&gt;max)&#123;
                max=nums[i];
                index=i;
            &#125;
        &#125;
        return index;
    &#125;
&#125;
//优化后
class Solution &#123;
    int[] nums;
    public TreeNode constructMaximumBinaryTree(int[] nums) &#123;
        this.nums=nums;
        return buildTreee(0,nums.length-1);
    &#125;
    public TreeNode buildTreee(int left,int right)&#123;
        if(left&gt;right) return null;
        int best=left;
        for (int i = left + 1; i &lt;= right; ++i) &#123;
            if (nums[i] &gt; nums[best]) &#123;
                best = i;
            &#125;
        &#125;
        TreeNode root=new TreeNode(nums[best]);
        root.left=buildTreee(left,best-1);
        root.right=buildTreee(best+1,right);
        return root;
    &#125;
&#125;
</code></pre>
<p><strong>单调栈</strong></p>
<h2 id="验证二叉搜索树"><a href="#验证二叉搜索树" class="headerlink" title="验证二叉搜索树"></a>验证二叉搜索树</h2><p>给你一个二叉树的根节点 <code>root</code> ，判断其是否是一个有效的二叉搜索树。</p>
<p><strong>有效</strong> 二叉搜索树定义如下：</p>
<ul>
<li><p>节点的左子树只包含 <strong>小于</strong> 当前节点的数。</p>
</li>
<li><p>节点的右子树只包含 <strong>大于</strong> 当前节点的数。</p>
</li>
<li><p>所有左子树和右子树自身必须也是二叉搜索树。</p>
<pre><code class="java">class Solution &#123;
    public boolean isValidBST(TreeNode root) &#123;
        return dfs(root,Long.MIN_VALUE,Long.MAX_VALUE);
    &#125;
    public boolean dfs(TreeNode root,long l,long r)&#123;
        if(root==null) return true;
        if(root.val&lt;=l||root.val&gt;=r) return false;
        return dfs(root.left,l,root.val)&amp;&amp;dfs(root.right,root.val,r);
    &#125;
&#125;
</code></pre>
</li>
</ul>
<h2 id="二叉搜索树的最小绝对差"><a href="#二叉搜索树的最小绝对差" class="headerlink" title="二叉搜索树的最小绝对差"></a>二叉搜索树的最小绝对差</h2><pre><code class="java">class Solution &#123;
    int ans=Integer.MAX_VALUE;
    public int getMinimumDifference(TreeNode root) &#123;
        dfs(root);
        return ans;
    &#125;
    public void dfs(TreeNode root)&#123;
        if(root==null) return;
        //我的题解：寻找左子树里最大值和右子树里面最小值 然后同根节点做差求Min
        //左子树里最大值就是左孩子的最右结点 右子树同理
        TreeNode node_l=root.left,node_r=root.right;
        while(node_l!=null&amp;&amp;node_l.right!=null)&#123;
            node_l=node_l.right;
        &#125;
        while(node_r!=null&amp;&amp;node_r.left!=null)&#123;
            node_r=node_r.left;
        &#125;
        int l=node_l==null?Integer.MAX_VALUE:root.val-node_l.val;
        int r=node_r==null?Integer.MAX_VALUE:node_r.val-root.val;
        ans=Math.min(Math.min(l,r),ans);
        dfs(root.left);
        dfs(root.right);
    &#125;
&#125;
</code></pre>


<pre><code class="java">class Solution &#123;
    int pre;
    int ans;
    public int getMinimumDifference(TreeNode root) &#123;
        ans = Integer.MAX_VALUE;
        pre = -1;
        dfs(root);
        return ans;
    &#125;
    public void dfs(TreeNode root) &#123;
        if (root == null) &#123;
            return;
        &#125;
        //中序 左根右  有序
        //只需要计算相邻结点差值的最小值就可
        dfs(root.left);
        if (pre == -1) &#123;
            pre = root.val;
        &#125; else &#123;
            ans = Math.min(ans, root.val - pre);
            pre = root.val;
        &#125;
        dfs(root.right);
    &#125;
&#125;
优雅！！！！！！！！
</code></pre>
<h2 id="二叉搜索树中的众数"><a href="#二叉搜索树中的众数" class="headerlink" title="二叉搜索树中的众数"></a>二叉搜索树中的众数</h2><p>给你一个含重复值的二叉搜索树（BST）的根节点 <code>root</code> ，找出并返回 BST 中的所有 <a href="https://baike.baidu.com/item/%E4%BC%97%E6%95%B0/44796">众数</a>（即，出现频率最高的元素）。</p>
<p>如果树中有不止一个众数，可以按 <strong>任意顺序</strong> 返回。</p>
<p>假定 BST 满足如下定义：</p>
<ul>
<li>结点左子树中所含节点的值 <strong>小于等于</strong> 当前节点的值</li>
<li>结点右子树中所含节点的值 <strong>大于等于</strong> 当前节点的值</li>
<li>左子树和右子树都是二叉搜索树</li>
</ul>
<p>我的思路：</p>
<p>哈希表 dfs遍历结点 map存储结点以及结点出现个数，然后每个entrySet取value 打擂台的方式，最后得出最大的value以及key 然后根据value再遍历一次 看看有无相等的 有就加入结果集List   but不想实现。。。。。</p>


<pre><code class="java">class Solution &#123;
    //记录众数
    List&lt;Integer&gt; answer=new ArrayList&lt;&gt;();
    //  当前数字 出现个数   最大出现个数
    int base,count,maxcount;

    public int[] findMode(TreeNode root) &#123;
        dfs(root);
        int[] ans=new int[answer.size()];
        for(int i=0;i&lt;answer.size();i++)&#123;
            ans[i]=answer.get(i);
        &#125;
        return ans;
    &#125;
    public void dfs(TreeNode root)&#123;
    //中序遍历 使得递增顺序
        if(root==null) return;
        dfs(root.left);
        update(root.val);
        dfs(root.right);
    &#125;
    public void update(int val)&#123;
        if(val==base)&#123;
            count++;
        &#125;else&#123;
            count=1;
            base=val;
        &#125;
        if(count==maxcount)&#123;
            answer.add(val);
        &#125;
        if(count&gt;maxcount)&#123;
            answer.clear();
            maxcount=count;
            answer.add(val);
        &#125;
    &#125;
&#125;
</code></pre>
<h2 id="二叉树前序遍历"><a href="#二叉树前序遍历" class="headerlink" title="二叉树前序遍历"></a>二叉树前序遍历</h2><p><strong>递归</strong>（本质栈）</p>
<pre><code class="java">class Solution &#123;
    public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123;
        List&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;();
        preorder(root, res);
        return res;
    &#125;

    public void preorder(TreeNode root, List&lt;Integer&gt; res) &#123;
        if (root == null) &#123;
            return;
        &#125;
        res.add(root.val);
        preorder(root.left, res);
        preorder(root.right, res);
    &#125;
&#125;
</code></pre>
<p><strong>迭代</strong>（利用栈）</p>
<pre><code class="java">class Solution &#123;
    public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123;
        List&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;();
        if (root == null) &#123;
            return res;
        &#125;

        Deque&lt;TreeNode&gt; stack = new LinkedList&lt;TreeNode&gt;();
        TreeNode node = root;
        //结束条件：栈为空且node为Null
        while (!stack.isEmpty() || node != null) &#123;
            //到达最左
            while (node != null) &#123;
                res.add(node.val);
                stack.push(node);
                node = node.left;
            &#125;
            //到达最左后，node为Null，此时要出栈（也就是返回父结点）
            node = stack.pop();
            //遍历右结点
            node = node.right;
        &#125;
        return res;
    &#125;
&#125;
</code></pre>
<p><strong>Morris 遍历</strong></p>
<p><a href="https://blog.csdn.net/liujia2115/article/details/109215284">https://blog.csdn.net/liujia2115/article/details/109215284</a></p>
<pre><code class="java">class Solution &#123;
    public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123;
        return morrisMethod(root);
    &#125;

    /**
     * Morris遍历
     * @param root
     * @return
     */
    private List&lt;Integer&gt; morrisMethod(TreeNode root) &#123;
        List&lt;Integer&gt; list = new ArrayList&lt;&gt;();
        if (root == null) &#123;
            return list;
        &#125;
        TreeNode cur = root;
        TreeNode mostRight = null;
        while (cur != null) &#123;
            mostRight = cur.left;
            if (mostRight != null) &#123; 
                //左子树最右结点 mostRight.right != cur防止循环回去了
                while (mostRight.right != null &amp;&amp; mostRight.right != cur) &#123;
                    mostRight = mostRight.right;
                &#125;
                //第一次来
                if (mostRight.right == null) &#123;
                    mostRight.right = cur;
                    list.add(cur.val); // 第一次到的时候打印
                    cur = cur.left;
                    continue;
                &#125; else &#123;//第二次来
                    mostRight.right = null; // 第二次到的时候不打印
                &#125;
            &#125; else &#123; // cur.left为空 直接add cur的值
                list.add(cur.val);
            &#125;
            cur = cur.right;
            &#125;
        return list;
    &#125;
&#125;
</code></pre>
<p>morris中序遍历就是在第一次到的时候不打印  第二次到的时候打印  list.add(cur.val);移到 mostRight.right &#x3D; null; 后面</p>
<h2 id="合并二叉树"><a href="#合并二叉树" class="headerlink" title="合并二叉树"></a>合并二叉树</h2>

<pre><code class="java">class Solution &#123;
    public TreeNode mergeTrees(TreeNode root1, TreeNode root2) &#123;
        if(root1 == null) return root2;
        if(root2 == null) return root1;
        TreeNode merged = new TreeNode(root1.val + root2.val);//返回结点
        merged.left=mergeTrees(root1.left, root2.left);//构造左边是啥
        merged.right=mergeTrees(root1.right, root2.right);//构造右边是啥
        return merged;
    &#125;
&#125;
</code></pre>
<h2 id="二叉搜索数转累加数"><a href="#二叉搜索数转累加数" class="headerlink" title="二叉搜索数转累加数"></a>二叉搜索数转累加数</h2><p>给出二叉 搜索 树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），使每个节点 node 的新值等于原树中大于或等于 node.val 的值之和。</p>
<pre><code class="java">class Solution &#123;
    int sum = 0;
    public TreeNode convertBST(TreeNode root) &#123;
        dfs(root);
        return root;
    &#125;
    void dfs(TreeNode node) &#123;
        if (node == null) return;
        dfs(node.right);
        sum += node.val;
        node.val = sum;
        dfs(node.left);
    &#125;
&#125;
</code></pre>
<p>我对于本题递归的理解：dfs(node.right)直接递归到最右下结点，sum&#x3D;最右下结点的值，赋给最右下结点值， dfs(node.left); 判断为空 return出来</p>
<p>dfs(node.right)执行完毕，进入上一递归，此时为上一层根结点，然后sum +&#x3D; node.val;node.val &#x3D; sum;此时算的是根结点的累加值，同理，dfs(node.left)；</p>
<p>递归不要人肉递归，还是要套模板，只需要关注</p>
<p>这一部分内容就行，让变量具有普适性</p>
<h2 id="二叉树遍历题和二叉树展开为链表题的对比（均为迭代）"><a href="#二叉树遍历题和二叉树展开为链表题的对比（均为迭代）" class="headerlink" title="二叉树遍历题和二叉树展开为链表题的对比（均为迭代）"></a>二叉树遍历题和二叉树展开为链表题的对比（均为迭代）</h2><p>做二叉树首先要想到用递归（and迭代）</p>
<pre><code class="java">二叉树遍历
class Solution &#123;
    public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123;
        List&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;();
        Deque&lt;TreeNode&gt; stk = new LinkedList&lt;TreeNode&gt;();
        while (root != null || !stk.isEmpty()) &#123;
            while (root != null) &#123;
                stk.push(root);
                root = root.left;
            &#125;
            root = stk.pop();
            res.add(root.val);
            root = root.right;
        &#125;
        return res;
    &#125;
&#125;
二叉树展开为链表
    class Solution &#123;
        //同中序遍历的题进行对比
        public void flatten(TreeNode root) &#123;
            List&lt;TreeNode&gt; list = new ArrayList&lt;&gt;();
            Deque&lt;TreeNode&gt; stk = new LinkedList&lt;&gt;();
            while (root != null || !stk.isEmpty()) &#123;
                while (root != null) &#123;
                    list.add(root);//和中序比较多了这一行
                    stk.push(root);
                    root = root.left;
                &#125;
                root = stk.pop();
                //少了一行list.add(root.val);
                root = root.right;
            &#125;
            int size = list.size();
            for (int i = 1; i &lt; size; i++) &#123;
                TreeNode pre = list.get(i - 1), cur = list.get(i);
                pre.left = null;
                pre.right = cur;
            &#125;

        &#125;
</code></pre>
<h2 id="二叉树的最近公共祖先"><a href="#二叉树的最近公共祖先" class="headerlink" title="二叉树的最近公共祖先"></a>二叉树的最近公共祖先</h2><img src="/.xyz//image-20220919202400688.png" alt="image-20220919202400688" style="zoom: 67%;">



<pre><code class="java"> */
class Solution &#123;
    private TreeNode ans;
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123;
//        TreeNode ans=null;   //这一句不能有，有的话，ans=root就无法覆盖ans的值，ans=root只能识别到 private TreeNode ans;   如果有的话 下面必须return this.ans才行 把外面的引进来作为成员变量
        dfs(root,p,q);
        return ans;//想引用外面的变量需要加this.
    &#125;
    private boolean dfs(TreeNode root, TreeNode p, TreeNode q)&#123;
        if(root==null) return false;
        boolean lson=dfs(root.left,p,q);//这里必须加数据类型呀，因为lson rson第一次出现，都没初始化呢，要指定其数据类型
        boolean rson=dfs(root.right,p,q);
        if((lson&amp;&amp;rson)||(p.val==root.val||q.val==root.val)&amp;&amp;(lson||rson))&#123;
            ans=root;
            System.out.println(ans);
        &#125;
        return root.val==p.val||root.val==q.val||lson||rson;
    &#125;
&#125;
</code></pre>
<h2 id="二叉搜索树最近公共祖先"><a href="#二叉搜索树最近公共祖先" class="headerlink" title="二叉搜索树最近公共祖先"></a>二叉搜索树最近公共祖先</h2><p>方法一：不用二叉搜索树的性质，直接用二叉树的也可以过。</p>
<p><strong>方法二：一次遍历</strong></p>
<img src="/.xyz//image-20221107120758813.png" alt="image-20221107120758813" style="zoom:67%;">

<pre><code class="java">class Solution &#123;
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123;
        TreeNode ancestor = root;
        while (true) &#123;
            if (p.val &lt; ancestor.val &amp;&amp; q.val &lt; ancestor.val) &#123;
                ancestor = ancestor.left;
            &#125; else if (p.val &gt; ancestor.val &amp;&amp; q.val &gt; ancestor.val) &#123;
                ancestor = ancestor.right;
            &#125; else &#123;
                break;
            &#125;
        &#125;
        return ancestor;
    &#125;
&#125;
</code></pre>
<h2 id="二叉搜索树中的插入操作"><a href="#二叉搜索树中的插入操作" class="headerlink" title="二叉搜索树中的插入操作"></a>二叉搜索树中的插入操作</h2><p>给定二叉搜索树（BST）的根节点 <code>root</code> 和要插入树中的值 <code>value</code> ，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据 <strong>保证</strong> ，新值和原始二叉搜索树中的任意节点值都不同。</p>
<p><strong>注意</strong>，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回 <strong>任意有效的结果</strong> 。</p>
<pre><code class="java">class Solution &#123;
    public TreeNode insertIntoBST(TreeNode root, int val) &#123;
        //为空建一个返回
        if(root==null) return new TreeNode(val);
        dfs(root,val);
        return root;
    &#125;
    public void dfs(TreeNode root, int val)&#123;
        //大于的话 需要插入到左子树 看左节点是否为空，空的话直接加入，然后返回， 否则递归到左子树 
        if(root.val&gt;val)&#123;
            if(root.left==null)&#123;
                root.left=new TreeNode(val);
                return;
            &#125;
            dfs(root.left,val);
        &#125;else&#123;
            if(root.right==null)&#123;
                root.right=new TreeNode(val);
                return;
            &#125;
            dfs(root.right,val);
        &#125;
    &#125;
&#125;
</code></pre>
<h2 id="删除二叉搜索树的节点"><a href="#删除二叉搜索树的节点" class="headerlink" title="删除二叉搜索树的节点"></a>删除二叉搜索树的节点</h2>



<pre><code class="java">class Solution &#123;
    public TreeNode deleteNode(TreeNode root, int key) &#123;
        if(root==null) return null;
        if(key&lt;root.val)&#123;
            root.left=deleteNode(root.left,key);
            return root;
        &#125;
        if(key&gt;root.val)&#123;
            root.right=deleteNode(root.right,key);
            return root;
        &#125;
        //key==root.val
        //左右都空
        if(key==root.val)&#123;
            if(root.right==null&amp;&amp;root.left==null)&#123;
                return null;
            &#125;
            //左子树为空
            if(root.left==null)&#123;
                return root.right;
            &#125;
            //右子树为空
            if(root.right==null)&#123;
                return root.left;
            &#125;
            //左右都不为空
            if(root.right!=null&amp;&amp;root.left!=null)&#123;
                //寻找左子树最大结点值val
                int val=getMaxInLeft(root.left);
                //对根节点赋值val 
                root.val=val;
                //删除等于val的那个结点，并更新左结点
                root.left=deleteNode(root.left,val);
                return root;
            &#125;
        &#125;
        return root;
        
    &#125;
     //找到左子树中最大的值
    public int getMaxInLeft(TreeNode root)&#123;
        //递归
        // if(root.right==null&amp;&amp;root.left==null) return root.val;
        // //右子树为空 必然最大的就是根节点
        // if(root.right==null) return root.val;
        // return getMaxInLeft(root.right);
        TreeNode node=root;
        while(node.right!=null)&#123;
            node=node.right;
        &#125;
        return node.val;
    &#125;
</code></pre>
<h2 id="修剪二叉搜索树"><a href="#修剪二叉搜索树" class="headerlink" title="修剪二叉搜索树"></a>修剪二叉搜索树</h2><p>给你二叉搜索树的根节点 <code>root</code> ，同时给定最小边界<code>low</code> 和最大边界 <code>high</code>。通过修剪二叉搜索树，使得所有节点的值在<code>[low, high]</code>中。修剪树 <strong>不应该</strong> 改变保留在树中的元素的相对结构 (即，如果没有被移除，原有的父代子代关系都应当保留)。 可以证明，存在 <strong>唯一的答案</strong> 。</p>
<p>所以结果应当返回修剪好的二叉搜索树的新的根节点。注意，根节点可能会根据给定的边界发生改变。</p>


<pre><code class="java">class Solution &#123;
    public TreeNode trimBST(TreeNode root, int low, int high) &#123;
        //在根结点把三种情况解决掉了 套用递归解决问题
        if(root==null) return null;
        if(root.val&gt;high)&#123;
            return trimBST(root.left,low,high);
        &#125;else if(root.val&lt;low)&#123;
            return trimBST(root.right,low,high);
        &#125;else&#123;
            root.right=trimBST(root.right,low,high);
            root.left=trimBST(root.left,low,high);
            return root;
        &#125;
    &#125;
&#125;
</code></pre>
<h2 id="将有序数组转换为二叉搜索树"><a href="#将有序数组转换为二叉搜索树" class="headerlink" title="将有序数组转换为二叉搜索树"></a>将有序数组转换为二叉搜索树</h2><p>给你一个整数数组 <code>nums</code> ，其中元素已经按 <strong>升序</strong> 排列，请你将其转换为一棵 <strong>高度平衡</strong> 二叉搜索树。</p>
<p><strong>高度平衡</strong> 二叉树是一棵满足「每个节点的左右两个子树的高度差的绝对值不超过 1 」的二叉树。</p>
<pre><code class="java">class Solution &#123;

    public TreeNode sortedArrayToBST(int[] nums) &#123;
        return dfs(nums,0,nums.length-1);
    &#125;
    public TreeNode dfs(int[] nums,int begin,int end)&#123;
        //越界返回空
        if(begin&gt;end) return null;
        //二分确定根结点
        int index=(begin+end)/2;
        int val=nums[index];
        //创建结点
        TreeNode root=new TreeNode(val);
        //递归
        root.right=dfs(nums,index+1,end);
        root.left=dfs(nums,begin,index-1);
        return root;
    &#125;
&#125;
</code></pre>
<h2 id="把二叉搜索树转换为累加树"><a href="#把二叉搜索树转换为累加树" class="headerlink" title="把二叉搜索树转换为累加树"></a>把二叉搜索树转换为累加树</h2><p>给出二叉 <strong>搜索</strong> 树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），使每个节点 <code>node</code> 的新值等于原树中大于或等于 <code>node.val</code> 的值之和。</p>
<p>提醒一下，二叉搜索树满足下列约束条件：</p>
<ul>
<li>节点的左子树仅包含键 <strong>小于</strong> 节点键的节点。</li>
<li>节点的右子树仅包含键 <strong>大于</strong> 节点键的节点。</li>
<li>左右子树也必须是二叉搜索树。</li>
</ul>
<p><strong>方法一：反序中序遍历</strong></p>
<p>思路及算法</p>
<p>本题中要求我们将每个节点的值修改为原来的节点值加上所有大于它的节点值之和。这样我们只需要反序中序遍历该二叉搜索树，记录过程中的节点值之和，并不断更新当前遍历到的节点的节点值，即可得到题目要求的累加树。</p>
<pre><code class="java">class Solution &#123;
    int sum=0;
    public TreeNode convertBST(TreeNode root) &#123;
        dfs(root);
        return root;
    &#125;
    public void dfs(TreeNode root)&#123;
        if(root==null) return;
        dfs(root.right);
        sum+=root.val;
        root.val=sum;
        dfs(root.left);
    &#125;
&#125;
</code></pre>
<h2 id="翻转二叉树"><a href="#翻转二叉树" class="headerlink" title="翻转二叉树"></a>翻转二叉树</h2><p><strong>递归</strong></p>
<p>深度优先</p>
<img src="/.xyz//0f91f7cbf5740de86e881eb7427c6c3993f4eca3624ca275d71e21c5e3e2c550-226_2.gif" alt="226_2.gif" style="zoom:33%;">

<pre><code class="java">自顶向下(好理解  优先这个)
class Solution &#123;
    public TreeNode invertTree(TreeNode root) &#123;
        //递归函数的终止条件，节点为空时返回
        if(root==null) &#123;
            return null;
        &#125;
        //下面三句是将当前节点的左右子树交换
        TreeNode tmp = root.right;
        root.right = root.left;
        root.left = tmp;
        //递归交换当前节点的 左子树
        invertTree(root.left);
        //递归交换当前节点的 右子树
        invertTree(root.right);
        //函数返回时就表示当前这个节点，以及它的左右子树
        //都已经交换完了
        return root;
    &#125;
&#125;
自底向上(代码简洁)   
class Solution &#123;
    public TreeNode invertTree(TreeNode root) &#123;
        if (root == null) &#123;
            return null;
        &#125;
        TreeNode left = invertTree(root.left);
        TreeNode right = invertTree(root.right);
        root.left = right;
        root.right = left;
        return root;
    &#125;
&#125;
</code></pre>
<p><strong>迭代</strong></p>
<p>广度优先</p>
<img src="/.xyz//f9e06159617cbf8372b544daee37be70286c3d9b762c016664e225044fc4d479-226_%E8%BF%AD%E4%BB%A3.gif" alt="226_迭代.gif" style="zoom:50%;">

<pre><code class="JAVA">class Solution &#123;
    public TreeNode invertTree(TreeNode root) &#123;
        if(root==null) &#123;
            return null;
        &#125;
        //将二叉树中的节点逐层放入队列中，再迭代处理队列中的元素
        LinkedList&lt;TreeNode&gt; queue = new LinkedList&lt;TreeNode&gt;();
        queue.add(root);
        while(!queue.isEmpty()) &#123;
            //每次都从队列中拿一个节点，并交换这个节点的左右子树
            TreeNode tmp = queue.poll();
            TreeNode left = tmp.left;
            tmp.left = tmp.right;
            tmp.right = left;
            //如果当前节点的左子树不为空，则放入队列等待后续处理
            if(tmp.left!=null) &#123;
                queue.add(tmp.left);
            &#125;
            //如果当前节点的右子树不为空，则放入队列等待后续处理
            if(tmp.right!=null) &#123;
                queue.add(tmp.right);
            &#125;
            
        &#125;
        //返回处理完的根节点
        return root;
    &#125;
&#125;
</code></pre>
<h2 id="二叉树的序列化和反序列化"><a href="#二叉树的序列化和反序列化" class="headerlink" title="二叉树的序列化和反序列化"></a>二叉树的序列化和反序列化</h2><p>题目：</p>


<p>算法：</p>
<img src="/.xyz//image-20220923172455790.png" alt="image-20220923172455790" style="zoom:67%;">

<img src="/.xyz//image-20220923172606089.png" alt="image-20220923172606089" style="zoom:67%;">

<pre><code class="java">public class Codec &#123;
    public String serialize(TreeNode root) &#123;
        return rserialize(root, &quot;&quot;);
    &#125;
  
    public TreeNode deserialize(String data) &#123;
        String[] dataArray = data.split(&quot;,&quot;);
        List&lt;String&gt; dataList = new LinkedList&lt;String&gt;(Arrays.asList(dataArray));
        return rdeserialize(dataList);
    &#125;

    public String rserialize(TreeNode root, String str) &#123;
        if (root == null) &#123;
            str += &quot;None,&quot;;
        &#125; else &#123;
            str += str.valueOf(root.val) + &quot;,&quot;;//或者这样写 str+=String.valueOf(root.val)+&quot;,&quot;;  把root.val转成String类型
            str = rserialize(root.left, str);
            str = rserialize(root.right, str);
        &#125;
        return str;
    &#125;
  
    public TreeNode rdeserialize(List&lt;String&gt; dataList) &#123;
        if (dataList.get(0).equals(&quot;None&quot;)) &#123;
            dataList.remove(0);
            return null;
        &#125;
  
        TreeNode root = new TreeNode(Integer.valueOf(dataList.get(0)));
        dataList.remove(0);
        root.left = rdeserialize(dataList);
        root.right = rdeserialize(dataList);
    
        return root;
    &#125;
&#125;
</code></pre>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2>

<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><h2 id="经验"><a href="#经验" class="headerlink" title="经验"></a>经验</h2><p><strong>动态规划的三大步骤</strong></p>
<p>利用历史记录，来避免重复计算。而这些历史记录，我们得需要一些变量来保存，一般是用一维数组或者<a href="https://www.zhihu.com/search?q=%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:%2291582909%22%7D">二维数组</a>来保存。<br> 第一步骤：定义数组元素的含义，用一个数组，来保存历史数组，假设用一维数组 dp[] 你的 dp[i] 是代表什么意思？</p>
<p>第二步骤：找出数组元素之间的关系式<br> 第三步骤：找出<a href="https://www.zhihu.com/search?q=%E5%88%9D%E5%A7%8B%E5%80%BC&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:%2291582909%22%7D">初始值</a>。</p>
<p><strong>什么时候用二维数组？</strong></p>
<p>涉及到数组和”和“的问题，考虑用二维数组 ，比如目标和这道题：</p>
<p>定义二维数组 dp，其中 dp[i][j] 表示在数组 num的前 i个数中选取元素，使得这些元素之和等于 j 的方案数。</p>
<p>再比如分割等和子集这道题</p>
<p>优化步骤：一般这种dp二维数组的每一行的计算只和上一行有关，因此可以使用滚动数组的方式，去掉 dp 的第一个维度，将空间复杂度降低</p>
<pre><code class="java">else if (i - dp[i - 1] &gt; 0 &amp;&amp; s.charAt(i - dp[i - 1] - 1) == &#39;(&#39;) 
</code></pre>
<h2 id="分割等和子集"><a href="#分割等和子集" class="headerlink" title="分割等和子集"></a>分割等和子集</h2><p>给你一个 <strong>只包含正整数</strong> 的 <strong>非空</strong> 数组 <code>nums</code> 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p>
<img src="/.xyz//image-20221005155841234.png" alt="image-20221005155841234" style="zoom: 80%;">

<p><strong>改进</strong></p>




<p><strong>我的理解：</strong> 不管j和num[i]的关系 我这个公式一定成立    改进后，行i简化成循环次数，j不变<br>$$<br>dp[i][j]&#x3D;dp[i-1][j]||dp[i-1][j-num[i]]<br>$$</p>
<p>$$<br>dp[j]&#x3D;dp<a href="%E8%BF%99%E4%B8%AA%E5%85%B6%E5%AE%9E%E6%98%AF%E4%B8%8A%E4%B8%80%E6%AD%A5%E7%9A%84dp">j</a>||dp[j-num[i](一样 也是上一步的)]<br>$$</p>
<pre><code class="JAVA">class Solution &#123;
    public boolean canPartition(int[] nums) &#123;
        int n = nums.length;
        if (n &lt; 2) &#123;
            return false;
        &#125;
        int sum = 0, maxNum = 0;
        for (int num : nums) &#123;
            sum += num;
            maxNum = Math.max(maxNum, num);
        &#125;
        if (sum % 2 != 0) &#123;
            return false;
        &#125;
        int target = sum / 2;
        if (maxNum &gt; target) &#123;
            return false;
        &#125;
        boolean[] dp = new boolean[target + 1];
        dp[0] = true;//目标值为0 不选就行了 因此为true
        for (int i = 0; i &lt; n; i++) &#123;
            int num = nums[i];
            for (int j = target; j &gt;= num; --j) &#123;
                dp[j] |= dp[j - num];
            &#125;
        &#125;
        return dp[target];
    &#125;
&#125;
</code></pre>
<h2 id="打家劫舍-III"><a href="#打家劫舍-III" class="headerlink" title="打家劫舍 III"></a>打家劫舍 III</h2><img src="/.xyz//image-20220928145951556.png" alt="image-20220928145951556" style="zoom: 80%;">

<pre><code class="java">class Solution &#123;
    Map&lt;TreeNode, Integer&gt; f = new HashMap&lt;TreeNode, Integer&gt;();
    Map&lt;TreeNode, Integer&gt; g = new HashMap&lt;TreeNode, Integer&gt;();

    public int rob(TreeNode root) &#123;
        dfs(root);
        return Math.max(f.getOrDefault(root, 0), g.getOrDefault(root, 0));
    &#125;

    public void dfs(TreeNode node) &#123;
        if (node == null) &#123;
            return;
        &#125;
        dfs(node.left);
        dfs(node.right);
        f.put(node, node.val + g.getOrDefault(node.left, 0) + g.getOrDefault(node.right, 0));
        g.put(node, Math.max(f.getOrDefault(node.left, 0), g.getOrDefault(node.left, 0)) + Math.max(f.getOrDefault(node.right, 0), g.getOrDefault(node.right, 0)));
    &#125;
&#125;
</code></pre>
<img src="/.xyz//image-20220928150047852.png" alt="image-20220928150047852" style="zoom: 80%;">

<pre><code class="java">class Solution &#123;
    public int rob(TreeNode root) &#123;
        //返回f、g数组
        int[] rootStatus = dfs(root);
        //0-&gt;f选择    1-&gt;g未选择
        return Math.max(rootStatus[0], rootStatus[1]);
    &#125;

    public int[] dfs(TreeNode node) &#123;
        if (node == null) &#123;
            return new int[]&#123;0, 0&#125;;
        &#125;
        int[] l = dfs(node.left);
        int[] r = dfs(node.right);
        int selected = node.val + l[1] + r[1];
        int notSelected = Math.max(l[0], l[1]) + Math.max(r[0], r[1]);
        return new int[]&#123;selected, notSelected&#125;;//必须是new的	否则一直是同一个值 
    &#125;
&#125;
</code></pre>
<h2 id="零钱兑换"><a href="#零钱兑换" class="headerlink" title="零钱兑换"></a>零钱兑换</h2><p>给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。</p>
<p>计算并返回可以凑成总金额所需的 最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1 。</p>
<p>你可以认为每种硬币的数量是无限的。</p>


<img src="/.xyz//image-20220927211950883.png" alt="image-20220927211950883" style="zoom:80%;">

<p>在上面的递归树中，我们可以看到许多子问题被多次计算。例如，F(1)F(1)F(1) 被计算了 131313 次。为了避免重复的计算，我们将每个子问题的答案存在一个数组中进行记忆化，如果下次还要计算这个问题的值直接从数组中取出返回即可，这样能保证每个子问题最多只被计算一次。</p>
<img src="/.xyz//image-20220927212012322.png" alt="image-20220927212012322" style="zoom:80%;">

<pre><code class="java">public class Solution &#123;
    public int coinChange(int[] coins, int amount) &#123;
        int max = amount + 1;//必然比dp所有值都大
        int[] dp = new int[amount + 1];
        Arrays.fill(dp, max);//填充数组
        dp[0] = 0;
        //i是金额，自底向上，即i从1一直算到amount,每个dp[i]通过穷举硬币coins[j]计算dp[i - coins[j]]最小值 最后算出结果 
        for (int i = 1; i &lt;= amount; i++) &#123;
            for (int j = 0; j &lt; coins.length; j++) &#123;
                if (coins[j] &lt;= i) &#123;
                    dp[i] = Math.min(dp[i], dp[i - coins[j]] + 1);
                &#125;
            &#125;
        &#125;
        return dp[amount] &gt; amount ? -1 : dp[amount];
    &#125;
&#125;
</code></pre>




<h2 id="戳气球"><a href="#戳气球" class="headerlink" title="戳气球"></a>戳气球</h2>

<img src="/.xyz//image-20220927162801928.png" alt="image-20220927162801928" style="zoom: 67%;">

<img src="/.xyz//image-20220927162834656.png" alt="image-20220927162834656" style="zoom:67%;">

<pre><code class="java">class Solution &#123;
    public int maxCoins(int[] nums) &#123;
        int n = nums.length;
        //rec是record
        int[][] rec = new int[n + 2][n + 2];//初始二维数组元素全为0
        int[] val = new int[n + 2];
        val[0] = val[n + 1] = 1;//防止nums下标越界
        for (int i = 1; i &lt;= n; i++) &#123;
            val[i] = nums[i - 1];
        &#125;
        //自底向下
        for (int i = n - 1; i &gt;= 0; i--) &#123;
            for (int j = i + 2; j &lt;= n + 1; j++) &#123;
                for (int k = i + 1; k &lt; j; k++) &#123;
                    int sum = val[i] * val[k] * val[j];
                    //递归
                    sum += rec[i][k] + rec[k][j];
                    rec[i][j] = Math.max(rec[i][j], sum);//能得到的最多硬币数  考虑到会有重复的 因此选择打擂台方法
                &#125;
            &#125;
        &#125;
        return rec[0][n + 1];
    &#125;
&#125;
</code></pre>
<h2 id="最佳买卖股票时机含冷冻期"><a href="#最佳买卖股票时机含冷冻期" class="headerlink" title="最佳买卖股票时机含冷冻期"></a>最佳买卖股票时机含冷冻期</h2><p>给定一个整数数组prices，其中第  prices[i] 表示第 i 天的股票价格 。</p>
<p>设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:</p>
<p>卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。</p>
<p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
<p><strong>思路与算法</strong></p>
<p>我们用 f[i]表示第 ii天结束之后的「累计最大收益」。根据题目描述，由于我们最多只能同时买入（持有）一支股票，并且卖出股票后有冷冻期的限制，因此我们会有三种不同的状态：</p>
<pre><code>我们目前持有一支股票，对应的「累计最大收益」记为 f[i][0]；

我们目前不持有任何股票，并且处于冷冻期中，对应的「累计最大收益」记为 f[i][1]；

我们目前不持有任何股票，并且不处于冷冻期中，对应的「累计最大收益」记为 f[i][2]。
</code></pre>
<p><strong>这里的「处于冷冻期」指的是在第 i天结束之后的状态。也就是说：如果第 i 天结束之后处于冷冻期，那么第 i+1 天无法买入股票。</strong></p>
<img src="/.xyz//image-20220926192627869.png" alt="image-20220926192627869" style="zoom: 80%;">

<p>这里自己手推一遍</p>
<img src="/.xyz//image-20220926193642785.png" alt="image-20220926193642785" style="zoom:80%;">



<pre><code class="java">class Solution &#123;
    public int maxProfit(int[] prices) &#123;
        if (prices.length == 0) &#123;
            return 0;
        &#125;

        int n = prices.length;
        //初始化
        int f0 = -prices[0];
        int f1 = 0;
        int f2 = 0;
        //滚动数组
        for (int i = 1; i &lt; n; ++i) &#123;
            int newf0 = Math.max(f0, f2 - prices[i]);
            int newf1 = f0 + prices[i];
            int newf2 = Math.max(f1, f2);
            f0 = newf0;
            f1 = newf1;
            f2 = newf2;
        &#125;

        return Math.max(f1, f2);
    &#125;
&#125;
</code></pre>
<h2 id="完全平方数"><a href="#完全平方数" class="headerlink" title="完全平方数"></a>完全平方数</h2><p>给你一个整数 n ，返回 和为 n 的完全平方数的最少数量 。</p>
<p>完全平方数 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。</p>
<img src="/.xyz//image-20220921173922046.png" alt="image-20220921173922046" style="zoom: 67%;">

<p>从小到大枚举i，以计算f[i]，最终得到f[n]，j也是从小到大枚举，每次把j当作i的一个平方因子，因此f[i]&#x3D;1+f[ i-j^2 ]  初始条件f(0)&#x3D;0，因此可以一步步把f[i]算出来</p>
<pre><code class="java">class Solution &#123;
    public int numSquares(int n) &#123;
        int[] f = new int[n + 1];
        for (int i = 1; i &lt;= n; i++) &#123;
            int minn = Integer.MAX_VALUE;
            for (int j = 1; j * j &lt;= i; j++) &#123;
                minn = Math.min(minn, f[i - j * j]);//
            &#125;
            f[i] = minn + 1;
        &#125;
        return f[n];
    &#125;
&#125;
</code></pre>
<h2 id="最大正方形"><a href="#最大正方形" class="headerlink" title="最大正方形"></a><a href="https://leetcode.cn/problems/maximal-square/">最大正方形</a></h2><p>在一个由 <code>&#39;0&#39;</code> 和 <code>&#39;1&#39;</code> 组成的二维矩阵内，找到只包含 <code>&#39;1&#39;</code> 的最大正方形，并返回其面积。</p>
<pre><code>dp(i,j)=min(dp(i−1,j),dp(i−1,j−1),dp(i,j−1))+1//状态转移方程  
</code></pre>
<p>dp(i,j）代表以坐标点(i,j) 为右下角的最大正方形  还要注意如果i j之中有一个为0，那么dp值为0</p>
<pre><code class="java">    class Solution &#123;
        public int maximalSquare(char[][] matrix) &#123;
            int maxSide = 0, row = matrix.length, column = matrix[0].length;
            if (matrix == null || row == 0 || column == 0) return 0;
            int[][] dp = new int[row][column];
            for (int i = 0; i &lt; row; i++) &#123;
                for (int j = 0; j &lt; column; j++) &#123;
                    if (matrix[i][j] == &#39;1&#39;) &#123;
                        if (i == 0 || j == 0) &#123;
                            dp[i][j] = 1;
                        &#125; else &#123;
                            dp[i][j] = Math.min(Math.min(dp[i - 1][j - 1], dp[i - 1][j]), dp[i][j - 1]) + 1;
                        &#125;
                        maxSide = Math.max(maxSide, dp[i][j]);
                    &#125;
                &#125;
            &#125;
            return maxSide * maxSide;
        &#125;
    &#125;
</code></pre>
<h2 id="最长递增子序列-也可greedy-优先这个"><a href="#最长递增子序列-也可greedy-优先这个" class="headerlink" title="最长递增子序列(也可greedy 优先这个)"></a>最长递增子序列(也可greedy 优先这个)</h2><pre><code>输入：nums = [10,9,2,5,3,7,101,18]
输出：4
解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 
</code></pre>
<img src="/.xyz//image-20220924110440818.png" alt="image-20220924110440818" style="zoom: 80%;">

<pre><code class="java">class Solution &#123;
    public int lengthOfLIS(int[] nums) &#123;
        if (nums.length == 0) &#123;
            return 0;
        &#125;
        int[] dp = new int[nums.length];
        dp[0] = 1;
        int maxans = 1;//最少为1
        for (int i = 1; i &lt; nums.length; i++) &#123;
            dp[i] = 1;//以i为结尾 那必然包括自己 所以至少为
            for (int j = 0; j &lt; i; j++) &#123;
                if (nums[i] &gt; nums[j]) &#123;
                    dp[i] = Math.max(dp[i], dp[j] + 1);//选取以j为结尾的（j从0到i-1）最长序列，然后加1
                &#125;
            &#125;
            maxans = Math.max(maxans, dp[i]);
        &#125;
        return maxans;
    &#125;
&#125;
</code></pre>
<h2 id="爬楼梯"><a href="#爬楼梯" class="headerlink" title="爬楼梯"></a>爬楼梯</h2><p>假设你正在爬楼梯。需要 <code>n</code> 阶你才能到达楼顶。 每次你可以爬 <code>1</code> 或 <code>2</code> 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p>
<p>通项公式： f(x)&#x3D;f(x−1)+f(x−2)      滚动数组</p>
<img src="https://assets.leetcode-cn.com/solution-static/70/70_fig1.gif" alt="fig1" style="zoom:33%;">

<pre><code class="java">public int climbStairs(int n) &#123;
//        动态规划 滚动数组 初始值 通项公式
                int p = 0, q = 0, r = 1;//第0层
                for (int i = 1; i &lt;= n; i++) &#123;
                    p = q;
                    q = r;
                    r = p + q;
                &#125;
                return r;
            &#125;
</code></pre>
<pre><code class="cpp">/* 动态规划五部曲：
     * 1.确定dp[i]的下标以及dp值的含义： 爬到第i层楼梯，有dp[i]种方法；
     * 2.确定动态规划的递推公式：dp[i] = dp[i-1] + dp[i-2];
     * 3.dp数组的初始化：因为提示中，1&lt;=n&lt;=45 所以初始化值，dp[1] = 1, dp[2] = 2;
     * 4.确定遍历顺序：分析递推公式可知当前值依赖前两个值来确定，所以递推顺序应该是从前往后；
     * 5.打印dp数组看自己写的对不对；
    */
</code></pre>
<h2 id="乘积最大子数组"><a href="#乘积最大子数组" class="headerlink" title="乘积最大子数组"></a>乘积最大子数组</h2>

<pre><code class="java">class Solution &#123;
    public int maxProduct(int[] nums) &#123;
        int maxF=nums[0],minF=nums[0],ans=nums[0];
        int length=nums.length;
        for(int i=1;i&lt;length;i++)&#123;
            int mx=maxF,mn=minF;//每次循环都要重新赋值，因为乘的就是最大最小值
            maxF=Math.max(nums[i],Math.max(mx*nums[i],mn*nums[i]));//考虑到正负号的原因
            minF=Math.min(nums[i],Math.min(mx*nums[i],mn*nums[i]));//这个肯定要算，maxF用的上
            ans=Math.max(ans,maxF);
        &#125;
        return ans;

    &#125;
&#125;
</code></pre>
<p><strong>system.arraycopy的作用</strong></p>


<h2 id="偷窃"><a href="#偷窃" class="headerlink" title="偷窃"></a>偷窃</h2><p>计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p>
<p>给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。</p>


<h2 id="岛屿问题"><a href="#岛屿问题" class="headerlink" title="岛屿问题"></a>岛屿问题</h2><p><a href="https://leetcode-cn.com/problems/number-of-islands/">L200. 岛屿数量</a> （Easy）</p>
<p><a href="https://leetcode-cn.com/problems/island-perimeter/">463. 岛屿的周长</a> （Easy）</p>
<p><a href="https://leetcode-cn.com/problems/max-area-of-island/">695. 岛屿的最大面积</a> （Medium）</p>
<p><a href="https://leetcode-cn.com/problems/making-a-large-island/">827. 最大人工岛</a> （Hard）</p>
<p>采用DFS</p>
<p><strong>基本框架?</strong></p>
<p>dfs两要素:「<strong>访问相邻结点</strong>」和「<strong>判断 base case</strong>」</p>
<p><strong>如何避免重复遍历?</strong></p>
<p>答案是标记已经遍历过的格子</p>
<p><strong>岛屿数量问题</strong></p>
<pre><code class="java">class Solution &#123;
    public int numIslands(char[][] grid) &#123;
        int count = 0;
        for(int i = 0; i &lt; grid.length; i++) &#123;
            for(int j = 0; j &lt; grid[0].length; j++) &#123;
                if(grid[i][j] == &#39;1&#39;)&#123;
                    dfs(grid, i, j);
                    count++;
                &#125;
            &#125;
        &#125;
        return count;
    &#125;
    private void dfs(char[][] grid, int i, int j)&#123;
        if(i &lt; 0 || j &lt; 0 || i &gt;= grid.length || j &gt;= grid[0].length || grid[i][j] == &#39;0&#39;) return;
        grid[i][j] = &#39;0&#39;;
        dfs(grid, i + 1, j);
        dfs(grid, i, j + 1);
        dfs(grid, i - 1, j);
        dfs(grid, i, j - 1);
    &#125;
&#125;
</code></pre>
<h1 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h1><h2 id="前言-3"><a href="#前言-3" class="headerlink" title="前言"></a>前言</h2><p><a href="https://www.zhihu.com/question/325665309/answer/2245817776">https://www.zhihu.com/question/325665309/answer/2245817776</a></p>
<p><strong>很多需要列举所有可能性的题需要用回溯</strong></p>
<pre><code class="java">def backtrack(...):
    for 选择 in 选择列表:
        做选择
        backtrack(...)
        撤销选择
</code></pre>
<pre><code class="java">1、路径：也就是已经做出的选择。

2、选择列表：也就是你当前可以做的选择。

3、结束条件：也就是到达决策树底层，无法再做选择的条件。
result = []
def backtrack(路径, 选择列表):
    if 满足结束条件:
        result.add(路径)
        return

    for 选择 in 选择列表:
        做选择
        backtrack(路径, 选择列表)
        撤销选择
</code></pre>
<p>一般涉及到做选择的问题都可以考虑用回溯法，写回溯的题的时候，方法参数可以先空着，用到什么加什么、</p>
<p>当只有两个选择的时候，就不用for循环了，直接写出来就行，比如+- ()这种</p>
<img src="/.xyz//20210130173631174.png" alt="回溯算法理论基础" style="zoom:50%;">

<h2 id="目标和"><a href="#目标和" class="headerlink" title="目标和"></a>目标和</h2>

<pre><code class="java">class Solution &#123;
    int count=0;
    public int findTargetSumWays(int[] nums, int target) &#123;
        backtrack(nums, 0, 0, target);
        return count;
    &#125;
    private void backtrack(int[] nums, int i, int sum, int target)&#123;
        //结束条件
        if(i == nums.length)&#123;	
            if(sum == target)&#123;
                count++;
            &#125;
            return;
        &#125;else&#123;
            //两个选择
            backtrack(nums,i+1,sum+nums[i],target);
            backtrack(nums,i+1,sum-nums[i],target);
        &#125;
    &#125;
&#125;
</code></pre>
<p>我的理解：讲道理这个就是递归呀 相当于二叉树递归</p>
<h2 id="删除无效括号"><a href="#删除无效括号" class="headerlink" title="删除无效括号"></a>删除无效括号</h2><p>给你一个由若干括号和字母组成的字符串 <code>s</code> ，删除最小数量的无效括号，使得输入的字符串有效。</p>
<p>返回所有可能的结果。答案可以按 <strong>任意顺序</strong> 返回。</p>
<img src="/.xyz//image-20220926152136279.png" alt="image-20220926152136279" style="zoom:80%;">

<pre><code class="java">
class Solution &#123;
    List&lt;String&gt; res=new ArrayList&lt;&gt;();
    public List&lt;String&gt; removeInvalidParentheses(String s) &#123;
        int lremove=0,rremove=0;
        
        //统计最少需要去除的左括号以及右括号
        for(int i=0;i&lt;s.length();i++)&#123;
            if(s.charAt(i)==&#39;(&#39;)&#123;
                lremove++;
            &#125;else if(s.charAt(i)==&#39;)&#39;)&#123;//注意审题 有字母 所以 不能直接else 需要elseif 后面也是一样
                if(lremove==0)&#123;
                    rremove++;
                &#125;else&#123;
                    lremove--;
                &#125;
            &#125;
        &#125;
        //进行回溯
        backtrack(s,0,lremove,rremove);
        return res;
    &#125;
    public void backtrack(String str,int start,int lremove,int rremove)&#123;
        //结束条件
        if(lremove==0&amp;&amp;rremove==0)&#123;
            //判断是否有效
            if(isValid(str))&#123;
                res.add(str);
            &#125;
            return;
        &#125;
        for(int i=start;i&lt;str.length();i++)&#123;
            //剪枝 有连着重复的括号 跳过回溯 因为第一个已经回溯了 后面没必要了
            我们在每次进行搜索时，如果遇到连续相同的括号我们只需要搜索一次即可，比如当前遇到的字符串为 &quot;(((())&quot;，去掉前四个左括号中的任意一个，生成的字符串是一样的，均为 &quot;((())&quot;，因此我们在尝试搜索时，只需去掉一个左括号进行下一轮搜索，不需要将前四个左括号都尝试一遍。
            if(i!=start&amp;&amp;str.charAt(i)==str.charAt(i-1)) continue;
            //剪枝 需要去除括号大于所剩长度 直接返回
            if(lremove+rremove&gt;str.length()-i) return;
            //去除一个(   再加上后面一个元素 下标还是i，不会改变  因此“去除(”可以理解为选择 i++即为取消选择(即老子不去除这个括号)
            if(lremove&gt;0&amp;&amp;str.charAt(i)==&#39;(&#39;)&#123;
                //substring 左开右闭
                backtrack(str.substring(0,i)+str.substring(i+1),i,lremove-1,rremove);
            &#125;					
            if(rremove&gt;0&amp;&amp;str.charAt(i)==&#39;)&#39;)&#123;
                backtrack(str.substring(0,i)+str.substring(i+1),i,lremove,rremove-1);
            &#125;
        &#125;

    &#125;
 
    public boolean isValid(String str)&#123;
        int cnt=0;
        for(int i=0;i&lt;str.length();i++)&#123;
            if(str.charAt(i)==&#39;(&#39;)&#123;
                cnt++;
            &#125;else if(str.charAt(i)==&#39;)&#39;)&#123;
                if(cnt==0)&#123;
                    return false;
                &#125;else &#123;
                    cnt--;
                &#125;
            &#125;
        &#125;
        return cnt==0;
    &#125;
&#125;
</code></pre>
<h2 id="括号匹配"><a href="#括号匹配" class="headerlink" title="括号匹配"></a>括号匹配</h2><p><strong>if的两个选择  括号匹配</strong></p>
<p><img src="/.xyz//.assets%5Cimage-20220420170037385.png" alt="image-20220420170037385"></p>
<h2 id="组合总和"><a href="#组合总和" class="headerlink" title="组合总和"></a>组合总和</h2><pre><code>//给你一个 无重复元素 的整数数组 candidates 和一个目标整数 target ，找出 candidates 中可以使数字和为目标数 target 的
// 所有 不同组合 ，并以列表形式返回。你可以按 任意顺序 返回这些组合。 
</code></pre>
<pre><code class="java">class Solution &#123;
    public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) &#123;
        List&lt;List&lt;Integer&gt;&gt; ans=new ArrayList&lt;&gt;();
        List&lt;Integer&gt; cur=new ArrayList&lt;&gt;();
        backtrack(candidates,target,ans,cur,0,0);
        return ans;
    &#125;
    public void backtrack(int[] candidates,int target,List&lt;List&lt;Integer&gt;&gt; ans,List&lt;Integer&gt; cur,int sum,int index) &#123;
        if (sum == target) &#123;
            ans.add(new ArrayList&lt;Integer&gt;(cur));
            //此处为啥不是ans.add(cur)？
            //答案：因为cur是数组的引用地址，直接add最后是空的

            return;
        &#125;

        if (sum &lt; target) &#123;
            //index的作用是为了使得不出现 测试结果:[[2,2,3],[2,3,2],[3,2,2],[7]] 期望结果:[[2,2,3],[7]]
            //这种情况，保持数组cur升序，也就避免了重复
            for (int i = index; i &lt; candidates.length; i++) &#123;
                cur.add(candidates[i]);
                sum = sum + candidates[i];
                backtrack(candidates, target, ans, cur, sum,i);//i传进去
                cur.remove(cur.size() - 1);
                sum = sum - candidates[i];//剪枝操作 返回回原来状态 否则sum只会越来越大
            &#125;
        &#125;
    &#125;

&#125;
</code></pre>
<h2 id="例题3"><a href="#例题3" class="headerlink" title="例题3"></a>例题3</h2><p><img src="/.xyz//.assets%5Cimage-20220531161347850.png" alt="image-20220531161347850"></p>
<pre><code>vector&lt;int&gt; t;
void dfs(int cur, int n) &#123;
    if (cur == n) &#123;
        // 记录答案
        // ...
        return;
    &#125;
    // 考虑选择当前位置
    t.push_back(cur);
    dfs(cur + 1, n, k);
    t.pop_back();
    // 考虑不选择当前位置
    dfs(cur + 1, n, k);
&#125;
</code></pre>
<h1 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h1><h2 id="最长递增子序列（也可dp）"><a href="#最长递增子序列（也可dp）" class="headerlink" title="最长递增子序列（也可dp）"></a>最长递增子序列（也可dp）</h2><p>考虑一个简单的贪心，如果我们要使上升子序列尽可能的长，则我们需要让序列上升得尽可能慢，因此我们希望每次在上升子序列最后加上的那个数尽可能的小。</p>
<p>基于上面的贪心思路，我们维护一个数组 d[i]，表示长度为 i的最长上升子序列的末尾元素的最小值，用 len记录目前最长上升子序列的长度，起始时 len 为 1，d[1]&#x3D;nums[0]</p>
<p>同时我们可以注意到 d[i] 是关于 i 单调递增的。（显而易见）根据 ddd 数组的单调性，我们可以使用二分查找寻找下标 i，优化时间复杂度。</p>
<img src="/.xyz//image-20220924191640236.png" alt="image-20220924191640236" style="zoom:80%;">

<pre><code class="java">class Solution &#123;
    public int lengthOfLIS(int[] nums) &#123;
        int len = 1, n = nums.length;
        if (n == 0) &#123;
            return 0;
        &#125;
        //细节 d代表长度为i的最长上升子序列的末尾元素的最小值，d[0……n]因此共n+1个数 所以是new int[n + 1]
        int[] d = new int[n + 1];
        d[len] = nums[0];
        for (int i = 1; i &lt; n; ++i) &#123;
            if (nums[i] &gt; d[len]) &#123;
                d[++len] = nums[i];//先++
            &#125; else &#123;
                int l = 1, r = len, pos = 0; // 如果找不到说明所有的数都比 nums[i] 大，此时要更新 d[1]，所以这里将 pos 设为 0  
                while (l &lt;= r) &#123;
                    int mid = (l + r) &gt;&gt; 1;
                    //目的是找到第一个比num[i]小的数字，也就是小于nums[i]的数字里面最接近nums[i]的数字
                    if (d[mid] &lt; nums[i]) &#123;
                        pos = mid;//更新pos
                        l = mid + 1;
                    &#125; else &#123;
                        r = mid - 1;
                    &#125;
                &#125;
                d[pos + 1] = nums[i];//更新 
            &#125;
        &#125;
        return len;
    &#125;
&#125;
</code></pre>
<h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><p>我的理解：</p>
<p>主要函数里面return一个自定义函数，自定义函数里面前一部分写好递归的统一模板，然后开始递归下一层。</p>
<p>甩锅给后面的过程，然后得有一个出口。</p>
<p><img src="https://pic2.zhimg.com/80/v2-1ad28b5063f58925acfbc5df639f61ec_720w.jpg?source=1940ef5c" alt="img"></p>
<pre><code class="java">/**
 * 合并两有序链表  递归方法 代码少 但效率不行
 */
public ListNode mergeTwoLists(ListNode list1,ListNode list2)&#123;
    if(list1==null||list2==null)&#123;
        return list1==null?list2:list1;
    &#125;else if(list1.val&lt;list2.val)&#123;
        list1.next=mergeTwoLists(list1.next,list2);
        return list1;
    &#125;else&#123;
        list2.next=mergeTwoLists(list2.next,list1);
        return list2;
    &#125;
&#125;
/**
 * 普通方法 代码多 但效率快
 */
/*
public ListNode mergeTwoLists(ListNode list1,ListNode list2)&#123;
    if(list1==null||list2==null)&#123;
        return list1==null?list2:list1;
    &#125;
    ListNode head=new ListNode(0);
    ListNode tail=head,aptr=list1,bptr=list2;
    while (list1!=null&amp;&amp;list2!=null)&#123;
        if(list1.val&lt;list2.val)&#123;
            tail.next=list1;
            list1=list1.next;
        &#125;else&#123;
            tail.next=list2;
            list2=list2.next;
        &#125;
        tail=tail.next;
    &#125;
    tail.next=list1!=null?list1:list2;
    return head.next;
&#125;
 */
</code></pre>
<p>数学、规律</p>
<h1 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h1><p><a href="https://blog.csdn.net/the_zed/article/details/105126583">https://blog.csdn.net/the_zed/article/details/105126583</a></p>
<p>查找和合并 ，一边查询一边修改结点指向是并查集的特色。</p>
<h2 id="除法求值399"><a href="#除法求值399" class="headerlink" title="除法求值399"></a>除法求值399</h2><pre><code class="java">        public class Solution &#123;
            public double[] calcEquation(List&lt;List&lt;String&gt;&gt; equations, double[] values, List&lt;List&lt;String&gt;&gt; queries) &#123;
                int equationsSize = equations.size();
                //因为子数组里面有两个元素[[&quot;a&quot;,&quot;b&quot;],[&quot;b&quot;,&quot;c&quot;]], values = [2.0,3.0], queries = [[&quot;a&quot;,&quot;c&quot;],[&quot;b&quot;,&quot;a&quot;],[&quot;a&quot;,&quot;e&quot;]
                UnionFind unionFind = new UnionFind(2 * equationsSize);
                // 第 1 步：预处理，将变量的值与 id 进行映射，使得并查集的底层使用数组实现，方便编码
                Map&lt;String, Integer&gt; hashMap = new HashMap&lt;&gt;(2 * equationsSize);
                int id = 0;
                for (int i = 0; i &lt; equationsSize; i++) &#123;
                    List&lt;String&gt; equation = equations.get(i);
                    String var1 = equation.get(0);
                    String var2 = equation.get(1);

                    if (!hashMap.containsKey(var1)) &#123;
                        hashMap.put(var1, id);
                        id++;
                    &#125;
                    if (!hashMap.containsKey(var2)) &#123;
                        hashMap.put(var2, id);
                        id++;
                    &#125;
                    //hashmap   -&gt;   &#123;&#123;a,1&#125;,&#123;b,2&#125;……&#125;
                    unionFind.union(hashMap.get(var1), hashMap.get(var2), values[i]);
                &#125;
                // 第 2 步：做查询
                int queriesSize = queries.size();
                double[] res = new double[queriesSize];
                for (int i = 0; i < queriesSize; i++) &#123;
                    String var1 = queries.get(i).get(0);
                    String var2 = queries.get(i).get(1);

                    Integer id1 = hashMap.get(var1);
                    Integer id2 = hashMap.get(var2);

                    if (id1 == null || id2 == null) &#123;
                        res[i] = -1.0d;
                    &#125; else &#123;
                        res[i] = unionFind.isConnected(id1, id2);
                    &#125;
                &#125;
                return res;
            &#125;
            //Union并  Find查
            private class UnionFind &#123;
                private int[] parent;
                /**
                 * 指向的父结点的权值
                 */
                private double[] weight;

                //this的作用主要是引
                public UnionFind(int n) &#123;
                    this.parent = new int[n];
                    this.weight = new double[n];
                    for (int i = 0; i < n; i++) &#123;
                        parent[i] = i;
                        weight[i] = 1.0d;
                    &#125;
                &#125;
                //把xy合并
                public void union(int x, int y, double value) &#123;
                    int rootX = find(x);
                    int rootY = find(y);
                    //如果属于一个集合不做处理
                    if (rootX == rootY) &#123;
                        return;
                    &#125;
                    //x的根指向y 并计算rootx到rooty的权重
                    parent[rootX] = rootY;
                    // 关系式的推导请见「参考代码」下方的示意图
                    weight[rootX] = weight[y] * value / weight[x];
                &#125;

                /**
                 * 路径压缩
                 * @param x
                 * @return 根结点的 id
                 * 查根的过程中进行了路径压缩 即压缩成高度为2的树  同时也计算了所有结点到根节点的权重
                 */
                public int find(int x) &#123;
                    if (x != parent[x]) &#123;
                        int origin = parent[x];
                        parent[x] = find(parent[x]);
                        weight[x] *= weight[origin];
                    &#125;
                    return parent[x];
                &#125;
                //合并完后再不在一个集合直接一个-1
                // 在的话 除即可
                public double isConnected(int x, int y) &#123;
                    int rootX = find(x);
                    int rootY = find(y);
                    if (rootX == rootY) &#123;
                        return weight[x] / weight[y];
                    &#125; else &#123;
                        return -1.0d;
                    &#125;
                &#125;
            &#125;
        &#125;
```

<img src="/.xyz//image-20221003210317519.png" alt="image-20221003210317519" style="zoom:67%;">







# 通项公式

<img src="/.xyz//image-20220529175511733.png" alt="image-20220529175511733" style="zoom:50%;">

<img src="/.xyz//image-20220529175454488.png" alt="image-20220529175454488" style="zoom: 50%;">

**力扣48题翻转矩阵**

<img src="/.xyz//image-20220516212619082.png" alt="image-20220516212619082" style="zoom: 50%;">

<img src="/.xyz//image-20220516212931381.png" alt="image-20220516212931381" style="zoom:33%;">

只关注我画黑框的部分 其余三块都是每个元素旋转而成

```java
//        官方第二种方法
        class Solution &#123;
            public void rotate(int[][] matrix) &#123;
                int n = matrix.length;
                for (int i = 0; i < n / 2; ++i) &#123;//行数 向下区取余
                    for (int j = 0; j < (n + 1) / 2; ++j) &#123;//列数 加一再向下取余
                        int temp = matrix[i][j];
                        matrix[i][j] = matrix[n - j - 1][i];
                        matrix[n - j - 1][i] = matrix[n - i - 1][n - j - 1];
                        matrix[n - i - 1][n - j - 1] = matrix[j][n - i - 1];
                        matrix[j][n - i - 1] = temp;
                    &#125;
                &#125;
            &#125;
        &#125;
```

最终解法  将旋转分解为水平翻转和主对角线翻转(因为这俩翻转都是俩俩交换 直接temp换就完事儿，而旋转是4个元素在换)

```java
class Solution &#123;
    public void rotate(int[][] matrix) &#123;
        int n = matrix.length;
        // 水平翻转
        for (int i = 0; i < n / 2; ++i) &#123;
            for (int j = 0; j < n; ++j) &#123;
                int temp = matrix[i][j];
                matrix[i][j] = matrix[n - i - 1][j];
                matrix[n - i - 1][j] = temp;
            &#125;
        &#125;
        // 主对角线翻转
        for (int i = 0; i < n; ++i) &#123;
            for (int j = 0; j < i; ++j) &#123;
                int temp = matrix[i][j];
                matrix[i][j] = matrix[j][i];
                matrix[j][i] = temp;
            &#125;
        &#125;
    &#125;
&#125;

```

# 二分

部分有序也可以二分

## 模板

1、记录答案法（推荐这个）：

要保证左右断点都能取到

~~~java
while (l<=r) &#123; int mid="l+(r-l)/2;" if (check(mid)) r="mid-1;" &#125; else l="mid+1;" reurn的时候要注意，现在的l是多的一个 ~~~ 2、不记录法 ```java bool check(int x) * ... 检查x是否满足某种性质 寻找满足条件的左边界 bsearch_1(int l, r) while (l < +>> 1;
        //对应l+(r-l)/2
        if (check(mid)) r = mid;    // check()判断mid是否满足性质
        else l = mid + 1;
    &#125;
    return l;
&#125;
// 寻找满足条件的右边界(222完全二叉树的节点个数的题解就是这个思路)   
int bsearch_2(int l, int r)
&#123;
    while (l < r)
    &#123;
        //对应l+(r-l+1)/2
        int mid = l + r + 1 >> 1;
        if (check(mid)) l = mid;
        else r = mid - 1;
    &#125;
    return l;
&#125;
//要记住  满足条件，需要保留的就mid，不满足条件就是mid+1 mid-1
```

## 旋转数组

将数组一分为二，其中一定有一个是有序的，另一个可能是有序，也能是部分有序。
此时有序部分用二分法查找。无序部分再一分为二，其中一个一定有序，另一个可能有序，可能无序。就这样循环. 

## 二分查找

给定一个 `n` 个元素有序的（升序）整型数组 `nums` 和一个目标值 `target`  ，写一个函数搜索 `nums` 中的 `target`，如果目标值存在返回下标，否则返回 `-1`。

```java
class Solution &#123;
    public int search(int[] nums, int target) &#123;
        int left=0,right=nums.length-1;
        while(left<=right)&#123; 取下标中点>>1表示除以2
            int mid=(left+right)>>1;
            if(nums[mid]==target)&#123;
                return mid;
            &#125;else if(nums[mid]<target)&#123; left="mid+1;" &#125;else&#123; right="mid-1;" &#125; return -1; ``` # 任务调度器 ## 方法一：模拟 &#123;% asset_img image-20221012192843953.png image-20221012192843953 %&#125; image-20221012192916861.png image-20221012192916861 此处对于”我们应当选择剩余执行次数最多的那个任务“的证明忽略 ```java class solution &#123; public int leastinterval(char[] tasks, n) map<character, integer> freq = new HashMap<Character, integer>();
              for (char ch : tasks) &#123;
                  freq.put(ch, freq.getOrDefault(ch, 0) + 1);
              &#125;

              // 任务总数
              int m = freq.size();
              //最早有效时间
              List<Integer> nextValid = new ArrayList<Integer>();
              List<Integer> rest = new ArrayList<Integer>();
              Set<Map.Entry<Character, integer>> entrySet = freq.entrySet();
              for (Map.Entry<Character, integer> entry : entrySet) &#123;
                  int value = entry.getValue();
                  //初始为1
                  nextValid.add(1);
                  rest.add(value);
              &#125;

              int time = 0;
              for (int i = 0; i < tasks.length; ++i) &#123;
                  ++time;
//                  将 time更新为所有nextValid中的最小值，直接「跳过」待命状态  最小值代表最早有效时间，前面肯定是冷却时间
                  int minNextValid = Integer.MAX_VALUE;
                  for (int j = 0; j < m; ++j) &#123;
                      //剩余任务不为0时
                      if (rest.get(j) != 0) &#123;
                          minNextValid = Math.min(minNextValid, nextValid.get(j));
                      &#125;
                  &#125;
                  time = Math.max(time, minNextValid);
                  //寻找不在冷却中的，剩余执行次数最多的任务
                  int best = -1;
                  for (int j = 0; j < m; ++j) &#123;
                      if (rest.get(j) != 0 && nextValid.get(j) <= time) &#123; if (best="=" -1 || rest.get(j)> rest.get(best)) &#123;
                              best = j;
                          &#125;
                      &#125;
                  &#125;
                  //赋值z
                  nextValid.set(best, time + n + 1);
                  rest.set(best, rest.get(best) - 1);
              &#125;

              return time;
          &#125;
      &#125;
```

方法一代码量太多 不想写

## 方法二：构造

构造n+1列矩阵，每个格子代表一个时间，行优先，也就是先第一行再第二行，记需要执行maxExec次(任务数最多的任务的数量)任务数量为maxCount,如图，maxExec就是5，maxCount为3，因此总时间为(maxExec−1)(n+1)+maxCount

&#123;% asset_img image-20221012195808588.png image-20221012195808588 %&#125;



对于小于maxExec的任务如下图：

&#123;% asset_img image-20221012200212774.png image-20221012200212774 %&#125;



&#123;% asset_img image-20221012200347122.png image-20221012200347122 %&#125;

&#123;% asset_img image-20221012200357248.png image-20221012200357248 %&#125;

```JAVA
class Solution &#123;
    public int leastInterval(char[] tasks, int n) &#123;
        Map<Character, integer> freq = new HashMap<Character, integer>();
        // 最多的执行次数
        int maxExec = 0;
        for (char ch : tasks) &#123;
            int exec = freq.getOrDefault(ch, 0) + 1;
            freq.put(ch, exec);
            maxExec = Math.max(maxExec, exec);
        &#125;

        // 具有最多执行次数的任务数量
        int maxCount = 0;
        //这一句可以不要
        //Set<Map.Entry<Character, integer>> entrySet = freq.entrySet();
        for (Map.Entry<Character, integer> entry : entrySet) &#123;
            int value = entry.getValue();
            if (value == maxExec) &#123;
                ++maxCount;
            &#125;
        &#125;

        return Math.max((maxExec - 1) * (n + 1) + maxCount, tasks.length);
    &#125;
&#125;
```

# 双指针

反过来就会报错 必须保证先不出界才能继续后面条件判断双指针

这个方法就是我们常说的「双指针」，当我们需要枚举数组中的两个元素时，如果我们发现随着第一个元素的递增，第二个元素是递减的，那么就可以使用双指针的方法，

**将给定数字序列重新排列成字典序中下一个更大的排列。**

&#123;% asset_img 31.gif https://assets.leetcode-cn.com/solution-static/31/31.gif %&#125;

## 四数之和

与三数之和类似，使用两重循环分别枚举前两个数，然后在两重循环枚举到的数之后使用双指针枚举剩下的两个数。

- 每一种循环枚举到的下标必须大于上一重循环枚举到的下标；

- 同一重循环中，如果当前元素与上一个元素相同，则跳过当前元素。

  剪枝操作：

<img src="/.xyz//image-20221018194452672.png" alt="image-20221018194452672" style="zoom:80%;">

```java
按照三数之和写
class Solution &#123;
    public List<List<Integer>> fourSum(int[] nums, int target) &#123;
        Arrays.sort(nums);
        List<List<Integer>> ans=new ArrayList<>();
        int n=nums.length;
        for(int i=0;i<n-3;i++)&#123; 严格来说前面这个条件break，后面continue if((long) nums[i]+nums[i+1]+nums[i+2]+nums[i+3]>target||(long) nums[i]+nums[n-1]+nums[n-2]+nums[n-3]<target) continue; if(i>0&&nums[i]==nums[i-1]) continue;
            for(int j=i+1;j<n-2;j++)&#123; 严格来说前面这个条件break，后面continue if((long) nums[i]+nums[j]+nums[j+1]+nums[j+2]>target||(long) nums[i]+nums[j]+nums[n-1]+nums[n-2]<target) continue; if(j>i+1&&nums[j]==nums[j-1]) continue;
                int k=j+1,l=n-1;
                while(k<l)&#123; long sum="(long)" nums[i]+nums[j]+nums[k]+nums[l]; if(sum>target)&#123;
                        while(k<l&&nums[l]==nums[--l]); 0 &#125;else if(sum<target)&#123; while(k<l&&nums[k]="=nums[++k]);" &#125;else&#123; ans.add(arrays.aslist(nums[i],nums[j],nums[k],nums[l])); while(k<l&&nums[l]="=nums[--l]);" &#125; return ans; ``` &#123;% asset_img image-20221018204117697.png image-20221018204117697 %&#125; 遇到这种情况，是因为溢出了，强转为 long即可，int存不下这么大数字 ## 三数之和 给你一个整数数组 nums ，判断是否存在三元组 [nums[i], nums[j], nums[k]] 满足 i !="j、i" 且 j ，同时还满足 nums[i] + nums[j] nums[k]="=" 。请 你返回所有和为 且不重复的三元组。注意：答案中不可以包含重复的三元组。 双指针： <img src="力扣.assets/image-20221017211410717.png" alt="image-20221017211410717" style="zoom:80%;">

```java
//感觉k神比官方题解好一点
class Solution &#123;
    public List<List<Integer>> threeSum(int[] nums) &#123;
        //排序 递增排列
        Arrays.sort(nums);
        List<List<Integer>> res = new ArrayList<>();
        for(int k = 0; k < nums.length - 2; k++)&#123;
            //三个大于0的不可能满足 直接结束所有循环
            if(nums[k] > 0) break;
            //从第二个开始
            if(k > 0 && nums[k] == nums[k - 1]) continue;
            int i = k + 1, j = nums.length - 1;
            while(i < j)&#123;
                int sum = nums[k] + nums[i] + nums[j];
                //小于0 左指针移动到和上一个元素不同的数字上面
                //大于0 右指针移动到和上一个元素不同的数字上面
                //等于0 左右指针移动到和上一个元素不同的数字上面
                if(sum < 0)&#123;
                    while(i < j && nums[i] == nums[++i]);
                &#125; else if (sum > 0) &#123;
                    while(i < j && nums[j] == nums[--j]);
                &#125; else &#123;
                    res.add(new ArrayList<Integer>(Arrays.asList(nums[k], nums[i], nums[j])));
                    while(i < j && nums[i] == nums[++i]);	
                    while(i < j && nums[j] == nums[--j]);
                &#125;
            &#125;
        &#125;
        return res;
    &#125;
&#125;
```



## 27 移除元素

给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。  元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。

<img src="/.xyz//image-20221012161829652.png" alt="image-20221012161829652" style="zoom:80%;">

~~~java
class Solution &#123;
    public int removeElement(int[] nums, int val) &#123;
        int left=0,right=nums.length-1;
        while(left<=right)&#123; if(nums[left]="=val)&#123;" nums[left]="nums[right];" right--; &#125;else&#123; left++; &#125; return left; ~~~ ## 977. 有序数组的平方 给你一个按 **非递减顺序** 排序的整数数组 `nums`，返回 **每个数字的平方** 组成的新数组，要求也按 排序。 方法一：原地平方加sort 但nlogn 方法二：双指针 使用两个指针分别指向位置 0和 n−1，每次比较两个指针对应的数，选择较大的那个**逆序**放入答案并移动指针。 ```java class solution &#123; public int[] sortedsquares(int[] nums) int n="nums.length;" ans="new" int[n]; 注意i <="j;后面有分号" for (int i="0," j="n" - 1, pos="n" 1; if (nums[i] * nums[i]> nums[j] * nums[j]) &#123;
                ans[pos] = nums[i] * nums[i];
                ++i;
            &#125; else &#123;
                ans[pos] = nums[j] * nums[j];
                --j;
            &#125;
            --pos;
        &#125;
        return ans;
    &#125;
&#125;
```

## 209.长度最小的子数组（滑动窗口）

所以，滑动窗口也算是双指针的一个类吧

题目：

给定一个含有 n 个正整数的数组和一个正整数 target 。

找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 [numsl, numsl+1, ..., numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。

&#123;% asset_img image-20221012224459033.png 、 %&#125;



&#123;% asset_img 209.%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84.gif 209.长度最小的子数组 %&#125;

~~~java
class Solution &#123;
    public int minSubArrayLen(int s, int[] nums) &#123;
        int n = nums.length;
        //这个判断条件不写也可以通过
        if (n == 0) &#123;
            return 0;
        &#125;
        int ans = Integer.MAX_VALUE;
        int start = 0, end = 0;
        int sum = 0;
        while (end < n) &#123;
            sum += nums[end];
            while (sum >= s) &#123;
                ans = Math.min(ans, end - start + 1);
                sum -= nums[start];
                start++;
            &#125;
            end++;
        &#125;
        return ans == Integer.MAX_VALUE ? 0 : ans;
    &#125;
&#125;
~~~



# 小技巧

## 快捷键

```
~~~java就用这个来创建代码块
```

**一些变量符号**

表示数量的话用cnt

flag表示标志，一般为正负

**IDEA插件LeetEditor** 

出现cookie问题 怎么办？在idea进行插件更新！这是没想到的！

```
class Solution &#123;
    public boolean exist(char[][] board, String word) &#123;
        int h = board.length, w = board[0].length;
        boolean[][] visited = new boolean[h][w];
        for (int i = 0; i < h; i++) &#123;//遍历每个格子看以其开头是否可行
            for (int j = 0; j < w; j++) &#123;
                boolean flag = check(board, visited, i, j, word, 0);
                if (flag) &#123;
                    return true;
                &#125;
            &#125;
        &#125;
        return false;//都不行的话才返回false
    &#125;
```



    public boolean check(char[][] board, boolean[][] visited, int i, int j, String s, int k) &#123;
        if (board[i][j] != s.charAt(k)) &#123;
            return false;
        &#125; else if (k == s.length() - 1) &#123;
            return true;
        &#125;
        visited[i][j] = true;
        int[][] directions = &#123;&#123;0, 1&#125;, &#123;0, -1&#125;, &#123;1, 0&#125;, &#123;-1, 0&#125;&#125;;
        boolean result = false;
        for (int[] dir : directions) &#123;//做选择
            int newi = i + dir[0], newj = j + dir[1];
            if (newi &gt;= 0 &amp;&amp; newi &lt; board.length &amp;&amp; newj &gt;= 0 &amp;&amp; newj &lt; board[0].length) &#123;
                if (!visited[newi][newj]) &#123;//看是否被用过
                    boolean flag = check(board, visited, newi, newj, s, k + 1);回溯 此时是在board[i][j]=s.charAt(k)的基础上，因此k+1;
                    if (flag) &#123;
                        result = true;
                        break;//只要有一条路径可行 直接跳过for循环 返回true
                    &#125;
                &#125;
            &#125;
        &#125;
        visited[i][j] = false;//每一格判断完是否是可行的之后需要将其置为false，因为其他格子也要用到该格子作为路径
        return result; 返回结果
    &#125;
&#125;

**求最值**

求最大值就int maxSum = Integer.MIN_VALUE;

反之亦然

# 位运算

## 前言

x&gt;&gt;y    =》   x➗2^y   右移

x&gt;&gt;y    =》   x × 2^y   左移  =====这个地方可以用来做2的幂次运算  比如  1&gt;&gt;x就是 求  2^x的值

## 比特位计数

给你一个整数 `n` ，对于 `0 &lt;= i &lt;= n` 中的每个 `i` ，计算其二进制表示中 **`1` 的个数** ，返回一个长度为 `n + 1` 的数组 `ans` 作为答案。

前沿知识：

1、Brian Kernighan 算法原理：对于任意整数 x，令 x=x &amp; (x−1)，该运算将 x 的二进制表示的最后一个 1  变成 0

2、如果正整数 y是 2 的整数次幂，则 y的二进制表示中只有最高位是 1，其余都是 0，因此 y &amp; (y−1)=0 ；

3、对于正整数 x，将其二进制表示右移一位，等价于将其二进制表示的最低位去掉，得到的数是 ⌊x➗2⌋

**方法四：动态规划——最低设置位**

直接用第一条知识

&#123;% asset_img image-20220930205258719.png image-20220930205258719 %&#125;

```java
class Solution &#123;
    public int[] countBits(int n) &#123;
        int[] bits = new int[n + 1];
        for (int i = 1; i &lt;= n; i++) &#123;
            bits[i] = bits[i &amp; (i - 1)] + 1;
        &#125;
        return bits;
    &#125;
&#125;
</=right)&#123;></Integer></List<Integer></List<Integer></l&&nums[l]==nums[--l]);></l)&#123;></target)></n-2;j++)&#123;></target)></n-3;i++)&#123;></List<Integer></List<Integer></Character,></Map.Entry<Character,></Character,></Character,></=></Character,></Map.Entry<Character,></Integer></Integer></Integer></Integer></Character,></target)&#123;></=right)&#123;></=r)></code></pre>
<h2 id="只出现一次数字"><a href="#只出现一次数字" class="headerlink" title="只出现一次数字"></a>只出现一次数字</h2><p>题目：给定一个<strong>非空</strong>整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p>


<p>答案：</p>


<p><strong>总结：异或运算：不同为1 相同为0</strong></p>
<p> Leetcode报错 error：＜identifier＞ expected：<br>原因是在定义<strong>方法</strong>的时候，在方法参数列表没有声明参数的类型，或者是方法参数列表写错，比如我就犯了如下错误：</p>
<pre><code>public boolean check(char[][] board, boolean[][] visited, int i, int, j, String s, int k)
</code></pre>
<p>自己一直没发现，而且Idea的比较文件也没有发现，idea比较文件方法，选中两个文件，右键compare files （ctrl+D）</p>
<p><img src="/.xyz//.assets%5Cimage-20220608185515191.png" alt="image-20220608185515191"></p>
<h1 id="Leetcode插件"><a href="#Leetcode插件" class="headerlink" title="Leetcode插件"></a>Leetcode插件</h1><p>因为我已经在一台电脑上配置好了，因此在新电脑上面只需要在idea安装leetcode editor，输入用户名密码保存路径和格式设置（可直接远程操作原电脑进行复制操作）</p>
<p><a href="mailto:&#x35;&#48;&#x35;&#51;&#55;&#x31;&#53;&#51;&#48;&#64;&#x71;&#113;&#x2e;&#99;&#111;&#109;">&#x35;&#48;&#x35;&#51;&#55;&#x31;&#53;&#51;&#48;&#64;&#x71;&#113;&#x2e;&#99;&#111;&#109;</a>   4873350781cet</p>
<pre><code>$&#123;question.content&#125;
  package leetcode.editor.en;
  public class $!velocityTool.camelCaseName($&#123;question.titleSlug&#125;)&#123;
      public static void main(String[] args) &#123;
           Solution solution = new $!velocityTool.camelCaseName($&#123;question.titleSlug&#125;)().new Solution();
      &#125;
      $&#123;question.code&#125;
  &#125;
</code></pre>
<pre><code>$&#123;question.title&#125;	题目标题	示例:两数之和
$&#123;question.titleSlug&#125;	题目标记	示例:two-sum
$&#123;question.frontendQuestionId&#125;	题目编号
$&#123;question.content&#125;	题目描述
$&#123;question.code&#125;	题目代码
$!velocityTool.camelCaseName(str)	转换字符为大驼峰样式（开头字母大写）
$!velocityTool.smallCamelCaseName(str)	转换字符为小驼峰样式（开头字母小写）
$!velocityTool.snakeCaseName(str)	转换字符为蛇形样式
$!velocityTool.leftPadZeros(str,n)	在字符串的左边填充0，使字符串的长度至少为n
$!velocityTool.date()	获取当前时间
</code></pre>
<img src="/.xyz//image-20220706213501965.png" alt="image-20220706213501965" style="zoom: 67%;">

<p>记得勾选画框处，Custom Templete ,如果有的题模板不对的话，右键clear cache</p>

  </div>
  <div id="gitalk-container"></div>
</div>

<script>
  
Fancybox.bind('[data-fancybox="fancybox-gallery-img"]', {
  dragToClose: true,
  Toolbar: true,
  closeButton: "top",
  Image: {
    zoom: true,
  },
  on: {
    initCarousel: (fancybox) => {
      const slide = fancybox.Carousel.slides[fancybox.Carousel.page];
      fancybox.$container.style.setProperty(
        "--bg-image",
        `url("${slide.$thumb.src}")`
      );
    },
    "Carousel.change": (fancybox, carousel, to, from) => {
      const slide = carousel.slides[to];
      fancybox.$container.style.setProperty(
        "--bg-image",
        `url("${slide.$thumb.src}")`
      );
    },
  },
});
</script>

<style>
    #noneimg img {
        display: none;
        z-index: 9999;
        /* width: 600px !important; */
        min-width: 0%;
        max-width: 90%;
        max-height: 80%;
        border-radius: 0px;
        position: fixed;
        box-shadow: 0 0 0px #c3c3c300 !important;
        left: 0;
        top: 0;
        right: 0;
        bottom: 0;
        margin: auto !important;
    }

    @media screen and (max-width:600px) {
        #noneimg img {
            max-width: 88%
        }
    }
</style>

    <div class="post-paging">
    
    <a href="/2022/11/09/%E9%AD%94%E6%96%B9%E6%8A%80%E5%B7%A7/">
        <div class="post-paging-last">
            <span>上一篇</span>
            <p>魔方</p>
        </div>
    </a>
    

    
    <a href="/2022/06/18/llb%E6%AF%95%E8%AE%BE/">
        <div class="post-paging-next">
            <span>下一篇</span>
            <p>llb毕设</p>
        </div>
    </a>
    
</div>
</div>
		
<div class="footer">
	<div class="Copyright">
		©2023 By weiyang. 主题：<a
			style="text-decoration: none;display: contents; color: #898F9F;"
			href="https://github.com/qiaobug/hexo-theme-quiet">Quiet</a>
	</div>
	<div class="contact">
		
		<a href="https://github.com/viacheung">
			<img src="https://cdn.jsdelivr.net/gh/duogongneng/MyBlogImg/imggithub.png" alt="Quiet主题">
		</a>
		
		<a href="https://blog.csdn.net/qq_47897934?spm=1000.2115.3001.5343">
			<img src="https://bce.bdstatic.com/portal/img/customer/case/csdn/logo_c76b3044.png" alt="Quiet主题">
		</a>
		
		<a href="https://www.zhihu.com/people/qi-yi-shao-nu-de-meng-29-3">
			<img src="https://photo.16pic.com/00/56/07/16pic_5607016_b.jpg" alt="Quiet主题">
		</a>
		
	</div>
</div>

<script src="/js/gotop.js"></script>


<style type="text/css">
    @media screen and (min-width: 600px) {
        .goTop>span {
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 10px;
            width: 40px;
            height: 40px;
            cursor: pointer;
            opacity: 0.8;
            background: rgba(18, 24, 58, 0.06);
            text-align: center;
            transition: border .5s;
            border: 1px solid rgba(18, 24, 58, 0.06);

            -moz-transition: border .5s;
            /* Firefox 4 */
            -webkit-transition: border .5s;
            /* Safari 和 Chrome */
            -o-transition: border .5s;
            /* Opera */
        }

        .goTop>span:hover {
            border: 1px solid #6680B3;
        }


        .goTop {
            position: fixed;
            right: 30px;
            bottom: 80px;
        }

        .goTop>span>svg {
            width: 20px;
            height: 20px;
            opacity: 0.7;
        }

    }

    @media screen and (max-width: 600px) {
        .goTop {
            display: none;
        }
    }
</style>
<div class="goTop" id="js-go_top">
    <span>
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
            <g>
                <path d="M13 12v8h-2v-8H4l8-8 8 8z"></path>
            </g>
        </svg>
    </span>
</div>
<script>
    $( '#js-go_top' )
	.gotoTop( {
		offset: 500,
		speed: 300,
		animationShow: {
			'transform': 'translate(0,0)',
			'transition': 'transform .5s ease-in-out'
		},
		animationHide: {
			'transform': 'translate(100px,0)',
			'transition': 'transform .5s ease-in-out'
		}
	} );
</script>


    <!-- Gitalk -->
    <script>
        const data = '{"clientID":"7ef512ed947db5786473","clientSecret":"0b2bdd54512e9742d7bc75efaf3273869742bee1","repo":"https://github.com/viacheung/blog_commets","owner":"viacheung","admin":"viacheung"}'
        const gitalk = new Gitalk({
            ...JSON.parse( data),
            id:location.pathname,
            distractionFreeMode:false
        })
        gitalk.render('gitalk-container')
    </script>

<script>
	console.log('\n %c Hexo-Quiet 主题 %c https://github.com/QiaoBug/hexo-theme-quiet \n', 'color: #fadfa3; background: #030307; padding:5px 0;', 'background: #fadfa3; padding:5px 0;')
</script>
	</body>
</html>


<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.1.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"viacheung.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="el psy congroo">
<meta property="og:type" content="website">
<meta property="og:title" content="命运石之门">
<meta property="og:url" content="http://viacheung.github.io/page/2/index.html">
<meta property="og:site_name" content="命运石之门">
<meta property="og:description" content="el psy congroo">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="ViaCheung">
<meta property="article:tag" content="Java,python">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://viacheung.github.io/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>命运石之门</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">命运石之门</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">欢迎来到我的博客空间🙇</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-schedule">

    <a href="/schedule/" rel="section"><i class="fa fa-calendar fa-fw"></i>日程表</a>

  </li>
        <li class="menu-item menu-item-sitemap">

    <a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>站点地图</a>

  </li>
        <li class="menu-item menu-item-commonweal">

    <a href="/404/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>公益 404</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/viacheung" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://viacheung.github.io/2023/06/04/%E6%B5%8B%E5%BC%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="ViaCheung">
      <meta itemprop="description" content="el psy congroo">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="命运石之门">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/06/04/%E6%B5%8B%E5%BC%80/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
	  <span class="post-time">

	  
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-06-04 01:04:27 / 修改时间：01:04:28" itemprop="dateCreated datePublished" datetime="2023-06-04T01:04:27+08:00">2023-06-04</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="1-测试开发本质"><a href="#1-测试开发本质" class="headerlink" title="1.测试开发本质"></a>1.测试开发本质</h3><p>测试开发的本质是助力业务成功</p>
<h3 id="2-软件测试存在的意义"><a href="#2-软件测试存在的意义" class="headerlink" title="2.软件测试存在的意义"></a>2.软件测试存在的意义</h3><p>提前发现和定位错误。</p>
<blockquote>
<p>提前发现和定位错误之后呢？</p>
</blockquote>
<p>可以促进开发人员修正错误，从而保证交付的软件质量满足客户需求。</p>
<blockquote>
<p>提前发现和定位错误的重要性？</p>
</blockquote>
<p>越早发现软件中存在的问题，开发费用就越低，软件质量越高，维护费用越低。</p>
<p>提前测试可以使得在需求分析时期就可发现的错误，不必等到开发完成后才被发现</p>
<h3 id="3-高频-测试开发与测试的区别？"><a href="#3-高频-测试开发与测试的区别？" class="headerlink" title="3.(高频)测试开发与测试的区别？"></a>3.(高频)测试开发与测试的区别？</h3><blockquote>
<p>软件测试是什么</p>
</blockquote>
<p>在规定的条件下对一个产品或者程序进行操作，以发现<strong>程序错误</strong>，<strong>衡量软件质量</strong>，并对其是<strong>否能满足设计要求</strong>进行评估的过程。</p>
<blockquote>
<p>软件测试工程师的任务</p>
</blockquote>
<p>软件测试工程师主要工作是检查软件<strong>是否有bug</strong>、是否具<strong>有稳定性</strong>，</p>
<p>写出相应的<strong>测试计划、测试规范、测试用例、测试数据、测试报告</strong>，</p>
<p>在项目中担任类似“质量管理的角色”，及时纠错及时更正，<strong>确保产品的正常运转</strong>。</p>
<blockquote>
<p>测试开发工程师的任务</p>
</blockquote>
<p>测试开发的核心职能依然是测试。</p>
<p>只是工程师在具备测试经验、熟练使用测试工具并有一定开发能力的前提下，可以<strong>自主开发平台，</strong>或对现有的开源工具进行二次开发</p>
<p>最<strong>终目的是提升产品的测试效率</strong>。</p>
<blockquote>
<p>测试开发与开发的联系</p>
</blockquote>
<p>测试开发是测试岗位衍生的一个分支，利用开发能力解决测试工作中的问题，</p>
<p>小到生成数据、并发模拟等工具的开发，大到整个自动化测试平台的设计与实现，</p>
<p>旨在提高效率，降低成本。</p>
<h3 id="4-高频-为什么选择测试开发？"><a href="#4-高频-为什么选择测试开发？" class="headerlink" title="4.(高频)为什么选择测试开发？"></a>4.(高频)为什么选择测试开发？</h3><p>【岗位角度来说】</p>
<p>从用户角度来说，现在的软件产品种类多样，已经可以满足用户大部分的基本需求了，对于同类产品，用户会更加关注产品的<strong>质量和服务</strong>，所以测试的发展前景是非常好的</p>
<p>在产品研发中，提前发现和定位问题，对整个产品和质量和公司的成本都是非常重要的，测试人员的责任非常大。是非常重要的一个岗位</p>
<p>【自己角度来说】(你的经历都是开发为什么会想到做测试？)</p>
<p><strong>测开还有一部分开发工作，</strong>无论是自动化脚本还是测试工具或框架，都提高了测试的效率，为质量效率保证工作提供了有力的保障。</p>
<p><strong>所以测开的所需技术广度也是很高，会激发我持续学习的态度。</strong></p>
<p>并且来说，我目前<strong>具备了一些测开所必备的理论知识和技能并且还在不断地学习中，我认为我可以较快的胜任这个岗位</strong></p>
<h3 id="5-中频-测试开发需要哪些知识和能力？"><a href="#5-中频-测试开发需要哪些知识和能力？" class="headerlink" title="5.(中频)测试开发需要哪些知识和能力？"></a>5.(中频)测试开发需要哪些知识和能力？</h3><p><strong>需要的知识：</strong></p>
<p>软件测试基础理论知识，如黑盒测试、白盒测试等</p>
<p>编程语言基础，如C&#x2F;C ++、java、python等</p>
<p>自动化测试工具，如Selenium、Appium、Robotium等</p>
<p>计算机基础知识，如数据库、Linux、计算机网络等</p>
<p>测试框架，如JUnit等</p>
<p><strong>需要具备的能力：</strong></p>
<blockquote>
<p>测试能力</p>
</blockquote>
<p>业务分析能力，分析被测系统<strong>架构</strong>、分析被测业务<strong>模块</strong>、分析整体业务<strong>流程</strong>、分析被测业务<strong>数据</strong>、分析测试所需资源、分析测试<strong>完成目标</strong>；</p>
<p>缺陷洞察能力，<strong>一般缺陷</strong>的发现能力、<strong>隐形问题</strong>的发现能力、<strong>发现连带问题</strong>的能力、<strong>发现问题隐患</strong>的能力、<strong>尽早</strong>发现问题的能力、发现问题<strong>根源</strong>的能力</p>
<p>宏观把控能力，有效制定测试<strong>计划</strong>、有效进行<strong>风险评估</strong>、有效控制测试<strong>时间</strong>、有效控制测试<strong>成本</strong>、有效控制<strong>测试方向。</strong></p>
<blockquote>
<p>个人能力</p>
</blockquote>
<p>专业技术能力，掌握测试基础知识、掌握计算机知识、熟练运用测试工具；</p>
<p>逻辑思考能力，判断逻辑的正确性、对可行性逻辑分析、站在客观角度思考</p>
<p>问题解决能力，技术上的问题、工作中的问题、沟通问题</p>
<blockquote>
<p>和团队</p>
</blockquote>
<p>沟通表达能力，和技术人员、产品人员、上下级的沟通</p>
<p>团队协作能力，合理进行人员分工、协助组原解决问题、配合完成测试任务、配合开发重现缺陷、督促项目整体进度、出现问题勇于承担</p>
<h3 id="6-软件测试的核心竞争力？"><a href="#6-软件测试的核心竞争力？" class="headerlink" title="6.软件测试的核心竞争力？"></a>6.软件测试的核心竞争力？</h3><p>测试人员的核心竞争力在于提早发现问题，并能够发现别人无法发现的问题。</p>
<p>1.<strong>早发现问题</strong>：问题发现的越早，解决的成本越低。如果一个需求在还未实现的时候就能发现需求的漏洞，那么这种问题的价值是最高的</p>
<p>2**.发现别人发现不了的问题**：所有人都能发现的问题，你发现了，那就证明你是可以被替代的。别人发现不了，而你可以发现，那么你就是无法被替代的</p>
<h3 id="7-测试和开发如何结合才能使软件质量得到更好保障？"><a href="#7-测试和开发如何结合才能使软件质量得到更好保障？" class="headerlink" title="7.测试和开发如何结合才能使软件质量得到更好保障？"></a>7.测试和开发如何结合才能使软件质量得到更好保障？</h3><p>测试和开发应该按照W模型的方式进行结合，测试和开发同步进行，能够尽早发现软件缺陷，降低软件开发的成本。</p>
<p><img src="https://pic3.zhimg.com/80/v2-cc8c88211b354ee21e531a93d5f05466_720w.webp#alt=img"></p>
<blockquote>
<p>什么是w模型</p>
</blockquote>
<p>测试伴随着整个软件开发周期，而且测试的对象不仅仅是程序，需求、设计等同样要测试，也就是说，测试与开发是同步进行的。</p>
<blockquote>
<p>w模型的优点</p>
</blockquote>
<p>W模型有利于尽早地全面的发现问题。例如，需求分析完成后，测试人员就应该参与到对需求的验证和确认活动中，以尽早地找出缺陷所在。同时，对需求的测试也有利于及时了解项目难度和测试风险，及早制定应对措施，这将显著减少总体测试时间，加快项目进度。</p>
<blockquote>
<p>w模型的缺点</p>
</blockquote>
<p>但W模型也存在局限性。在W模型中，需求、设计、编码等活动被视为串行的，</p>
<p>测试和开发活动也保持着一种线性的前后关系，上一阶段完全结束，才可正式开始下一个阶段工作。</p>
<p>这样就无法支持<a href="https://link.zhihu.com/?target=https://baike.baidu.com/item/%E8%BF%AD%E4%BB%A3/8415523">迭代</a>的开发模型。对于当前软件开发复杂多变的情况，W模型并不能解除测试管理面临的困惑。</p>
<h3 id="8-怎么看待软件测试的潜力和挑战？"><a href="#8-怎么看待软件测试的潜力和挑战？" class="headerlink" title="8.怎么看待软件测试的潜力和挑战？"></a>8.怎么看待软件测试的潜力和挑战？</h3><p>软件测试是正在快速发展、充满挑战的领域。</p>
<p>尽管现在许多自动化测试软件的出现使得传统手工测试的方式被代替，但自动化测试工具的开发、安全测试、测试建模、精准测试、性能测试、可靠性测试等专项测试中仍然需要大量具有专业技能与专业素养的测试人员。</p>
<p>并且随着云计算、物联网、大数据的发展，传统的测试技术可能不再适用，测试人员也因此面临着挑战，需要深入了解新场景并针对不同场景尝试新的测试方法，同时敏捷测试、Devops的出现也显示了软件测试的潜力</p>
<h3 id="9-高频-一个完整的测试流程，要干什么？"><a href="#9-高频-一个完整的测试流程，要干什么？" class="headerlink" title="9.(高频)一个完整的测试流程，要干什么？"></a>9.(高频)一个完整的测试流程，要干什么？</h3><p>测试工作需要贯穿整个软件的生命周期</p>
<p><strong>需求分析阶段</strong></p>
<ul>
<li>测试人员会进行需求评审，对产品的功能进行整体把握，根据需求写用例</li>
</ul>
<p><strong>写测试计划</strong></p>
<ul>
<li>根据开发计划制定具体的测试时间计划</li>
</ul>
<p><strong>撰写测试用例：</strong></p>
<ul>
<li>根据详细的需求文档，进行用例的编写</li>
<li>使用思维导图列举测试大纲，尽量发散，想到什么就写什么。先放后收，对知识点进行总结和归纳，标记重点测试模块，删除冗余及重复测试点</li>
<li>可使用边界值法、等价类划分法、错误推测法、因果图法等设计案例</li>
<li>根据测试大纲制定测试用例，需包含模块名、测试优先级、操作步骤、期望结果、测试结果、备注</li>
</ul>
<p><strong>用例评审：</strong></p>
<ul>
<li>测试作为主导，联合开发、项目经理、PM进行测试用例评审</li>
<li>可先讲解测试大纲，让开发、项目经理对测试用例有个大概后再详细测试用例讲解</li>
</ul>
<p><strong>执行测试用例：</strong></p>
<ul>
<li>根据测试用例执行测试</li>
<li>发现问题保留现场，记录测试方法，通知开发解决问题</li>
<li>覆盖测试用例之外若有时间可进行探索性测试</li>
</ul>
<p><strong>缺陷报告编写及提交</strong></p>
<ul>
<li>将发现的缺陷编写成正式的缺陷报告，提交给开发人员进行缺陷的确认和修复</li>
</ul>
<p><strong>跟踪BUG修改情况</strong></p>
<p><strong>执行自动化测试，编写脚本，执行，分析，报告</strong></p>
<p><strong>进行性能测试，压力测试等其他测试，执行，分析，调优，报告</strong></p>
<h3 id="10-一条缺陷都记录哪些内容"><a href="#10-一条缺陷都记录哪些内容" class="headerlink" title="10.一条缺陷都记录哪些内容"></a>10.一条缺陷都记录哪些内容</h3><p>缺陷内容包括：缺陷的标题、缺陷类型、详细步骤、期望结果、缺陷等级、优先级、截图、日志信息等。</p>
<p>怎样提交一个高质量的缺陷：</p>
<p>1）缺陷的标题尽量简单、明确、完整</p>
<p>2）尽量使用惯用的表达术语和表达方法，保证表达准确专业</p>
<p>3）一个缺陷报告只包括一个缺陷，复现步骤描述清楚</p>
<p>4）是UI问题的话，尽量配上截图标注好有问题的地方；功能问题，尽量配上视频；闪退一类的Bug配上Log日志等</p>
<p>5）一些特殊数据出现的bug,需要备注好数据信息</p>
<p>6）一些非必现的问题，多测试几遍，然后备注清楚bug的复现率</p>
<p>7）兼容性问题需要备注好设备型号、操作系统及浏览器版本信息</p>
<p>8）缺陷尽量保证不重复提交</p>
<h2 id="二、测试基本流程和方法"><a href="#二、测试基本流程和方法" class="headerlink" title="二、测试基本流程和方法"></a>二、测试基本流程和方法</h2><h3 id="测试伴随着软件开发模型的演进"><a href="#测试伴随着软件开发模型的演进" class="headerlink" title="测试伴随着软件开发模型的演进"></a>测试伴随着软件开发模型的演进</h3><p>开发模型，从软件发展来看，比较典型的有瀑布模型，V模型和W模型以及敏捷开发模型。</p>
<p><strong>瀑布模型</strong></p>
<p>瀑布模型的主要<strong>特征</strong>在于项目完全按照阶段划分，只有前一阶段完成，才能开始下一阶段。</p>
<p>具体到<strong>测试活动</strong>，则只能在全部编码完成后、发布之前执行，</p>
<p>在这种开发模型中，测试活动被完全后置了，测试仅仅是编码后的一个活动阶段，测试的<strong>重要性</strong>没有被凸显出来</p>
<p><strong>V模型</strong></p>
<p><img src="https://raw.githubusercontent.com/viacheung/img/main/image/v2-160001540463468a4720448342d6705c_720w.webp#alt=img"></p>
<p>V模型不仅相对<strong>清晰地划分了测试活动的不同级别</strong>，还将其不同级别的测试活动与软件开发各阶段清晰地对应起来，强调了测试在整个开发过程中的重要性。</p>
<p>但在V模型中，<strong>测试依旧是编码之后才开始的，测试介入时间还是太晚。比如，需求分析阶段出现的问题，要等到系统测试阶段才能发现</strong></p>
<p><strong>W模型</strong></p>
<p><img src="https://pic4.zhimg.com/80/v2-40a8fa51c8939898b5217d6c6f78340f_720w.webp#alt=img"></p>
<p>为了弥补V模型的缺点，出现了W模型，把V模型左边的每一个活动都加了一个测试设计活动，尽早和不断地进行测试</p>
<p>W模型认为测试伴随着整个软件开发周期，而且测试的对象不仅仅是程序，需求、设计等同样要测试。</p>
<p><strong>优点：</strong>测试的活动与软件开发同步进行，而且测试的对象不仅仅是程序，还包括需求和设计。这样可以尽早发现软件缺陷可降低软件开发的成本</p>
<p><strong>缺点</strong>：开发和测试依然是线性的关系，需求的变更和调整，依然不方便，而且如果没有文档，根本无法执行W模型，使用W模型对于项目组成员的技术也很高。</p>
<p><strong>H模型</strong></p>
<p>相对于V模型和W模型，H模型将测试活动完全独立出来，形成了一个完全独立的流程，将测试准备活动和测试执行活动清晰地体现出来</p>
<p><img src="https://pic4.zhimg.com/80/v2-f685dee9b555f1bc5e46fa2eb44b35db_720w.webp#alt=img"></p>
<p>这个示意图仅仅演示了在整个生产周期中某个层次上的一次测试“微循环”。图中标注的其他流程可以是任意的开发流程，例如，设计流程或编码流程。只要测试条件成熟了，测试准备活动完成了，测试执行活动就可以进行了。</p>
<p>H模型中包含了如下概念：</p>
<ul>
<li>测试准备：所有测试活动的准备判断是否到测试就绪点</li>
<li>测试就绪点：测试准入准则，即是否可以开始执行测试的条件</li>
<li>测试执行：具体的执行测试的程序</li>
<li>其他流程：设计流程或编码流程</li>
</ul>
<p><strong>优点：</strong>让测试活动完全独立贯穿整个生命周期与其他流程并发进行。在H模型中，软件测试活动可以尽早准备尽早执行，具有很强的灵活性。而且软件测试可以根据被测对象的不同而分层次、分阶段、分次序的执行，同时也是可以被迭代的。</p>
<p><strong>缺点：</strong>对于管理要求很高，需要定义清晰的规则和管理制度，否则测试过程将很难管理和控制，而且对于技能要求也很高。因为H模型要求能够很好的定义每个迭代的规模，不能太大也不能太小。在H模型中，测试就绪点的分析也比较困难。因为测试过程中，并不知道测试准备到什么时候是合适的，就绪点在哪，就绪点标准是什么，这就对后续的测试执行启动带来很大的困难。</p>
<p><strong>敏捷模型</strong></p>
<p>按一个短的迭代周期工作，强调“快”，每次迭代交付一些成果（或者说先做出一个不完美但能实现一定的功能的版本）；让客户参与进来，有新需求就，快速响应变化，迭代产生新版本，缩短软件版本的周期。</p>
<p>强调软件开发软件而不是文档。</p>
<p>特点：让客户参与进来，客户需求的变动和软件有些不符合需求的地方可以第一时间进行了解和改动；缩短版本周期；每隔一段时间，团队可以在工作方面进行反省和改进，调整自己的行为</p>
<p>敏捷测试：</p>
<p>以用户需求为中心，在每一个迭代周期都需要进行测试</p>
<p>基于自动化测试-》速度快、敏捷</p>
<p>更强调测试的速度和适应性，侧重计划的不断调整以使用需求的变化</p>
<p>强调面对面的沟通、协作，强调团队的责任，不太关注对缺陷的记录与跟踪。<strong>缺陷修复的成本也比较低</strong></p>
<h3 id="1-测试的相关流程"><a href="#1-测试的相关流程" class="headerlink" title="1.测试的相关流程"></a>1.测试的相关流程</h3><p>需求测试-&gt;概要设计测试-&gt;详细设计测试-&gt;单元测试-&gt;集成测试-&gt;系统测试-&gt;验收测试</p>
<p><strong>1)单元测试(模块测试)：</strong></p>
<blockquote>
<p>什么是单元测试</p>
</blockquote>
<p>完成最小的软件设计单元(模块)的验证工作，目标是确保模块被正确的编码，对代码风格和规则、程序设计和结构、业务逻辑等进行静态测试，<strong>及早的发现</strong>和解决不易显现的错误</p>
<blockquote>
<p>单元测试方法</p>
</blockquote>
<p>通常情况下是<strong>白盒</strong>的，</p>
<blockquote>
<p>单元测试的依据</p>
</blockquote>
<p>代码、注释、详细设计文档LLD</p>
<blockquote>
<p>单元测试的测试重点：</p>
</blockquote>
<ul>
<li>模块接口：数据能否正确进出，检查参数的数目、次序、属性，全局变量的定义和用法在各个模块中是否一致</li>
<li>局部数据结构：局部数据说明、初始化、默认值等方面的错误</li>
<li>重要执行通路：选择具有<strong>代表性</strong>、最可能发现错误的执行通路进行测试</li>
<li>出错处理通路：应该能<strong>预见出错的条件</strong>，并且设置适当的处理错误的通路</li>
<li><strong>边界条件</strong>：对于刚好小于、等于、大于最大值或小于最小值的数据结构、控制量和数据值进行测试</li>
</ul>
<p><strong>2)集成测试：</strong></p>
<blockquote>
<p>什么是集成测试</p>
</blockquote>
<p>通过测试发现与模块接口有关的问题。目标是把通过了单元测试的模块拿来，构造一个在设计中所描述的程序结构。</p>
<blockquote>
<p>集成测试方法</p>
</blockquote>
<p>黑盒和白盒结合</p>
<blockquote>
<p>集成测试的依据</p>
</blockquote>
<p>单元测试模块、概要设计文档HLD</p>
<blockquote>
<p>集成测试的两种方法</p>
</blockquote>
<p>一种方法是先分别测试每个模块，再把所有模块设计要求放在一起<strong>组合</strong>成所要的程序，称为<strong>非渐增式测试方法</strong>；</p>
<p>另一种方法是要把下一个测试的模块同已经测试好的模块结合起来进行测试，称为<strong>渐增式测试</strong>。</p>
<p><strong>应当避免一次性的集成(除非软件规模很小)，而采用增量集成。</strong>非渐增式测试一下子把所有模块放在一起，情况复杂，会遇到很多错误，改正错误更是极端困难。</p>
<p>使用渐增式方法有<strong>自顶向下和自底向</strong>上两种集成策略</p>
<table>
<thead>
<tr>
<th>渐增式方法</th>
<th>概述</th>
<th>流程</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td>自顶向下集成</td>
<td>首先集成主模块，然后按照控制层次结构向下进行集成，隶属于主模块的模块按照深度优先或广度优先的方式集成到整个结构中去</td>
<td>1.对主控制模块进行测试，测试时用存根程序代替所有直接附属于主控制模块的模块2.根据选定的结合策略（DFS BFS）每次用一个实际模块代换一个存根程序3.在结合进一个模块的同时进行测试4.为了保证加入模块没有引进新的错误，可能需要进行回归测试（全部或部分重复以前做过的测试）5.直到构造起完整的软件结构</td>
<td>能够在测试早期对主要的控制或关键的抉择进行检验，在一个分解的好的软件结构中，关键抉择位于层次系统的较上层，因此首先碰到，早期认识主要控制里的问题是有好处的</td>
<td>实际使用会遇到逻辑上的问题。为了充分地测试软件系统的较高层次，需要在较低层次上的处理。然而存根程序代替了低层次的模块，没有重要的数据自下往上流，为了解决这个问题：把许多测试推迟到用真实模块代替了存根程序后再进行从层次系统的底部向上组装</td>
</tr>
<tr>
<td>自底向上集成</td>
<td>从原子模块开始来进行构造和测试</td>
<td>1.把底层模块组合成实现某个特定的软件子功能的族2.写一个驱动程序，协调测试数据的输入输出3.对由模块组成的子功能族进行测试4.去掉驱动程序，沿软件结构自下向上移动，把子功能族组合起来形成更大的子功能族</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p><strong>3)系统测试：</strong></p>
<blockquote>
<p>什么是系统测试</p>
</blockquote>
<p>系统测试是对已经集成好的软件系统进行彻底的测试，以验证软件系统的正确性和性能等是否满足其规约所指定的要求。</p>
<blockquote>
<p>系统测试方法</p>
</blockquote>
<p>黑盒测试</p>
<blockquote>
<p>系统测试依据</p>
</blockquote>
<p>需求测试文档SRS</p>
<blockquote>
<p>系统测试的种类</p>
</blockquote>
<p><strong>功能</strong>测试：对产品的各功能进行验证，以检查是否满足需求的要求</p>
<p><strong>性能</strong>测试：通过自动化测试工具模拟多种正常、峰值以及异常负载条件来对系统的各项性能指标进行测试</p>
<p><strong>安全</strong>测试：检查系统对非法入侵的防范能力</p>
<p><strong>兼容</strong>测试：测试系统在不同的软硬件环境下是否能够正常的运行</p>
<p><strong>4)回归测试：</strong></p>
<p>回归测试是指在发生修改之后重新测试先前的测试用例以保证修改的正确性。理论上，软件产生新版本，都需要进行回归测试，验证以前发现和修复的错误是否在新软件版本上再次出现</p>
<p><strong>5)验收测试：</strong></p>
<p>验收测试是部署软件之前的最后一个测试操作。目的是确保软件准备就绪，展示该系统满足用户的需求</p>
<p>测试方法：黑盒</p>
<p>验收测试包括Alpha测试和Beta测试</p>
<p>Alpaha测试：是由用户在开发者的场所来进行的，开发者对用户的指导下进行测试，开发者负责记录发现的错误和使用中的问题，<strong>内测版本</strong></p>
<p>Beta测试：由软件的最终用户在一个或多个用户场所来进行的，开发者通常不在现场，用户记录测试中遇到的问题并报告给开发者，开发者对系统进行最后的修改，并开始准备发布最终的软件，<strong>公测版本</strong></p>
<p><strong>那一步最重要</strong></p>
<p>这些测试步骤分别在软件开发的不同阶段对软件进行测试，我认为对软件完整功能进行测试的<strong>系统测试</strong>很重要，</p>
<p>因为此时单元测试和集成测试已经完成，能够对软件所有功能进行功能测试，能够覆盖系统所有联合的部件，是针对整个产品系统进行的测试，能够验证系统是否满足了需求规格的定义，因此我认为系统测试很重要。</p>
<p><strong>你觉得单元测试可行吗</strong></p>
<p>可行，单元测试可以有效地测试某个程序模块的行为，是未来重构代码的信心保证。</p>
<p>事前可以保证质量，事后可以快速复现问题，并在修改代码后做回归自测</p>
<p>可行性考虑的是要用一些可行的方法做到关键的代码可测试，如通过边界条件、等价类划分、错误、因果，设计测试用例要覆盖常用的输入组合、边界条件和异常。</p>
<p><strong>集成测试和系统测试的区别和应用场景</strong></p>
<p>1.<strong>计划和用例编制的先后顺序</strong>：从V模型来讲，在需求阶段就要制定系统测试计划和用例，HLD(概要设计)的时候做集成测试计划和用例，有些公司的具体实践不一样，但是顺序肯定是<strong>先做系统测试计划用例，再做集成</strong></p>
<p>2.<strong>用例的粒度</strong>：系统测试用例相对很接近用户接受测试用例，<strong>集成测试用例比系统测试用例更详细</strong>，而且对于接口部分要重点写，毕竟要集成各个模块或者子系统</p>
<p><strong>集成测试：</strong></p>
<ul>
<li>时间：完成单元测试后，各模块联调测试；</li>
<li>测试目标：各模块的接口是否一致，各模块间的数据流和控制流是否按照设计实现功能、以及结果的正确性验证等等；可以是整个产品的集成测试，也可以是大模块的集成测试；</li>
<li>测试重点：集成测试主要是针对程序内部结构进行测试，特别是对程序之间的接口进行测试。集成测试对测试人员的编写脚本能力要求比较高。</li>
<li>测试方式：一般选用<strong>黑盒测试和白盒测试相结合。</strong></li>
</ul>
<p><strong>系统测试</strong>：</p>
<ul>
<li>时间：集成测试之后，针对整个产品的全面测试</li>
<li>测试目标：《需求规格说明书》中提到的功能是否有遗漏，是否正确的实现。</li>
<li>测试重点：既包含各模块的验证性测试（验证前两个阶段测试的正确性）和功能性（产品提交给用户的功能）测试，又包括对整个产品的健壮性、安全性、可维护性及各种性能参数的测试。</li>
<li>测试方法：一般都使用<strong>黑盒测试法。</strong></li>
</ul>
<h3 id="2-高频-黑盒测试和白盒测试"><a href="#2-高频-黑盒测试和白盒测试" class="headerlink" title="2.(高频)黑盒测试和白盒测试"></a>2.(高频)黑盒测试和白盒测试</h3><p><strong>什么是黑盒测试</strong></p>
<p>主要是检查软件的每一个功能<strong>是否能够正常使用</strong>，检查程序功能是否按照设计需求以及说明书的规定能够正常使用。在测试过程中，<strong>不考虑程序内部结构和特性的基础上通过程序接口进行测试</strong></p>
<h4 id="黑盒测试常用方法并举例"><a href="#黑盒测试常用方法并举例" class="headerlink" title="**黑盒测试常用方法并举例"></a>**黑盒测试常用方法并举例</h4><p><strong>等价类划分法</strong></p>
<blockquote>
<p>什么是等价类划分</p>
</blockquote>
<p>等价类划分是将系统的输入域划分为若干部分，则可以合理做出下述假定：<strong>每类中的一个典型值在测试中的作用与这一类中其他值的作用相同</strong>。然后从每个部分选取少量代表性数据进行测试。一个理想的测试用例能独自发现一类错误。</p>
<p>研究程序的功能说明，从而确定输入数据的有效等价类和无效等价类，在确定输入数据的等价类时常常<strong>还需要分析输出数据的等价类</strong>，<strong>以便根据输出数据的等价类导出对应的输入数据等价类</strong></p>
<blockquote>
<p>下述几条启发式规则可能有助于等价类的划分：</p>
</blockquote>
<p>（1）如果规定了输入值的范围，则可划分出一个有效的等价类和两个无效的等价类</p>
<p>（2）如果规定了输入数据的个数，则类似地也可以划分出一个有效等价类和两个无效等价类</p>
<p>（3）如果规定了输入数据的一组值，并且程序对不同输入值做不同处理，则每个允许的输入值是一个有效等价类，还有一个无效等价类（<strong>任意一个不允许的输入值）</strong></p>
<p>（4）如果规定了输入数据必须遵循的规则，则可以划分出一个有效的等价类和若干个无效的等价类</p>
<p>（5）如果规定了输入数据为整形，则可以划分出<strong>正整数、零和负整数3个有效类</strong></p>
<p>（6）如果程序的处理对象是表格，<strong>则应该使用空表，以及含一项或多项的表</strong></p>
<blockquote>
<p>划分出等价类以后，设计测试方案：</p>
</blockquote>
<p>（1）设计一个新的测试方案以<strong>尽可能多地覆盖</strong>尚未被覆盖的有效等价类，重复这一步骤直到所有有效等价类都被覆盖位置</p>
<p>（2）设计一个新的测试方案，使他<strong>覆盖一个</strong>而且只覆盖一个尚未被覆盖的无效等价类，重复这一步骤直到所有无效等价类都被覆盖为止</p>
<p><strong>边界值分析法</strong></p>
<blockquote>
<p>什么是边界值分析法</p>
</blockquote>
<p>边界值分析法是对等价类划分的一种补充，<strong>因为大多数错误都在输入输出的边界上。如果边界附近取值不会导致程序出错，那么其他取值出错的可能性也就很小。</strong></p>
<p>边界值分析法是通过优先选择不同等价类间的边界值覆盖有效等价类和无效等价类来<strong>更有效</strong>的进行测试，因此该方法要和等价类划分法结合使用。<strong>选取的测试数据应该刚好等于、刚刚小于和刚刚大于边界值</strong></p>
<p><strong>判定表法</strong></p>
<ul>
<li>判定表驱动法是分析和表达多逻辑条件下执行不同操作的情况的工具。</li>
</ul>
<p>（1）条件桩：列出了问题的所有条件</p>
<p>（2）动作桩：列出了问题规定可能采取的操作</p>
<p>（3）条件项：列出针对它所列条件的取值，在所有可能情况下的真假值</p>
<p>（4）动作项：列出在条件项的各种取值情况下应该采取的动作</p>
<p><strong>错误分析法</strong></p>
<p>错误推测法是<strong>基于以往的经验和直觉</strong>，参照以往的软件系统出现的错误，推测当前被测程序中可能存在的缺陷和错误，有针对性地设计测试用例。</p>
<p><strong>什么是白盒测试</strong></p>
<p>它根据程序的控制结构设计测试用例，白盒测试法检查程序内部逻辑结构，对所有的逻辑路径进行测试，是一种<strong>穷举路径</strong>的测试方法，</p>
<h4 id="白盒测试常用方法并举例："><a href="#白盒测试常用方法并举例：" class="headerlink" title="白盒测试常用方法并举例："></a><strong>白盒测试常用方法并举例：</strong></h4><p>强度由低到高：</p>
<ul>
<li>语句覆盖：所有的“语句”都要覆盖一遍。就是设计若干个测试用例，运行被测程序，使得每一个执行语句至少执行一次。</li>
<li>判定覆盖：包含语句覆盖，每个判断T、F各一次。使设计的测试用例保证程序中每个判断的<strong>每个取值分支</strong>至少经历一次。</li>
<li>条件覆盖：包含语句覆盖，每个条件T、F各一次是指选择足够的测试用例，使得运行这些测试用例时，判定中每个条件的<strong>所有可能结果</strong>至少出现一次，但未必能覆盖全部分支。</li>
<li>判定条件覆盖：包含判定覆盖、条件覆盖。说白了就是我们设计的测试用例可以使得<strong>判断中每个条件所有的可能取值至少执行一次（</strong>条件覆盖），<strong>同时每个判断本身所有的结果，也要至少执行一次</strong>（判定覆盖）。不难发现判定条件覆盖同时满足判定覆盖和条件覆盖，弥补了两者各自的不足，<strong>但是判定条件覆盖并未考虑条件的组合情况。</strong></li>
<li>条件组合覆盖：每个条件的每种组合。在白盒测试法中，选择足够的测试用例，使所有判定中各条件判断结果的所有组合至少出现一次，满足这种覆盖标准成为条件组合覆盖。意思是说我们设计的测试用例应该使得<strong>每个判定中的各个条件的各种可能组合都至少出现一次</strong>。显然，满足条件组合覆盖的测试用例一定是满足判定覆盖、条件覆盖和判定条件覆盖的。</li>
<li>路径覆盖：所有路径至少执行一次。</li>
</ul>
<p><strong>黑盒和白盒测试的区别和关系</strong></p>
<table>
<thead>
<tr>
<th></th>
<th>黑盒测试</th>
<th>白盒测试</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>不查看内部代码结构</td>
<td>了解程序内部的代码结构</td>
</tr>
<tr>
<td></td>
<td>根据软件需求和规范设计</td>
<td>按照程序内部逻辑设计</td>
</tr>
<tr>
<td></td>
<td>涉及到单元、集成、系统和验收测试</td>
<td>涉及到单元、集成测试</td>
</tr>
<tr>
<td></td>
<td>测试人员不需要程序经验</td>
<td>需要有一定的程序经验</td>
</tr>
<tr>
<td></td>
<td>可以手动或自动化测试</td>
<td>可以手动或自动化测试</td>
</tr>
<tr>
<td>缺点</td>
<td>覆盖率低</td>
<td>穷举路径不太可能，只能测试开发人员做的对不对，不知道需求是否正确满足</td>
</tr>
</tbody></table>
<h3 id="3-自动化测试"><a href="#3-自动化测试" class="headerlink" title="3.自动化测试"></a>3.自动化测试</h3><p>自动化测试把以人为驱动的测试行为转化为机器执行的一种过程。在预设条件下运行系统或应用程序，评估运行结果，预先条件应包括正常条件和异常条件。</p>
<p><strong>自动化测试的前提条件</strong></p>
<p>1）需求变动不频繁</p>
<p>2）项目周期足够长：自动化测试需求的确定、框架的设计、测试脚本的编写与调试均需要相当长的时间来完成，</p>
<p>3）自动化测试脚本可重复使用</p>
<p><strong>你觉得自动化测试由什么意义，都需要做什么</strong></p>
<p>1.可以对程序的新版本自动执行回归测试</p>
<p>2.可以执行手工测试困难或者不可能实现的测试，如<strong>压力测试，并发测试</strong></p>
<p>3.能够更好的利用资源，<strong>节省时间和人力</strong></p>
<p>执行自动化测试之前首先判断这个项目<strong>适不适合</strong>推广自动化测试，然后对项目做需求分析，指定测试计划，搭建自动化测试框架，设计测试用例，执行测试，评估。</p>
<p><strong>手动测试与自动化测试的优缺点</strong></p>
<blockquote>
<p>手动测试：</p>
</blockquote>
<p>优点：</p>
<p>1.测试人员具有经验和对错误的猜测能力</p>
<p>2.测试人员具有审美能力和心理体验</p>
<p>3.测试人员具有是非判断和逻辑推理能力</p>
<p>缺点：</p>
<p>1.重复的手工回归测试，代价昂贵、容易出错</p>
<p>2.依赖于软件测试人员的能力</p>
<blockquote>
<p>自动化测试：</p>
</blockquote>
<p><strong>优点</strong></p>
<p>1.对程序的回归测试更方便。这可能是自动化测试最主要的任务，特别是在程序修改比较频繁时，效果使非常明显的。由于回归测试的动作和用例是完全设计好的，测试期望的结果也是完全可以预料的，将<strong>回归测试自动运行</strong>，可以极大提高测试效率，缩短回归测试时间。</p>
<p>2.可以运行更多更繁琐的测试。自动化的一个明显的好处是可以在较少的时间内运行更多的测试</p>
<p>3.可以执行一些手工测试困难或不可能进行的测试。比如，对于大量用户的测试，不可能同时让足够多的测试人员同时进行测试，但是却可以通过自动化测试模拟同时有许多用户，从而达到测试的目的</p>
<p>4.更好地利用资源。将繁琐的任务自动化，可以提高准确性和测试人员的积极性，将测试技术人员解脱出来投入<strong>更多精力设计更好的测试用例</strong>。有些测试不适合于自动测试，仅适合于手工测试，将可自动测试的测试自动化后，可以让测试人员专注于手工测试部分，提高手工测试的效率</p>
<p>5.测试具有一致性和可重复性。由于测试是自动执行的，这样就可能只需要做少量的甚至不做修改，实现在不同的测试过程中使用相同的用例</p>
<p>6.测试的复用性：由于自动测试通常采用脚本技术，这样就有可能只需要做少量的甚至不做修改，实现在不同的测试过程中使用相同的用例</p>
<p>7.增加软件信任度：由于测试是自动执行的，所以不存在执行过程中的疏忽和错误，完全取决于测试的设计质量。一旦软件通过了强有力的自动测试后，软件的信任度自然会增加</p>
<p><strong>缺点：</strong></p>
<p>1.不能取代手工测试</p>
<p>2.手工测试比自动测试发现的缺陷更多</p>
<p>3.对测试质量的依赖性极大</p>
<p>4.测试自动化不能提高有效性</p>
<p>5.测试自动化可能会制约软件开发。由于自动化测试比手动测试更脆弱，维护会受到限制，从而制约软件的开发</p>
<p>6.工具本身并无想象力。</p>
<h3 id="4-Bug"><a href="#4-Bug" class="headerlink" title="4.Bug"></a>4.Bug</h3><p><strong>Bug的周期？以及不同类别的Bug?</strong></p>
<p><strong>1) New:(新的)</strong></p>
<p>当某个bug 被第一次发现的时候，测试人员需要与项目负责人沟通以确认发现的的确是一个bug，如果被确认是一个bug，就将其记录下来。并将bug的状态设为new</p>
<p><strong>2）Assigned(已指派的)</strong></p>
<p>当一个Bug被指认为New之后，将其反馈给开发人员，开发人员将确认这是否是一个Bug,如果是，开发组的负责人就将这个bug指定给某位开发人员处理，并将bug的状态设定为assigned</p>
<p><strong>3）Open 打开的</strong></p>
<p>一旦开发人员开始处理bug的时候，他就将这个bug的状态设置为Open,表示开发人员正在处理这个Bug</p>
<p><strong>4)Fixed 已修复的</strong></p>
<p>当开发人员进行处理（并认为已经解决）之后，他就可以将这个bug的状态设置为fixed并将其提交给开发组的负责人，然后开发组的负责人将这个Bug返还给测试组</p>
<p><strong>5）Pending Reset 待在测试的</strong></p>
<p>当bug被返还给测试组后，状态设为这个</p>
<p><strong>6）Reset 再测试</strong></p>
<p>测试组的负责人将Bug指定给某位测试人员进行再测试，并将Bug的状态设置为Reset</p>
<p><strong>7）closed 已关闭的</strong></p>
<p>如果测试人员经过再次测试之后确认bug已经被解决之后，就将状态设置为closed</p>
<p><strong>8）Reopen 再次打开的</strong></p>
<p>如果经过再次测试发现bug仍然存在的话（指bug本身而不是包括因修复而引发的新bug），测试人员将bug再次传递给开发组，并将bug的状态设置为Reopen</p>
<p><strong>9) pending reject 拒绝中</strong></p>
<p>如果测试人员传递到开发组的bug 被开发人员认为是正常行为而不是Bug时，这种情况下开发人员可以拒绝，并将Bug的状态设置为pending reject</p>
<p><strong>10）rejected 被拒绝的</strong></p>
<p>测试组的负责人接到上述bug的时候，如果他发现这是产品说明书中定义的正常行为或者经过与开发人员的讨论之后认为这并不能算作Bug的时候，开发组负责人就将这个Bug的状态设置为rejected</p>
<p><strong>11）postponed 延期</strong></p>
<p>对于一些特殊的Bug的测试需要搁置一段时间，比如无效的测试数据，一些特殊的无效的功能等等，在这种情况下，Bug的状态就被设置为postponed</p>
<p><strong>Bug类型</strong></p>
<p>代码错误</p>
<p>界面优化</p>
<p>设计缺陷</p>
<p>配置相关</p>
<p>安装部署</p>
<p>安全相关</p>
<p>性能问题</p>
<p>标准规范</p>
<p>测试脚本</p>
<p>其他</p>
<p><strong>如何进行Bug测评</strong></p>
<p>Bug的priority() 和 severity() 是两个重要属性，通常人员在提交bug的时候，只定义severity ,将priority交给leader定义，通常bug管理中，severtity 分为四个等级blocker&#x2F;critical&#x2F;major&#x2F;minor(trivial)，而priority分为五个等级 immediate urgent high normal low</p>
<p>Severity:</p>
<p>1)blocker:即系统无法执行，崩溃，或严重资源不足，应用模块无法启动或异常退出，无法测试，造成系统不稳定。 常见的有严重花屏、内存泄漏、用户数据丢失或破坏、系统崩溃&#x2F;死机&#x2F;冻结、模块无法启动或异常退出、严重的数值计算错误、功能设计与需求严重不符、其他导致无法测试的错误，如服务器500错误</p>
<p>2)critical: 即映像系统功能或操作，主要功能存在严重缺陷，但不会映像到系统稳定性。常见的有：功能未实现、功能错误、系统刷新错误、数据通讯错误、轻微的数值计算错误、影响功能及界面的错误字或拼写错误。</p>
<p>3)major: 即界面、性能缺陷、兼容性，常见的有：操作界面错误，边界条件错误，提示信息错误，长时间操作无进度提示，系统未优化，兼容性问题</p>
<p>4)minor&#x2F;trivial:即易用性及建议性问题</p>
<p>Priority:</p>
<ol>
<li>immediate : 即马上解决</li>
</ol>
<p>2）urgent: 急需解决</p>
<p>3）high:高度重视，有时间要马上解决</p>
<p>4）low:在系统发布前解决，或确认可以不用解决</p>
<h3 id="5-APP性能"><a href="#5-APP性能" class="headerlink" title="5. APP性能"></a>5. APP性能</h3><p><strong>软件质量的六个特征</strong></p>
<p>按照软件质量国家标准GB-T8566–2001G，软件质量可以用下列特征来评价：</p>
<p>a.功能特征：与一组功能及其指定性质有关的一组属性，这里的功能是满足明确或隐含的需求的那些功能</p>
<p>b.可靠特征：在规定的一段时间和条件下，与软件维持其性能水平的能力有关的一组属性</p>
<p>c.易用特征：由一组规定或潜在的用户为使用软件所需作的努力和所作的评价有关的一组属性</p>
<p>d.效率特征：与在规定条件下软件的性能水平与所使用资源量之间关系有关的一组属性</p>
<p>e.可维护特征：与进行指定的修改所需的努力有关的一组属性</p>
<p>f.可移植特征：与软件从一个环境转移到另一个环境的能力有关的一组属性</p>
<p><strong>测试的类型？</strong></p>
<p>测试分为功能测试和非功能测试，非功能测试又可分为性能测试、压力测试、容量测试、健壮性测试、安全性测试、可靠性测试、恢复性测试、备份测试、协议测试、兼容性测试、可用性测试、配置测试、GUI测试。</p>
<p><strong>APP性能测试的指标</strong></p>
<p>1）内存：</p>
<p>内存消耗测试节点的设计目标是为了让应用不占用过多的系统资源，且及时释放内存，保障整个系统的稳定性。当然关于内存测试，需要引入几个概念：空闲状态、中等规格、满规格。</p>
<ul>
<li><strong>空闲状态指打开应用后</strong>，点击home键让应用后台运行，此时应用处于的状态叫做空闲；</li>
<li>中等规格和满规格指的是对应用的操作时间的间隔长短不一，<strong>中等规格时间较长，满规格时间较短</strong>。</li>
</ul>
<p>内存测试中存在很多测试子项，清单如下：</p>
<ul>
<li>空闲状态下的应用内存消耗；</li>
<li>中等规格状态下的应用内存消耗；</li>
<li>满规格状态下的应用内存消耗；</li>
<li>应用内存峰值；</li>
<li>应用内存泄漏；</li>
<li>应用是否常驻内存</li>
<li>压力测试后的内存使用</li>
</ul>
<p>2）CPU</p>
<p>使用Android 提供的view plaincopy 在CODE上查看代码片派生到我的代码片</p>
<p>adbshell dumpsys CPUinfo | grep packagename &gt;&#x2F;address&#x2F;CPU.txt 来获取</p>
<p>使用top命令view plaincopy 在CODE上查看代码片派生到我的代码片</p>
<p>adbshell top | grep packagename &gt;&#x2F;address&#x2F;CPU.txt 来获取</p>
<p>3）流量</p>
<p>网络流量测试是针对大部分应用而言的，可能还有部分应用会关注网速、弱网之类的测试。</p>
<p>流量测试包括以下测试项：</p>
<p>应用首次启动流量提示；</p>
<p>应用后台连续运行2小时的流量值；</p>
<p>应用高负荷运行的流量峰值</p>
<p>4）电量：</p>
<p>测试手机安装目标APK前后待机功耗无明显差异</p>
<p>常见使用场景中能够正常进入待机，待机电流在正常范围内</p>
<p>长时间连续使用应用无异常耗电现象。</p>
<p>5）启动速度</p>
<p>第一次：<strong>首次启动</strong>–应用首次启动所花费的时间</p>
<p>第二次：<strong>非首次启动</strong>-应用非首次启动所花费的时间</p>
<p>第三类：<strong>应用界面切换-</strong>-应用界面内切换所花费的时间</p>
<p>6）滑动速度、界面切换速度</p>
<p>7）与服务器交互的网络速度</p>
<p><strong>APP测试工具</strong></p>
<p>功能测试自动化：</p>
<p>a) 轻量接口自动化测试：jmeter</p>
<p>b) APP UI 层面的自动化：</p>
<p>android: UI Automator Viewer,Android Junit, Instrumentation, UIAutomator,</p>
<p>IOS :基于Instrument 的 IOS UI自动化</p>
<p>性能测试：</p>
<p>a)Web前端性能测试</p>
<p>网络抓包工具：Wireshark</p>
<p>网页文件大小：webpagetest pagespeed insight chrome adb</p>
<p>b) APP端性能测试</p>
<p>Android内存占用分析：MAT</p>
<p>IOS内存问题分析：ARC模式</p>
<p>Android WebView性能分析：</p>
<p>IOS WebView 性能分析</p>
<p>c)后台服务性能测试</p>
<p>负载、压力、耐久性、可扩展性、基准</p>
<p>工具：apacheAB , Jmeter, LoadRunner</p>
<p>专项测试</p>
<p>a)兼容性测试</p>
<p>手工测试：操作系统、分辨率、rom、网络类型</p>
<p>云平台：testin 脚本编写 Android</p>
<p>b)流量测试</p>
<p>Android自带的流量管理</p>
<p>IOS自带的Network</p>
<p>tcpdump抓包</p>
<p>WIFI代理抓包：Fiddler</p>
<p>流量节省方法：压缩数据，json优于xml; WebP优于传统的JPG，PNG；控制访问的频次；只获取必要的数据；缓存</p>
<p>c)电量测试</p>
<p>基于测试设备的方法，购买电量表进行测试</p>
<p>GSam Battery Monitoe Pro</p>
<p>IOS 基于Instrument Energy工具</p>
<p>d)弱网络测试</p>
<p>手机自带的网络状况模拟工具</p>
<p>基于代理的弱网络的模拟</p>
<p>工具：</p>
<p>Windows: Network Delay Simulator</p>
<p>Mac: Network Link Conditioner</p>
<h3 id="6-性能、压力测试"><a href="#6-性能、压力测试" class="headerlink" title="6.性能、压力测试"></a>6.性能、压力测试</h3><p>性能测试是通过自动化的测试工具模拟多种<strong>正常、峰值以及异常负载</strong>条件来对系统的各项性能指标进行测试。</p>
<p>负载测试和压力测试都属于性能测试，两者可以结合进行。通过负载测试，确定在各种工作负载下系统的性能，目标是测试当负载逐渐增加时，系统各项性能指标的变化情况。压力测试是通过<strong>确定一个系统的瓶颈或者不能接受的性能点，来获得系统能提供的最大服务级别的测试。</strong></p>
<p><strong>性能测试关注什么</strong></p>
<p>性能测试概括为三个方面：应用在<a href="https://link.zhihu.com/?target=https://baike.baidu.com/item/%E5%AE%A2%E6%88%B7%E7%AB%AF?fromModule=lemma_inlink">客户端</a>性能的测试、应用在<strong>网络</strong>上性能的测试和应用在<strong>服务器</strong>端性能的测试。</p>
<p>应用在<a href="https://link.zhihu.com/?target=https://baike.baidu.com/item/%E5%AE%A2%E6%88%B7%E7%AB%AF?fromModule=lemma_inlink">客户端</a>性能测试的目的是考察客户端应用的性能，测试的入口是客户端。它主要包括并发性能测试、疲劳<a href="https://link.zhihu.com/?target=https://baike.baidu.com/item/%E5%BC%BA%E5%BA%A6%E6%B5%8B%E8%AF%95?fromModule=lemma_inlink">强度测试</a>、大数据量测试和速度测试等，其中<strong>并发性能测试</strong>是重点。</p>
<p>应用在网络上性能的测试重点是利用成熟先进的自动化技术进行网络应用性能监控、网络应用<a href="https://link.zhihu.com/?target=https://baike.baidu.com/item/%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90?fromModule=lemma_inlink">性能分析</a>和网络预测。</p>
<p>对于应用在服务器上性能的测试，可以采用工具监控，也可以使用系统本身的监控命令，实施测试的目的是实现服务器设备、<a href="https://link.zhihu.com/?target=https://baike.baidu.com/item/%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F?fromModule=lemma_inlink">服务器操作系统</a>、<a href="https://link.zhihu.com/?target=https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F?fromModule=lemma_inlink">数据库系统</a>、应用在服务器上性能的全面监控</p>
<p>响应时间RT</p>
<p>每秒能完成的响应数TPS</p>
<p>CPU利用率</p>
<p>内存占用</p>
<p>网络（带宽使用率）</p>
<p>手机APP要考虑耗电量</p>
<p>负载大时，各项指标如何变化</p>
<p>联网的话要考虑不同网络环境（正常网、超快网、网速慢、断网）时指标的变化</p>
<p><strong>并发用户数和在线用户数的区别</strong></p>
<p>在线用户数：用户同时在一定时间段的在线数量</p>
<p>并发用户数：某一时刻同时向服务器发送请求的用户数</p>
<p><strong>QPS（每秒查询率）</strong></p>
<p>每秒查询率是对一个特定的查询服务器在规定时间内所处理流量多少的衡量标准，用来衡量服务器的机器性能</p>
<p><strong>QPS和TPS的区别</strong></p>
<p>TPS：Transactions Per Second(每秒传输的事物处理个数)，即服务器每秒处理的<strong>事务数</strong></p>
<p>TPS包括一条消息入和一条消息出，加上一次用户数据库访问，是软件测试结果的测量单位</p>
<h2 id="三、故障排除类题目"><a href="#三、故障排除类题目" class="headerlink" title="三、故障排除类题目"></a>三、故障排除类题目</h2><h3 id="1-PC网络故障，以及如何排除障碍"><a href="#1-PC网络故障，以及如何排除障碍" class="headerlink" title="1.PC网络故障，以及如何排除障碍"></a>1.PC网络故障，以及如何排除障碍</h3><p>1）首先排除接触故障，即确保你的网线是可以正常使用的。然后禁用网卡后再启用，排除偶然故障。打开网络和共享中心，单击窗口左上侧“更改适配器设置”，右击其中的“本地连接”或“无线网络连接”，单击快捷菜单中的“禁用”命令，即可禁用所选网络。接下来重启网络，只需右击后单击启用即可。</p>
<p>2）使用ipconfig 查看计算机的上网参数</p>
<p>单击“开始-所有程序-附件-命令提示符”，打开命令提示符窗口</p>
<p>输入Ipconfig，按enter确认，可以看到机器的配置信息，输入ipconfig&#x2F;all 可以看到IP地址和网卡物理地址等相关网络详细信息</p>
<p>3）使用Ping命令测试网络的连通性，定位故障范围</p>
<p>在命令提示符窗口中输入“ping 127.0.0.1” 数据显示本机分别发送和接受了4个数据包，丢包率为零，可以判断本机网络协议工作正常，如显示“请求超时”则表明本机网卡的安装或TCP&#x2F;IP 协议有问题，接下来就应该检查<strong>网卡</strong>和TCP&#x2F;IP 协议，卸载后重装即可</p>
<p>4）ping本机IP</p>
<p>在确认127.0.0.1 地址能被Ping通的情况下，继续使用Ping命令测试本机IP地址能否被Ping通，如不能，说明本机的网卡驱动程序不正确，或者网卡与网线之间连接有故障，也有可能是本地的路由表面受到了破坏，此时应检查本机网卡的状态是否为已连接，网络参数是否设置正确，如果正确可是不能Ping通，就应该重新安装<strong>网卡驱动程序</strong>。丢失率为0，可以判断网卡安装配置没有问题，工作正常。</p>
<p>5）ping网关</p>
<p>网关地址能被Ping通的话，表明本机网络连接以及 正常，如果命令不成功，可能是<strong>网关设备</strong>自身存在问题，也可能是本机上网参数设置有误，检查网络参数</p>
<h3 id="2-请问你怎么测试网络协议"><a href="#2-请问你怎么测试网络协议" class="headerlink" title="2.请问你怎么测试网络协议"></a>2.请问你怎么测试网络协议</h3><p>协议测试包括四种类型的测试</p>
<p>1.一致性测试：检测协议实现本身与协议规范的符合程度</p>
<p>2.互操作性测试：基于某一协议检测不同协议实现间互操作互通信的能力</p>
<p>3.性能测试：检测协议实现的性能指标，比如数据传输速度，连接时间，执行速度，吞吐量，并发度</p>
<p>并发数：指系统同时能处理的请求数量，同样反应了系统的负载能力。这个数值可以分析机器1s内的访问日志数量来得到、</p>
<p>吞吐量：是指系统在单位时间内处理请求的数量，TPS、QPS都是吞吐量的常用量化指标。</p>
<p>4.健壮性测试：检测协议在各种恶劣环境下运行的能力，比如注入干扰报文、通信故障、信道被切断</p>
<h2 id="四、设计测试用例"><a href="#四、设计测试用例" class="headerlink" title="四、设计测试用例"></a>四、设计测试用例</h2><h3 id="测试用例的组成元素"><a href="#测试用例的组成元素" class="headerlink" title="测试用例的组成元素"></a>测试用例的组成元素</h3><p>内容包括<strong>测试目标、测试环境、输入数据、测试步骤、预期结果、测试脚本</strong>等</p>
<p>简单地认为，测试用例是为某个特殊目标而编制的一组测试输入、执行条件以及预期结果，用于核实是否满足某个特定软件需求。</p>
<p>测试用例主要包含四个内容：</p>
<p>用例标题-主要描述测试某项功能；</p>
<p>前置条件-用例标题需要满足该条件</p>
<p>测试步骤-描述用例的操作步骤</p>
<p>预期结果-符合预期需求（开发规格书、需求文档、用户需求等）</p>
<h3 id="如何写测试用例"><a href="#如何写测试用例" class="headerlink" title="如何写测试用例"></a>如何写测试用例</h3><p>1.测试人员<strong>尽早介入</strong>，彻底理解清楚需求，这个是写好测试用例的基础</p>
<p>2.如果以前有类似的需求，可以<strong>参考类似需求的测试用例</strong>，然后还需要看类似需求的bug情况</p>
<p>3.清楚输入、输出的<strong>各种可能性</strong>，以及各种输入的之间的关联关系，理解清楚需求的执行逻辑，通过等价类、边界值、判定表等方法找出大部分用例</p>
<p>4.找到需求相关的一些特性，补充测试用例</p>
<p>5.根据自己的经验分析遗漏的测试场景</p>
<p>6.多总结类似功能点的测试点，才能够写出质量越来越高的测试用例</p>
<p>7.书写格式一定要清晰(测试用例编号、测试标题、重要级别、测试输入、操作步骤、预期结果)</p>
<h3 id="测试用例的重要级别是怎么分的"><a href="#测试用例的重要级别是怎么分的" class="headerlink" title="测试用例的重要级别是怎么分的"></a>测试用例的重要级别是怎么分的</h3><p>1）特高用例</p>
<p>划分原则：特高用例主要是<strong>核心功能的主流程</strong>，基本业务流，保证功能的完整性，特高用例失败会导致其他多处功能无法正常使用。</p>
<p>用例设计常用思想&amp;方法：场景法</p>
<p>参考比例：10%左右</p>
<p>（2）高等级</p>
<p>划分原则：核心功能的正向业务流，覆盖平台功能的所有重要业务流</p>
<p>参考比例： 15%左右</p>
<p>特高及高等级用例要覆盖所有功能的正向业务流，能够保证软件功能稳定使用。包含<strong>功能交互、使用场景、使用频率较高</strong>的正常功能用例；</p>
<p>（3）中等级</p>
<p>划分原则：重要功能的正向业务流、核心&amp;重要功能的异常业务流</p>
<p>参考比例：30%左右</p>
<p>常见输入框、字符等正向用例，常见异常场景的业务流，常见的失败类场景；</p>
<p>（4）低等级</p>
<p>划分原则：其他异常用例、UI&#x2F;UE相关用例等</p>
<p>用例设计常用思想&amp;方法<strong>：边界值、无效等价类等</strong></p>
<p>参考比例：45%左右</p>
<p>常见的输入框异常用例，包括一些异常的触发条件</p>
<h3 id="1-微信红包设计"><a href="#1-微信红包设计" class="headerlink" title="1.微信红包设计"></a>1.微信红包设计</h3><p><strong>单个红包的功能上：</strong></p>
<p>发送方：</p>
<p><strong>输入红包金额</strong>：红包金额为0、0.01 200.00 200.01 199.99 20</p>
<p><strong>输入留言：</strong>留言输入数字、字母、汉字、特殊字符；留言长度；留言复制粘贴</p>
<p><strong>选择表情</strong>：表情-选择收藏的表情、其他表情； 删除表情、选择新的表情</p>
<p><strong>选择红包封面</strong>：封面选择</p>
<p><strong>选择支付方法</strong>：（零钱、零钱通、银行卡、添加新卡支付）判断里面钱数与红包钱数的关系；使用指纹、面部识别、密码支付（正确输入、错误输入的情况）</p>
<p><strong>钱财金额：</strong>红包发送成功后，钱包金额减少对应数值</p>
<p>接收方：</p>
<p><strong>接收方收到红包</strong>：接受者对红包封面、留言、表情、金额均能正确了解</p>
<p><strong>接收方的金额</strong>：被领取后显示已领取，领取者钱包增加相应金额，再次点开红包只能显示红包信息</p>
<p><strong>只有接收方可以点开</strong>：发送方点开不能领取，只显示相关信息</p>
<p><strong>未领取</strong>：24小时后未领取显示退回，钱包金额增加，对方不能再领取</p>
<p><strong>群发红包功能：</strong></p>
<p><strong>红包个数</strong>：红包个数为空、0、001、100、99、101</p>
<p><strong>红包金额</strong>：红包拆开每个金额一样，均为发红包时设置的单个金额对应的钱数</p>
<p><strong>红包被拆提示</strong>：红包被拆时，有相应提示</p>
<p><strong>退回</strong>：红包24小时内未被拆完，剩余钱被退回，相应支付方式中钱数增加</p>
<p><strong>群发红包-拼手气红包功能</strong></p>
<p>每个人拆开数额不同，总金额等于红包总额；24小时内领完显示最佳手气，否则不显示</p>
<p><strong>兼容性测试</strong></p>
<p>测试安卓、ios不同型号收集</p>
<p>UI测试：显示无错误，风格样式统一</p>
<p>中断测试：不同应用间切换、没电、没网、来电话、短信</p>
<p>网络测试：2g、3g、4g、5g、wifi、移动联通电信、弱网、没网</p>
<h3 id="2-用户登录过程需要做哪些分析？"><a href="#2-用户登录过程需要做哪些分析？" class="headerlink" title="2.用户登录过程需要做哪些分析？"></a>2.用户登录过程需要做哪些分析？</h3><p><strong>功能测试：</strong></p>
<p><strong>输入用户名和密码：</strong></p>
<ul>
<li>用户名和密码，太短或太长的处理（边界值法）</li>
<li>用户名和密码，有特殊字符(比如空格)及其他非英文的情况</li>
<li>记住用户名，记住密码</li>
<li>登录失败后，不记录密码</li>
<li>用户名和密码前后有空格的处理</li>
<li>密码是否是密文显示，使用*号或圆点等符号代替</li>
<li>验证码的辨认难度，考虑颜色（色盲使用者），刷新或换一个按钮是否好用</li>
<li>输入密码时，大写键盘开启时是否有提示信息</li>
<li>什么都不输入，点击提交按钮，检查提示信息</li>
</ul>
<p><strong>登录流程：</strong></p>
<ul>
<li>正常流程（正确账号密码，点击提交，验证能否正确登录）</li>
<li>异常流程（错误的账号密码，点击提交，验证登录失败，并提示相应错误信息）</li>
<li>登录成功后能否正确跳转</li>
<li>登录token测试</li>
</ul>
<p><strong>界面测试：</strong></p>
<ul>
<li>布局是否合理，按钮和表单是否整齐</li>
<li>按钮和表单高度和长度是否符合要求</li>
<li>界面风格是否符合UI设计稿</li>
<li>文字有无错别字</li>
</ul>
<p><strong>性能测试：</strong></p>
<ul>
<li>打开登录界面，需要的时间是否在需求要求的时间内</li>
<li>输入正确的账号密码，点击登录，是否在需求时间内跳转成功</li>
<li>模拟大量用户同时登录，检查一定压力下能否正常跳转</li>
</ul>
<p><strong>安全性测试</strong>：</p>
<ul>
<li>用户名或密码是否通过加密方式，发送给后端服务器</li>
<li>用户名和密码应该在前端和后端做双重验证</li>
<li>用户名和密码的输入框，应该屏蔽SQL注入攻击</li>
<li>用户名和密码的输入框，应该禁止输入脚本（防止XSS攻击）</li>
<li>防止暴力破解，检测是否有错误登录的次数限制</li>
<li>是否支持多用户在同一机器上登录</li>
<li>同一用户能否在多台机器上登录</li>
</ul>
<p><strong>可用性测试：</strong></p>
<ul>
<li>是否可以用全键盘操作，是否有快捷键</li>
<li>输入用户名，密码后按回车，是否可以登录</li>
<li>输入框是否可以Tab切换</li>
</ul>
<p><strong>兼容性测试</strong>：</p>
<ul>
<li>不同浏览器下能否显示正常，且功能正常</li>
<li>同种浏览器下不同版本能否显示正常且功能正常</li>
<li>不同的操作系统是否能正常工作</li>
<li>移动设备上是否正常工作</li>
</ul>
<h3 id="3-如何对短视频APP-抖音-进行测试"><a href="#3-如何对短视频APP-抖音-进行测试" class="headerlink" title="3.如何对短视频APP(抖音)进行测试"></a>3.如何对短视频APP(抖音)进行测试</h3><p><strong>功能测试：</strong></p>
<p><strong>刷抖音</strong>：</p>
<ul>
<li>视频清晰度</li>
<li>视频暂停、播放功能</li>
<li>视频信息（标题、描述、音乐、标签）</li>
<li>点赞数、双击点赞功能</li>
<li>评论功能（评论数、查看评论、发表评论）</li>
<li>分享转发</li>
<li>同款音乐</li>
<li>用户个人主页</li>
<li>搜索测试（热搜、话题功能）</li>
</ul>
<p><strong>拍抖音</strong></p>
<ul>
<li>调起摄像头</li>
<li>视频拍摄、本地视频</li>
<li>视频剪辑功能测试</li>
<li>选择音乐功能测试</li>
<li>道具、表情、滤镜</li>
<li>发布短视频测试</li>
</ul>
<p><strong>商业化</strong></p>
<ul>
<li>广告植入（跳过广告）</li>
<li>抖音商城</li>
</ul>
<p><strong>性能测试：</strong></p>
<ul>
<li>视频质量（码流、帧率、不卡帧）</li>
<li>网络测试（wifi&#x2F;5G&#x2F;4G&#x2F;3G&#x2F;弱网、断网）</li>
<li>服务器负载测试</li>
<li>服务器压力测试</li>
<li>长时间运行</li>
<li>耗电量</li>
<li>内存是否泄漏</li>
<li>CPU状况</li>
</ul>
<p><strong>安全测试：</strong></p>
<ul>
<li>视频链接加密</li>
<li>视频防止去水印</li>
<li>视频反爬</li>
</ul>
<p><strong>异常测试</strong></p>
<ul>
<li>弱网、断网等异常测试</li>
<li>码率切换测试</li>
<li>破坏性点击（疯狂点赞、取消点赞）</li>
<li>切换前后台</li>
</ul>
<p><strong>兼容性测试</strong></p>
<ul>
<li>移动端系统兼容性</li>
<li>应用权限测试</li>
</ul>
<p><strong>安装、卸载测试</strong></p>
<h3 id="4-如何对聊天系统（偏客服系统）进行测试"><a href="#4-如何对聊天系统（偏客服系统）进行测试" class="headerlink" title="4.如何对聊天系统（偏客服系统）进行测试"></a>4.如何对聊天系统（偏客服系统）进行测试</h3><p><strong>功能测试：</strong></p>
<p>用户端：</p>
<ul>
<li>登陆状态下正常发送消息</li>
<li>未登录状态下发送消息，会提示去登陆</li>
<li>输入框发消息测试（过长、过短、表情、图片、视频、语音、英文、数字、url、卡片、红包、位置等）</li>
<li>接收消息测试</li>
<li>消息顺序（不乱序、不重复、不错误、不丢失）</li>
<li>历史消息</li>
<li>未读消息提醒（小红点显示隐藏、未读消息数）</li>
<li>用户头像点击</li>
<li>自动回复选项点击</li>
<li>长按消息（复制&#x2F;转发&#x2F;删除&#x2F;撤回&#x2F;引用）</li>
<li>一键跳转到最新消息</li>
</ul>
<p>客服端：</p>
<ul>
<li>正常回复消息</li>
<li>输入框发消息测试（过长、过短、表情、图片、视频、语音、英文、数字、url、卡片、红包、位置等）</li>
<li>接收消息测试</li>
<li>消息顺序（不乱序、不重复、不错误、不丢失）</li>
<li>历史消息</li>
<li>未读消息提醒</li>
<li>自动回复设置</li>
<li>用户头像点击，用户信息采集</li>
<li>长按消息（复制&#x2F;转发&#x2F;删除&#x2F;撤回&#x2F;引用）</li>
<li>一键跳转到最新消息</li>
<li>消息群发（有可能也没有此功能）</li>
</ul>
<p>接口测试：</p>
<ul>
<li>发送消息接口(msg_type&#x2F;msg_content&#x2F;埋点测试&#x2F;extra_content)</li>
<li>RPC接口调用</li>
<li>消息队列（排序、队列长度、数据格式）</li>
</ul>
<p>性能测试：</p>
<ul>
<li>模拟多用户同时向单用户发送消息</li>
<li>模拟单用户同时向多用户发送消息</li>
<li>1s内发送多条消息</li>
<li>同一聊天室内，1s内接收多条消息，端上应有消息延迟展示策略</li>
</ul>
<p>兼容性测试：</p>
<ul>
<li>跨平台跨系统登陆接收消息并展示</li>
<li>多端登陆同一个账号，接收别人发来的消息（若支持多端登录）</li>
<li>多端登录同一个账号，一端发送消息，自己的消息在别的端的展示情况（若支持多端登录）</li>
</ul>
<p>异常测试：</p>
<ul>
<li>断网&#x2F;弱网情况下发送消息</li>
<li>输入框输入sql、脚本等</li>
</ul>
<h3 id="5-如何对长视频APP（优酷）进行测试"><a href="#5-如何对长视频APP（优酷）进行测试" class="headerlink" title="5.如何对长视频APP（优酷）进行测试"></a>5.如何对长视频APP（优酷）进行测试</h3><p>1.功能测试：</p>
<ul>
<li>视频能够正常播放</li>
<li>会员特权（购买、有效期、行使特权）</li>
<li>播放组件（点播播放器、直播播放器、缓存视频播放器）</li>
<li>视频清晰度转换（手动、自动）</li>
<li>全屏&#x2F;缩放； 横屏&#x2F;竖屏；锁屏</li>
<li>播放&#x2F;暂停&#x2F;下一集</li>
<li>进度条（快进、快退、锚点播放）</li>
<li>亮度</li>
<li>声音</li>
<li>弹幕</li>
<li>缓存</li>
<li>投屏</li>
<li>选集</li>
<li>倍速</li>
<li>断点续播</li>
<li>视频水印</li>
<li>返回键</li>
<li>分享&#x2F;收藏</li>
<li>睡眠模式</li>
<li>商业化（广告）</li>
<li>片前广告&#x2F;片中广告&#x2F;片尾广告</li>
<li>暂停广告弹窗</li>
<li>VIP跳过广告</li>
<li>广告倒计时自动关闭</li>
</ul>
<p>2.性能测试</p>
<ul>
<li>清晰度测试（4K、蓝光、超清、高清、标清、流畅），测试固定码率播放以及切换码率播放</li>
<li>负载测试（最大同时拉流数）</li>
<li>网络测试（wifi&#x2F;5G &#x2F;4G&#x2F;3G&#x2F;弱网、断网）</li>
<li>首屏加载时间</li>
<li>长时间运行</li>
<li>耗电量</li>
<li>内存泄漏</li>
<li>CPU状况</li>
<li>是否有丢帧</li>
</ul>
<p>3.安全测试：</p>
<ul>
<li>视频流地址加密</li>
<li>会员接口不对外暴露</li>
<li>防止去广告脚本攻击</li>
<li>缓存视频加密</li>
</ul>
<p>4.异常测试：</p>
<ul>
<li>弱网、断网等异常测试</li>
<li>码率切换测试</li>
<li>频繁切换前后台</li>
</ul>
<p>5.兼容性测试</p>
<ul>
<li>移动端兼容性</li>
<li>PC端兼容性</li>
<li>浏览器兼容性</li>
<li>TV端</li>
</ul>
<h3 id="6-如何对列表页（贝壳找房）进行测试"><a href="#6-如何对列表页（贝壳找房）进行测试" class="headerlink" title="6.如何对列表页（贝壳找房）进行测试"></a>6.如何对列表页（贝壳找房）进行测试</h3><p>1.功能测试</p>
<ul>
<li>列表排序</li>
<li>列表翻页</li>
<li>列表筛选</li>
<li>列表少结果、无结果、多结果的页面展示</li>
<li>检索系统、推荐系统、商业化（广告）测试</li>
<li>回到顶端浮标</li>
<li>列表卡片跳转</li>
<li>列表卡片UI展示（价格、标题、描述、标签等）</li>
<li>上滑加载更多</li>
<li>下拉刷新列表</li>
<li>其他（浮标按钮等）</li>
</ul>
<p>2.性能测试</p>
<ul>
<li>压力测试</li>
<li>负载测试</li>
<li>大数据量返回的表现（一般后端会做翻页）</li>
<li>页面响应时间测试</li>
</ul>
<p>3.兼容性</p>
<ul>
<li>浏览器兼容性</li>
<li>PC端操作系统兼容性</li>
<li>移动端操作系统兼容性</li>
<li>弱网&#x2F;无网显示</li>
</ul>
<p>4.埋点测试</p>
<ul>
<li>曝光埋点</li>
<li>点击埋点</li>
<li>PV&#x2F;uv统计</li>
</ul>
<h3 id="7-如何对搜索框（贝壳找房）进行测试"><a href="#7-如何对搜索框（贝壳找房）进行测试" class="headerlink" title="7.如何对搜索框（贝壳找房）进行测试"></a>7.如何对搜索框（贝壳找房）进行测试</h3><p>1.功能测试</p>
<ul>
<li>输入关键字，查看返回结果是否准确</li>
<li>查询有结果的显示</li>
<li>查询无结果的显示</li>
<li>查询少结果的显示</li>
<li>输入框测试：输入特殊内容，过长&#x2F;过短的关键词，关键词输入</li>
<li>正常：楼盘、地区、街道、公司、城市、地铁沿线、商圈等关键词</li>
<li>异常：空格及其他特殊字符、代码等。</li>
<li>热门关键词搜索测试（需要结合CMS后台测试）</li>
<li>sug动态搜索测试</li>
<li>商业化（广告）相关测试</li>
<li>搜索出来的楼盘结果列表：排序、翻页、是否列表去重</li>
<li>搜索历史功能测试</li>
<li>检索系统和推荐系统的测试</li>
<li>结果跳转（跳转到详情页、跳转到列表页）</li>
</ul>
<p>2.性能测试</p>
<ul>
<li>sug耗时</li>
<li>点击搜索结果，渲染结果列表耗时</li>
<li>压力测试，不同用户数压力下的表现</li>
<li>负载测试，看极限能承受多大的用户量同时正常使用</li>
<li>大数据量返回的表现</li>
</ul>
<p>3.易用性</p>
<ul>
<li>功能是否易用，输入法调起是否正常，按钮可点击区域是否满足易用性</li>
<li>针对不同，是否有友好的提醒</li>
<li>搜索结果的楼盘卡片是否显示合理（价格、标题、描述等）</li>
<li>搜索结果是否准确，排序是否合理</li>
<li>控件设计是否符合APP整体设计风格</li>
</ul>
<p>4.兼容性</p>
<ul>
<li>浏览器兼容性</li>
<li>PC端操作系统兼容性</li>
<li>移动端操作系统兼容性</li>
<li>杀毒软件、防火墙、不同输入法等工具共同使用，是否适配</li>
</ul>
<p>5.安全性</p>
<ul>
<li>表单不允许被SQL注入（录入一些数据库查询的保留字符，如单引号，%等）</li>
<li>是否有反爬策略</li>
<li>是否有黄反策略或对涉及国家安全、法律禁止的内容是否进行过滤和控制</li>
</ul>
<h3 id="8-测试一瓶矿泉水"><a href="#8-测试一瓶矿泉水" class="headerlink" title="8.测试一瓶矿泉水"></a>8.测试一瓶矿泉水</h3><p>1.功能测试</p>
<p>水瓶漏不漏、瓶中的水能不能被喝到</p>
<p>2.界面测试</p>
<p>外观是否没管</p>
<p>3.安全性：瓶子的材质有没有毒或者细菌</p>
<p>4.可靠性：从不同高度落下的损坏程度</p>
<p>5.可移植性：在不同的地方、温度等环境下是否都可以正常使用</p>
<p>6.兼容性：是否能够容纳果汁、白水、酒精、汽油等</p>
<p>7.易用性：是否烫手、是否有防滑措施，是否方便饮用</p>
<p>8.用户文档：使用手册是否对用法、限制、使用条件等有详细描述</p>
<p>疲劳测试：将盛上水放24小时检查泄漏时间和情况；盛上汽油放24小时检查泄漏时间和情况等</p>
<p>压力测试：用根针并在针上面不断加重量，看压强多大时会穿透</p>
<p>跌落测试：测试在何种高度跌落会破坏水瓶</p>
<h3 id="9-测试朋友圈点赞功能"><a href="#9-测试朋友圈点赞功能" class="headerlink" title="9.测试朋友圈点赞功能"></a>9.测试朋友圈点赞功能</h3><p>功能测试：</p>
<p>1.是否可以正常点赞和取消</p>
<p>2.点赞的人是否在可见分组里</p>
<p>3.点赞状态是否能即时更新显示</p>
<p>4.点赞状态，共同好友是否可见</p>
<p>5.点赞显示的是否正确，一行几个</p>
<p>6.点赞是否按时间进行排序，头像对应的是否正确</p>
<p>7.是否能在消息列表中显示点赞人的昵称</p>
<p>接口测试：点赞朋友圈，验证朋友能否收到提示消息</p>
<p>性能测试：点赞朋友圈，是否在规定时间显示结果，是否在规定时间在朋友手机上进行提示</p>
<p>兼容性测试：在不同的终端上点赞，验证是否成功</p>
<h3 id="答题角度总结"><a href="#答题角度总结" class="headerlink" title="答题角度总结"></a>答题角度总结</h3><p><strong>日常物品</strong></p>
<p>功能测试：等价类划分+边界值分析。</p>
<p>外观测试：外观完整、美观；尺寸大小&#x2F;材质；外部说明清晰；舒适度</p>
<p>性能测试：使用寿命、响应时间、长时间使用情况、负载情况、压力情况</p>
<p>安全测试：材质毒性</p>
<p>兼容测试：</p>
<p>易用测试：使用方便、携带方便、操作简单、防护措施</p>
<p>异常测试：耐破坏性、异常情况的响应、应急情况</p>
<p>可维护性：配件更换、维修、拆除</p>
<p><strong>文本框&#x2F;登录&#x2F;聊天&#x2F;查找类</strong></p>
<p>功能测试：太短&#x2F;太长(边界值分析)&#x2F;特殊字符&#x2F;输入为空、正常流程、异常流程、选中、复制粘贴、光标位置</p>
<p>性能测试：响应时间、压力测试、负载测试、单人聊天、多人聊天</p>
<p>易用&#x2F;界面：输入法调起、按钮点击区域、提醒到位、搜索结果、展示结果是否合理、设计风格、快捷键</p>
<p>兼容性：浏览器、PC端、移动端、杀毒软件、防火墙、不同输入法、不同版本、</p>
<p>安全性：异常测试（弱网、断网）、反爬策略、内容审核、不允许SQL注入、加密传输、防止暴力破解、多端登录</p>
<p><strong>支付交易类</strong></p>
<p>功能测试：支付方式、余额充足或不足、密码输入正确或错误、验证码、金额校验(空值、负值、最小金额、最大金额、消费上限)、取消支付</p>
<p>性能测试：页面跳转时间、耗电量和流量、更换支付方式响应时间、并发情况下、多端登录</p>
<p>外观测试：页面美观、布局合理、信息提示正确、字体清晰</p>
<p>安全测试：密码暗纹、支付金额过大、对面账户异常、新设备授权、</p>
<p>易用测试：操作简单快捷、提示信息到位</p>
<p>兼容性测试：不同系统、不同版本、不同网络、不同浏览器、</p>
<p>异常测试：断网、弱网、关机、刷新页面、退出程序</p>
<p><strong>人工智能类</strong></p>
<p>功能测试：不说话&#x2F;声音小&#x2F;错别字&#x2F;文字长度限制&#x2F;语音时间限制&#x2F;不同语言&#x2F;不同物种语音&#x2F;多语音&#x2F;敏感词处理&#x2F;断句功能&#x2F;识别数字</p>
<p>性能测试：响应时间、耗电量、资源占用</p>
<p>外观测试：界面设计、布局合理、信息提示正确</p>
<p>易用测试：操作简单快捷、提示信息到位</p>
<p>兼容性测试：不同系统、不同版本、不同网络、不同浏览器</p>
<p>异常测试：断网、弱网发送顺序、关机</p>
<p><strong>视频类</strong></p>
<p>功能测试：清晰度、暂停播放、视频信息、互动功能、分享转发、个人主页、广告植入、会员特权、播放组件（弹幕、进度条、声音、投屏、小屏幕、）断点续播</p>
<p>性能测试：负载测试、压力测试、资源消耗、视频质量（帧率、码流）</p>
<p>安全测试：视频链接加密、反爬、防止去水印、脚本攻击</p>
<p>异常测试：弱网、断网、码率切换测试、破坏性点击、切换前后台</p>
<p>兼容性测试：不同设备、不同网络、不同操作系统</p>
<p>- </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://viacheung.github.io/2023/06/04/Java_api%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="ViaCheung">
      <meta itemprop="description" content="el psy congroo">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="命运石之门">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/06/04/Java_api%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
	  <span class="post-time">

	  
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-06-04 01:03:17 / 修改时间：01:03:18" itemprop="dateCreated datePublished" datetime="2023-06-04T01:03:17+08:00">2023-06-04</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="比较器"><a href="#比较器" class="headerlink" title="比较器"></a>比较器</h2><pre><code>Arrays.sort(points, (a, b) -&gt; Integer.compare(a[0], b[0]));//表升序
   java.lang包的Integer类的compare()方法比较作为参数给出的两个整数值(x，y)，如果(x == y)则返回零，如果(x &lt;y)则返回小于零，如果(x&gt; y)，则返回大于零的值。
</code></pre>
<h2 id="Switch"><a href="#Switch" class="headerlink" title="Switch"></a>Switch</h2><p><img src="https://raw.githubusercontent.com/viacheung/img/main/image/image-20230225192923077.png#from=url&id=Gpkml&originHeight=563&originWidth=761&originalType=binary&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&title="></p>
<h2 id="Boolean-amp-boolean"><a href="#Boolean-amp-boolean" class="headerlink" title="Boolean &amp;boolean"></a>Boolean &amp;boolean</h2><p>一个是泛型 一个是普通类型</p>
<h3 id="超大数据"><a href="#超大数据" class="headerlink" title="超大数据"></a>超大数据</h3><p>BigDecimal b1 &#x3D; new BigDecimal(Double.toString(v1));<br>cnblogs.com&#x2F;zhangyinhua&#x2F;p&#x2F;11545305.html</p>
<h2 id="和-的区别"><a href="#和-的区别" class="headerlink" title="|和||的区别"></a><strong>|和||的区别</strong></h2><p>||会短路</p>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>int float double : 0<br>boolean: false<br>String : null<br>char : 空格<br>List&lt;int[]&gt; 转二维数组<br> ans.toArray(new int[ans.size()][]);<br>打印二维数组<br> System.out.println(Arrays.deepToString(intervals));<br>打印一维数组Arrays.toString();<br>返回二维数组<br> return new int[]{num0,num1};</p>
<h2 id="求长度三剑客"><a href="#求长度三剑客" class="headerlink" title="求长度三剑客"></a>求长度三剑客</h2><p><img src="https://raw.githubusercontent.com/viacheung/img/main/image/image-20220919155428203.png#from=url&id=vWlyI&originHeight=705&originWidth=1062&originalType=binary&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&title="></p>
<h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><p><strong>转Int</strong><br>Integer.valueOf()和Integer.parseInt()<br>valueOf(String)方法会返回Integer类的对象，而parseInt(String)方法返回原始的int值。<br>xx.valueOf(a) 把a转为xx类型； xx.valueOf(a，0，n) 表示把a转为xx类型，同时取下标从0开始的n个数据；<br><strong>判断字符串相等</strong><br>1、&#x3D;&#x3D; 引用<br>2、.equals() 内容 （用这个）</p>
<h2 id="StringBuilder"><a href="#StringBuilder" class="headerlink" title="StringBuilder"></a>StringBuilder</h2><p>添加：append<br>查询 CharAt<br>删除 deleteCharAt(index) delete(start,end)</p>
<h2 id="List系列"><a href="#List系列" class="headerlink" title="List系列"></a>List系列</h2><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/181428633">ArrayList</a><br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/182470738">LinkedList</a><br>add 添加<br>remove 删除</p>
<h2 id="Queue系列"><a href="#Queue系列" class="headerlink" title="Queue系列"></a>Queue系列</h2><ul>
<li><p><strong>ArrayDeque</strong>ArrayDeque 是 Java 集合中<strong>双端队列</strong>的<strong>数组实现</strong>，双端队列的链表实现（<strong>LinkedList</strong>）我们在前几篇文章中讲过了。ArrayDeque 几乎没有容量限制，设计为<strong>线程不安全的</strong>，<strong>禁止 null 元素</strong>。ArrayDeque 作为<strong>栈</strong>使用时<strong>比 Stack 类效率要高</strong>，作为<strong>队列</strong>使用时<strong>比 LinkedList 要快</strong>。</p>
<h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h3><p>ArrayList 类是一个可以动态修改的数组，与普通数组的区别就是它是没有固定大小的限制，我们可以添加或删除元素。<br><strong>添加元素</strong><br>ArrayList 类提供了很多有用的方法，添加元素到 ArrayList 可以使用 add() 方法:<br><strong>访问元素</strong><br>访问 ArrayList 中的元素可以使用 <strong>get()</strong> 方法<br><strong>修改元素</strong><br>如果要修改 ArrayList 中的元素可以使用 <strong>set()</strong> 方法：<br><strong>删除元素</strong><br>如果要删除 ArrayList 中的元素可以使用 <strong>remove()</strong> 方法：<br><strong>计算大小</strong><br>如果要计算 ArrayList 中的元素数量可以使用 <strong>size()</strong> 方法：<br><strong>判断相等</strong><br>.equals方法</p>
<h3 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h3><p>可以把他当作队列 数组 栈来看待，因此不用单独记忆其api<br>添加 add<br>移除最后元素： removeLast<br>获取最后一个元素：getLast<br>效果其实和Array</p>
<h3 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h3><p>不允许有重复元素 允许有 null 值 是无序的 不是线程安全的<br>同样 add() remove() size()<br>contains() 方法来判断元素是否存在于集合当中<br>检查数字是否在哈希集合中需要 O(1)的时间，而对于其他数据结构，则需要 O(n 的时间。选择正确的数据结构是解决这些问题的关键部分。</p>
<h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><p>散列表，存储的内容是键值对(key-value)映射。<br>实现了 Map 接口，根据键的 HashCode 值存储数据，具有很快的访问速度，最多允许一条记录的键为 null，不支持线程同步。<br>无序的，即不会记录插入的顺序。<br><strong>api:</strong><br>添加键值对(key-value)可以使用 put() 方法:<br>get(key) 方法来获取 key 对应的 value:<br>我们可以使用 remove(key) 方法来删除 key 对应的键值对(key-value):<br><strong>size()</strong> 方法：<br>isEmpty() containKey() containValue() entrySet() keySet() values()<br>Map的<strong>entrySet()方法</strong>返回一个实现Map.Entry接口的对象集合。集合中每个对象都是底层Map中一个特定的键&#x2F;值对。通过这个集合的迭代器，获得每一个条目(唯一获取方式)的键或值并对值进行更改。Map.Entry中的常用方法如下所示：<br>   (1) Object getKey(): 返回条目的关键字<br>(2) Object getValue(): 返回条目的值 (3) Object setValue(Object value): 将相关映像中的值改为value，并且返回旧值<br>Trie树<br>「前缀树」又叫「字典树」或「单词查找树」<br>「前缀树」的应用场景：给定一个字符串集合构建一棵前缀树，然后给一个字符串，判断前缀树中是否存在该字符串或者该字符串的前缀<br><strong>分析</strong><br>一般而言，字符串的集合都是仅由小写字母构成，所以本文章都是基于该情况展开分析！<br>字符串集合：[them, zip, team, the, app, that]。这个样例的前缀树长什么样呢？<br><img src="https://raw.githubusercontent.com/viacheung/img/main/image/1657540498-HHnzlV-1.svg#from=url&id=HNbuN&originHeight=521&originWidth=441&originalType=binary&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&title="><br>由于都是小写字母，所以对于每个节点，均有 26 个孩子节点，上图中没有画出来，省略了而已…，但是要记住：每个节点均有 26 个孩子节点<br>还有一个点要明确：节点仅仅表示从根节点到本节点的路径构成的字符串是否有效而已<br>对于上图中橙色的节点，均为有效节点，即：从根节点到橙色节点的路径构成的字符串均在集合中</p>
<pre><code>如果现在要看目标字符串 te 是否存在，分两步：
 首先看看表示 te 字符串的路径是否存在，这个例子是存在的
 其次看看该路径的终点处的节点是否有效，很遗憾，此处为白色，无效
 所以前缀 te 不存在！！
</code></pre>
<p><strong>构建前缀树 插入字符串 查找前缀过程</strong><br>&#96;&#96;&#96;<br>class Trie {<br>   &#x2F;&#x2F;结点定义<br>   class TrieNode {<br>   boolean val;<br>   TrieNode[] children &#x3D; new TrieNode[26];<br>   }<br>   &#x2F;&#x2F;根节点定义<br>   private TrieNode root;<br>   &#x2F;&#x2F;根节点初始化<br>   public Trie() {<br>   root &#x3D; new TrieNode();<br>   }</p>
<p>   public void insert(String word) {<br>   TrieNode p &#x3D; root;<br>   for (char c : word.toCharArray()) {<br>       int i &#x3D; c - ‘a’;<br>       if (p.children[i] &#x3D;&#x3D; null) p.children[i] &#x3D; new TrieNode();<br>       p &#x3D; p.children[i];<br>   }<br>   p.val &#x3D; true;<br>   }<br>   &#x2F;&#x2F;查询<br>   public boolean search(String word) {<br>   TrieNode p &#x3D; root;<br>   for (char c : word.toCharArray()) {<br>       int i &#x3D; c - ‘a’;<br>       if (p.children[i] &#x3D;&#x3D; null) return false;<br>       p &#x3D; p.children[i];<br>   }<br>   return p.val;&#x2F;&#x2F;成功，返回值（看看此处存不存在值）<br>   }<br>   &#x2F;&#x2F;查询前缀<br>   public boolean startsWith(String prefix) {<br>   TrieNode p &#x3D; root;<br>   for (char c : prefix.toCharArray()) {<br>       int i &#x3D; c - ‘a’;<br>       if (p.children[i] &#x3D;&#x3D; null) return false;<br>       p &#x3D; p.children[i];<br>   }<br>   return true;&#x2F;&#x2F;和查询一样的思路，只是返回的是true而已<br>   }</p>
</li>
</ul>
<p> }</p>
<pre><code>
</code></pre>
<p>&#x2F;&#x2F;官方解法<br> class Trie {<br>     private Trie[] children;&#x2F;&#x2F;定义两个成员变量<br>     private boolean isEnd;&#x2F;&#x2F;</p>
<pre><code> public Trie() &#123;
     //两个成员变量
     children = new Trie[26];
     isEnd = false;
 &#125;
 //构建
 public void insert(String word) &#123;
     Trie node = this;
     for (int i = 0; i &lt; word.length(); i++) &#123;
         char ch = word.charAt(i);
         int index = ch - &#39;a&#39;;//转化为数字，从左边往右边a到z
         if (node.children[index] == null) &#123;
             node.children[index] = new Trie();//如果为空的话构建
         &#125;
         node = node.children[index];//向下移动
     &#125;
     node.isEnd = true;//置为true
 &#125;
 
 public boolean search(String word) &#123;
     Trie node = searchPrefix(word);
     return node != null &amp;&amp; node.isEnd;//需要既是非Null，也得是最后一个(isend为true)
 &#125;
 
 public boolean startsWith(String prefix) &#123;
     return searchPrefix(prefix) != null;//看查到的node结点是否存在就行，因为是前缀，不用管Isend
 &#125;
 //查前缀
 private Trie searchPrefix(String prefix) &#123;
     Trie node = this;//指向当前对象的指针  可以理解为指向trie的根部节点
     for (int i = 0; i &lt; prefix.length(); i++) &#123;
         char ch = prefix.charAt(i);
         int index = ch - &#39;a&#39;;
         if (node.children[index] == null) &#123;
             return null;//发现其中一个为null就肯定查询失败
         &#125;
         node = node.children[index];
     &#125;
     return node;//返回最后一个Node，此时还没判断是否为Null,此时路径没问题
 &#125;
</code></pre>
<p> }</p>
<pre><code>时间复杂度：O(∣S∣)，其中 ∣S∣是每次插入或查询的字符串的长度。
空间复杂度：O(∣T∣⋅Σ)，其中 ∣T∣为所有插入字符串的长度之和，Σ 为字符集的大小，本题 Σ=26
官方题解的for可以用增强for循环
## ACM
nextInt()：读取到空格或回车之后结束本次的int值；同理还有nextDouble() 、nextFloat()、nextInt()
 int n=sc.nextInt();只获取数字 换行符需要sc.nextLine();拿掉
第二个字符串排序就不用nextLine了
next()：直至读取到空格或回车之后结束本次的String值，不可读取回车；nextLine()：直至读取到换行符（回车）之后结束本次读取的String，可读取回车（空值）hasNextInt()：判断控制台接收是否为数字,是则接收 hasNextInt()只起到判断作用而不是接收数据
导包建议：
 import java.util.*;
**例子：**
输入描述:输入有两行，第一行n
第二行是n个字符串，字符串之间用空格隔开输出描述:输出一行排序后的字符串，空格隔开，无结尾空格
</code></pre>
<p>import java.util.*;<br> public class Main {<br>   public static void main(String[] args) {<br>       Scanner sc &#x3D; new Scanner(System.in);<br>       int n&#x3D;sc.nextInt();<br>       String enter&#x3D;sc.nextLine();&#x2F;&#x2F;把换车符拿掉<br>       String line&#x3D;sc.nextLine();<br>       String[] s&#x3D;line.split(“ “);&#x2F;&#x2F;转为数组好排序<br>       Arrays.sort(s);<br>       StringBuilder sb&#x3D;new StringBuilder();<br>       for(String ss:s){<br>           sb.append(ss).append(“ “);<br>       }<br>       String s1 &#x3D; sb.toString();<br>       System.out.println(s1.substring(0,s1.length()-1));<br>   }<br> }</p>
<pre><code>### 接受输入的字符a
</code></pre>
<p>String b &#x3D; in.next<br> if(b.equals(“a”))</p>
<pre><code>### 格式化输出
System.out.printf(&quot;%.11f&quot;, ans+sum);//.11表示位数
</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://viacheung.github.io/2023/06/04/%E6%95%B0%E7%BB%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="ViaCheung">
      <meta itemprop="description" content="el psy congroo">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="命运石之门">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/06/04/%E6%95%B0%E7%BB%84/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
	  <span class="post-time">

	  
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-06-04 01:02:43 / 修改时间：01:02:44" itemprop="dateCreated datePublished" datetime="2023-06-04T01:02:43+08:00">2023-06-04</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="API、经验"><a href="#API、经验" class="headerlink" title="API、经验"></a>API、经验</h2><h4 id="填充数组"><a href="#填充数组" class="headerlink" title="填充数组"></a><strong>填充数组</strong></h4><pre><code>一维数组
 boolean[] a1 = new boolean[5];
     Arrays.fill( a1,true );
 Arrays.fill( a1,3,4,false);//下标3变为false 左开右闭
 二维数组  把一维数组当作一个对象
  int[][] map=new int[4][5];
    int[] ten=new int[10];
    Arrays.fill(ten, -1);
    Arrays.fill(map,ten);  //成功
</code></pre>
<h4 id="填充集合"><a href="#填充集合" class="headerlink" title="填充集合"></a>填充集合</h4><p>  Collections.fill();</p>
<h4 id="判断数组相等"><a href="#判断数组相等" class="headerlink" title="判断数组相等"></a><strong>判断数组相等</strong></h4><p>Arrays.equals（a,b)</p>
<h4 id="边界条件"><a href="#边界条件" class="headerlink" title="边界条件"></a>边界条件</h4><p>数组可以为空也可以长度为0，都要考虑</p>
<pre><code>if(nums==null||nums.length==0)&#123;
     return 0;
 &#125;
</code></pre>
<h4 id="新建包含一定元素的可变数组"><a href="#新建包含一定元素的可变数组" class="headerlink" title="新建包含一定元素的可变数组"></a>新建包含一定元素的可变数组</h4><pre><code>int[] ans=new int[]&#123;1,1,1&#125;;
 
 Arrays.asList(nums[i],nums[j],nums[k]);
</code></pre>
<h4 id="数组排序"><a href="#数组排序" class="headerlink" title="数组排序"></a>数组排序</h4><pre><code>1、Arrays.sort(a, Collections.reverseOrder());//a需要是Integer
 2、实现Comparator接口 复写compare方法 return o2 - o1;
</code></pre>
<h2 id="59-螺旋矩阵-II（√）"><a href="#59-螺旋矩阵-II（√）" class="headerlink" title="59 螺旋矩阵 II（√）"></a>59 螺旋矩阵 II（√）</h2><p>给你一个正整数 n ，生成一个包含 1 到 n2 所有元素，且元素按顺时针顺序螺旋排列的 n x n 正方形矩阵 matrix	<br>遍历，边界记得变化一下<br><img src="https://raw.githubusercontent.com/viacheung/img/main/image/image-20221013000130186.png#from=url&id=TF9xq&originHeight=348&originWidth=468&originalType=binary&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&title="><br><img src="https://raw.githubusercontent.com/viacheung/img/main/image/image-20221013000449047.png#from=url&id=h6laW&originHeight=705&originWidth=896&originalType=binary&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&title="></p>
<pre><code>class Solution &#123;
     public int[][] generateMatrix(int n) &#123;
         int l = 0, r = n - 1, t = 0, b = n - 1;
         int[][] mat = new int[n][n];
         int num = 1, tar = n * n;
         while(num &lt;= tar)&#123;
             //先mat[t][i] = num  再num++
             for(int i = l; i &lt;= r; i++) mat[t][i] = num++; // left to right.
             //for循环外面做t++
             t++;
             for(int i = t; i &lt;= b; i++) mat[i][r] = num++; // top to bottom.
             r--;
             for(int i = r; i &gt;= l; i--) mat[b][i] = num++; // right to left.
             b--;
             for(int i = b; i &gt;= t; i--) mat[i][l] = num++; // bottom to top.
             l++;
         &#125;
         return mat;
     &#125;
 &#125;
</code></pre>
<h2 id="最短无序连续子数组（√）"><a href="#最短无序连续子数组（√）" class="headerlink" title="最短无序连续子数组（√）"></a>最短无序连续子数组（√）</h2><p>给你一个整数数组 nums ，你需要找出一个 连续子数组 ，如果对这个子数组进行升序排序，那么整个数组都会变为升序排序。<br>请你找出符合题意的 最短 子数组，并输出它的长度。<br>1、遍历找排序入口和排序出口<br>2、中间找最大最小值<br>3、遍历找左边小于min的值，找右边大于max值<br>4、结果</p>
<pre><code>class Solution &#123;
     public int findUnsortedSubarray(int[] nums) &#123;
         int n = nums.length;
         int max = Integer.MIN_VALUE, min = Integer.MAX_VALUE;
         int left = 0, right = 0;
         //找到排序的入口
         //注意数组越界
         for(int i = 1; i &lt; n; i++)&#123;
             if(nums[i] &lt; nums[i - 1])&#123;
                 left = i - 1;//记录严格升序的最后一个元素
                 break;
             &#125;
         &#125;
         //找到排序的出口
         for(int i = n - 1; i &gt; 0; i--)&#123;
             if(nums[i] &lt; nums[i - 1])&#123;
                 right = i;//记录严格升序的第一个元素
                 break;
             &#125;
         &#125;
         //找到最大最小值
         for(int i = left; i &lt;= right; i++)&#123;
             max = Math.max(nums[i], max);
             min = Math.min(nums[i], min);
         &#125;
         //l向左扩展，r向右扩展
         //找到比Min小的 因为max min 已经是在l-r里面产生，因此需要从l-1 r+1开始比较
         while(left &gt; 0 &amp;&amp; nums[left - 1] &gt; min) left --;
         //找到比max大的
         while(right &lt; n - 1 &amp;&amp; nums[right + 1] &lt; max) right ++;
         if(left == right) return 0;//决定了我的初始l r的取值就得是0 0
         return right - left + 1;
     &#125;
 &#125;
</code></pre>
<h2 id="寻找重复数（√）"><a href="#寻找重复数（√）" class="headerlink" title="寻找重复数（√）"></a>寻找重复数（√）</h2><p>给定一个包含 n + 1 个整数的数组 nums ，其数字都在 [1, n] 范围内（包括 1 和 n），可知至少存在一个重复的整数。<br>假设 nums 只有 一个重复的整数 ，返回 这个重复的数 。<br>你设计的解决方案必须 不修改 数组 nums 且只用常量级 O(1) 的额外空间。<br><strong>快慢指针(floyd判圈算法)</strong><br><img src="https://raw.githubusercontent.com/viacheung/img/main/image/image-20220923113728679.png#from=url&id=QaGhU&originHeight=272&originWidth=1048&originalType=binary&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&title="><br><strong>结论：不管是什么数据结构，用上快慢指针，快慢指针相遇之后，把slow放起点，两个指针同时移动，必然于入环点相遇，也就是答案，包括之前的环形链表II</strong></p>
<pre><code>class Solution &#123;
     public int findDuplicate(int[] nums) &#123;
         int slow = 0, fast = 0;
         //初始化随便写
         slow=nums[slow];
         fast=nums[nums[fast]];
         //不用单独建环，思路就是环的思想，数组里面快慢指针不能像像链表那样next next.next，但我们想象有i-&gt;nums[i]的边，也就与链表无异了,即  nums[slow]   nums[nums[fast]]
         while(fast!=slow)&#123;
             slow=nums[slow];
             fast=nums[nums[fast]];  
         &#125;
         slow = 0;//相遇之后的骚操作     slow 回到起点
         while (slow != fast) &#123;
             slow = nums[slow];
             fast = nums[fast];
         &#125;
         //此时slow和fast相等 因此重复元素必然就是slow 直接返回即可
         return slow;
     &#125;
 &#125;
</code></pre>
<h2 id="移动零"><a href="#移动零" class="headerlink" title="移动零"></a>移动零</h2><pre><code>输入: nums = [0,1,0,3,12]
 输出: [1,3,12,0,0]
</code></pre>
<p>我的思路：双指针，左右指针都指向数组最左侧，左指针找到第一个为0的数字，右指针往右找到第一个非0数字，交换，注意边界条件，<strong>很Tm烦人</strong> 不可取</p>
<pre><code>class Solution &#123;
     public void moveZeroes(int[] nums) &#123;
         int n=nums.length,left=0,right=0;
         //left到倒数第二个的时候已经没必要继续下去
         while(left&lt;n-1)&#123;
             if(nums[left]==0)&#123;
                 right=left+1; 
                 while(right&lt;n&amp;&amp;nums[right]==0)&#123;
                     right++;
                     //有可能right=n-1且nums[n-1]=0，防止right出界 swap函数数组越界
                     if(right&gt;=n) return;
                 &#125;
                 swap(nums,left,right);
             &#125;
             left++;
         &#125;
 
     &#125;
     public void swap(int[] nums,int i,int j)&#123;
             int tmp=nums[i];
             nums[i]=nums[j];
             nums[j]=tmp;
     &#125;
 &#125;
</code></pre>
<p>代码随想录方法<br><strong>双指针</strong> （推荐这个） slow指针存元素 fast管遍历&#x3D;&#x3D;</p>
<pre><code>public void moveZeroes(int[] nums) &#123;
         int slow = 0;
     //   fast用来遍历，nums[fast] != 0的话，slow就存储nums[fast]
         for (int fast = 0; fast &lt; nums.length; fast++) &#123;
             if (nums[fast] != 0) &#123;
                 nums[slow++] = nums[fast];
             &#125;
         &#125;
         // 后面的元素全变成 0
         for (int j = slow; j &lt; nums.length; j++) &#123;
             nums[j] = 0;
         &#125;
     &#125;
</code></pre>
<h2 id="除自身以外数组的乘积（√）"><a href="#除自身以外数组的乘积（√）" class="headerlink" title="除自身以外数组的乘积（√）"></a>除自身以外数组的乘积（√）</h2><p>题目：给你一个整数数组 nums，返回 <em>数组 answer ，其中 answer[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积</em> 。<br>给定两个概念，L数组 R数组<br>L[i] 代表的是 i 左侧所有数字的乘积，R[i] 代表的是 i 右侧所有数字的乘积。<br><img src="https://raw.githubusercontent.com/viacheung/img/main/image/image-20220920154818329.png#from=url&id=w4qbc&originHeight=256&originWidth=1017&originalType=binary&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&title="><br>改进算法：空间复杂度 O(1) 的方法<br><img src="https://raw.githubusercontent.com/viacheung/img/main/image/image-20220920154907687.png#from=url&id=UduWL&originHeight=286&originWidth=1050&originalType=binary&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&title="></p>
<pre><code>//我的代码
 class Solution &#123;
     public int[] productExceptSelf(int[] nums) &#123;
         int[] answer=new int[nums.length];
         int L=1;
         answer[0]=1;//显而易见
         //L数组
         for(int i=1;i&lt;nums.length;i++)&#123;
             answer[i]=nums[i-1]*L;
             L=L*nums[i-1];
         &#125;
         //i=num.length-1不用变
         int R=1;
         for(int i=nums.length-2;i&gt;=0;i--)&#123;
             R=R*nums[i+1];
             answer[i]=answer[i]*R;
         &#125;
         return answer;
     &#125;
 &#125;
</code></pre>
<h2 id="滚动数组"><a href="#滚动数组" class="headerlink" title="滚动数组"></a>滚动数组</h2><p>结果只和前两个数据有关系，可以采用滚动数组，复杂度可以从O（n)降低到O（1）；</p>
<h2 id="多数元素（√）"><a href="#多数元素（√）" class="headerlink" title="多数元素（√）"></a>多数元素（√）</h2><p>给定一个大小为 n 的数组 nums ，返回其中的多数元素。多数元素是指在数组中出现次数 大于 ⌊ n&#x2F;2 ⌋ 的元素。<br>你可以假设数组是非空的，并且给定的数组总是存在多数元素。<br><img src="https://raw.githubusercontent.com/viacheung/img/main/image/image-20220917190606201.png#from=url&id=nQdy9&originHeight=388&originWidth=1130&originalType=binary&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&title="></p>
<pre><code>class Solution &#123;
     private Map&lt;Integer, Integer&gt; countNums(int[] nums) &#123;
         Map&lt;Integer, Integer&gt; counts = new HashMap&lt;Integer, Integer&gt;();
         for (int num : nums) &#123;
             //不包含设为1 包含就加一
             if (!counts.containsKey(num)) &#123;
                 counts.put(num, 1);
             &#125; else &#123;
                 counts.put(num, counts.get(num) + 1);
             &#125;
         &#125;
         return counts;
     &#125;
 
     public int majorityElement(int[] nums) &#123;
         Map&lt;Integer, Integer&gt; counts = countNums(nums);
 
         Map.Entry&lt;Integer, Integer&gt; majorityEntry = null;//定义一下
         for (Map.Entry&lt;Integer, Integer&gt; entry : counts.entrySet()) &#123;
             //打擂台，挑选出value最大的entry作为majorityEntry
             //这里要加majorityEntry == null的原因是防止出现NullPointerException，majorityEntry为Null时， majorityEntry.getValue()无法执行
             if (majorityEntry == null || entry.getValue() &gt; majorityEntry.getValue()) &#123;
                 majorityEntry = entry;
             &#125;
         &#125;
 
         return majorityEntry.getKey();
     &#125;
 &#125;
</code></pre>
<p>推荐这个快一点<br><img src="https://raw.githubusercontent.com/viacheung/img/main/image/image-20220911115300392.png#from=url&id=D2Ngc&originHeight=812&originWidth=1235&originalType=binary&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&title="><br>但这个复杂度是nlog(n)</p>
<h3 id="方法五"><a href="#方法五" class="headerlink" title="方法五"></a>方法五</h3><h4 id="Boyer-Moore-投票算法"><a href="#Boyer-Moore-投票算法" class="headerlink" title="Boyer-Moore 投票算法"></a>Boyer-Moore 投票算法</h4><p>我们维护一个候选众数 candidate 和它出现的次数 count。初始时 candidate 可以为任意值，count 为 0；<br>我们遍历数组 nums 中的所有元素，对于每个元素 x，在判断 x 之前，如果 count 的值为 0，我们先将 x 的值赋予 candidate，随后我们判断 x：<br>    如果 x 与 candidate 相等，那么计数器 count 的值增加 1；<br>    如果 x 与 candidate 不等，那么计数器 count 的值减少 1。<br>在遍历完成后，candidate 即为整个数组的众数。</p>
<pre><code>class Solution &#123;
     public int majorityElement(int[] nums) &#123;
         int count = 0;
         Integer candidate = null;
         for (int num : nums) &#123;
             if (count == 0) &#123;
                 candidate = num;
             &#125;
             count += (num == candidate) ? 1 : -1;
         &#125;
         return candidate;
     &#125;
 &#125;
</code></pre>
<h2 id="搜索二维矩阵（Z查找）（√）"><a href="#搜索二维矩阵（Z查找）（√）" class="headerlink" title="搜索二维矩阵（Z查找）（√）"></a>搜索二维矩阵（Z查找）（√）</h2><p>编写一个高效的算法来搜索 m x n 矩阵 matrix 中的一个目标值 target 。该矩阵具有以下特性：<br>每行的元素从左到右升序排列。 每列的元素从上到下升序排列。<br><img src="https://raw.githubusercontent.com/viacheung/img/main/image/searchgrid2.jpg#from=url&id=Jyu9h&originHeight=402&originWidth=402&originalType=binary&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&title="><br><strong>方法一</strong><br>直接查找 复杂度O（mn）</p>
<pre><code>class Solution &#123;
     public boolean searchMatrix(int[][] matrix, int target) &#123;
         for (int[] row : matrix) &#123;
             for (int element : row) &#123;
                 if (element == target) &#123;
                     return true;
                 &#125;
             &#125;
         &#125;
         return false;
     &#125;
 &#125;
</code></pre>
<p><strong>方法二：</strong><br>二分</p>
<pre><code>class Solution &#123;
     public boolean searchMatrix(int[][] matrix, int target) &#123;
         for (int[] row : matrix) &#123;
             int index = search(row, target);
             if (index &gt;= 0) &#123;
                 return true;
             &#125;
         &#125;
         return false;
     &#125;
 
     public int search(int[] nums, int target) &#123;
         int low = 0, high = nums.length - 1;
         while (low &lt;= high) &#123;
             int mid = (high - low) / 2 + low;
             int num = nums[mid];
             if (num == target) &#123;
                 return mid;
             &#125; else if (num &gt; target) &#123;
                 high = mid - 1;
             &#125; else &#123;
                 low = mid + 1;
             &#125;
         &#125;
         return -1;
     &#125;
 &#125;
</code></pre>
<p><strong>方法三（掌握这个）</strong><br><img src="https://raw.githubusercontent.com/viacheung/img/main/image/image-20220921123558099.png#from=url&id=emGF7&originHeight=380&originWidth=949&originalType=binary&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&title="><br>我的理解：必须从右上角开始搜索，保证我搜索到的元素在行是最大值，在列是小值，因此如果我元素大于target，则列的最小值大于target（整个列都大于target），列–；小于target，则列的最大值小于target(整个行小于target)，行++</p>
<pre><code>class Solution &#123;
     public boolean searchMatrix(int[][] matrix, int target) &#123;
         int m = matrix.length, n = matrix[0].length;
         int x = 0, y = n - 1;
         while (x &lt; m &amp;&amp; y &gt;= 0) &#123;
             if (matrix[x][y] == target) &#123;
                 return true;
             &#125;
             if (matrix[x][y] &gt; target) &#123;
                 --y;
             &#125; else &#123;
                 ++x;
             &#125;
         &#125;
         return false;
     &#125;
 &#125;
</code></pre>
<h2 id="空间时间复杂度"><a href="#空间时间复杂度" class="headerlink" title="空间时间复杂度"></a>空间时间复杂度</h2><p><img src="https://raw.githubusercontent.com/viacheung/img/main/image/image-20221001122257963.png#from=url&id=qsNQi&originHeight=549&originWidth=1218&originalType=binary&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&title="></p>
<h2 id="有多少小于当前数字的数字"><a href="#有多少小于当前数字的数字" class="headerlink" title="有多少小于当前数字的数字"></a>有多少小于当前数字的数字</h2><p>给你一个数组 nums，对于其中每个元素 nums[i]，请你统计数组中比它小的所有数字的数目。<br>换而言之，对于每个 nums[i] 你必须计算出有效的 j 的数量，其中 j 满足 j !&#x3D; i<strong>且</strong>nums[j] &lt; nums[i] 。<br>以数组形式返回答案。<br>题解：</p>
<pre><code>class Solution &#123;
     public int[] smallerNumbersThanCurrent(int[] nums) &#123;
         [8,1,2,2,3]
         Map&lt;Integer,Integer&gt; map=new HashMap&lt;&gt;();
         //copy nums的值到res
         int[] res=Arrays.copyOf(nums,nums.length);//[I@7e774085 不能这样(int[] res=nums)拷贝数据  只是一个引用
         Arrays.sort(res); //1，2，2，3，8
         for(int i=0;i&lt;res.length;i++)&#123;
             if(!map.containsKey(res[i]))&#123;
                 map.put(res[i],i);  (1,0)  (2,1)  (3,3)  (8,4)
             &#125;
         &#125;
         for(int i=0;i&lt;nums.length;i++)&#123;
             res[i]=map.get(nums[i]);
             4 0 1 1 3
         &#125;
         return res;
     &#125;
 &#125;
</code></pre>
<h2 id="有效的山脉数组"><a href="#有效的山脉数组" class="headerlink" title="有效的山脉数组"></a>有效的山脉数组</h2><p>给定一个整数数组 arr，如果它是有效的山脉数组就返回 true，否则返回 false。<br>让我们回顾一下，如果 arr 满足下述条件，那么它是一个山脉数组<br><img src="https://raw.githubusercontent.com/viacheung/img/main/image/hint_valid_mountain_array.png#from=url&id=orSD0&originHeight=563&originWidth=892&originalType=binary&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&title="><br><strong>思路</strong><br>判断是山峰，主要就是要严格的保存左边到中间，和右边到中间是递增的。<br>这样可以使用两个指针，left和right，让其按照如下规则移动，如图：<br><img src="https://raw.githubusercontent.com/viacheung/img/main/image/941.%E6%9C%89%E6%95%88%E7%9A%84%E5%B1%B1%E8%84%89%E6%95%B0%E7%BB%84.png#from=url&id=Z7L1U&originHeight=552&originWidth=1234&originalType=binary&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&title="><br><strong>注意这里还是有一些细节，例如如下两点：</strong></p>
<ul>
<li>因为left和right是数组下标，移动的过程中注意不要数组越界</li>
<li>如果left或者right没有移动，说明是一个单调递增或者递减的数组，依然不是山峰<pre><code>class Solution &#123;
   public boolean validMountainArray(int[] arr) &#123;
       // 双指针
       int n=arr.length;
       int left=0,right=n-1;
       while(left+1&lt;n&amp;&amp;arr[left]&lt;arr[left+1])&#123;
           left++;
       &#125;
       while(right-1&gt;=0&amp;&amp;arr[right]&lt;arr[right-1])&#123;
           right--;
       &#125;
       if(right==left&amp;&amp;right!=n-1&amp;&amp;left!=0)&#123;
           return true;
       &#125;       
       return false;
   &#125;
 &#125;
</code></pre>
<h2 id="独一无二的出现次数"><a href="#独一无二的出现次数" class="headerlink" title="独一无二的出现次数"></a>独一无二的出现次数</h2>给你一个整数数组 arr，请你帮忙统计数组中每个数的出现次数。<br>如果每个数的出现次数都是独一无二的，就返回 true；否则返回 false。<br>&#96;&#96;&#96;<br>class Solution {<br>   public boolean uniqueOccurrences(int[] arr) {<br>   Set<Integer> set&#x3D;new HashSet&lt;&gt;();<br>   Map&lt;Integer,Integer&gt; map&#x3D;new HashMap&lt;&gt;();<br>   &#x2F;&#x2F;统计一下<br>   for(int a:arr){<br>       map.put(a,map.getOrDefault(a,0)+1);<br>   }<br>   &#x2F;&#x2F;验证value是否重复    values()是所有value的集合<br>   for(int b:map.values()){<br>       if(!set.add(b)) return false;<br>   }<br>   return true;<br>   }</Integer></li>
</ul>
<p> }</p>
<pre><code>## 轮转数组
给你一个数组，将数组中的元素向右轮转 k 个位置，其中 k 是非负数。
</code></pre>
<p>输入: nums &#x3D; [1,2,3,4,5,6,7], k &#x3D; 3<br> 输出: [5,6,7,1,2,3,4]<br> 解释:<br> 向右轮转 1 步: [7,1,2,3,4,5,6]<br> 向右轮转 2 步: [6,7,1,2,3,4,5]<br> 向右轮转 3 步: [5,6,7,1,2,3,4]</p>
<pre><code>我的思路
</code></pre>
<p>class Solution {<br>     public void rotate(int[] nums, int k) {<br>         int n&#x3D;nums.length;<br>         &#x2F;&#x2F;不是原地操作<br>         int[] value&#x3D;Arrays.copyOf(nums,n);<br>         for(int i&#x3D;0;i&lt;n;i++){<br>             nums[i]&#x3D;value[(n-k%n+i)%n];<br>         }<br>     }<br> }</p>
<pre><code>原地操作
**双指针**

1. 反转整个字符串
2. 反转区间为前k的子串
3. 反转区间为k到末尾的子串

**如果k大于nums.size了应该怎么办？其实就是右移 k % nums.size() 次，即：15 % 7 = 1**
</code></pre>
<p>class Solution {<br>     public void rotate(int[] nums, int k) {<br>         int n&#x3D;nums.length;<br>         k%&#x3D;n;<br>         reverse(nums,0,n-1);<br>         reverse(nums,0,k-1);<br>         reverse(nums,k,n-1);<br>     }<br>     public void reverse(int[] nums,int left,int right){<br>         for(int i&#x3D;left,j&#x3D;right;i&lt;j;i++,j–){<br>             int temp&#x3D;nums[i];<br>             nums[i]&#x3D;nums[j];<br>             nums[j]&#x3D;temp;<br>         }<br>     }<br> }</p>
<pre><code>## 寻找数组的中心下标
给你一个整数数组 nums ，请计算数组的 **中心下标** 。
数组 **中心下标** 是数组的一个下标，其左侧所有元素相加的和等于右侧所有元素相加的和。
如果中心下标位于数组最左端，那么左侧数之和视为 0 ，因为在下标的左侧不存在元素。这一点对于中心下标位于数组最右端同样适用。
如果数组有多个中心下标，应该返回 **最靠近左边** 的那一个。如果数组不存在中心下标，返回 -1 。
</code></pre>
<p>class Solution {<br>     public int pivotIndex(int[] nums) {<br>         int n&#x3D;nums.length;<br>         int sum&#x3D;0;<br>         &#x2F;&#x2F;计算总和<br>         for(int i&#x3D;0;i&lt;n;i++){<br>             sum+&#x3D;nums[i];<br>         }<br>         &#x2F;&#x2F;左总和<br>         int sum_left&#x3D;0;<br>         for(int i&#x3D;0;i&lt;n;i++){<br>             &#x2F;&#x2F;sum-当前元素值等于2倍的左总和  那么找到<br>             if(sum-nums[i]&#x3D;&#x3D;2*sum_left){<br>                 return i;<br>             }<br>             sum_left+&#x3D;nums[i];<br>         }<br>         return -1;<br>     }<br> }</p>
<pre><code>## 在排序数组中查找元素的第一个和最后一个位置
给你一个按照非递减顺序排列的整数数组 nums，和一个目标值 target。请你找出给定目标值在数组中的开始位置和结束位置。
如果数组中不存在目标值 target，返回 [-1, -1]。
你必须设计并实现时间复杂度为 O(log n) 的算法解决此问题。
</code></pre>
<p>class Solution {<br>         public int[] searchRange(int[] nums, int target) {<br>             int l &#x3D; searh(nums, target);<br>             int r &#x3D; searh(nums, target + 1);&#x2F;&#x2F;很妙<br>             &#x2F;&#x2F;if语句第一个边界条件是空数组 第二个是数组无target<br>             if (l &#x3D;&#x3D; nums.length || nums[l] !&#x3D; target) {<br>                 return new int[]{-1,-1};<br>             } else {<br>                 return new int[]{l,r-1};<br>             }<br>         }<br>         public int searh(int[] nums, int target) {<br>             int l &#x3D; 0, r &#x3D; nums.length - 1, ans &#x3D; nums.length;<br>             while (l &lt;&#x3D; r) {<br>                 int mid &#x3D; (l + r) &#x2F; 2;<br>                 if (nums[mid] &gt;&#x3D; target) {<br>                     r &#x3D; mid - 1;<br>                 } else {<br>                     l &#x3D; mid + 1;<br>                 }<br>                 ans &#x3D; l;<br>             }<br>             return ans;<br>         }</p>
<pre><code> &#125;
</code></pre>
<pre><code>## 按奇偶排序数组 II
给定一个非负整数数组 nums， nums 中一半整数是 **奇数** ，一半整数是 **偶数** 。
对数组进行排序，以便当 nums[i] 为奇数时，i 也是 **奇数** ；当 nums[i] 为偶数时， i 也是 **偶数** 。
你可以返回 _任何满足上述条件的数组作为答案_
</code></pre>
<p>&#x2F;&#x2F;方法一：采用额外的数组空间<br> class Solution {<br>     public int[] sortArrayByParityII(int[] nums) {<br>         &#x2F;&#x2F;定义结果数组 result<br>         int[] result &#x3D; new int[nums.length];<br>         int even &#x3D; 0, odd &#x3D; 1;<br>         for(int i &#x3D; 0; i &lt; nums.length; i++){<br>             &#x2F;&#x2F;如果为偶数<br>             if(nums[i] % 2 &#x3D;&#x3D; 0){<br>                 result[even] &#x3D; nums[i];<br>                 even +&#x3D; 2;<br>             }else{<br>                 result[odd] &#x3D; nums[i];<br>                 odd +&#x3D; 2;<br>             }<br>         }<br>         return result;<br>     }<br> }</p>
<pre><code>## 搜索插入位置
给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。
请必须使用时间复杂度为 O(log n) 的算法。
**题解:**
只要看到面试题里给出的数组是有序数组，都可以想一想是否可以使用二分法。
</code></pre>
<p>class Solution {<br>     public int searchInsert(int[] nums, int target) {<br>         int l&#x3D;0,r&#x3D;nums.length-1;<br>         while(l&lt;&#x3D;r){<br>             int mid&#x3D;l+(r-l)&#x2F;2;<br>             if(nums[mid]&gt;target){<br>                 r&#x3D;mid-1;<br>             }else if(nums[mid]&lt;target){<br>                 l&#x3D;mid+1;<br>             }else{<br>                 return mid;<br>             }<br>         }<br>         return r+1;<br>     }<br> }</p>
<pre><code>
 
</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://viacheung.github.io/2023/06/04/%E9%93%BE%E8%A1%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="ViaCheung">
      <meta itemprop="description" content="el psy congroo">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="命运石之门">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/06/04/%E9%93%BE%E8%A1%A8/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
	  <span class="post-time">

	  
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-06-04 01:02:36" itemprop="dateCreated datePublished" datetime="2023-06-04T01:02:36+08:00">2023-06-04</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>常用方法：dummyNode空结点 、双指针、快慢指针<br>链表好多都可以用递归或者迭代，递归简洁不好想，递归好理解<br>ListNode是由自己定义的java中的链表对象<br><img src="https://raw.githubusercontent.com/viacheung/img/main/image/image-20220915164549004.png#from=url&id=jmahs&originHeight=199&originWidth=919&originalType=binary&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&title="><br>类结构如下</p>
<pre><code>public class ListNode &#123;
        int val;
        ListNode next;
        public ListNode(int x) &#123;
             val = x;
        &#125;
 &#125;
</code></pre>
<h2 id="删除链表结点"><a href="#删除链表结点" class="headerlink" title="删除链表结点"></a>删除链表结点</h2><pre><code>class Solution &#123;
     public ListNode removeElements(ListNode head, int val) &#123;
         ListNode dumyNode=new ListNode();
         dumyNode.next=head;
         ListNode cur=dumyNode;
         while(cur.next!=null)&#123;
             if(cur.next.val==val)&#123;
                 cur.next=cur.next.next;
             &#125;else&#123;
                 cur=cur.next;
             &#125;
         &#125;
         return dumyNode.next;
     &#125;
 &#125;
</code></pre>
<h2 id="删除链表的倒数第-N-个结点"><a href="#删除链表的倒数第-N-个结点" class="headerlink" title="删除链表的倒数第 N 个结点"></a>删除链表的倒数第 N 个结点</h2><p>给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。<br>方法一：一种容易想到的方法是，我们首先从头节点开始对链表进行一次遍历，得到链表的长度 L。随后我们再从头节点开始对链表进行一次遍历，当遍历到第 L−n+1 个节点时，它就是我们需要删除的节点。<br>方法二：我们也可以在遍历链表的同时将所有节点依次入栈。根据栈「先进后出」的原则，我们弹出栈的第 n 个节点就是需要删除的节点，并且目前栈顶的节点就是待删除节点的前驱节点。这样一来，删除操作就变得十分方便了。<br><img src="https://raw.githubusercontent.com/viacheung/img/main/image/image-20221015173826107.png#from=url&id=I1dqL&originHeight=414&originWidth=941&originalType=binary&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&title="><br> ListNode dummy &#x3D; new ListNode(0, head);&#x2F;&#x2F;val为0 下一个结点为head</p>
<pre><code>//我喜欢方法三
 class Solution &#123;
     public ListNode removeNthFromEnd(ListNode head, int n) &#123;
         // 双指针
         ListNode dummyNode =new ListNode(0);
         dummyNode.next=head;
         //用dummyNode好删除
         ListNode node1=dummyNode;
         ListNode node2=dummyNode;
         //Node1先往后移动n个位置
         for(int i=0;i&lt;n;i++)&#123;
              node1=node1.next;
         &#125;
         //这俩同时移动 node1.next!=null这个判断条件是为了到最后一个节点 而不是null节点
         while(node1.next!=null)&#123;
             node1=node1.next;
             node2=node2.next;
         &#125;
         //删除
         node2.next=node2.next.next;
         return dummyNode.next;
     &#125;
 &#125;
</code></pre>
<h2 id="两两交换链表中的节点24"><a href="#两两交换链表中的节点24" class="headerlink" title="两两交换链表中的节点24"></a>两两交换链表中的节点24</h2><p>给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。<br><img src="https://raw.githubusercontent.com/viacheung/img/main/image/image-20221015163411413.png#from=url&id=Qcy5p&originHeight=437&originWidth=1020&originalType=binary&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&title="></p>
<pre><code>class Solution &#123;
     public ListNode swapPairs(ListNode head) &#123;
         if (head == null || head.next == null) &#123;
             return head;
         &#125;
         ListNode newHead = head.next;
         head.next = swapPairs(newHead.next);
         newHead.next = head;
         return newHead;
     &#125;
 &#125;
</code></pre>
<p>选择迭代！<br><img src="https://raw.githubusercontent.com/viacheung/img/main/image/image-20221015163434779.png#from=url&id=ClEFA&originHeight=573&originWidth=1032&originalType=binary&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&title="></p>
<pre><code>class Solution &#123;
     public ListNode swapPairs(ListNode head) &#123;
         ListNode dummyNode=new ListNode(0);
         dummyNode.next=head;
         ListNode temp=dummyNode;
         while(temp.next!=null&amp;&amp;temp.next.next!=null)&#123;
            //存一下
             ListNode node1=temp.next;
             ListNode node2=temp.next.next;
             //node1指向node2指向的
             node1.next=node2.next;
             //temp指向node2
             temp.next=node2;
             //node2--&gt;node1
             node2.next=node1;
             //移动temp
             temp=node1;
         &#125;
         //返回头结点
         return dummyNode.next;
     &#125;
 &#125;
</code></pre>
<h2 id="移除链表元素203"><a href="#移除链表元素203" class="headerlink" title="移除链表元素203"></a>移除链表元素203</h2><p>优先迭代<br>给你一个链表的头节点 head 和一个整数 val ，请你删除链表中所有满足 Node.val &#x3D;&#x3D; val 的节点，并返回 <strong>新的头节点</strong> 。<br><img src="https://raw.githubusercontent.com/viacheung/img/main/image/image-20221014152913347.png#from=url&id=pMqN0&originHeight=399&originWidth=1000&originalType=binary&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&title="><br>要求返回头节点 最好的方法 用一个dumyNode！！！！</p>
<pre><code>class Solution &#123;
     public ListNode removeElements(ListNode head, int val) &#123;
         ListNode dumyNode=new ListNode();
         dumyNode.next=head;
         ListNode cur=dumyNode;
         while(cur.next!=null)&#123;
             if(cur.next.val==val)&#123;
                 cur.next=cur.next.next;
             &#125;else&#123;
                 cur=cur.next;
             &#125;
         &#125;
         return dumyNode.next;
     &#125;
 &#125;
</code></pre>
<p>优先方法二，比较好理解。<br><img src="https://raw.githubusercontent.com/viacheung/img/main/image/image-20221014152957745.png#from=url&id=xCFzX&originHeight=616&originWidth=983&originalType=binary&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&title="></p>
<h2 id="设计链表"><a href="#设计链表" class="headerlink" title="设计链表"></a>设计链表</h2><p><img src="https://raw.githubusercontent.com/viacheung/img/main/image/image-20221014160959772.png#from=url&id=aMxLq&originHeight=330&originWidth=926&originalType=binary&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&title="><br><strong>单链表</strong></p>
<pre><code>class MyLinkedList &#123;
     //用哨兵节点（值为0）当作头结点(但不是真的头结点)
     int size;
     ListNode head;
     //初始化
     public MyLinkedList() &#123;
         size=0;
         head=new ListNode(0);
     &#125;
     
     public int get(int index) &#123;
         if(index&lt;0||index&gt;=size)&#123;
             return -1;
         &#125;
         ListNode cur=head;
         for(int i=0;i&lt;=index;i++)&#123;
             cur=cur.next;
         &#125;
         return cur.val;
     &#125;
     //操作某个结点 cur到它前面一个去
     public void addAtHead(int val) &#123;
         addAtIndex(0,val);
     &#125;
     
     public void addAtTail(int val) &#123;
         addAtIndex(size,val);
     &#125;
     
     public void addAtIndex(int index, int val) &#123;
         if(index&gt;size)&#123;
             return;
         &#125;
         //小于0设为0
         index=index&lt;0?0:index;
         ListNode tar=new ListNode(val);
         ListNode cur=head;
         for(int i=0;i&lt;index;i++)&#123;
             cur=cur.next;
         &#125;
         tar.next=cur.next;
         cur.next=tar;
         size++;
     &#125;
     
     public void deleteAtIndex(int index) &#123;
         if(index&lt;0||index&gt;=size)&#123;
             return;
         &#125;
         ListNode cur=head;
         for(int i=0;i&lt;index;i++)&#123;
             cur=cur.next;
         &#125;
         cur.next=cur.next.next;
         size--;
     &#125;
 &#125;
</code></pre>
<p>双链表就不写辣</p>
<h2 id="回文链表"><a href="#回文链表" class="headerlink" title="回文链表"></a>回文链表</h2><p><strong>方法一：将值复制到数组中后用双指针法</strong><br>一共为两个步骤：</p>
<ol>
<li>复制链表值到数组列表中。</li>
<li>使用双指针法判断是否为回文。node_1.val &#x3D;&#x3D; node_2.val</li>
</ol>
<p><strong>方法二：快慢指针</strong></p>
<ol>
<li>找到前半部分链表的尾节点。</li>
<li>根据前半部分分链表尾结点，反转后半部分链表。</li>
<li>判断是否回文。</li>
<li>恢复链表（再把步骤二做一次）。</li>
<li>返回结果。<br>&#96;&#96;&#96;<br>&#x2F;**</li>
</ol>
<ul>
<li>Definition for singly-linked list.</li>
<li>public class ListNode {</li>
<li><pre><code>int val;
</code></pre>
</li>
<li><pre><code>ListNode next;
</code></pre>
</li>
<li><pre><code>ListNode() &#123;&#125;
</code></pre>
</li>
<li><pre><code>ListNode(int val) &#123; this.val = val; &#125;
</code></pre>
</li>
<li><pre><code>ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;
</code></pre>
</li>
<li>}<br>  *&#x2F;<br> class Solution {<br> public boolean isPalindrome(ListNode head) {<br> &#x2F;&#x2F;方法一 辅助数组 双指针<br> &#x2F;&#x2F; ListNode cur&#x3D;head;<br> &#x2F;&#x2F; int len&#x3D;0;<br> &#x2F;&#x2F; while(cur!&#x3D;null){<br> &#x2F;&#x2F;     len++;<br> &#x2F;&#x2F;     cur&#x3D;cur.next;<br> &#x2F;&#x2F; }<br> &#x2F;&#x2F; int[] result&#x3D;new int[len];<br> &#x2F;&#x2F; cur&#x3D;head;<br> &#x2F;&#x2F; for(int i&#x3D;0;i&lt;len;i++){<br> &#x2F;&#x2F;     result[i]&#x3D;cur.val;<br> &#x2F;&#x2F;     cur&#x3D;cur.next;<br> &#x2F;&#x2F; }<br> &#x2F;&#x2F; int l&#x3D;0,r&#x3D;len-1;<br> &#x2F;&#x2F; while(l&lt;r){<br> &#x2F;&#x2F;     if(result[l]!&#x3D;result[r]) return false;<br> &#x2F;&#x2F;     l++;<br> &#x2F;&#x2F;     r–;<br> &#x2F;&#x2F; }<br> &#x2F;&#x2F; return true;<br> &#x2F;&#x2F;方法二 快慢指针<br> ListNode slow&#x3D;head,fast&#x3D;head,pre&#x3D;head;<br> while(fast!&#x3D;null&amp;&amp;fast.next!&#x3D;null){<br>     pre&#x3D;slow;<br>     slow&#x3D;slow.next;<br>     fast&#x3D;fast.next.next;<br> }<br> pre.next&#x3D;null;<br> ListNode node1&#x3D;head;<br> ListNode node2&#x3D;reverseList(slow);<br> while(node1!&#x3D;null){<br>     if(node1.val!&#x3D;node2.val) return false;<br>     node1&#x3D;node1.next;<br>     node2&#x3D;node2.next;<br> }<br> return true;<br> }<br> &#x2F;&#x2F;反转链表<br> public ListNode reverseList(ListNode head){<br> ListNode pre&#x3D;null,temp&#x3D;null,cur&#x3D;head;<br> while(cur!&#x3D;null){<br>     &#x2F;&#x2F;记录当前节点的下一个节点<br>     temp&#x3D;cur.next;<br>     &#x2F;&#x2F;然后将当前节点指向pre<br>     cur.next&#x3D;pre;<br>     &#x2F;&#x2F;pre和cur节点都前进一位<br>     pre&#x3D;cur;<br>     cur&#x3D;temp;<br> }<br> return pre;<br> }</li>
</ul>
<p> }</p>
<pre><code>## 反转链表
最简单的不考虑复杂度的话，利用**外部空间**
先申请一个动态扩容的数组或者容器，比如 ArrayList 这样的。然后不断遍历链表，将链表中的元素添加到这个容器中。再利用容器自身的 API，反转整个容器，这样就达到反转的效果了。最后同时遍历容器和链表，将链表中的值改为容器中的值。因为此时容器的值是：
5 4 3 2 1
链表按这个顺序重新被设置一边，就达到要求啦。
**一、迭代**（好理解一点）
两个指针，cur和pre，pre先指向Null，cur指向head，然后遍历cur，每次迭代到cur，用一个tmp存储cur的下一结点，然后cur的Next指向pre，pre前进一位（pre指向cur，cur指向tmp）
**代码**
</code></pre>
<p>class Solution {<br>     public ListNode reverseList(ListNode head) {<br>         &#x2F;&#x2F;申请节点，pre和 cur，pre指向null<br>         ListNode pre &#x3D; null;<br>         ListNode cur &#x3D; head;<br>         ListNode tmp &#x3D; null;<br>         while(cur!&#x3D;null) {<br>             &#x2F;&#x2F;记录当前节点的下一个节点<br>             tmp &#x3D; cur.next;<br>             &#x2F;&#x2F;然后将当前节点指向pre<br>             cur.next &#x3D; pre;<br>             &#x2F;&#x2F;pre和cur节点都前进一位<br>             pre &#x3D; cur;<br>             cur &#x3D; tmp;<br>         }<br>         return pre;<br>     }<br> }</p>
<pre><code>**二、递归（不好理解）**
递归的两个条件：
</code></pre>
<p>终止条件是当前节点或者下一个节点&#x3D;&#x3D;null<br> 在函数内部，改变节点的指向，也就是 head 的下一个节点指向 head 递归函数那句</p>
<pre><code>head.next.next = head
很不好理解，其实就是 head 的下一个节点指向head。递归函数中每次返回的 cur 其实只最后一个节点，在递归函数内部，改变的是当前节点的指向。动画演示如下：
![](https://raw.githubusercontent.com/viacheung/img/main/image/dacd1bf55dec5c8b38d0904f26e472e2024fc8bee4ea46e3aa676f340ba1eb9d-%E9%80%92%E5%BD%92.gif#from=url&amp;id=RJoNw&amp;originHeight=360&amp;originWidth=640&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=)
我的理解：先一直执行ListNode cur = reverseList(head.next)，一直到head为4的时候，if里面成立（head.next==null），跳出，此时cur为5，但是是在4这个结点的递归里面，因此head为4，所以head.next.next 就是5-&gt;4；防止链表循环（因为已经形成了一个环了），需要将head.next设置为空，然后返回cur，因为每层递归函数都返回cur。
</code></pre>
<p>class Solution {<br>     public ListNode reverseList(ListNode head) {<br>         &#x2F;&#x2F;递归终止条件是当前为空，或者下一个节点为空<br>         if(head&#x3D;&#x3D;null || head.next&#x3D;&#x3D;null) {<br>             return head;<br>         }<br>         &#x2F;&#x2F;这里的cur就是最后一个节点<br>         ListNode cur &#x3D; reverseList(head.next);<br>         &#x2F;&#x2F;这里请配合动画演示理解<br>         &#x2F;&#x2F;如果链表是 1-&gt;2-&gt;3-&gt;4-&gt;5，那么此时的cur就是5<br>         &#x2F;&#x2F;而head是4，head的下一个是5，下下一个是空<br>         &#x2F;&#x2F;所以head.next.next 就是5-&gt;4<br>         head.next.next &#x3D; head;<br>         &#x2F;&#x2F;防止链表循环，需要将head.next设置为空<br>         head.next &#x3D; null;<br>         &#x2F;&#x2F;每层递归函数都返回cur，也就是最后一个节点<br>         return cur;<br>     }<br> }</p>
<pre><code>## 环形链表I
![](https://raw.githubusercontent.com/viacheung/img/main/image/image-20221015175612893.png#from=url&amp;id=jfKJC&amp;originHeight=510&amp;originWidth=813&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=)
**方法一：哈希表**
最容易想到的方法是遍历所有节点，每次遍历到一个节点时，判断该节点此前是否被访问过。
具体地，我们可以使用哈希表来存储所有已经访问过的节点。每次我们到达一个节点，如果该节点已经存在于哈希表中，则说明该链表是环形链表，否则就将该节点加入哈希表中。重复这一过程，直到我们遍历完整个链表即可。
</code></pre>
<p>public class Solution {<br>     public boolean hasCycle(ListNode head) {<br>         Set<ListNode> seen &#x3D; new HashSet<ListNode>();<br>         while (head !&#x3D; null) {<br>             if (!seen.add(head)) {<br>                 return true;<br>             }<br>             head &#x3D; head.next;<br>         }<br>         return false;<br>     }<br> }</ListNode></ListNode></p>
<pre><code>**方法二：快慢指针**（龟兔赛跑）
本方法需要读者对「Floyd 判圈算法」（又称龟兔赛跑算法）有所了解。
假想「乌龟」和「兔子」在链表上移动，「兔子」跑得快，「乌龟」跑得慢。当「乌龟」和「兔子」从链表上的同一个节点开始移动时，如果该链表中没有环，那么「兔子」将一直处于「乌龟」的前方；如果该链表中有环，那么「兔子」会先于「乌龟」进入环，并且一直在环内移动。等到「乌龟」进入环时，由于「兔子」的速度快，它一定会在某个时刻与乌龟相遇，即套了「乌龟」若干圈。
我们可以根据上述思路来解决本题。具体地，我们定义两个指针，一快一慢。慢指针每次只移动一步，而快指针每次移动两步。初始时，慢指针在位置 head，而快指针在位置 head.next。这样一来，如果在移动的过程中，快指针反过来追上慢指针，就说明该链表为环形链表。否则快指针将到达链表尾部，该链表不为环形链表。
**细节**
为什么我们要规定初始时慢指针在位置 head，快指针在位置 head.next，而不是两个指针都在位置 head（即与「乌龟」和「兔子」中的叙述相同）？
观察下面的代码，我们使用的是 while 循环，循环条件先于循环体。由于循环条件一定是判断快慢指针是否重合，如果我们将两个指针初始都置于 head，那么 while 循环就不会执行。因此，我们可以假想一个在 head 之前的虚拟节点，慢指针从虚拟节点移动一步到达 head，快指针从虚拟节点移动两步到达 head.next，这样我们就可以使用 while 循环了。
当然，我们也可以使用 do-while 循环。此时，我们就可以把快慢指针的初始值都置为 head。
</code></pre>
<p>public class Solution {<br>     public boolean hasCycle(ListNode head) {<br>         if (head &#x3D;&#x3D; null || head.next &#x3D;&#x3D; null) {<br>             return false;<br>         }<br>         ListNode slow &#x3D; head;<br>         ListNode fast &#x3D; head.next;<br>         while (slow !&#x3D; fast) {<br>             if (fast &#x3D;&#x3D; null || fast.next &#x3D;&#x3D; null) {<br>                 return false;<br>             }<br>             slow &#x3D; slow.next;<br>             fast &#x3D; fast.next.next;<br>         }<br>         return true;<br>     }<br> }</p>
<pre><code>## 环形链表II
给定一个链表的头节点 head ，返回链表开始入环的第一个节点。 _如果链表无环，则返回 null。_
方法一 哈希
</code></pre>
<p>public class Solution {<br>     public ListNode detectCycle(ListNode head) {<br>         Set<ListNode> seen&#x3D;new HashSet&lt;&gt;();<br>         while(head!&#x3D;null){<br>             &#x2F;&#x2F;用contains也可<br>             if(seen.add(head)){<br>                 head&#x3D;head.next;<br>             }else{<br>                 return head;<br>             }<br>         }<br>         return null;<br>     }<br> }</ListNode></p>
<pre><code>方法二
![](https://raw.githubusercontent.com/viacheung/img/main/image/image-20221015181031942.png#from=url&amp;id=NKSlT&amp;originHeight=815&amp;originWidth=1002&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=)
环形链表和龟兔赛跑很像，也是相遇后，再有一个指针从头开始和slow一起移动，最后相遇即为结果
</code></pre>
<p>public class Solution {<br>     public ListNode detectCycle(ListNode head) {<br>         ListNode slow&#x3D;head,fast&#x3D;head;<br>         while(fast!&#x3D;null&amp;&amp;fast.next!&#x3D;null){<br>             slow&#x3D;slow.next;<br>             fast&#x3D;fast.next.next;<br>             if(slow&#x3D;&#x3D;fast){<br>                 ListNode node&#x3D;head;<br>                 while(node!&#x3D;slow){<br>                     slow&#x3D;slow.next;<br>                     node&#x3D;node.next;<br>                 }<br>                 return node;<br>             }<br>         }<br>         return null;<br>     }<br> }</p>
<pre><code>弗洛伊德循环查找算法结论：
1、如果有环，兔子乌龟(兔子和乌龟可以不在一个位置出发，这个要看具体情况)必定会相遇（判断是否有环，循环问题，链表、快乐数）
2、如果有环，兔子乌龟同时同位置出发，相遇后，再有一个指针从头开始和slow一起移动，最后在入环点相遇。
## 相交链表(√)
给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 null
![](https://raw.githubusercontent.com/viacheung/img/main/image/160_statement.png#from=url&amp;id=FbSsk&amp;originHeight=241&amp;originWidth=742&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=)
![](https://raw.githubusercontent.com/viacheung/img/main/image/image-20220910174724580.png#from=url&amp;id=k655o&amp;originHeight=418&amp;originWidth=1054&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=)
![](https://raw.githubusercontent.com/viacheung/img/main/image/image-20221015175222441.png#from=url&amp;id=PgMOV&amp;originHeight=449&amp;originWidth=910&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=)
</code></pre>
<p>public ListNode getIntersectionNode(ListNode headA, ListNode headB) {<br>     if (headA &#x3D;&#x3D; null || headB &#x3D;&#x3D; null) return null;<br>     ListNode pA &#x3D; headA, pB &#x3D; headB;<br>     while (pA !&#x3D; pB) {<br>         pA &#x3D; pA &#x3D;&#x3D; null ? headB : pA.next;<br>         pB &#x3D; pB &#x3D;&#x3D; null ? headA : pB.next;<br>     }<br>     return pA;<br> }<br> 总结：当某个结点为空就去另一个链表的头节点（目的是缩短差距 慢慢的这俩就可以一起到达相交结点），直到两者相遇，管他为空还是在一个结点处</p>
<pre><code>还有一种基本的方法，就是构造一个哈希表，先把A链表的结点都存进去，然后遍历B链表，当某个节点在A里面有则返回之；
## 两两交换链表中的节点
给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。
题解：
模拟 娅结点 temp
</code></pre>
<p>class Solution {<br>     public ListNode swapPairs(ListNode head) {<br>         ListNode dummyNode&#x3D;new ListNode(0);<br>         dummyNode.next&#x3D;head;<br>         ListNode temp&#x3D;dummyNode;<br>         while(temp.next!&#x3D;null&amp;&amp;temp.next.next!&#x3D;null){<br>             ListNode node1&#x3D;temp.next;<br>             ListNode node2&#x3D;temp.next.next;<br>             temp.next&#x3D;node2;<br>             node1.next&#x3D;node2.next;<br>             node2.next&#x3D;node1;<br>             temp&#x3D;node1;<br>         }<br>         return dummyNode.next;<br>     }<br> }</p>
<pre><code>## **链表内指定区间反转**
![](https://raw.githubusercontent.com/viacheung/img/main/image/image-20230402185058710.png#from=url&amp;id=MGZKI&amp;originHeight=211&amp;originWidth=653&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=)
题解：
![](https://raw.githubusercontent.com/viacheung/img/main/image/image-20230402185131136.png#from=url&amp;id=TIzP1&amp;originHeight=540&amp;originWidth=861&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=)
算法思路：
1、设置一个dummyNode指向头节点 方便后面返回结果
2、pre指到m位置前一个
3、开始工作 for(m-&gt;n )每次把后面一个节点放到头节点位置
4、返回结果
</code></pre>
<p>public ListNode reverseBetween (ListNode head, int m, int n) {<br>         &#x2F;&#x2F; write code here<br>         ListNode dumyNode &#x3D;new ListNode(-1);<br>         dumyNode.next&#x3D;head;<br>         ListNode pre&#x3D;dumyNode;<br>         for(int i&#x3D;0;i&lt;m-1;i++){<br>             pre&#x3D;pre.next;<br>         }<br>         ListNode cur&#x3D;pre.next;<br>         for(int i&#x3D;m;i&lt;n;i++){<br>             ListNode curNext&#x3D;cur.next;<br>             cur.next&#x3D;curNext.next;<br>             curNext.next&#x3D;pre.next;&#x2F;&#x2F;这里我原本写的curNext.next&#x3D;cur 这是不对的 这个算法思路就是每次把后面节点移动到最前面 如果我们在循环里面不改cur 那么此时cur并不是头节点  pre.next最保险；<br>             pre.next&#x3D;curNext;<br>         }<br>         return dumyNode.next;<br>     }</p>
<pre><code>## **链表中的节点每k个一组翻转**
将给出的链表中的节点每 k 个一组翻转，返回翻转后的链表 如果链表中的节点数不是 k 的倍数，将最后剩下的节点保持原样 你不能更改节点中的值，只能更改节点本身。
题解：
须知：这个方法返回反转后的头节点
1、遍历到下一组的头节点 记为tail 中间如果发现tail为null 直接返回head
2、然后反转链表 此时pre为null 判断条件为cur!=tail 平常反转链表条件为cur!=null 有异曲同工之妙
3、head.next=reverseKGroup(tail,k); 此处为递归 tail正好也是下一组的头节点
4、直接返回pre;
![](https://raw.githubusercontent.com/viacheung/img/main/image/D024AA6BA7A670402678A9ACAD54EB10#from=url&amp;id=aRkHY&amp;originHeight=1080&amp;originWidth=1920&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=)
</code></pre>
<p>public ListNode reverseKGroup (ListNode head, int k) {<br>         &#x2F;&#x2F; write code here<br>         &#x2F;&#x2F; 这个方法返回的是反转后的头节点<br>         ListNode tail&#x3D;head;<br>         &#x2F;&#x2F; 此时tail为下一组的头节点<br>         for(int i&#x3D;0;i&lt;k;i++){<br>             if(tail&#x3D;&#x3D;null) return head;<br>             tail&#x3D;tail.next;<br>         }<br>         ListNode pre&#x3D;null;<br>         ListNode cur&#x3D;head;<br>         while(cur!&#x3D;tail){<br>             ListNode curNext&#x3D;cur.next;<br>             cur.next&#x3D;pre;<br>             pre&#x3D;cur;<br>             cur&#x3D;curNext;<br>         }<br>         head.next&#x3D;reverseKGroup(tail,k);<br>         &#x2F;&#x2F; 最后pre指向的是cur(tail的前一个 也就是本组的最后一个节点（现在变成头节点）)<br>         return pre;<br>     }</p>
<pre><code>## 合并两个有序链表
描述
输入两个递增的链表，单个链表的长度为n，合并这两个链表并使新链表中的节点仍然是递增排序的。
### 递归
1、如果有一个链表为空，返回另一个链表2、如果pHead1 节点值比小pHead2，下一个节点应该是 pHead1，应该return pHead1，在return之前，指定pHead1的下一个节点应该是pHead1.next和pHead2俩链表的合并后的头结点3、如果pHead1 节点值比pHead2大，下一个节点应该是pHead2，应该return pHead2，在return之前，指定pHead2的下一个节点应该是pHead1和pHead2.next俩链表的合并后的头结点
</code></pre>
<p>public class Solution {<br>     public ListNode Merge(ListNode list1, ListNode list2) {<br>         if (list1 &#x3D;&#x3D; null || list2 &#x3D;&#x3D; null) return list1 &#x3D;&#x3D; null ? list2 : list1;<br>         if (list1.val &gt; list2.val) {<br>             list2.next &#x3D; Merge(list2.next, list1);<br>             return list2;<br>         } else {<br>             list1.next &#x3D; Merge(list1.next, list2);<br>             return list1;<br>         }<br>     }<br> }</p>
<pre><code>## **链表相加(二)**
![](https://raw.githubusercontent.com/viacheung/img/main/image/image-20230403212432459.png#from=url&amp;id=P9GBR&amp;originHeight=470&amp;originWidth=641&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=)
题解：
反转链表后进行相加，每次记录相加后的进位数字
</code></pre>
<p>public ListNode addInList (ListNode head1, ListNode head2) {<br>         &#x2F;&#x2F; 进行判空处理<br>         if(head1 &#x3D;&#x3D; null)<br>             return head2;<br>         if(head2 &#x3D;&#x3D; null){<br>             return head1;<br>         }<br>         &#x2F;&#x2F; 反转h1链表<br>         head1 &#x3D; reverse(head1);<br>         &#x2F;&#x2F; 反转h2链表<br>         head2 &#x3D; reverse(head2);<br>         &#x2F;&#x2F; 创建新的链表头节点<br>         ListNode head &#x3D; new ListNode(-1);<br>         ListNode nHead &#x3D; head;<br>         &#x2F;&#x2F; 记录进位的数值<br>         int tmp &#x3D; 0;<br>         while(head1 !&#x3D; null || head2 !&#x3D; null){<br>             &#x2F;&#x2F; val用来累加此时的数值（加数+加数+上一位的进位&#x3D;当前总的数值）<br>             int val &#x3D; tmp;<br>             &#x2F;&#x2F; 当节点不为空的时候，则需要加上当前节点的值<br>             if (head1 !&#x3D; null) {<br>                 val +&#x3D; head1.val;<br>                 head1 &#x3D; head1.next;<br>             }<br>             &#x2F;&#x2F; 当节点不为空的时候，则需要加上当前节点的值<br>             if (head2 !&#x3D; null) {<br>                 val +&#x3D; head2.val;<br>                 head2 &#x3D; head2.next;<br>             }<br>             &#x2F;&#x2F; 求出进位<br>             tmp &#x3D; val&#x2F;10;<br>             &#x2F;&#x2F; 进位后剩下的数值即为当前节点的数值<br>             nHead.next &#x3D; new ListNode(val%10);<br>             &#x2F;&#x2F; 下一个节点<br>             nHead &#x3D; nHead.next;</p>
<pre><code>     &#125;
     // 最后当两条链表都加完的时候，进位不为0的时候，则需要再加上这个进位
     if(tmp &gt; 0)&#123;
         nHead.next = new ListNode(tmp);
     &#125;
     // 重新反转回来返回
     return reverse(head.next);
 &#125;

 // 反转链表
 public ListNode reverse(ListNode head)&#123;
     ListNode pre=null;
     ListNode cur=head;
     while(cur!=null)&#123;
         ListNode curNext=cur.next;
         cur.next=pre;
         pre=cur;
         cur=curNext;
     &#125;
     return pre;
 &#125;
</code></pre>
<pre><code>## **单链表的排序**
给定一个节点数为n的无序单链表，对其按升序排序

- step 1：遍历链表，将节点值加入数组。
- step 2：使用内置的排序函数对数组进行排序。
- step 3：依次遍历数组和链表，按照位置将链表中的节点值修改为排序后的数组值。
</code></pre>
<p>public class Solution {<br>     &#x2F;**<br>      *<br>      * @param head ListNode类 the head node<br>      * @return ListNode类<br>      <em>&#x2F;<br>     public ListNode sortInList (ListNode head) {<br>         &#x2F;&#x2F; write code here<br>         &#x2F;</em>*<br>         1、复制到数组<br>         2、sort<br>         3、转为链表<br>          *&#x2F;<br>         List<Integer> list&#x3D;new ArrayList&lt;&gt;();<br>         ListNode p&#x3D;head;<br>         while(p!&#x3D;null){<br>             list.add(p.val);<br>             p&#x3D;p.next;<br>         }<br>         p&#x3D;head;<br>         Collections.sort(list);<br>         for(int num:list){<br>             p.val&#x3D;num;<br>             p&#x3D;p.next;<br>         }<br>         return head;<br>     }</Integer></p>
<pre><code>## **判断一个链表是否为回文结构**
### 思路
因为需要判断是否为回文结构，所以要比较头尾的数据，而链表无法随机查询数据，所以可以先将链表转换成list。
### 具体步骤

- 首先初始化一个list列表；
- 遍历链表，将链表中的值转移至list中；
- 在list中通过比较头尾的值来判断链表是否为回文结构。
- 代码如下：
</code></pre>
<p>import java.util.<em>;<br> &#x2F;</em></p>
<ul>
<li>public class ListNode {</li>
<li>int val;</li>
<li>ListNode next &#x3D; null;</li>
<li>}<br> <em>&#x2F;<br> public class Solution {<br>&#x2F;</em>*<br> * <ul>
<li><p>@param head ListNode类 the head</p>
</li>
<li><p>@return bool布尔型<br> *&#x2F;<br>public boolean isPail (ListNode head) {<br> &#x2F;&#x2F; write code here<br> &#x2F;&#x2F; n&#x3D;&#x3D;1，返回true<br> if (head.next &#x3D;&#x3D; null){<br> return true;<br> }<br> List<Integer> nums &#x3D; new ArrayList<Integer>();<br> &#x2F;&#x2F; 将链表转换成list<br> while(head!&#x3D;null){<br> nums.add(head.val);<br> head &#x3D; head.next;<br> }<br> int i &#x3D; 0;<br> int j &#x3D; nums.size()-1;<br> while(i&lt;j){<br> &#x2F;&#x2F; 不等则返回false<br> &#x2F;&#x2F; 这边有一个坑，如果不适用equals而使用!&#x3D;的话，在牛客上对于有负数的测试用例可能会无法通过。<br> if (!nums.get(i).equals(nums.get(j))){<br>     return false;<br> }<br> ++i;<br> –j;<br> }<br> return true;<br>}<br> }</Integer></Integer></p>
<pre><code>## 旋转链表
给你一个链表的头节点 head ，旋转链表，将链表每个节点向右移动 k 个位置。
记给定链表的长度为 ，注意到当向右移动的次数 k≥n 时，我们仅需要向右移动 k mod n次即可。因为每 n 次移动都会让链表变为原状。这样我们可以知道，新链表的最后一个节点为原链表的第 (n−1)−(k mod n)个节点（从 0 开始计数）。
这样，我们可以先将给定的链表连接成环，然后将指定位置断开。
具体代码中，我们首先计算出链表的长度 n，并找到该链表的末尾节点，将其与头节点相连。这样就得到了闭合为环的链表。然后我们找到新链表的最后一个节点（即原链表的第 (n−1)−(k mod n)个节点），将当前闭合为环的链表断开，即可得到我们所需要的结果。
特别地，当链表长度不大于 1，或者 k 为 n 的倍数时，新链表将与原链表相同，我们无需进行任何处理。
</code></pre>
<p>class Solution {<br>  public ListNode rotateRight(ListNode head, int k) {</p>
<p>   if (k &#x3D;&#x3D; 0 || head &#x3D;&#x3D; null || head.next &#x3D;&#x3D; null) {<br>   return head;<br>   }<br>   &#x2F;&#x2F; 初始链表长度<br>   int n &#x3D; 1;<br>   ListNode iter &#x3D; head;<br>   &#x2F;&#x2F; 到最后一个结点<br>   while (iter.next !&#x3D; null) {<br>   iter &#x3D; iter.next;<br>   n++;<br>   }<br>   &#x2F;&#x2F; 计算旧头节点和新头节点偏移量<br>   int add &#x3D; n - k % n;<br>   if (add &#x3D;&#x3D; n) {<br>   return head;<br>   }<br>   &#x2F;&#x2F; 连接为环<br>   iter.next &#x3D; head;<br>   &#x2F;&#x2F; 移动到新头结点<br>   while (add– &gt; 0) {<br>   iter &#x3D; iter.next;<br>   }<br>   &#x2F;&#x2F; 断开即可<br>   ListNode ret &#x3D; iter.next;<br>   iter.next &#x3D; null;<br>   &#x2F;&#x2F; 返回<br>   return ret;</p>
</li>
</ul>
<p>  }</p>
</li>
</ul>
<p> }</p>
<pre><code>## 重排链表
![](https://raw.githubusercontent.com/viacheung/img/main/image/image-20230406191651380.png#from=url&amp;id=uA2FK&amp;originHeight=256&amp;originWidth=669&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=)

1. 创建一个队列
2. 除了head 其他入队
3. 维护一个count 根据count值奇偶连接链表
</code></pre>
<p>class Solution {<br>     public void reorderList(ListNode head) {<br>         &#x2F;&#x2F; 使用双端队列的方法来解决<br>         Deque<ListNode> de &#x3D; new LinkedList&lt;&gt;();<br>         &#x2F;&#x2F; 这里是取head的下一个节点，head不需要再入队了，避免造成重复<br>         ListNode cur &#x3D; head.next;<br>         while (cur !&#x3D; null){<br>             de.offer(cur);<br>             cur &#x3D; cur.next;<br>         }<br>         cur &#x3D; head;  &#x2F;&#x2F; 回到头部</ListNode></p>
<pre><code>     int count = 0;
     while (!de.isEmpty())&#123;
         if (count % 2 == 0)&#123;
             // 偶数，取出队列右边尾部的值
             cur.next = de.pollLast();
         &#125;else &#123;
             // 奇数，取出队列左边头部的值
             cur.next = de.poll();
         &#125;
         cur  = cur.next;
         count++;
     &#125;
     cur.next = null;
 &#125;
</code></pre>
<p> }</p>
<pre><code>
 
</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://viacheung.github.io/2023/06/04/%E5%93%88%E5%B8%8C%E8%A1%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="ViaCheung">
      <meta itemprop="description" content="el psy congroo">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="命运石之门">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/06/04/%E5%93%88%E5%B8%8C%E8%A1%A8/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
	  <span class="post-time">

	  
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-06-04 01:02:30 / 修改时间：01:02:31" itemprop="dateCreated datePublished" datetime="2023-06-04T01:02:30+08:00">2023-06-04</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="同构字符串"><a href="#同构字符串" class="headerlink" title="同构字符串"></a>同构字符串</h2><p>给定两个字符串 s 和 t ，判断它们是否是同构的。<br>如果 s 中的字符可以按某种映射关系替换得到 t ，那么这两个字符串是同构的。<br>每个出现的字符都应当映射到另一个字符，同时不改变字符的顺序。不同字符不能映射到同一个字符上，相同字符只能映射到同一个字符上，字符可以映射到自己本身。</p>
<pre><code>class Solution &#123;
     public boolean isIsomorphic(String s, String t) &#123;
         Map&lt;Character, Character&gt; map1 = new HashMap&lt;&gt;();
         Map&lt;Character, Character&gt; map2 = new HashMap&lt;&gt;();
         for (int i = 0, j = 0; i &lt; s.length(); i++, j++) &#123;
             if (!map1.containsKey(s.charAt(i))) &#123;
                 map1.put(s.charAt(i), t.charAt(j)); // map1保存 s[i] 到 t[j]的映射
             &#125;
             if (!map2.containsKey(t.charAt(j))) &#123;
                 map2.put(t.charAt(j), s.charAt(i)); // map2保存 t[j] 到 s[i]的映射
             &#125;  
             // 无法映射，返回 false   //之前映射一次了 所以这次不行 例如 a-&gt;b   又遇到a  c 那必然失败
             if (map1.get(s.charAt(i)) != t.charAt(j) || map2.get(t.charAt(j)) != s.charAt(i)) &#123;
                 return false;
             &#125;
         &#125;
         return true;
     &#125;
 &#125;
</code></pre>
<h2 id="查找共用字符"><a href="#查找共用字符" class="headerlink" title="查找共用字符"></a>查找共用字符</h2><p>给你一个字符串数组 words ，请你找出所有在 words 的每个字符串中都出现的共用字符（ <strong>包括重复字符</strong>），并以数组形式返回。你可以按 <strong>任意顺序</strong> 返回答案。<br>思路</p>
<pre><code>class Solution &#123;
     public List&lt;String&gt; commonChars(String[] words) &#123;
         // 哈希    hash数组存储每个字符对应的在各个字符串里面出现的最小频率    
         // 输入：words = [&quot;bella&quot;,&quot;label&quot;,&quot;roller&quot;]
         // hash[1]=0,hash[&#39;l&#39;-&#39;a&#39;]=2
         // 输出：[&quot;e&quot;,&quot;l&quot;,&quot;l&quot;]   
         List&lt;String&gt; res=new ArrayList&lt;&gt;();
         int[] hash=new int[26];
         //给hash初始化一个最大值
         Arrays.fill(hash,Integer.MAX_VALUE);
         for(int i=0;i&lt;words.length;i++)&#123;
             int[] newhash=new int[26];
             for(int j=0;j&lt;words[i].length();j++)&#123;
                 newhash[words[i].charAt(j)-&#39;a&#39;]++;
             &#125;
             for(int k=0;k&lt;26;k++)&#123;
                 hash[k]=Math.min(hash[k],newhash[k]);
             &#125;
         &#125;
         for(int i=0;i&lt;26;i++)&#123;
             while(hash[i]!=0)&#123;
                 char c=(char)(&#39;a&#39;+i);//必须指定转的类型
                 res.add(String.valueOf(c));
                 hash[i]--;
             &#125;
         &#125;
         return res;
 
     &#125;
 &#125;
</code></pre>
<h2 id="赎金信"><a href="#赎金信" class="headerlink" title="赎金信"></a>赎金信</h2><p>给你两个字符串：ransomNote 和 magazine ，判断 ransomNote 能不能由 magazine 里面的字符构成。<br>如果可以，返回 true ；否则返回 false 。<br>magazine 中的每个字符只能在 ransomNote 中使用一次。<br><strong>官方题解</strong><br><img src="https://raw.githubusercontent.com/viacheung/img/main/image/image-20221017202244463.png#from=url&id=LG3Sq&originHeight=874&originWidth=1076&originalType=binary&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&title="><br><strong>我的题解</strong></p>
<pre><code>class Solution &#123;
     //我的思路：先magazine存kv，然后ransomNote找如果没key或者value为0直接返回false，否则magazine对应v-1
     public boolean canConstruct(String ransomNote, String magazine) &#123;
         Map&lt;Character,Integer&gt; map=new HashMap&lt;&gt;();
         for(char c:magazine.toCharArray())&#123;
             map.put(c,map.getOrDefault(c,0)+1);
         &#125;
         for(char d:ransomNote.toCharArray())&#123;  
             if(!map.containsKey(d)||map.get(d)==0)&#123;
                 return false;
             &#125;else&#123;
                 map.put(d,map.get(d)-1);
             &#125;
         &#125;
         return true;
     &#125;
 &#125;
</code></pre>
<h2 id="四数相加II"><a href="#四数相加II" class="headerlink" title="四数相加II"></a>四数相加II</h2><p><strong>这题和四数之和不一样 四数之和是一个数组里面 用排序+双重for循环+双指针，这个用两次hash就行</strong><br>给你四个整数数组nums1、nums2、nums3 和 nums4 ，数组长度都是 n ，请你计算有多少个元组 (i, j, k, l) 能满足：</p>
<ul>
<li>0 &lt;&#x3D; i, j, k, l &lt; n</li>
<li>nums1[i] + nums2[j] + nums3[k] + nums4[l] &#x3D;&#x3D; 0</li>
</ul>
<p><img src="https://raw.githubusercontent.com/viacheung/img/main/image/image-20221017155818344.png#from=url&id=w5HII&originHeight=331&originWidth=1020&originalType=binary&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&title="></p>
<pre><code>class Solution &#123;
     public int fourSumCount(int[] A, int[] B, int[] C, int[] D) &#123;
         Map&lt;Integer, Integer&gt; countAB = new HashMap&lt;Integer, Integer&gt;();
         for (int u : A) &#123;
             for (int v : B) &#123;
                 countAB.put(u + v, countAB.getOrDefault(u + v, 0) + 1);
             &#125;
         &#125;
         int ans = 0;
         for (int u : C) &#123;
             for (int v : D) &#123;
                 if (countAB.containsKey(-u - v)) &#123;
                     ans += countAB.get(-u - v);
                 &#125;
             &#125;
         &#125;
         return ans;
     &#125;
 &#125;
</code></pre>
<h2 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a>1. 两数之和</h2><p><strong>方法一：暴力</strong><br>最容易想到的方法是枚举数组中的每一个数 x，寻找数组中是否存在 target - x。 时间复杂度：O(N2)<br><strong>方法二（优先）：哈希表</strong><br>注意到方法一的时间复杂度较高的原因是寻找 target - x 的时间复杂度过高。因此，我们需要一种更优秀的方法，能够快速寻找数组中是否存在目标元素。如果存在，我们需要找出它的索引。<br>哈希表：存key 数字 value 下标<br>使用哈希表，可以将寻找 target - x 的时间复杂度降低到从 O(N) 降低到 O(1)。<br>这样我们创建一个哈希表，对于每一个 x，我们首先查询哈希表中是否存在 target - x，然后将 x 插入到哈希表中，即可保证不会让 x 和自己匹配。</p>
<pre><code>class Solution &#123;
     public int[] twoSum(int[] nums, int target) &#123;
         Map&lt;Integer, Integer&gt; hashtable = new HashMap&lt;Integer, Integer&gt;();
         for (int i = 0; i &lt; nums.length; ++i) &#123;
             if (hashtable.containsKey(target - nums[i])) &#123;
                 return new int[]&#123;hashtable.get(target - nums[i]), i&#125;;
             &#125;
             hashtable.put(nums[i], i);
         &#125;
         return new int[0];
     &#125;
 &#125;
</code></pre>
<h2 id="202-快乐数"><a href="#202-快乐数" class="headerlink" title="202. 快乐数"></a>202. 快乐数</h2><p>编写一个算法来判断一个数 n 是不是快乐数。<br>「快乐数」 定义为：<br>对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。如果这个过程 结果为 1，那么这个数就是快乐数。<br><strong>方法一（选这个）</strong>（简单一点）<br><img src="https://raw.githubusercontent.com/viacheung/img/main/image/image-20221016165323827.png#from=url&id=glXK9&originHeight=621&originWidth=965&originalType=binary&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&title="><br><img src="https://raw.githubusercontent.com/viacheung/img/main/image/image-20221016165445320.png#from=url&id=yHRmp&originHeight=267&originWidth=858&originalType=binary&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&title="></p>
<pre><code>class Solution &#123;
     //简单 求下一个元素
     private int getNext(int n) &#123;
         int totalSum = 0;
         while (n &gt; 0) &#123;
             int d = n % 10;
             n = n / 10;
             totalSum += d * d;
         &#125;
         return totalSum;
     &#125;
     //hashset存  要么循环要么最后为1
     public boolean isHappy(int n) &#123;
         Set&lt;Integer&gt; seen = new HashSet&lt;&gt;();
         while (n != 1 &amp;&amp; !seen.contains(n)) &#123;
             seen.add(n);
             n = getNext(n);
         &#125;
         return n == 1;
     &#125;
 &#125;
</code></pre>
<p><strong>方法二</strong><br><img src="https://raw.githubusercontent.com/viacheung/img/main/image/image-20221016165617310.png#from=url&id=P0wkd&originHeight=292&originWidth=926&originalType=binary&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&title="><br><img src="https://raw.githubusercontent.com/viacheung/img/main/image/image-20221016165555141.png#from=url&id=clO5X&originHeight=156&originWidth=808&originalType=binary&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&title="></p>
<pre><code>class Solution &#123;
      public int getNext(int n) &#123;
         int totalSum = 0;
         while (n &gt; 0) &#123;
             int d = n % 10;
             n = n / 10;
             totalSum += d * d;
         &#125;
         return totalSum;
     &#125;
 
     public boolean isHappy(int n) &#123;
         int slowRunner = n;
         int fastRunner = n;
         while (fastRunner != 1 &amp;&amp; slowRunner != fastRunner) &#123;
             slowRunner = getNext(slowRunner);
             fastRunner = getNext(getNext(fastRunner));
         &#125;
         return fastRunner == 1;
     &#125;
 &#125;
</code></pre>
<h2 id="349-两个数组的交集"><a href="#349-两个数组的交集" class="headerlink" title="349. 两个数组的交集"></a>349. 两个数组的交集</h2><p>给定两个数组 nums1 和 nums2 ，返回 <em>它们的交集</em> 。输出结果中的每个元素一定是 <strong>唯一</strong> 的。我们可以 <strong>不考虑输出结果的顺序</strong> 。<br>我自己的解法</p>
<pre><code>class Solution &#123;
     public int[] intersection(int[] nums1, int[] nums2) &#123;
         int n=nums1.length;
         int m=nums2.length;
         Set&lt;Integer&gt; hashSet=new HashSet&lt;&gt;();
         Set&lt;Integer&gt; mergeSet=new HashSet&lt;&gt;();
         //1、利用Set无重复元素的特点 把nums1进行去重
         for(int i=0;i&lt;n;i++)&#123;
             hashSet.add(nums1[i]);
         &#125;
         //2、判断hashSet里面有么有nums2,有的话把nums2放到Set结果里面
         for(int i=0;i&lt;m;i++)&#123;
             if(hashSet.contains(nums2[i]))&#123;
                 mergeSet.add(nums2[i]);
             &#125;
         &#125;
         //Set转int[]
         int[] res=new int[mergeSet.size()];
         int i=0;
         for(int num:mergeSet)&#123;
             res[i++]=num;
         &#125;
         return res;
     &#125;
 &#125;
</code></pre>
<h2 id="242-有效的字母异位词"><a href="#242-有效的字母异位词" class="headerlink" title="242.有效的字母异位词"></a>242.有效的字母异位词</h2><p>题解：这个比寻找字母异位词起始下标还简单一点 是基础 那个是用滑动窗口，然后每次移动后再去判断 这个都不用 直接算<br>给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。<br>注意：若 s 和 t 中每个字符出现的次数都相同，则称 s 和 t 互为字母异位词。<br><img src="https://raw.githubusercontent.com/viacheung/img/main/image/image-20221015215819113.png#from=url&id=awpBE&originHeight=419&originWidth=806&originalType=binary&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&title="><br><img src="https://raw.githubusercontent.com/viacheung/img/main/image/image-20221015215826918.png#from=url&id=HglzT&originHeight=570&originWidth=869&originalType=binary&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&title="></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="ViaCheung"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">ViaCheung</p>
  <div class="site-description" itemprop="description">el psy congroo</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">32</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/viacheung" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;viacheung" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:viacheung5@gmail.com" title="E-Mail → mailto:viacheung5@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/zh-CN" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ViaCheung</span>
</div>

<!--
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div> -->

<!-- 网站运行时间的设置 -->
<span id="timeDate">载入天数...</span>
<span id="times">载入时分秒...</span>
<script>
    var now = new Date();
    function createtime() {
        var grt= new Date("03/01/2023 10:00:00"); //此处修改你的建站时间或者网站上线时间
        now.setTime(now.getTime()+250);
        days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days);
        hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours);
        if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);
        mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;}
        seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
        snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;}
        document.getElementById("timeDate").innerHTML = "本站已安全运行 "+dnum+" 天 ";
        document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒.";
    }
setInterval("createtime()",250);
</script>
        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>

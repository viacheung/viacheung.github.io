<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.1.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"viacheung.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="el psy congroo">
<meta property="og:type" content="website">
<meta property="og:title" content="命运石之门">
<meta property="og:url" content="http://viacheung.github.io/page/6/index.html">
<meta property="og:site_name" content="命运石之门">
<meta property="og:description" content="el psy congroo">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="ViaCheung">
<meta property="article:tag" content="Java,python">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://viacheung.github.io/page/6/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>命运石之门</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">命运石之门</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">欢迎来到我的博客空间🙇</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-schedule">

    <a href="/schedule/" rel="section"><i class="fa fa-calendar fa-fw"></i>日程表</a>

  </li>
        <li class="menu-item menu-item-sitemap">

    <a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>站点地图</a>

  </li>
        <li class="menu-item menu-item-commonweal">

    <a href="/404/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>公益 404</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/viacheung" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://viacheung.github.io/2023/06/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="ViaCheung">
      <meta itemprop="description" content="el psy congroo">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="命运石之门">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/06/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
	  <span class="post-time">

	  
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-06-04 00:59:01 / 修改时间：00:59:02" itemprop="dateCreated datePublished" datetime="2023-06-04T00:59:01+08:00">2023-06-04</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="计网"><a href="#计网" class="headerlink" title="计网"></a>计网</h1><h2 id="计算机网络的各层协议及作用？"><a href="#计算机网络的各层协议及作用？" class="headerlink" title="计算机网络的各层协议及作用？"></a>计算机网络的各层协议及作用？</h2><p><img src="https://raw.githubusercontent.com/viacheung/img/main/image/image-20230318181257136.png#id=tOJCK&originHeight=604&originWidth=1132&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<p>应用层：<strong>应用进程之间交互</strong>    DNS（域名系统）   HTTP（超文本传输协议）   SMTP（电子邮件）</p>
<p>表示层：<strong>数据格式的转换</strong>，如加密解密、转换翻译、压缩解压缩等。</p>
<p>会话层：网络中的两节点之间建立、维持和终止通信，如<strong>服务器验证用户登录</strong></p>
<p>运输层：为应用层提供通用数据传输服务 TCP（面向连接 可靠） UDP（⽆连接  不保证数据传输的可靠性  ）</p>
<p>网络层：选择合适路由节点  确保数据及时发送   IP协议</p>
<p>数据链路层：把网络层交付下来的ip数据报组装为帧 在两个相邻节点间链路传送帧（发数据）  帧包括数据＋控制信息（同步信息、地址信息、差错控制–丢失帧）</p>
<p>物理层：数据单位bt  实现相邻节点<strong>比特流</strong>的透明传输 尽量屏蔽传输介质和物理设备差异</p>
<h2 id="为什么分层？"><a href="#为什么分层？" class="headerlink" title="为什么分层？"></a>为什么分层？</h2><p>1、易于实现和标准化各层独立，就可以把大问题分割成多个小问题，利于实现；</p>
<p>2、灵活性好：如果某一层发生变化，只要接口不变，不会影响其他层；</p>
<p>3、分层后，用户只关心用到的应用层，其他层用户可以复用；<br>4、各层之间相互独立：高层不需要知道底层的功能是采取硬件来实现的，只需要知道通过底层的接口来获得所需要的服务。</p>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>三层架构和MVC</p>
<h2 id="三次握手-（建立连接）"><a href="#三次握手-（建立连接）" class="headerlink" title="三次握手 （建立连接）"></a>三次握手 （建立连接）</h2><p><img src="https://raw.githubusercontent.com/viacheung/img/main/image/image-20210520161056918.png#id=tsMFW&originHeight=931&originWidth=1200&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<p>三次握手机制：</p>
<ul>
<li>第一次握手：客户端请求建立连接，向服务端发送一个<strong>同步报文</strong>（SYN&#x3D;1），同时选择一个随机数 seq &#x3D; x 作为<strong>初始序列号</strong>，并进入SYN_SENT状态，等待服务器确认。</li>
<li>第二次握手：：服务端收到连接请求报文后，如果同意建立连接，则向客户端发送<strong>同步确认报文</strong>（SYN&#x3D;1，ACK&#x3D;1），确认号为 ack &#x3D; x + 1，同时选择一个随机数 seq &#x3D; y 作为初始序列号，此时服务器进入SYN_RECV状态。</li>
<li>第三次握手：客户端收到服务端的确认后，向服务端发送一个<strong>确认报文</strong>（ACK&#x3D;1），确认号为 ack &#x3D; y + 1，序列号为 seq &#x3D; x + 1，客户端和服务器进入ESTABLISHED状态，完成三次握手。</li>
</ul>
<p>理想状态下，TCP连接一旦建立，在通信双方中的任何一方主动关闭连接之前，TCP 连接都将被一直保持下去。</p>
<p>确认号&#x3D;序列号+1;</p>
<p>总结：</p>
<p>1、客户端发送带有syn(请求同步)的数据包到服务端  选择一个随机数seq&#x3D;x</p>
<p>服务端发送带有syn+ack的数据包</p>
<p>客户端发送带有ack标志数据包</p>
<p>目的：建立可靠传输，双方确认自己与对方的发送接受都正常</p>
<p>确保双方都是能发能接</p>
<h2 id="为什么需要三次握手，而不是两次？"><a href="#为什么需要三次握手，而不是两次？" class="headerlink" title="为什么需要三次握手，而不是两次？"></a><a target="_blank" rel="noopener" href="https://www.javalearn.cn/#/doc/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%9D%A2%E8%AF%95%E9%A2%98?id=_5-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%EF%BC%8C%E8%80%8C%E4%B8%8D%E6%98%AF%E4%B8%A4%E6%AC%A1%EF%BC%9F">为什么需要三次握手，而不是两次？</a></h2><p>主要有三个原因：</p>
<ol>
<li>防止已过期的连接请求报文突然又传送到服务器，因而产生错误和资源浪费。<br>在双方两次握手即可建立连接的情况下，假设客户端发送 A 报文段请求建立连接，由于网络原因造成 A 暂时无法到达服务器，服务器接收不到请求报文段就不会返回确认报文段。<br>客户端在长时间得不到应答的情况下重新发送请求报文段 B，这次 B 顺利到达服务器，服务器随即返回确认报文并进入 ESTABLISHED 状态，客户端在收到 确认报文后也进入 ESTABLISHED 状态，双方建立连接并传输数据，之后正常断开连接。<br>此时姗姗来迟的 A 报文段才到达服务器，服务器随即返回确认报文并进入 ESTABLISHED 状态，但是已经进入 CLOSED 状态的客户端无法再接受确认报文段，更无法进入 ESTABLISHED 状态，这将导致服务器长时间单方面等待，造成资源浪费。 </li>
<li>三次握手才能让双方均确认自己和对方的发送和接收能力都正常。<br>第一次握手：客户端只是发送处请求报文段，<strong>什么都无法确认</strong>，而服务器可以确认自己的接收能力和对方的发送能力正常；<br>第二次握手：客户端可以确认自己发送能力和接收能力正常，对方发送能力和接收能力正常；<br>第三次握手：服务器可以确认自己发送能力和接收能力正常，对方发送能力和接收能力正常；<br>可见三次握手才能让双方都确认自己和对方的发送和接收能力全部正常，这样就可以愉快地进行通信了。 </li>
<li>告知对方自己的初始序号值，并确认收到对方的初始序号值。<br>TCP 实现了可靠的数据传输，原因之一就是 TCP 报文段中维护了序号字段和确认序号字段，通过这两个字段双方都可以知道在自己发出的数据中，哪些是已经被对方确认接收的。这两个字段的值会在初始序号值得基础递增，<strong>如果是两次握手，只有发起方的初始序号可以得到确认，而另一方的初始序号则得不到确认。</strong></li>
</ol>
<h2 id="为什么要三次握手，而不是四次？"><a href="#为什么要三次握手，而不是四次？" class="headerlink" title="为什么要三次握手，而不是四次？"></a><a target="_blank" rel="noopener" href="https://www.javalearn.cn/#/doc/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%9D%A2%E8%AF%95%E9%A2%98?id=_6-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%EF%BC%8C%E8%80%8C%E4%B8%8D%E6%98%AF%E5%9B%9B%E6%AC%A1%EF%BC%9F">为什么要三次握手，而不是四次？</a></h2><p>因为<strong>三次握手已经可以确认双方的发送接收能力正常</strong>，双方都知道彼此已经准备好，而且也可以完成对双方初始序号值得确认，也就无需再第四次握手了。</p>
<ul>
<li>第一次握手：服务端确认“自己收、客户端发”报文功能正常。</li>
<li>第二次握手：客户端确认“自己发、自己收、服务端收、客户端发”报文功能正常，客户端认为连接已建立。</li>
<li>第三次握手：服务端确认“自己发、客户端收”报文功能正常，此时双方均建立连接，可以正常通信。</li>
</ul>
<h2 id="什么是-SYN洪泛攻击？如何防范？"><a href="#什么是-SYN洪泛攻击？如何防范？" class="headerlink" title="什么是 SYN洪泛攻击？如何防范？"></a><a target="_blank" rel="noopener" href="https://www.javalearn.cn/#/doc/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%9D%A2%E8%AF%95%E9%A2%98?id=_7-%E4%BB%80%E4%B9%88%E6%98%AF-syn%E6%B4%AA%E6%B3%9B%E6%94%BB%E5%87%BB%EF%BC%9F%E5%A6%82%E4%BD%95%E9%98%B2%E8%8C%83%EF%BC%9F">什么是 SYN洪泛攻击？如何防范？</a></h2><p>SYN洪泛攻击属于 DOS 攻击的一种，它利用 TCP 协议缺陷，通过发送大量的半连接请求，耗费 CPU 和内存资源。</p>
<p>原理：</p>
<ul>
<li>在三次握手过程中，服务器发送 <code>[SYN/ACK]</code> 包（第二个包）之后、收到客户端的 <code>[ACK]</code> 包（第三个包）之前的 TCP 连接称为半连接（half-open connect），此时服务器处于 <code>SYN_RECV</code>（等待客户端响应）状态。如果接收到客户端的 <code>[ACK]</code>，则 TCP 连接成功，如果未接受到，则会<strong>不断重发请求</strong>直至成功。</li>
<li>SYN 攻击的攻击者在短时间内<strong>伪造大量不存在的 IP 地址</strong>，向服务器不断地发送 <code>[SYN]</code> 包，服务器回复 <code>[SYN/ACK]</code> 包，并等待客户的确认。由于源地址是不存在的，服务器需要不断的重发直至超时。</li>
<li>这些伪造的 <code>[SYN]</code> 包将长时间占用未连接队列，影响了正常的 SYN，导致目标系统运行缓慢、网络堵塞甚至系统瘫痪。</li>
</ul>
<p>总结，不存在Ip发syn包，让服务器一直等待</p>
<p>检测：当在服务器上看到大量的半连接状态时，特别是源 IP 地址是随机的，基本上可以断定这是一次 SYN 攻击。</p>
<p>防范：</p>
<ul>
<li>通过防火墙、路由器等过滤网关防护。</li>
<li>通过加固 TCP&#x2F;IP 协议栈防范，如增加最大半连接数，缩短超时时间。</li>
<li>SYN cookies技术。SYN Cookies 是对 TCP 服务器端的三次握手做一些修改，专门用来防范 SYN 洪泛攻击的一种手段。</li>
</ul>
<h2 id="三次握手连接阶段，最后一次ACK包丢失，会发生什么？"><a href="#三次握手连接阶段，最后一次ACK包丢失，会发生什么？" class="headerlink" title="三次握手连接阶段，最后一次ACK包丢失，会发生什么？"></a><a target="_blank" rel="noopener" href="https://www.javalearn.cn/#/doc/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%9D%A2%E8%AF%95%E9%A2%98?id=_8-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E8%BF%9E%E6%8E%A5%E9%98%B6%E6%AE%B5%EF%BC%8C%E6%9C%80%E5%90%8E%E4%B8%80%E6%AC%A1ack%E5%8C%85%E4%B8%A2%E5%A4%B1%EF%BC%8C%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%EF%BC%9F">三次握手连接阶段，最后一次ACK包丢失，会发生什么？</a></h2><p><strong>服务端：</strong></p>
<p>（服务端超时重传 重传指定次数后 服务器自动关连接）</p>
<ul>
<li>第三次的ACK在网络中丢失，那么服务端该TCP连接的状态为SYN_RECV,并且会根据 TCP的超时重传机制，会等待3秒、6秒、12秒后重新发送SYN+ACK包，以便客户端重新发送ACK包。</li>
<li>如果重发指定次数之后，仍然未收到 客户端的ACK应答，那么一段时间后，服务端自动关闭这个连接。</li>
</ul>
<p><strong>客户端：</strong></p>
<p>(后面发数据 会发现三次握手失败)</p>
<p>客户端认为这个连接已经建立，如果客户端向服务端发送数据，服务端将以RST包（Reset，标示复位，用于异常的关闭连接）响应。此时，客户端知道第三次握手失败。</p>
<h2 id="四次挥手（断开连接）"><a href="#四次挥手（断开连接）" class="headerlink" title="四次挥手（断开连接）"></a>四次挥手（断开连接）</h2><p><img src="https://raw.githubusercontent.com/viacheung/img/main/image/image-20210520180127547.png#id=JyZIl&originHeight=960&originWidth=1088&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<ul>
<li>第一次挥手：客户端向服务端发送连接释放报文（FIN&#x3D;1，ACK&#x3D;1），主动关闭连接，同时等待服务端的确认。 <ul>
<li>序列号 seq &#x3D; u，即客户端上次发送的报文的最后一个字节的序号 + 1</li>
<li>确认号 ack &#x3D; k, 即服务端上次发送的报文的最后一个字节的序号 + 1</li>
</ul>
</li>
<li>第二次挥手：服务端收到连接释放报文后，立即发出<strong>确认报文</strong>（ACK&#x3D;1）（序列号 seq &#x3D; k，确认号 ack &#x3D; u + 1）。<br>这时 TCP 连接处于半关闭状态，即客户端到服务端的连接已经释放了，但是服务端到客户端的连接还未释放。这表示客户端已经没有数据发送了，但是服务端可能还要给客户端发送数据。 </li>
<li>第三次挥手：服务端向客户端发送连接释放报文（FIN&#x3D;1，ACK&#x3D;1），主动关闭连接，同时等待 A 的确认。 <ul>
<li>序列号 seq &#x3D; w，即服务端上次发送的报文的最后一个字节的序号 + 1。</li>
<li>确认号 ack &#x3D; u + 1，与第二次挥手相同，因为这段时间客户端没有发送数据</li>
</ul>
</li>
<li>第四次挥手：客户端收到服务端的连接释放报文后，立即发出<strong>确认报文</strong>（ACK&#x3D;1）（序列号 seq &#x3D; u + 1，确认号为 ack &#x3D; w + 1）。<br>此时，客户端就进入了 <code>TIME-WAIT</code> 状态。注意此时客户端到 TCP 连接还没有释放，必须经过 2*MSL（最长报文段寿命）的时间后，才进入 <code>CLOSED</code> 状态。而服务端只要收到客户端发出的确认，就立即进入 <code>CLOSED</code> 状态。可以看到，服务端结束 TCP 连接的时间要比客户端早一些。</li>
</ul>
<p>总结：</p>
<p>客户端发送一个fin，服务端回一个ack，然后客户端到服务端的数据传送关闭</p>
<p>服务端发送一个fin，客户端回一个ack，然后服务端到客户端的数据传送关闭</p>
<p>目的  ：两边确认对方没有要发送的数据</p>
<h2 id="为什么连接的时候是三次握手，关闭的时候却是四次握手？"><a href="#为什么连接的时候是三次握手，关闭的时候却是四次握手？" class="headerlink" title="为什么连接的时候是三次握手，关闭的时候却是四次握手？"></a><a target="_blank" rel="noopener" href="https://www.javalearn.cn/#/doc/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%9D%A2%E8%AF%95%E9%A2%98?id=_10-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%9E%E6%8E%A5%E7%9A%84%E6%97%B6%E5%80%99%E6%98%AF%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%EF%BC%8C%E5%85%B3%E9%97%AD%E7%9A%84%E6%97%B6%E5%80%99%E5%8D%B4%E6%98%AF%E5%9B%9B%E6%AC%A1%E6%8F%A1%E6%89%8B%EF%BC%9F">为什么连接的时候是三次握手，关闭的时候却是四次握手？</a></h2><p>服务器在收到客户端的 FIN 报文段后，可能还有一些数据要传输，所以不能马上关闭连接，但是会做出应答，返回 ACK 报文段.</p>
<p>接下来可能会继续发送数据，在数据发送完后，服务器会向客户单发送 FIN 报文，表示数据已经发送完毕，请求关闭连接。服务器的<strong>ACK和FIN一般都会分开发送</strong>，从而导致多了一次，因此一共需要四次挥手。</p>
<h2 id="为什么客户端的-TIME-WAIT-状态必须等待-2MSL-？"><a href="#为什么客户端的-TIME-WAIT-状态必须等待-2MSL-？" class="headerlink" title="为什么客户端的 TIME-WAIT 状态必须等待 2MSL ？"></a><a target="_blank" rel="noopener" href="https://www.javalearn.cn/#/doc/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%9D%A2%E8%AF%95%E9%A2%98?id=_11-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84-time-wait-%E7%8A%B6%E6%80%81%E5%BF%85%E9%A1%BB%E7%AD%89%E5%BE%85-2msl-%EF%BC%9F">为什么客户端的 TIME-WAIT 状态必须等待 2MSL ？</a></h2><p>主要有两个原因：</p>
<ol>
<li>确保 ACK 报文能够到达服务端，从而使服务端正常关闭连接。<br>第四次挥手时，客户端第四次挥手的 ACK 报文不一定会到达服务端。服务端会超时重传 FIN&#x2F;ACK 报文，此时如果客户端已经断开了连接，那么就无法响应服务端的二次请求，这样服务端迟迟收不到 FIN&#x2F;ACK 报文的确认，就无法正常断开连接。<br>MSL 是报文段在网络上存活的最长时间。客户端等待 2MSL 时间，即「客户端 ACK 报文 1MSL 超时 + 服务端 FIN 报文 1MSL 传输」，就能够收到服务端重传的 FIN&#x2F;ACK 报文，然后客户端重传一次 ACK 报文，并重新启动 2MSL 计时器。如此保证服务端能够正常关闭。<br>如果服务端重发的 FIN 没有成功地在 2MSL 时间里传给客户端，服务端则会继续超时重试直到断开连接。 </li>
<li>防止已失效的连接请求报文段出现在之后的连接中。<br>TCP 要求在 2MSL 内不使用相同的序列号。客户端在发送完最后一个 ACK 报文段后，再经过时间 2MSL，就可以保证本连接持续的时间内产生的所有报文段都从网络中消失。这样就可以使下一个连接中不会出现这种旧的连接请求报文段。或者即使收到这些过时的报文，也可以不处理它。</li>
</ol>
<h2 id="如果已经建立了连接，但是客户端出现故障了怎么办？"><a href="#如果已经建立了连接，但是客户端出现故障了怎么办？" class="headerlink" title="如果已经建立了连接，但是客户端出现故障了怎么办？"></a><a target="_blank" rel="noopener" href="https://www.javalearn.cn/#/doc/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%9D%A2%E8%AF%95%E9%A2%98?id=_12-%E5%A6%82%E6%9E%9C%E5%B7%B2%E7%BB%8F%E5%BB%BA%E7%AB%8B%E4%BA%86%E8%BF%9E%E6%8E%A5%EF%BC%8C%E4%BD%86%E6%98%AF%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%87%BA%E7%8E%B0%E6%95%85%E9%9A%9C%E4%BA%86%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F">如果已经建立了连接，但是客户端出现故障了怎么办？</a></h2><p>或者说，如果三次握手阶段、四次挥手阶段的包丢失了怎么办？如“服务端重发 FIN丢失”的问题。</p>
<p>简而言之，通过<strong>定时器 + 超时重试机制</strong>，尝试获取确认，直到最后会自动断开连接。</p>
<p>具体而言，TCP 设有一个保活计时器。服务器每收到一次客户端的数据，都会重新复位这个计时器，以Linux服务器为例，时间通常是设置为 2 小时。若 2 小时还没有收到客户端的任何数据，服务器就开始重试：每隔 75 秒（默认）发送一个探测报文段，若一共发送 10 个探测报文后客户端依然没有回应，那么服务器就认为连接已经断开了。</p>
<blockquote>
<p>附：Linux服务器系统内核参数配置</p>
</blockquote>
<ol>
<li>tcp_keepalive_time，在TCP保活打开的情况下，最后一次数据交换到TCP发送第一个保活探测包的间隔，即允许的持续空闲时长，或者说每次正常发送心跳的周期，默认值为7200s（2h）。</li>
<li>tcp_keepalive_probes 在tcp_keepalive_time之后，没有接收到对方确认，<strong>继续发送保活探测包次数，默认值为9（次）</strong>。</li>
<li>tcp_keepalive_intvl，在tcp_keepalive_time之后，没有接收到对方确认，继续发送保活探测包的发送频率，默认值为75s。 发送频率tcp_keepalive_intvl乘以发送次数tcp_keepalive_probes，就得到了从开始探测到放弃探测确定连接断开的时间； 举例：若设置，服务器在客户端连接空闲的时候，每90秒发送一次保活探测包到客户端，若没有及时收到客户端的TCP Keepalive ACK确认，将继续等待15秒*2&#x3D;30秒。总之可以在90s+30s&#x3D;120秒（两分钟）时间内可检测到连接失效与否。</li>
</ol>
<h2 id="TIME-WAIT-状态过多会产生什么后果？怎样处理？"><a href="#TIME-WAIT-状态过多会产生什么后果？怎样处理？" class="headerlink" title="TIME-WAIT 状态过多会产生什么后果？怎样处理？"></a><a target="_blank" rel="noopener" href="https://www.javalearn.cn/#/doc/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%9D%A2%E8%AF%95%E9%A2%98?id=_13-time-wait-%E7%8A%B6%E6%80%81%E8%BF%87%E5%A4%9A%E4%BC%9A%E4%BA%A7%E7%94%9F%E4%BB%80%E4%B9%88%E5%90%8E%E6%9E%9C%EF%BC%9F%E6%80%8E%E6%A0%B7%E5%A4%84%E7%90%86%EF%BC%9F">TIME-WAIT 状态过多会产生什么后果？怎样处理？</a></h2><p>从服务器来讲，短时间内关闭了大量的Client连接，就会造成服务器上出现大量的TIME_WAIT连接，严重消耗着服务器的资源，此时部分客户端就会显示连接不上。</p>
<p>从客户端来讲，客户端TIME_WAIT过多，就会导致端口资源被占用，因为端口就65536个，被占满就会导致无法创建新的连接。</p>
<p><strong>解决办法：</strong></p>
<ul>
<li>服务器可以设置 SO_REUSEADDR 套接字选项来避免 TIME_WAIT状态，此套接字选项告诉内核，即使此端口正忙（处于 TIME_WAIT状态），也请继续并重用它。</li>
<li>调整系统内核参数，修改&#x2F;etc&#x2F;sysctl.conf文件，即修改<code>net.ipv4.tcp_tw_reuse 和 tcp_timestamps</code></li>
<li>强制关闭，发送 RST 包越过TIME_WAIT状态，直接进入CLOSED状态。</li>
</ul>
<h2 id="TIME-WAIT-是服务器端的状态-还是客户端的状态"><a href="#TIME-WAIT-是服务器端的状态-还是客户端的状态" class="headerlink" title="TIME_WAIT 是服务器端的状态?还是客户端的状态?"></a><a target="_blank" rel="noopener" href="https://www.javalearn.cn/#/doc/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%9D%A2%E8%AF%95%E9%A2%98?id=_14-time_wait-%E6%98%AF%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E7%9A%84%E7%8A%B6%E6%80%81%E8%BF%98%E6%98%AF%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84%E7%8A%B6%E6%80%81">TIME_WAIT 是服务器端的状态?还是客户端的状态?</a></h2><p>TIME_WAIT 是主动断开连接的一方会进入的状态，一般情况下，都是客户端所处的状态;服务器端一般设置不主动关闭连接。</p>
<p>TIME_WAIT 需要等待 2MSL，在大量短连接的情况下，TIME_WAIT会太多，这也会消耗很多系统资源。对于服务器来说，在 HTTP 协议里指定 KeepAlive（浏览器重用一个 TCP 连接来处理多个 HTTP 请求），由浏览器来主动断开连接，可以一定程度上减少服务器的这个问题</p>
<h2 id="详细讲一下TCP的滑动窗口？"><a href="#详细讲一下TCP的滑动窗口？" class="headerlink" title="详细讲一下TCP的滑动窗口？"></a><a target="_blank" rel="noopener" href="https://www.javalearn.cn/#/doc/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%9D%A2%E8%AF%95%E9%A2%98?id=_16-%E8%AF%A6%E7%BB%86%E8%AE%B2%E4%B8%80%E4%B8%8Btcp%E7%9A%84%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%EF%BC%9F">详细讲一下TCP的滑动窗口？</a></h2><p>在进行数据传输时，如果传输的数据比较大，就需要拆分为多个数据包进行发送。TCP 协议需要对数据进行确认后，才可以发送下一个数据包。这样一来，就会在等待确认应答包环节浪费时间。</p>
<p>为了避免这种情况，TCP引入了窗口概念。窗口大小指的是不需要等待确认应答包而可以继续发送数据包的最大值。</p>
<p><img src="https://raw.githubusercontent.com/viacheung/img/main/image/image-20210520214432214.png#id=Ty2Fk&originHeight=531&originWidth=1026&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<p>从上面的图可以看到滑动窗口左边的是已发送并且被确认的分组，滑动窗口右边是还没有轮到的分组。</p>
<p>滑动窗口里面也分为两块，一块是已经发送但是未被确认的分组，另一块是窗口内等待发送的分组。随着已发送的分组不断被确认，窗口内等待发送的分组也会不断被发送。整个窗口就会往右移动，让还没轮到的分组进入窗口内。</p>
<p>可以看到滑动窗口起到了一个限流的作用，也就是说当前滑动窗口的大小决定了当前 TCP 发送包的速率，而滑动窗口的大小取决于拥塞控制窗口和流量控制窗口的两者间的最小值。</p>
<h2 id="TCP-VS-UD"><a href="#TCP-VS-UD" class="headerlink" title="TCP VS UD"></a>TCP VS UD</h2><p><img src="https://raw.githubusercontent.com/viacheung/img/main/image/image-20230318181625164.png#id=Wyq6S&originHeight=323&originWidth=881&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<p>TCP 用于在传输层有必要实现可靠传输的情况，UDP 用于对高速传输和实时性有较高要求的通信。TCP 和 UDP 应该根据应用目的按需使用。</p>
<h2 id="UDP-和-TCP-对应的应用场景是什么？"><a href="#UDP-和-TCP-对应的应用场景是什么？" class="headerlink" title="UDP 和 TCP 对应的应用场景是什么？"></a><a target="_blank" rel="noopener" href="https://www.javalearn.cn/#/doc/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%9D%A2%E8%AF%95%E9%A2%98?id=_3-udp-%E5%92%8C-tcp-%E5%AF%B9%E5%BA%94%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F">UDP 和 TCP 对应的应用场景是什么？</a></h2><p>TCP 是面向连接，能保证数据的可靠性交付，因此经常用于：</p>
<ul>
<li>FTP文件传输</li>
<li>HTTP &#x2F; HTTPS</li>
</ul>
<p>UDP 面向无连接，它可以随时发送数据，再加上UDP本身的处理既简单又高效，因此经常用于：</p>
<ul>
<li>包总量较少的通信，如 DNS 、SNMP等</li>
<li>视频、音频等多媒体通信</li>
<li>广播通信</li>
</ul>
<p><img src="https://raw.githubusercontent.com/viacheung/img/main/image/image-20210519180008296.png#id=UkTy2&originHeight=627&originWidth=800&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<h2 id="TCP-协议如何保证可靠传输"><a href="#TCP-协议如何保证可靠传输" class="headerlink" title="TCP 协议如何保证可靠传输"></a>TCP 协议如何保证可靠传输</h2><p>重传、流量控制、拥塞控制、序列号与确认应达号、校验和</p>
<p>1、合适地分割数据变成数据块</p>
<p>2、给包编号</p>
<p>3、校验和： 通过检验和的方式，接收端可以检测出来数据是否有差错和异常，假如有差错就会直接丢弃TCP段，重新发送。</p>
<p>4、丢失重复</p>
<p>5、流量控制 （缓冲空间 利用滑动窗口实现）：</p>
<p>如果主机A 一直向主机B发送数据，不考虑主机B的接受能力，则可能导致主机B的接受缓冲区满了而无法再接受数据，从而会导致大量的数据丢包，引发重传机制。而在重传的过程中，若主机B的接收缓冲区情况仍未好转，则会将大量的时间浪费在重传数据上，降低传送数据的效率。所以引入流量控制机制，主机B通过告诉主机A自己接收缓冲区的大小，来使主机A控制发送的数据量。流量控制与TCP协议报头中的窗口大小有关。</p>
<p>6、拥塞控制（拥塞时减少发送）：</p>
<p>在数据传输过程中，可能由于网络状态的问题，造成网络拥堵，此时引入拥塞控制机制，在保证TCP可靠性的同时，提高性能。</p>
<p>7、ARQ</p>
<p>8、超时重传（有个定时器，等待接收端发ack，等不到就重发）：</p>
<p>超时重传是指发送出去的数据包到接收到确认包之间的时间，如果超过了这个时间会被认为是丢包了，需要重传。最大超时时间是动态计算的。</p>
<p>9、滑动窗口：</p>
<p>滑动窗口既提高了报文传输的效率，也避免了发送方发送过多的数据而导致接收方无法正常处理的异常。</p>
<p>10、序列号&#x2F;确认应答：</p>
<p>序列号的作用不仅仅是应答的作用，有了序列号能够将接收到的数据根据序列号排序，并且去掉重复序列号的数据。</p>
<p>TCP传输的过程中，每次接收方收到数据后，都会对传输方进行确认应答。也就是发送ACK报文，这个ACK报文当中带有对应的确认序列号，告诉发送方，接收到了哪些数据，下一次的数据从哪里发。</p>
<h2 id="ARQ"><a href="#ARQ" class="headerlink" title="ARQ"></a>ARQ</h2><p>⾃动重传请求，它通过使⽤确认和超时这两个机制，在不可靠服务的基础上实现可靠的信息传输。如果发送⽅在发送后⼀段时间之内没有收到确认帧，它通常会重新发送。</p>
<p>ARQ包括停⽌等待ARQ协议和连续ARQ协议</p>
<h3 id="停⽌等待ARQ协议"><a href="#停⽌等待ARQ协议" class="headerlink" title="停⽌等待ARQ协议"></a>停⽌等待ARQ协议</h3><p>优点： 简单<br>缺点： 信道利⽤率低，等待时间⻓</p>
<p>1、⽆差错情况:<br>发送⽅发送分组,接收⽅在规定时间内收到,并且回复确认.发送⽅再次发送。</p>
<p>2、出现差错情况（超时重传） :<br>停⽌等待协议中超时重传是指只要超过⼀段时间仍然没有收到确认，就重传前⾯发送过的分组（认为刚才发送过的分组丢失了）。因此每发送完⼀个分组需要设置⼀个超时计时器。</p>
<p>3、确认丢失和确认迟到<br>确认丢失 ：syn  –ack丢失   客户端没收到ack  超时计时后  再syn</p>
<p>因此服务端收到俩syn，处理有2种：丢弃这个重复的syn和向A发送<br>确认消息。</p>
<h3 id="连续ARQ协议"><a href="#连续ARQ协议" class="headerlink" title="连续ARQ协议"></a>连续ARQ协议</h3><p>连续 ARQ 协议可提⾼信道利⽤率。发送⽅维持⼀个发送窗⼝，位于窗口内的分组可以连续发送，接受端对到达的最后⼀个分组发送确认，表明所有分组都已经正确收到了。</p>
<p>优点： 信道利⽤率⾼，容易实现，即使确认丢失，也不必重传。</p>
<p>缺点： 不能向发送⽅反映出接收⽅已经正确收到的所有分组的信息。 ⽐如：发送⽅发送了 5条消息，中间第三条丢失（3号），这时接收⽅只能对前两个发送确认。发送⽅⽆法知道后三个分组的下落，⽽只好把后三个全部重传⼀次。这也叫 Go-Back-N</p>
<h2 id="滑动窗⼝和流量控制"><a href="#滑动窗⼝和流量控制" class="headerlink" title="滑动窗⼝和流量控制"></a>滑动窗⼝和流量控制</h2><p>TCP 利⽤滑动窗⼝实现流量控制。流量控制是为了控制发送⽅发送速率，保证接收⽅来得及接收。</p>
<h2 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h2><p>拥塞：某段时间，若对⽹络中某⼀资源的需求超过了该资源所能提供的可⽤部分，⽹络的性能就要变坏。这种情况就叫拥塞。</p>
<p>拥塞控制：拥塞控制就是为了防⽌过多的数据注⼊到⽹络中，这样就可以使⽹络中的路由器或链路不致过载。</p>
<p>vs流量控制：拥塞是全局（涉及到所有主机路由器  ）流量是端到端</p>
<p>实操：维持⼀个 拥塞窗⼝</p>
<p>TCP 一共使用了四种算法来实现拥塞控制：</p>
<ul>
<li>慢开始 (slow-start)；</li>
<li>拥塞避免 (congestion avoidance)；</li>
<li>快速重传 (fast retransmit)；</li>
<li>快速恢复 (fast recovery)。</li>
</ul>
<p><strong>慢开始</strong>：不要一开始就发送大量的数据，由小到大逐渐增加拥塞窗口的大小。（每一个传播轮次加倍）</p>
<p><strong>拥塞避免</strong>：拥塞避免算法让拥塞窗口缓慢增长，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1而不是加倍。这样拥塞窗口按线性规律缓慢增长。一个RTT   cwnd+1）</p>
<p><strong>快重传：</strong>我们可以剔除一些不必要的拥塞报文，提高网络吞吐量。比如接收方在<strong>收到一个失序的报文段后就立即发出重复确认，而不要等到自己发送数据时捎带确认。</strong>快重传规定：发送方只要<strong>一连收到三个</strong>重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期。</p>
<p><img src="https://raw.githubusercontent.com/viacheung/img/main/image/image-20210520214123058.png#id=D2Qml&originHeight=362&originWidth=724&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<p><strong>快恢复：</strong>主要是配合快重传。当发送方连续收到三个重复确认时，就执行“乘法减小”算法，把ssthresh门限减半（为了预防网络发生拥塞），但<strong>接下来并不执行慢开始算法</strong>，因为如果网络出现拥塞的话就不会收到好几个重复的确认，收到三个重复确认说明网络状况还可以。</p>
<p><img src="https://raw.githubusercontent.com/viacheung/img/main/image/image-20210520214146324.png#id=Me0rP&originHeight=397&originWidth=880&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<p><strong>快重传与快恢复</strong>：</p>
<p>之前的重传是数据丢失导致接收端收不到数据导致发送端收不到ack，然后超时就会重新发syn，耗时且中间不能发其他数据了</p>
<p>但是有了FRR ，当接收端收到不按序的数据段 连发三个确认 那么发送端就立即重发 不等计时器</p>
<h2 id="HTTP常见的状态码有哪些？"><a href="#HTTP常见的状态码有哪些？" class="headerlink" title="HTTP常见的状态码有哪些？"></a><a target="_blank" rel="noopener" href="https://www.javalearn.cn/#/doc/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%9D%A2%E8%AF%95%E9%A2%98?id=_18-http%E5%B8%B8%E8%A7%81%E7%9A%84%E7%8A%B6%E6%80%81%E7%A0%81%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F">HTTP常见的状态码有哪些？</a></h2><p>常见状态码：</p>
<ul>
<li>200：服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页。</li>
<li>301 ： (永久移动) 请求的网页已永久移动到新位置。 服务器返回此响应(对 GET 或 HEAD 请求的响应)时，会自动将请求者转到新位置。</li>
<li>302：(临时移动) 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。</li>
<li>400 ：客户端请求有语法错误，不能被服务器所理解。</li>
<li>403 ：服务器收到请求，但是拒绝提供服务。</li>
<li>404 ：(未找到) 服务器找不到请求的网页。</li>
<li>500： (服务器内部错误) 服务器遇到错误，无法完成请求。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/viacheung/img/main/image/image-20210525114439748.png#id=ordgu&originHeight=218&originWidth=673&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<h2 id="状态码301和302的区别是什么？"><a href="#状态码301和302的区别是什么？" class="headerlink" title="状态码301和302的区别是什么？"></a><a target="_blank" rel="noopener" href="https://www.javalearn.cn/#/doc/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%9D%A2%E8%AF%95%E9%A2%98?id=_19-%E7%8A%B6%E6%80%81%E7%A0%81301%E5%92%8C302%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F">状态码301和302的区别是什么？</a></h2><p><strong>共同点</strong>：301和302状态码都表示重定向，就是说浏览器在拿到服务器返回的这个状态码后会自动跳转到一个新的URL地址，这个地址可以从响应的Location首部中获取（<strong>用户看到的效果就是他输入的地址A瞬间变成了另一个地址B</strong>）。</p>
<p><strong>不同点</strong>：</p>
<p>301表示旧地址A的资源已经被永久地移除了(这个资源不可访问了)，搜索引擎在抓取新内容的同时也将旧的网址交换为重定向之后的网址；</p>
<p>302表示旧地址A的资源还在（仍然可以访问），这个重定向只是临时地从旧地址A跳转到地址B，搜索引擎会抓取新的内容而保存旧的网址。 SEO中302好于301。</p>
<p><strong>补充，重定向原因</strong>：</p>
<ol>
<li>网站调整（如改变网页目录结构）；</li>
<li>网页被移到一个新地址；</li>
<li>网页扩展名改变(如应用需要把.php改成.Html或.shtml)。</li>
</ol>
<h2 id="HTTP-常用的请求方式？"><a href="#HTTP-常用的请求方式？" class="headerlink" title="HTTP 常用的请求方式？"></a><a target="_blank" rel="noopener" href="https://www.javalearn.cn/#/doc/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%9D%A2%E8%AF%95%E9%A2%98?id=_20-http-%E5%B8%B8%E7%94%A8%E7%9A%84%E8%AF%B7%E6%B1%82%E6%96%B9%E5%BC%8F%EF%BC%9F">HTTP 常用的请求方式？</a></h2><ul>
<li>PUT：上传文件，向服务器添加数据，可以看作增</li>
<li>DELETE：删除文件</li>
<li>POST：传输数据，向服务器提交数据，对服务器数据进行更新。</li>
<li>GET：获取资源，查询服务器资源</li>
</ul>
<h2 id="GET请求和POST请求的区别？"><a href="#GET请求和POST请求的区别？" class="headerlink" title="GET请求和POST请求的区别？"></a><a target="_blank" rel="noopener" href="https://www.javalearn.cn/#/doc/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%9D%A2%E8%AF%95%E9%A2%98?id=_21-get%E8%AF%B7%E6%B1%82%E5%92%8Cpost%E8%AF%B7%E6%B1%82%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F">GET请求和POST请求的区别？</a></h2><p><strong>使用上的区别</strong>：</p>
<ul>
<li>GET使用URL或Cookie传参，而POST将数据放在BODY中，这个是因为HTTP协议用法的约定。</li>
<li>GET方式提交的数据有长度限制，则POST的数据则可以非常大”，这个是因为它们使用的操作系统和浏览器设置的不同引起的区别。</li>
<li>POST比GET安全，因为数据在地址栏上不可见”，这个说法没毛病，但依然不是GET和POST本身的区别。</li>
</ul>
<p><strong>本质区别</strong></p>
<p>GET和POST最大的区别主要是GET请求是幂等性的，POST请求不是。这个是它们本质区别。</p>
<p>幂等性是指一次和多次请求某一个资源应该具有同样的副作用。简单来说意味着对同一URL的多个请求应该返回同样的结果。</p>
<h2 id="在浏览器中输⼊url地址-gt-gt-显示主⻚的过程"><a href="#在浏览器中输⼊url地址-gt-gt-显示主⻚的过程" class="headerlink" title="在浏览器中输⼊url地址 -&gt;&gt; 显示主⻚的过程"></a>在浏览器中输⼊url地址 -&gt;&gt; 显示主⻚的过程</h2><ol>
<li>DNS解析（<strong>浏览器搜索自己的DNS缓存</strong>（维护一张域名与IP的对应表）；若没有，则搜索<strong>操作系统的DNS缓存</strong>（维护一张域名与IP的对应表）；若没有，则搜索操作系统的<strong>hosts文件</strong>（维护一张域名与IP的对应表）。<br>若都没有，则找 tcp&#x2F;ip 参数中设置的首选 dns 服务器，即<strong>本地 dns 服务器</strong>（递归查询），<strong>本地域名服务器查询自己的dns缓存</strong>，如果没有，则进行迭代查询。将本地dns服务器将IP返回给操作系统，同时缓存IP。） </li>
<li>TCP连接（发起 tcp 的三次握手，建立 tcp 连接。浏览器会以一个随机端口（1024-65535）向服务端的 web 程序 80 端口发起 tcp 的连接。） </li>
<li>发送HTTP请求。 </li>
<li>服务器处理，客户端得到 html 代码。服务器 web 应用程序收到 http 请求后，就开始处理请求，处理之后就返回给浏览器 html 文件。 </li>
<li>浏览器解析，解析 html 代码，并请求 html 中的资源。浏览器对页面进行渲染，并呈现给用户 </li>
<li>连接结束</li>
</ol>
<p><img src="https://raw.githubusercontent.com/viacheung/img/main/image/image-20230313160513726.png#id=JK5ET&originHeight=453&originWidth=628&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<h2 id="各种协议与HTTP协议之间的关系"><a href="#各种协议与HTTP协议之间的关系" class="headerlink" title="各种协议与HTTP协议之间的关系"></a>各种协议与HTTP协议之间的关系</h2><p><img src="https://raw.githubusercontent.com/viacheung/img/main/image/image-20230313160546396.png#id=fMaN6&originHeight=699&originWidth=476&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<h2 id="HTTP⻓连接-短连接"><a href="#HTTP⻓连接-短连接" class="headerlink" title="HTTP⻓连接,短连接"></a>HTTP⻓连接,短连接</h2><p>**HTTP&#x2F;1.0中默认使⽤短连接  **，每次建立连接之后都中断</p>
<p>HTTP&#x2F;1.1里面默认使⽤⻓连接 ， 响应头加入Connection:keep-alive  ，再次访问这个服务器会继续使用已经建立的连接，但有时间限制，且客户端服务端都要支持长连接</p>
<p>HTTP协议的⻓连接和短连接，实质上是TCP协议的⻓连接和短连接。</p>
<h2 id="HTTP请求报文和响应报文的格式？"><a href="#HTTP请求报文和响应报文的格式？" class="headerlink" title="HTTP请求报文和响应报文的格式？"></a><a target="_blank" rel="noopener" href="https://www.javalearn.cn/#/doc/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%9D%A2%E8%AF%95%E9%A2%98?id=_23-http%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87%E5%92%8C%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87%E7%9A%84%E6%A0%BC%E5%BC%8F%EF%BC%9F">HTTP请求报文和响应报文的格式？</a></h2><p><strong>请求报文格式</strong>：</p>
<ol>
<li>请求行（请求方法+URI协议+版本）</li>
<li>请求头部</li>
<li>空行</li>
<li>请求主体</li>
</ol>
<pre><code class="html">GET/sample.jspHTTP/1.1 请求行
Accept:image/gif.image/jpeg, 请求头部
Accept-Language:zh-cn
Connection:Keep-Alive
Host:localhost
User-Agent:Mozila/4.0(compatible;MSIE5.01;Window NT5.0)
Accept-Encoding:gzip,deflate
username=jinqiao&amp;password=1234 请求主体
</code></pre>
<p><strong>响应报文</strong>：</p>
<ol>
<li>状态行（版本+状态码+原因短语）</li>
<li>响应首部</li>
<li>空行</li>
<li>响应主体</li>
</ol>
<pre><code class="html">HTTP/1.1 200 OK
Server:Apache Tomcat/5.0.12
Date:Mon,6Oct2003 13:23:42 GMT
Content-Length:112

&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;HTTP响应示例&lt;title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        Hello HTTP!
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h2 id="HTTP是不保存状态的协议-如何保存⽤户状态"><a href="#HTTP是不保存状态的协议-如何保存⽤户状态" class="headerlink" title="HTTP是不保存状态的协议,如何保存⽤户状态?"></a>HTTP是不保存状态的协议,如何保存⽤户状态?</h2><p>服务端放一个session记录用户状态，客户端我们通过在 Cookie 中附加⼀个 Session ID 来⽅式来跟踪。</p>
<h2 id="Cookie-被禁⽤怎么办"><a href="#Cookie-被禁⽤怎么办" class="headerlink" title="Cookie 被禁⽤怎么办?"></a>Cookie 被禁⽤怎么办?</h2><p>最常⽤的就是利⽤ URL 重写把 Session ID 直接附加在URL路径的后⾯  <a target="_blank" rel="noopener" href="https://javaguide.cn/?Session_id=xxx">https://javaguide.cn/?Session_id&#x3D;xxx</a></p>
<h2 id="什么是-Cookie-和-Session"><a href="#什么是-Cookie-和-Session" class="headerlink" title="什么是 Cookie 和 Session ?"></a><a target="_blank" rel="noopener" href="https://www.javalearn.cn/#/doc/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%9D%A2%E8%AF%95%E9%A2%98?id=_30-%E4%BB%80%E4%B9%88%E6%98%AF-cookie-%E5%92%8C-session-">什么是 Cookie 和 Session ?</a></h2><p><strong>什么是 Cookie</strong></p>
<p>HTTP Cookie（也叫 Web Cookie或浏览器 Cookie）是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。通常，它用于告知服务端两个请求是否来自同一浏览器，如保持用户的登录状态。Cookie 使基于无状态的 HTTP 协议记录稳定的状态信息成为了可能。</p>
<p>Cookie 主要用于以下三个方面：</p>
<ul>
<li>会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）</li>
<li>个性化设置（如用户自定义设置、主题等）</li>
<li>浏览器行为跟踪（如跟踪分析用户行为等）</li>
</ul>
<p><strong>什么是 Session</strong></p>
<p>Session 代表着服务器和客户端一次会话的过程。Session 对象存储特定用户会话所需的属性及配置信息。这样，当用户在应用程序的 Web 页之间跳转时，存储在 Session 对象中的变量将不会丢失，而是在整个用户会话中一直存在下去。当客户端关闭会话，或者 Session 超时失效时会话结束。</p>
<p><strong>总结</strong></p>
<p>作用：保存⽤户信息  ，帮你登录的⼀些基本信息给填了  ，cookie里面存放了⼀个Token  ，下次登录的时候只需要根据 Token 值来查找⽤户即可</p>
<p>区别：Cookie 数据保存在客户端(浏览器端)， Session 数据保存在服务器端。  session安全些</p>
<h2 id="Cookie-和-Session-是如何配合的呢？"><a href="#Cookie-和-Session-是如何配合的呢？" class="headerlink" title="Cookie 和 Session 是如何配合的呢？"></a><a target="_blank" rel="noopener" href="https://www.javalearn.cn/#/doc/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%9D%A2%E8%AF%95%E9%A2%98?id=_31-cookie-%E5%92%8C-session-%E6%98%AF%E5%A6%82%E4%BD%95%E9%85%8D%E5%90%88%E7%9A%84%E5%91%A2%EF%BC%9F">Cookie 和 Session 是如何配合的呢？</a></h2><p>用户第一次请求服务器的时候，服务器根据用户提交的相关信息，创建对应的 Session ，请求返回时将此 Session 的唯一标识信息 SessionID 返回给浏览器，浏览器接收到服务器返回的 SessionID 信息后，会将此信息存入到 Cookie 中，同时 Cookie 记录此 SessionID 属于哪个域名。</p>
<p>当用户第二次访问服务器的时候，请求会自动判断此域名下是否存在 Cookie 信息，如果存在自动将 Cookie 信息也发送给服务端，服务端会从 Cookie 中获取 SessionID，再根据 SessionID 查找对应的 Session 信息，如果没有找到说明用户没有登录或者登录失效，如果找到 Session 证明用户已经登录可执行后面操作。</p>
<p>根据以上流程可知，SessionID 是连接 Cookie 和 Session 的一道桥梁，大部分系统也是根据此原理来验证用户登录状态。</p>
<h2 id="Cookie和Session的区别？"><a href="#Cookie和Session的区别？" class="headerlink" title="Cookie和Session的区别？"></a><a target="_blank" rel="noopener" href="https://www.javalearn.cn/#/doc/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%9D%A2%E8%AF%95%E9%A2%98?id=_32-cookie%E5%92%8Csession%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F">Cookie和Session的区别？</a></h2><ul>
<li><strong>作用范围</strong>不同，Cookie 保存在客户端（浏览器），Session 保存在服务器端。</li>
<li><strong>存取方式</strong>的不同，Cookie 只能保存 ASCII，Session 可以存任意数据类型，一般情况下我们可以在 Session 中保持一些常用变量信息，比如说 UserId 等。</li>
<li><strong>有效期</strong>不同，Cookie 可设置为长时间保持，比如我们经常使用的默认登录功能，Session 一般失效时间较短，客户端关闭或者 Session 超时都会失效。</li>
<li><strong>隐私策略</strong>不同，Cookie 存储在客户端，比较容易遭到不法获取，早期有人将用户的登录名和密码存储在 Cookie 中导致信息被窃取；Session 存储在服务端，<strong>安全性相对 Cookie 要好一些。</strong></li>
<li><strong>存储大小不同，</strong> 单个 Cookie 保存的数据不能超过 4K，Session 可存储数据远高于 Cookie。</li>
</ul>
<h2 id="如何考虑分布式-Session-问题？"><a href="#如何考虑分布式-Session-问题？" class="headerlink" title="如何考虑分布式 Session 问题？"></a><a target="_blank" rel="noopener" href="https://www.javalearn.cn/#/doc/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%9D%A2%E8%AF%95%E9%A2%98?id=_33-%E5%A6%82%E4%BD%95%E8%80%83%E8%99%91%E5%88%86%E5%B8%83%E5%BC%8F-session-%E9%97%AE%E9%A2%98%EF%BC%9F">如何考虑分布式 Session 问题？</a></h2><p>在互联网公司为了可以支撑更大的流量，后端往往需要多台服务器共同来支撑前端用户请求，那如果用户在 A 服务器登录了，第二次请求跑到服务 B 就会出现登录失效问题。</p>
<p>分布式 Session 一般会有以下几种解决方案：</p>
<ul>
<li><strong>客户端存储</strong>：直接将信息存储在cookie中，cookie是存储在客户端上的一小段数据，客户端通过http协议和服务器进行cookie交互，通常用来存储一些不敏感信息 </li>
<li><strong>Nginx ip_hash 策略</strong>：服务端使用 Nginx 代理，每个请求按访问 IP 的 hash 分配，这样来自同一 IP 固定访问一个后台服务器，避免了在服务器 A 创建 Session，第二次分发到服务器 B 的现象。 </li>
<li><strong>Session 复制</strong>：任何一个服务器上的 Session 发生改变（增删改），该节点会把这个 Session 的所有内容序列化，然后广播给所有其它节点。 </li>
<li><strong>共享 Session</strong>（√）：服务端无状态话，将用户的 Session 等信息使用缓存中间件（如Redis）来统一管理，保障分发到每一个服务器的响应结果都一致。</li>
</ul>
<p>建议采用共享 Session的方案。</p>
<h2 id="为什么-Cookie-无法防止-CSRF-攻击，而-Token-可以？"><a href="#为什么-Cookie-无法防止-CSRF-攻击，而-Token-可以？" class="headerlink" title="为什么 Cookie 无法防止 CSRF 攻击，而 Token 可以？"></a>为什么 Cookie 无法防止 CSRF 攻击，而 Token 可以？</h2><p><strong>跨站请求伪造</strong>：黑客在链接中藏了一个请求，这个请求直接利用小壮的身份给银行发送了一个转账请求,也就是通过你的 Cookie 向银行发出请求。</p>
<p>但是使用Token的话 即使有个你点击了非法链接发送了请求到服务端，这个非法请求是不会携带 <code>Token</code> 的，所以这个请求将是非法的。</p>
<p>需要注意的是：不论是 <code>Cookie</code> 还是 <code>Token</code> 都无法避免 <strong>跨站脚本攻击（Cross Site Scripting）XSS</strong> 。</p>
<h2 id="什么是DDos攻击？"><a href="#什么是DDos攻击？" class="headerlink" title="什么是DDos攻击？"></a><a target="_blank" rel="noopener" href="https://www.javalearn.cn/#/doc/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%9D%A2%E8%AF%95%E9%A2%98?id=_34-%E4%BB%80%E4%B9%88%E6%98%AFddos%E6%94%BB%E5%87%BB%EF%BC%9F">什么是DDos攻击？</a></h2><p><strong>和syn区别：syn洪泛是那些不存在的ip，DDos是存在而且是第三次握手客户端不确认</strong></p>
<p>DDos全称Distributed Denial of Service，分布式拒绝服务攻击。最基本的DOS攻击过程如下：</p>
<ol>
<li>客户端向服务端发送请求链接数据包。</li>
<li>服务端向客户端发送确认数据包。</li>
<li>客户端不向服务端发送确认数据包，服务器一直等待来自客户端的确认</li>
</ol>
<p>DDoS则是采用分布式的方法，通过在网络上占领多台“肉鸡”，用多台计算机发起攻击。</p>
<p>DOS攻击现在基本没啥作用了，因为服务器的性能都很好，而且是多台服务器共同作用，1V1的模式黑客无法占上风。对于DDOS攻击，预防方法有：</p>
<ul>
<li><strong>减少SYN timeout时间</strong>。在握手的第三步，服务器会等待30秒-120秒的时间，减少这个等待时间就能释放更多的资源。</li>
<li><strong>限制同时打开的SYN半连接数目。</strong></li>
</ul>
<h2 id="什么是XSS攻击？"><a href="#什么是XSS攻击？" class="headerlink" title="什么是XSS攻击？"></a><a target="_blank" rel="noopener" href="https://www.javalearn.cn/#/doc/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%9D%A2%E8%AF%95%E9%A2%98?id=_35-%E4%BB%80%E4%B9%88%E6%98%AFxss%E6%94%BB%E5%87%BB%EF%BC%9F">什么是XSS攻击？</a></h2><p>XSS也称 cross-site scripting，<strong>跨站脚本</strong>。这种攻击是<strong>由于服务器将攻击者存储的数据原原本本地显示给其他用户所致的</strong>。比如一个存在XSS漏洞的论坛，用户发帖时就可以引入<strong>带有＜script＞标签的代码</strong>，导致恶意代码的执行。</p>
<p>预防措施有：</p>
<ul>
<li>前端：过滤。</li>
<li>后端：转义，比如go自带的处理器就具有转义功能。</li>
</ul>
<h2 id="SQL注入是什么，如何避免SQL注入？"><a href="#SQL注入是什么，如何避免SQL注入？" class="headerlink" title="SQL注入是什么，如何避免SQL注入？"></a><a target="_blank" rel="noopener" href="https://www.javalearn.cn/#/doc/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%9D%A2%E8%AF%95%E9%A2%98?id=_36-sql%E6%B3%A8%E5%85%A5%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8Dsql%E6%B3%A8%E5%85%A5%EF%BC%9F">SQL注入是什么，如何避免SQL注入？</a></h2><pre><code class="sql">select distinct * from company where id=&#39;1&#39; OR &#39;1&#39; = &#39;1&#39;
</code></pre>
<p>SQL 注入就是在用户输入的字符串中加入 SQL 语句，如果在设计不良的程序中忽略了检查，那么这些注入进去的 SQL 语句就会被数据库服务器误认为是正常的 SQL 语句而运行，<strong>攻击者就可以执行计划外的命令或访问未被授权的数据。</strong></p>
<p><strong>SQL注入的原理主要有以下 4 点</strong></p>
<ul>
<li>恶意拼接查询</li>
<li>利用注释执行非法命令</li>
<li>传入非法参数</li>
<li>添加额外条件</li>
</ul>
<p><strong>避免SQL注入的一些方法</strong>：</p>
<ul>
<li><strong>限制数据库权限</strong>，给用户提供仅仅能够满足其工作的最低权限。</li>
<li>对进入数据库的特殊字符（’”\尖括号&amp;*;等）<strong>转义处理</strong>。</li>
<li>提供参数化查询接口，不要直接使用原生SQL。</li>
</ul>
<h2 id="负载均衡算法有哪些？"><a href="#负载均衡算法有哪些？" class="headerlink" title="负载均衡算法有哪些？"></a><a target="_blank" rel="noopener" href="https://www.javalearn.cn/#/doc/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%9D%A2%E8%AF%95%E9%A2%98?id=_37-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AE%97%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F">负载均衡算法有哪些？</a></h2><p>多台服务器以对称的方式组成一个服务器集合，每台服务器都具有等价的地位，能互相分担负载。</p>
<ul>
<li>轮询法：将请求按照顺序轮流的分配到服务器上。大锅饭，不能发挥某些高性能服务器的优势。</li>
<li>随机法：随机获取一台，和轮询类似。</li>
<li>哈希法：通过ip地址哈希化（我客户端的Ip地址 也就是每个客户端请求到的服务器固定）来确定要选择的服务器编号。好处是,每次客户端访问的服务器都是同一个服务器，能很好地利用session或者cookie。</li>
<li>加权轮询：根据服务器性能不同加权。</li>
</ul>
<h2 id="HTTP-1-0和HTTP-1-1的主要-区别"><a href="#HTTP-1-0和HTTP-1-1的主要-区别" class="headerlink" title="HTTP 1.0和HTTP 1.1的主要 区别"></a>HTTP 1.0和HTTP 1.1的主要 区别</h2><p>1、长连接</p>
<p>在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，在HTTP1.1中默认开启<code>Connection： keep-alive</code>，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点。</p>
<p>2、错误状态响应码多了</p>
<p>新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。</p>
<p>3、缓存策略多了</p>
<p>4、只请求资源一部分，优化带宽</p>
<p>5、Host头处理：在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）。</p>
<h2 id="HTTP1-1和-HTTP2-0的区别？"><a href="#HTTP1-1和-HTTP2-0的区别？" class="headerlink" title="HTTP1.1和 HTTP2.0的区别？"></a><a target="_blank" rel="noopener" href="https://www.javalearn.cn/#/doc/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%9D%A2%E8%AF%95%E9%A2%98?id=_25-http11%E5%92%8C-http20%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F">HTTP1.1和 HTTP2.0的区别？</a></h2><p>HTTP2.0相比HTTP1.1支持的特性：</p>
<ul>
<li><strong>新的二进制格式</strong>：HTTP1.1的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合。基于这种考虑HTTP2.0的协议解析决定采用二进制格式，实现方便且健壮。</li>
<li><strong>多路复用</strong>，即连接共享，即每一个request都是用作连接共享机制的。一个request对应一个id，这样一个连接上可以有多个request，每个连接的request可以随机的混杂在一起，接收方可以根据request的 id将request再归属到各自不同的服务端请求里面。</li>
<li><strong>头部压缩</strong>，HTTP1.1的头部（header）带有大量信息，而且每次都要重复发送；HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小。</li>
<li><strong>服务端推送</strong>：服务器除了对最初请求的响应外，服务器还可以额外的向客户端推送资源，而无需客户端明确的请求。</li>
</ul>
<h2 id="URI和URL的区别是什么"><a href="#URI和URL的区别是什么" class="headerlink" title="URI和URL的区别是什么?"></a>URI和URL的区别是什么?</h2><p>都可以标识一个资源 但URL可以定位到这个资源</p>
<h2 id="HTTP-和-HTTPS-的区别？"><a href="#HTTP-和-HTTPS-的区别？" class="headerlink" title="HTTP 和 HTTPS 的区别？"></a>HTTP 和 HTTPS 的区别？</h2><p><img src="https://raw.githubusercontent.com/viacheung/img/main/image/image-20230404211801661.png#id=nJ1kA&originHeight=201&originWidth=594&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<p>1、端口  80-443   <a target="_blank" rel="noopener" href="http://---&gt;https//">http://---&gt;https://</a></p>
<p>2、安全性和资源消耗：HTTP协议运⾏在TCP之上，所有传输的内容都是明⽂，客户端和服务器端都⽆法验证对⽅的身份。 HTTPS是运⾏在SSL&#x2F;TLS之上的HTTP协议， SSL&#x2F;TLS 运⾏在TCP之上。所有传输的内容都经过加密，加密采⽤对称加密，但对称加密的密钥⽤服务器⽅的证书进⾏了⾮对称加密。所以说， HTTP 安全性没有 HTTPS⾼，但是 HTTPS ⽐HTTP耗费更多服务器资源</p>
<p>对称加密：密钥只有⼀个，加密解密为同⼀个密码     DES、 AES等；<br>⾮对称加密：密钥成对出现，加密解密使⽤不同密钥（公钥加密需要私钥解密，私钥加密需要公钥解密），相对对称加密速度较慢，典型的⾮对称加密算法有RSA、 DSA等</p>
<h2 id="HTTPS-的优缺点"><a href="#HTTPS-的优缺点" class="headerlink" title="HTTPS 的优缺点?"></a><a target="_blank" rel="noopener" href="https://www.javalearn.cn/#/doc/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%9D%A2%E8%AF%95%E9%A2%98?id=_27-https-%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9">HTTPS 的优缺点?</a></h2><p><strong>优点</strong>：</p>
<ul>
<li>安全性： <ul>
<li>使用HTTPS协议可认证用户和服务器，确保数据发送到正确的客户机和服务器；</li>
<li>HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全，可防止数据在传输过程中不被窃取、改变，确保数据的完整性。</li>
<li>HTTPS是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本。</li>
</ul>
</li>
<li>SEO方面：谷歌曾在2014年8月份调整搜索引擎算法，并称“比起同等HTTP网站，采用HTTPS加密的网站在搜索结果中的排名将会更高”。</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>在相同网络环境中，HTTPS 相比 HTTP 无论是响应时间还是耗电量都有大幅度上升。</li>
<li>HTTPS 的安全是有范围的，在黑客攻击、服务器劫持等情况下几乎起不到作用。</li>
<li>在现有的证书机制下，中间人攻击依然有可能发生。</li>
<li>HTTPS 需要更多的服务器资源，也会导致成本的升高。</li>
</ul>
<h2 id="讲一讲HTTPS-的原理？"><a href="#讲一讲HTTPS-的原理？" class="headerlink" title="讲一讲HTTPS 的原理？"></a><a target="_blank" rel="noopener" href="https://www.javalearn.cn/#/doc/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%9D%A2%E8%AF%95%E9%A2%98?id=_28-%E8%AE%B2%E4%B8%80%E8%AE%B2https-%E7%9A%84%E5%8E%9F%E7%90%86%EF%BC%9F">讲一讲HTTPS 的原理？</a></h2><p><img src="https://raw.githubusercontent.com/viacheung/img/main/image/image-20210525160006424.png#id=XzkWM&originHeight=612&originWidth=732&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<blockquote>
<p>图片来源：<a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000021494676">https://segmentfault.com/a/1190000021494676</a></p>
</blockquote>
<p>加密流程按图中的序号分为：</p>
<ol>
<li>客户端请求 HTTPS 网址，然后连接到 server 的 443 端口 (HTTPS 默认端口，类似于 HTTP 的80端口)。 </li>
<li>采用 HTTPS 协议的服务器必须要有一套数字 CA (Certification Authority)证书。颁发证书的同时会产生一个私钥和公钥。私钥由服务端自己保存，不可泄漏。公钥则是附带在证书的信息中，可以公开的。证书本身也附带一个证书电子签名，这个签名用来验证证书的完整性和真实性，可以防止证书被篡改。 </li>
<li>服务器响应客户端请求，将证书传递给客户端，证书包含公钥和大量其他信息，比如证书颁发机构信息，公司信息和证书有效期等。 </li>
<li>客户端解析证书并对其进行验证。如果证书不是可信机构颁布，或者证书中的域名与实际域名不一致，或者证书已经过期，就会向访问者显示一个警告，由其选择是否还要继续通信。<br>如果证书没有问题，客户端就会从服务器证书中取出服务器的公钥A。然后客户端还会生成一个随机码 KEY，并使用公钥A将其加密。 </li>
<li>客户端把加密后的随机码 KEY 发送给服务器，作为后面对称加密的密钥。 </li>
<li>服务器在收到随机码 KEY 之后会使用私钥B将其解密。经过以上这些步骤，客户端和服务器终于建立了安全连接，完美解决了对称加密的密钥泄露问题，接下来就可以用对称加密愉快地进行通信了。 </li>
<li>服务器使用密钥 (随机码 KEY)对数据进行对称加密并发送给客户端，客户端使用相同的密钥 (随机码 KEY)解密数据。 </li>
<li>双方使用对称加密愉快地传输所有数据。 <h2 id="校验和"><a href="#校验和" class="headerlink" title="校验和"></a>校验和</h2><h3 id="常用校验算法简单说明："><a href="#常用校验算法简单说明：" class="headerlink" title="常用校验算法简单说明："></a>常用校验算法简单说明：</h3>1：<strong>校验和</strong>：按每个字节，计算累加和，<br>2：<strong>异或校验</strong>：定义初值，按每个字节异或，求结果。<br>3：<strong>CRC校验</strong>：已有很多的标准及计算方式，可以返回8字节，16字节，32字节的结果。<br>所谓校验和，就是将被校验数据进行累加，并舍弃累加溢出的位，最终得到的1个或多个字节的结果。验证数据的准确性</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://viacheung.github.io/2023/06/04/Java%E9%9B%86%E5%90%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="ViaCheung">
      <meta itemprop="description" content="el psy congroo">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="命运石之门">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/06/04/Java%E9%9B%86%E5%90%88/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
	  <span class="post-time">

	  
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-06-04 00:58:26 / 修改时间：00:58:27" itemprop="dateCreated datePublished" datetime="2023-06-04T00:58:26+08:00">2023-06-04</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="常见的集合有哪些？"><a href="#常见的集合有哪些？" class="headerlink" title="常见的集合有哪些？"></a>常见的集合有哪些？</h2><p>Java集合类主要由两个根接口<strong>Collection</strong>和<strong>Map</strong>派生出来的，Collection派生出了三个子接口：List、Set、Queue（Java5新增的队列），因此Java集合大致也可分成List、Set、Queue、Map四种接口体系。<br><strong>注意：Collection是一个接口，Collections是一个工具类，Map不是Collection的子接口</strong>。<br>Java集合框架图如下：<br>图中，List代表了有序可重复集合，可直接根据元素的索引来访问；Set代表无序不可重复集合，只能根据元素本身来访问；Queue是队列集合。<br>Map代表的是存储key-value对的集合，可根据元素的key来访问value。<br>上图中淡绿色背景覆盖的是集合体系中常用的实现类，分别是ArrayList、LinkedList、ArrayQueue、HashSet、TreeSet、HashMap、TreeMap等实现类</p>
<h2 id="线程安全的集合有哪些？线程不安全的呢？"><a href="#线程安全的集合有哪些？线程不安全的呢？" class="headerlink" title="线程安全的集合有哪些？线程不安全的呢？"></a>线程安全的集合有哪些？线程不安全的呢？</h2><p>线程安全的：</p>
<ul>
<li>Hashtable：比HashMap多了个线程安全。</li>
<li>ConcurrentHashMap:是一种高效但是线程安全的集合。</li>
<li>Vector：比Arraylist多了个同步化机制。</li>
<li>Stack：栈，也是线程安全的，继承于Vector。</li>
</ul>
<p>线性不安全的：</p>
<ul>
<li><p>HashMap</p>
</li>
<li><p>Arraylist</p>
</li>
<li><p>LinkedList</p>
</li>
<li><p>HashSet</p>
</li>
<li><p>TreeSet</p>
<h2 id="说说List-Set-Map三者的区别？"><a href="#说说List-Set-Map三者的区别？" class="headerlink" title="说说List,Set,Map三者的区别？"></a>说说List,Set,Map三者的区别？</h2><p>List 有序的、可重复的。Set⽆序的、不可重复的。Map ⽆序的，key不可重复、value 可重复<br><strong>HashSet 和 HashMap 区别?</strong><br>HashSet的底层其实就是HashMap，只不过我们<strong>HashSet是实现了Set接口并且把数据作为K值，而V值一直使用一个相同的虚值来保存</strong>。<br>由于HashMap的K值本身就不允许重复，并且在HashMap中如果K&#x2F;V相同时，会用新的V覆盖掉旧的V，然后返回旧的V，那么在HashSet中执行这一句话始终会返回一个false，导致插入失败，这样就保证了数据的不可重复性。</p>
<h2 id="Arraylist-与-LinkedList-区别"><a href="#Arraylist-与-LinkedList-区别" class="headerlink" title="Arraylist 与 LinkedList 区别?"></a>Arraylist 与 LinkedList 区别?</h2><p>1、底层一个数组 一个双向链表<br>2、增删 和查的效率问题<br>3、内存空间，Arraylist 预留空间 LinkedList指针</p>
<h2 id="说⼀说-ArrayList-的扩容机制吧"><a href="#说⼀说-ArrayList-的扩容机制吧" class="headerlink" title="说⼀说 ArrayList 的扩容机制吧"></a>说⼀说 ArrayList 的扩容机制吧</h2><p>if 容量&#x3D;&#x3D;0，第一次添加元素容量为 10<br>else 会将修改次数 modCount++，并且会将原数组中的元素，拷贝至新数组中，新数组的大小是<br>原数组的 1.5 倍</p>
<h2 id="Array-和-ArrayList-有什么区别？什么时候该应-Array-而不是-ArrayList-呢？"><a href="#Array-和-ArrayList-有什么区别？什么时候该应-Array-而不是-ArrayList-呢？" class="headerlink" title="Array 和 ArrayList 有什么区别？什么时候该应 Array 而不是 ArrayList 呢？"></a>Array 和 ArrayList 有什么区别？什么时候该应 Array 而不是 ArrayList 呢？</h2></li>
<li><p>Array 可以包含基本类型和对象类型，ArrayList 只能包含对象类型。</p>
</li>
<li><p>Array 大小是固定的，ArrayList 的大小是动态变化的。</p>
</li>
<li><p>ArrayList 提供了更多的方法和特性，比如：addAll()，removeAll()，iterator() 等等。</p>
<h2 id="ArrayList-与-Vector-区别？"><a href="#ArrayList-与-Vector-区别？" class="headerlink" title="ArrayList 与 Vector 区别？"></a>ArrayList 与 Vector 区别？</h2></li>
<li><p>Vector是线程安全的，ArrayList不是线程安全的。其中，Vector在关键性的方法前面都加了<strong>synchronized</strong>关键字，来保证线程的安全性。如果有多个线程会访问到集合，那最好是使用 Vector，因为不需要我们自己再去考虑和编写线程安全的代码。</p>
</li>
<li><p>ArrayList在底层数组不够用时在原来的基础上扩展0.5倍，Vector是扩展1倍，这样ArrayList就有利于节约内存空间。</p>
<h2 id="HashMap系列"><a href="#HashMap系列" class="headerlink" title="HashMap系列"></a>HashMap系列</h2><h3 id="HashMap-和-HashSet（底层HashMap）区别"><a href="#HashMap-和-HashSet（底层HashMap）区别" class="headerlink" title="HashMap 和 HashSet（底层HashMap）区别"></a>HashMap 和 HashSet（底层HashMap）区别</h3><h3 id="HashSet如何检查重复"><a href="#HashSet如何检查重复" class="headerlink" title="HashSet如何检查重复"></a>HashSet如何检查重复</h3><p>hashcode—equals</p>
<h3 id="HashMap的底层实现"><a href="#HashMap的底层实现" class="headerlink" title="HashMap的底层实现"></a>HashMap的底层实现</h3><h3 id="HashMap构造函数"><a href="#HashMap构造函数" class="headerlink" title="HashMap构造函数"></a>HashMap构造函数</h3><p>三个 初始容量+默认加载因子<br>数组 +链表+红黑树</p>
<h3 id="HashMap-的扩容方式？"><a href="#HashMap-的扩容方式？" class="headerlink" title="HashMap 的扩容方式？"></a>HashMap 的扩容方式？</h3><p><strong>扩容：</strong><br>首先 HashMap 的初始容量是 16，并且每次对原数组长度 * 2 进行扩容，HashMap 在容量超过负载因子所定义的容量之后，就会扩容，默认0.75，构造函数可以调整，无参有参构造<br>当链表大于8，如果数组&lt;64 先数组扩容，否则链表转为红黑树<br>HashMap扩容：</p>
<h3 id="HashMap为什么默认加载因子是0-75？"><a href="#HashMap为什么默认加载因子是0-75？" class="headerlink" title="HashMap为什么默认加载因子是0.75？"></a>HashMap为什么默认加载因子是0.75？</h3><p>作为一般规则，默认负载因子（0.75）在时间和空间成本上提供了很好的折衷。较高的值会降低空间开销，但提高查找成本（体现在大多数的HashMap类的操作，包括get和put）。设置初始大小时，应该考虑预计的entry数在map及其负载系数，并且尽量减少rehash操作的次数。如果初始容量大于最大条目数除以负载因子，rehash操作将不会发生</p>
<h3 id="HashMap-中-key-的存储索引是怎么计算的？"><a href="#HashMap-中-key-的存储索引是怎么计算的？" class="headerlink" title="HashMap 中 key 的存储索引是怎么计算的？"></a>HashMap 中 key 的存储索引是怎么计算的？</h3><p><strong>取key的 hashCode 值、根据 hashcode 计算出hash值（hashcode 异或其右移十六位）、通过取模计算下标</strong></p>
<h4 id="1、JDK1-8-为什么要-hashcode-异或其右移十六位的值？"><a href="#1、JDK1-8-为什么要-hashcode-异或其右移十六位的值？" class="headerlink" title="1、JDK1.8 为什么要 hashcode 异或其右移十六位的值？"></a>1、JDK1.8 为什么要 hashcode 异或其右移十六位的值？</h4><p>右移后再亦或，高位和低位做了混合，在之后的hash &amp; (length-1) 中高位就也参与进运算了，增加了散列程度。<br>由于和 (length -1) 运算，length 绝大多数情况小于 2 的 16 次方。 所以始终是 hashcode 的低 16 位（甚至更低） 参与运算。 但是这样高 16 位是用不到的，为了让得到的下标更加散列，需要让高16位也参与运算，所以就需要低16位和高16位进行 ^ 运算。</p>
<h4 id="2、为什么-hash-值要与length-1相与？"><a href="#2、为什么-hash-值要与length-1相与？" class="headerlink" title="2、为什么 hash 值要与length-1相与？"></a>2、为什么 hash 值要与length-1相与？</h4><p>位运算快<br>充分散列</p>
<h3 id="HashMap-的put方法流程？"><a href="#HashMap-的put方法流程？" class="headerlink" title="HashMap 的put方法流程？"></a>HashMap 的put方法流程？</h3></li>
</ul>
<ol>
<li>首先根据 key 的值计算 hash 值，找到该元素在数组中存储的下标；</li>
<li>如果数组是空的，则调用 resize 进行初始化；</li>
<li>如果没有哈希冲突直接放在对应的数组下标里；</li>
<li>如果冲突后，发现该节点是红黑树，则调用equals判断TreeNode是否已存在，如果存在更新之；不存在则直接插入红黑树，++size，超出threshold容量就扩容，然后将这个节点挂在树上；</li>
<li>如果是链表，则判断Node是否已存在，如果存在更新之；不存在则直接插入链表尾部，判断链表长度，如果大于8则转为红黑树存储，++size，超出threshold容量就扩容； 判断该链表是否大于 8 ，如果大于 8 并且数组容量小于 64，就进行扩容；如果链表节点大于 8 并且数组的容量大于 64，则将这个结构转换为红黑树；<h3 id="解决hash冲突的办法有哪些？HashMap用的哪种？"><a href="#解决hash冲突的办法有哪些？HashMap用的哪种？" class="headerlink" title="解决hash冲突的办法有哪些？HashMap用的哪种？"></a>解决hash冲突的办法有哪些？HashMap用的哪种？</h3>解决Hash冲突方法有:开放定址法（线性探测法）、再哈希法（多个hash函数算）、链地址法（拉链法）、建立公共溢出区。HashMap中采用的是 链地址法<br>线性探测法和<h3 id="HashMap-多线程操作死链问题"><a href="#HashMap-多线程操作死链问题" class="headerlink" title="HashMap 多线程操作死链问题"></a>HashMap 多线程操作死链问题</h3>1.7头插会产生，1.8尾插没有了<br>线程2完成移动 线程1才开始移动 因此就会产生环形链表<h3 id="HashMap为什么线程不安全"><a href="#HashMap为什么线程不安全" class="headerlink" title="HashMap为什么线程不安全"></a>HashMap为什么线程不安全</h3>A判断好这个地方没有数据，准备插入的时候，这时候B线程抢夺到时间片，来插入，然后A再插入就把B覆盖了</li>
</ol>
<ul>
<li><p>多线程下扩容死循环。JDK1.7中的 HashMap 使用头插法插入元素，在多线程的环境下，扩容的时候有可能导致环形链表的出现，形成死循环。因此，JDK1.8使用尾插法插入元素，在扩容时会保持链表元素原本的顺序，不会出现环形链表的问题。</p>
</li>
<li><p>多线程的put可能导致元素的丢失。多线程同时执行 put 操作，如果计算出来的索引位置是相同的，那会造成前一个 key 被后一个 key 覆盖，从而导致元素的丢失。此问题在JDK 1.7和 JDK 1.8 中都存在。</p>
</li>
<li><p>put和get并发时，可能导致get为null。线程1执行put时，因为元素个数超出threshold而导致rehash，线程2此时执行get，有可能导致这个问题。此问题在JDK 1.7和 JDK 1.8 中都存在。</p>
<h3 id="为什么链表长度8树化"><a href="#为什么链表长度8树化" class="headerlink" title="为什么链表长度8树化"></a>为什么链表长度8树化</h3><p>链表阈值和产生冲突概率为泊松分布 选择8是千万分之6 7是十万分之一，差1000倍，降低冲突概率</p>
<h3 id="退化"><a href="#退化" class="headerlink" title="退化"></a>退化</h3><p>当扩容后链表长度小于等于 6 进行树的退化 长度为6的话链表和红黑树查找效率忽略不计。此时维护红黑树的平衡反而加大开销，所以退化</p>
<h3 id="红黑树特点"><a href="#红黑树特点" class="headerlink" title="红黑树特点"></a>红黑树特点</h3><p>1.节点是红色或黑色。<br>2.根节点是黑色。<br>3.每个叶子节点都是黑色的空节点（NIL节点）。<br>4 每个红色节点的两个子节点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点)<br>5.从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。<br>当插入打破规则可以采取变色或者旋转（左旋转和右旋转）</p>
<h3 id="红黑树vsAVL"><a href="#红黑树vsAVL" class="headerlink" title="红黑树vsAVL"></a>红黑树vsAVL</h3><p>1、增删性能红黑树好<br>2、查询性能AVL好<br>3、内存空间红黑树消耗大</p>
<h3 id="HashMap-的⻓度为什么是2的幂次⽅"><a href="#HashMap-的⻓度为什么是2的幂次⽅" class="headerlink" title="HashMap 的⻓度为什么是2的幂次⽅"></a>HashMap 的⻓度为什么是2的幂次⽅</h3><p>1、2 的幂次可以用 与 的方式进行取余运算，效率更高；<br>2）在扩容移动链表节点时，节点在新数组中的位置只可能是原位置 i 或 i + oldCap 旧数组长度，扩容时效率更高</p>
<h2 id="一般用什么作为HashMap的key"><a href="#一般用什么作为HashMap的key" class="headerlink" title="一般用什么作为HashMap的key?"></a>一般用什么作为HashMap的key?</h2><p>一般用Integer、String 这种不可变类当 HashMap 当 key，而且 String 最为常用。</p>
</li>
<li><p>因为字符串是不可变的，所以在它创建的时候 hashcode 就被缓存了，不需要重新计算。这就是 HashMap 中的键往往都使用字符串的原因。</p>
</li>
<li><p>因为获取对象的时候要用到 equals() 和 hashCode() 方法，那么键对象正确的重写这两个方法是非常重要的,这些类已经很规范的重写了 hashCode() 以及 equals() 方法。</p>
<h2 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h2><h3 id="ConcurrentHashMap线程安全的具体实现⽅式-x2F-底层具体实现"><a href="#ConcurrentHashMap线程安全的具体实现⽅式-x2F-底层具体实现" class="headerlink" title="ConcurrentHashMap线程安全的具体实现⽅式&#x2F;底层具体实现"></a>ConcurrentHashMap线程安全的具体实现⽅式&#x2F;底层具体实现</h3><p><strong>1.7:</strong> 分段锁 （可重入锁）Segment 数组 + HashEntry 数组 + 链表<br>JDK1.7中的ConcurrentHashMap 是由 Segment 数组结构和 HashEntry 数组结构组成，即ConcurrentHashMap 把哈希桶切分成小数组（Segment ），每个小数组有 n 个 HashEntry 组成。<br>其中，Segment 继承了 ReentrantLock，所以 Segment 是一种可重入锁，扮演锁的角色；HashEntry 用于存储键值对数据。<br>首先将数据分为一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据时，其他段的数据也能被其他线程访问，能够实现真正的并发访问。<br><strong>1.8</strong> CAS syn<br>在数据结构上， JDK1.8 中的ConcurrentHashMap 选择了与 HashMap 相同的<strong>数组+链表+红黑树</strong>结构；在锁的实现上，抛弃了原有的 Segment 分段锁，采用CAS + synchronized实现更加低粒度的锁。<br>将锁的级别控制在了更细粒度的哈希桶元素级别，也就是说只需要锁住这个链表头结点（红黑树的根节点），就不会影响其他的哈希桶元素的读写，大大提高了并发度。<br>node数组+链表+红黑树<br>synchronized 只锁定当前链表或红⿊⼆叉树的⾸节点，这样只要 hash 不冲突，就不会产⽣并发，效率⼜提升 N 倍 </p>
<h3 id="ConcurrentHashMap-的-put-方法执行逻辑是什么？"><a href="#ConcurrentHashMap-的-put-方法执行逻辑是什么？" class="headerlink" title="ConcurrentHashMap 的 put 方法执行逻辑是什么？"></a>ConcurrentHashMap 的 put 方法执行逻辑是什么？</h3><p><strong>先来看JDK1.7</strong><br>首先，会尝试获取锁，如果获取失败，利用自旋获取锁；如果自旋重试的次数超过 64 次，则改为阻塞获取锁。<br>获取到锁后：</p>
</li>
</ul>
<ol>
<li>将当前 Segment 中的 table 通过 key 的 hashcode 定位到 HashEntry。</li>
<li>遍历该 HashEntry，如果不为空则判断传入的 key 和当前遍历的 key 是否相等，相等则覆盖旧的 value。</li>
<li>没有相等的话则需要新建一个 HashEntry 并加入到 Segment 中，同时会先判断是否需要扩容。</li>
<li>释放 Segment 的锁。</li>
</ol>
<p><strong>再来看JDK1.8</strong><br>大致可以分为以下步骤：</p>
<ol>
<li>根据 key 计算出 hash值。</li>
<li>判断是否需要进行初始化。</li>
<li>定位到 Node，拿到首节点 f，判断首节点 f：<ul>
<li>如果为 null ，则通过cas的方式尝试添加。</li>
<li>如果为 f.hash &#x3D; MOVED &#x3D; -1 ，说明其他线程在扩容，参与一起扩容。</li>
<li>如果都不满足 ，synchronized 锁住 f 节点，判断是链表还是红黑树，遍历插入。</li>
</ul>
</li>
<li>当在链表长度达到8的时候，数组扩容或者将链表转换为红黑树。<h3 id="ConcurrentHashMap-的-get-方法是否要加锁，为什么？"><a href="#ConcurrentHashMap-的-get-方法是否要加锁，为什么？" class="headerlink" title="ConcurrentHashMap 的 get 方法是否要加锁，为什么？"></a>ConcurrentHashMap 的 get 方法是否要加锁，为什么？</h3>get 方法不需要加锁。因为 Node 的元素 val 和指针 next 是用 volatile 修饰的，在多线程环境下线程A修改结点的val或者新增节点的时候是对线程B可见的。<br>这也是它比其他并发集合比如 Hashtable、用 Collections.synchronizedMap()包装的 HashMap 安全效率高的原因之一。<h3 id="ConcurrentHashMap-不支持-key-或者-value-为-null-的原因？"><a href="#ConcurrentHashMap-不支持-key-或者-value-为-null-的原因？" class="headerlink" title="ConcurrentHashMap 不支持 key 或者 value 为 null 的原因？"></a>ConcurrentHashMap 不支持 key 或者 value 为 null 的原因？</h3>1、我们先来说value 为什么不能为 null ，因为ConcurrentHashMap是用于多线程的 ，如果map.get(key)得到了 null ，无法判断，是映射的value是 null ，还是没有找到对应的key而为 null ，这就有了二义性。<br><strong>追问：说说为什么ConcurrentHashMap判断不了呢？</strong><br>此时如果有A、B两个线程，A线程调用ConcurrentHashMap.get(key)方法返回null，但是我们不知道这个null是因为key没有在map中映射还是本身存的value值就是null，此时我们假设有一个key没有在map中映射过，也就是map中不存在这个key，此时我们调用ConcurrentHashMap.containsKey(key)方法去做一个判断，我们期望的返回结果是false。但是恰好在A线程get(key)之后，调用constainsKey(key)方法之前B线程执行了ConcurrentHashMap.put(key,null)，那么当A线程执行完containsKey(key)方法之后我们得到的结果是true，与我们预期的结果就不相符了。<br>而用于单线程状态的HashMap却可以用containsKey(key) 去判断到底是否包含了这个 null 。<br>2、至于ConcurrentHashMap 中的key为什么也不能为 null 的问题，源码就是这样写的，哈哈。就回答作者Doug不喜欢 null ，所以在设计之初就不允许了 null 的key存在<h3 id="get方法不需要加锁与volatile修饰的哈希桶有关吗？"><a href="#get方法不需要加锁与volatile修饰的哈希桶有关吗？" class="headerlink" title="get方法不需要加锁与volatile修饰的哈希桶有关吗？"></a>get方法不需要加锁与volatile修饰的哈希桶有关吗？</h3>没有关系。哈希桶table用volatile修饰主要是保证在数组扩容的时候保证可见性。<h3 id="ConcurrentHashMap-的并发度是多少？"><a href="#ConcurrentHashMap-的并发度是多少？" class="headerlink" title="ConcurrentHashMap 的并发度是多少？"></a>ConcurrentHashMap 的并发度是多少？</h3>jdk1.7里面，程序在运行时能够同时更新ConcurrentHashMap且不产生锁竞争的最大线程数默认是16，这个值可以在构造函数中设置。如果自己设置了并发度，ConcurrentHashMap 会使用大于等于该值的最小的2的幂指数作为实际并发度，也就是比如你设置的值是17，那么实际并发度是32。<h3 id="ConcurrentHashMap-迭代器是强一致性还是弱一致性？"><a href="#ConcurrentHashMap-迭代器是强一致性还是弱一致性？" class="headerlink" title="ConcurrentHashMap 迭代器是强一致性还是弱一致性？"></a>ConcurrentHashMap 迭代器是强一致性还是弱一致性？</h3><strong>类似快速失败和安全失败</strong><br>快速失败就是HashMap 安全失败是Con~<br>与HashMap迭代器是强一致性不同，ConcurrentHashMap 迭代器是弱一致性。<br>ConcurrentHashMap 的迭代器创建后，就会按照哈希表结构遍历每个元素，但在遍历过程中，内部元素可能会发生变化，如果变化发生在已遍历过的部分，迭代器就不会反映出来，而如果变化发生在未遍历过的部分，迭代器就会发现并反映出来，这就是弱一致性。<br>这样迭代器线程可以使用原来老的数据，而写线程也可以并发的完成改变，更重要的，这保证了多个线程并发执行的连续性和扩展性，是性能提升的关键。想要深入了解的小伙伴，可以看这篇文章<a target="_blank" rel="noopener" href="http://ifeve.com/ConcurrentHashMap%20-weakly-consistent/">为什么ConcurrentHashMap 是弱一致的</a><h3 id="JDK1-7与JDK1-8-中ConcurrentHashMap-的区别？"><a href="#JDK1-7与JDK1-8-中ConcurrentHashMap-的区别？" class="headerlink" title="JDK1.7与JDK1.8 中ConcurrentHashMap 的区别？"></a>JDK1.7与JDK1.8 中ConcurrentHashMap 的区别？</h3></li>
</ol>
<ul>
<li><p>数据结构：取消了Segment分段锁的数据结构，取而代之的是数组+链表+红黑树的结构。</p>
</li>
<li><p>保证线程安全机制：JDK1.7采用Segment的分段锁机制实现线程安全，其中segment继承自ReentrantLock。JDK1.8 采用CAS+Synchronized保证线程安全。</p>
</li>
<li><p>锁的粒度：原来是对需要进行数据操作的Segment加锁，现调整为对每个数组元素加锁（Node）。</p>
</li>
<li><p>链表转化为红黑树:定位结点的hash算法简化会带来弊端,Hash冲突加剧,因此在链表节点数量大于8时，会将链表转化为红黑树进行存储。</p>
</li>
<li><p>查询时间复杂度：从原来的遍历链表O(n)，变成遍历红黑树O(logN)。</p>
<h3 id="ConcurrentHashMap-和Hashtable的效率哪个更高？为什么？"><a href="#ConcurrentHashMap-和Hashtable的效率哪个更高？为什么？" class="headerlink" title="ConcurrentHashMap 和Hashtable的效率哪个更高？为什么？"></a>ConcurrentHashMap 和Hashtable的效率哪个更高？为什么？</h3><p>ConcurrentHashMap 的效率要高于Hashtable，因为<strong>Hashtable给整个哈希表加了一把大锁从而实现线程安全</strong>。而ConcurrentHashMap 的锁粒度更低，在JDK1.7中采用分段锁实现线程安全，在JDK1.8 中采用CAS+Synchronized实现线程安全。</p>
<h3 id="说一下Hashtable的锁机制"><a href="#说一下Hashtable的锁机制" class="headerlink" title="说一下Hashtable的锁机制 ?"></a>说一下Hashtable的锁机制 ?</h3><p>Hashtable是使用Synchronized来实现线程安全的，给整个哈希表加了一把大锁，多线程访问时候，只要有一个线程访问或操作该对象，那其他线程只能阻塞等待需要的锁被释放，在竞争激烈的多线程场景中性能就会非常差！<br><img src="https://cdn.nlark.com/yuque/0/2023/png/226907/1684750974008-15007cd1-0b39-4594-9798-11b0e05a95dc.png#averageHue=%23fcf8ec&clientId=u98aea6ab-93dd-4&from=paste&id=u6d63ad03&originHeight=592&originWidth=821&originalType=url&ratio=1.25&rotation=0&showTitle=false&size=37812&status=done&style=none&taskId=u4f08543c-3934-4c27-911e-27b583759f5&title=" alt="image.png"></p>
<h3 id="多线程下安全的操作-map还有其他方法吗？"><a href="#多线程下安全的操作-map还有其他方法吗？" class="headerlink" title="多线程下安全的操作 map还有其他方法吗？"></a>多线程下安全的操作 map还有其他方法吗？</h3><p>还可以使用Collections.synchronizedMap方法，对方法进行加同步锁<br>如果传入的是 HashMap 对象，其实也是对 HashMap 做的方法做了一层包装，里面使用对象锁来保证多线程场景下，线程安全，本质也是对 HashMap 进行全表锁。<strong>在竞争激烈的多线程环境下性能依然也非常差，不推荐使用！</strong></p>
<h2 id="⽐较-HashSet、-LinkedHashSet-和-TreeSet-三者的异同"><a href="#⽐较-HashSet、-LinkedHashSet-和-TreeSet-三者的异同" class="headerlink" title="⽐较 HashSet、 LinkedHashSet 和 TreeSet 三者的异同"></a>⽐较 HashSet、 LinkedHashSet 和 TreeSet 三者的异同</h2><p>HashSet 是 Set 接⼝的主要实现类 ， HashSet 的底层是 HashMap ，线程不安全的，可以存储 null 值；LinkedHashSet 按照添加的顺序遍历；TreeSet 底层红⿊树</p>
<h2 id="如何选⽤集合"><a href="#如何选⽤集合" class="headerlink" title="如何选⽤集合?"></a>如何选⽤集合?</h2><p>Map<br>collection：set list</p>
<h2 id="collection框架中实现比较要怎么做？"><a href="#collection框架中实现比较要怎么做？" class="headerlink" title="collection框架中实现比较要怎么做？"></a>collection框架中实现比较要怎么做？</h2><p>第一种，实体类实现Comparable接口，并实现 compareTo(T t) 方法，称为内部比较器。<br>第二种，创建一个外部比较器，这个外部比较器要实现Comparator接口的 compare(T t1, T t2)方法。</p>
<h2 id="Iterator-和-ListIterator-有什么区别？"><a href="#Iterator-和-ListIterator-有什么区别？" class="headerlink" title="Iterator 和 ListIterator 有什么区别？"></a>Iterator 和 ListIterator 有什么区别？</h2></li>
<li><p>遍历。使用Iterator，可以遍历所有集合，如Map，List，Set；但只能在向前方向上遍历集合中的元素。</p>
</li>
</ul>
<p>使用ListIterator，只能遍历List实现的对象，但可以向前和向后遍历集合中的元素。</p>
<ul>
<li>添加元素。Iterator无法向集合中添加元素；而，ListIteror可以向集合添加元素。</li>
<li>修改元素。Iterator无法修改集合中的元素；而，ListIterator可以使用set()修改集合中的元素。</li>
<li>索引。Iterator无法获取集合中元素的索引；而，使用ListIterator，可以获取集合中元素的索引。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://viacheung.github.io/2023/06/04/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="ViaCheung">
      <meta itemprop="description" content="el psy congroo">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="命运石之门">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/06/04/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
	  <span class="post-time">

	  
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-06-04 00:58:20 / 修改时间：00:58:21" itemprop="dateCreated datePublished" datetime="2023-06-04T00:58:20+08:00">2023-06-04</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="请简要描述线程与进程的关系-区别及优缺点？"><a href="#请简要描述线程与进程的关系-区别及优缺点？" class="headerlink" title="请简要描述线程与进程的关系,区别及优缺点？"></a>请简要描述线程与进程的关系,区别及优缺点？</h2><p><strong>根本区别</strong>：进程是操作系统资源分配的基本单位，而线程是处理器任务调度和执行的基本单位<br><strong>资源开销</strong>：进程独享内存空间，进程之间的切换会有较大的开销；而线程有自己独立的运行栈和程序计数器（PC），线程之间切换的开销小。<br><strong>包含关系</strong>：线程是进程划分成更小的运行单位<br><strong>影响关系</strong>：一个进程崩溃后，不会对其他进程产生影响，但是一个线程崩溃整个进程都死掉。所以多进程要比多线程健壮。</p>
<h2 id="简述线程、程序、进程的基本概念。以及他们之间关系是什么"><a href="#简述线程、程序、进程的基本概念。以及他们之间关系是什么" class="headerlink" title="简述线程、程序、进程的基本概念。以及他们之间关系是什么?"></a>简述线程、程序、进程的基本概念。以及他们之间关系是什么?</h2><p>程序： 含有数据和指令的静态 文件（存在磁盘）<br>进程：程序的一次执行过程<br>线程：进程划分为更小的运行单位 同类的多个线程共享进程的堆和⽅法区 但每个线程有⾃⼰的程序计数器、 虚拟机栈和本地⽅法栈 </p>
<h2 id="创建线程的三种方式的对比？"><a href="#创建线程的三种方式的对比？" class="headerlink" title="创建线程的三种方式的对比？"></a>创建线程的三种方式的对比？</h2><ul>
<li>定义Thread类的子类，并重写该类的run方法(new完Thread,直接start)</li>
<li>定义Runnable接口的实现类，并重写该接口的run()方法(new完Thread,再实现一个Runnable接口放到Thread里面)</li>
<li>定义Callable接口的实现类，并重写该接口的call()方法，一般配合Future使用</li>
<li>线程池的方式</li>
</ul>
<p><strong>1、采用实现Runnable. Callable接口的方式创建多线程：</strong><br>优势：只是实现接口，还可以继承其他类，功能扩展好劣势：要访问当前线程，则必须使用Thread.currentThread()<br><strong>Runnable和Callable的区别</strong>：<br>1、重写方法一个run 一个call<br>2、有无返回值 <strong>callable有</strong><br>3、call可以抛出异常 run不可以<br>4、运行Callable任务可以拿到一个Future对象，表示异步计算的结果<br><strong>2、使用继承Thread类的方式创建多线程</strong>：<br><strong>优势是：</strong><br>如果需要访问当前线程，直接使用this即可获得当前线程。<br><strong>劣势是：</strong><br>已经继承了Thread类，所以不能再继承其他父类。</p>
<h2 id="多线程的好处"><a href="#多线程的好处" class="headerlink" title="多线程的好处"></a>多线程的好处</h2><p>1、基于高并发的需求<br>2、<strong>线程间的切换和调度的成本远远小于进程</strong></p>
<h2 id="程序计数器为什么是私有的"><a href="#程序计数器为什么是私有的" class="headerlink" title="程序计数器为什么是私有的?"></a>程序计数器为什么是私有的?</h2><p>程序计数器记录当前线程执行位置，主要是为了线程切换后能恢复到正确的执⾏位置。 </p>
<h2 id="虚拟机栈和本地⽅法栈为什么是私有的"><a href="#虚拟机栈和本地⽅法栈为什么是私有的" class="headerlink" title="**虚拟机栈和本地⽅法栈为什么是私有的? **"></a>**虚拟机栈和本地⽅法栈为什么是私有的? **</h2><p>为了保证当前线程的局部变量不被别的线程访问</p>
<h2 id="⼀句话简单了解堆和⽅法区"><a href="#⼀句话简单了解堆和⽅法区" class="headerlink" title="⼀句话简单了解堆和⽅法区"></a>⼀句话简单了解堆和⽅法区</h2><p>堆：对象<br>方法区：已经加载的类信息、常量、静态变量，JIT编译的代码</p>
<h2 id="说说并发与并⾏的区别"><a href="#说说并发与并⾏的区别" class="headerlink" title="说说并发与并⾏的区别?"></a>说说并发与并⾏的区别?</h2><p>并发：一段时间<br>并行：同一时刻</p>
<h2 id="为什么要使⽤多线程呢-（而不是多进程）"><a href="#为什么要使⽤多线程呢-（而不是多进程）" class="headerlink" title="为什么要使⽤多线程呢? （而不是多进程）"></a>为什么要使⽤多线程呢? （而不是多进程）</h2><p>线程间切换调度成本小于进程<br>多核时代 利用多个cpu 提高利用率</p>
<h2 id="使⽤多线程可能带来什么问题"><a href="#使⽤多线程可能带来什么问题" class="headerlink" title="使⽤多线程可能带来什么问题?"></a>使⽤多线程可能带来什么问题?</h2><p>内存泄漏、 上下⽂切换、 死锁 。 </p>
<h2 id="说说线程的⽣命周期和状态"><a href="#说说线程的⽣命周期和状态" class="headerlink" title="说说线程的⽣命周期和状态?"></a>说说线程的⽣命周期和状态?</h2><p>新建-可运行-运行-等待-超时等待-阻塞-中止</p>
<h2 id="什么是上下⽂切换"><a href="#什么是上下⽂切换" class="headerlink" title="什么是上下⽂切换?"></a>什么是上下⽂切换?</h2><p>每个线程分配时间片并轮转，当前任务切换到其他线程之前需要保存自己状态，以便回来时再继续加载之前状态</p>
<h2 id="线程有哪些基本状态"><a href="#线程有哪些基本状态" class="headerlink" title="线程有哪些基本状态?"></a>线程有哪些基本状态?</h2><p>新建<br>可运行（就绪）<br>运行<br>阻塞<br>等待<br>超时等待<br>终止<br>说下过程？<br>notify notifyAll</p>
<h2 id="什么是线程死锁-如何避免死锁"><a href="#什么是线程死锁-如何避免死锁" class="headerlink" title="什么是线程死锁?如何避免死锁?"></a>什么是线程死锁?如何避免死锁?</h2><p><strong>线程死锁：</strong><br>两个或两个以上的线程在执行过程中,因争夺资源而造成的一种互相等待的现象<br><strong>如何避免</strong>？：<strong>1、如果自己获取不到，主动释放自己占有的资源</strong> 2、按序申请资源 反序释放<br>破坏死锁条件：</p>
<ol>
<li>互斥条件：该资源任意⼀个时刻只由⼀个线程占⽤。（解决：不能破坏）</li>
<li>请求与保持条件：⼀个进程因请求资源⽽阻塞时，对加锁资源保持不放。（一直阻塞在那里）（解决：一次性申请所有资源）</li>
<li>不剥夺条件:线程已获得的资源在末使⽤完之前不能被其他线程强⾏剥夺，只有⾃⼰使⽤完毕（解决：<strong>如果自己获取不到，主动释放自己占有的资源</strong>）后才释放资源。（占着锁 非抢占式）</li>
<li>循环等待条件:若⼲进程之间形成⼀种头尾相接的循环等待资源关系。（解决：按序申请资源 反序释放 ）<h2 id="常见线程相关api对比"><a href="#常见线程相关api对比" class="headerlink" title="常见线程相关api对比"></a>常见线程相关api对比</h2><h3 id="Runnable-VS-Callable"><a href="#Runnable-VS-Callable" class="headerlink" title="Runnable VS Callable"></a>Runnable VS Callable</h3></li>
</ol>
<ul>
<li><p>Callable 接口可以返回结果或抛出检查异常</p>
</li>
<li><p>Runnable 接口不会</p>
</li>
<li><p>Executors 可以实现 Runnable 对象和 Callable 对象之间的相互转换</p>
<h3 id="shutdown-VS-shutdownNow"><a href="#shutdown-VS-shutdownNow" class="headerlink" title="shutdown() VS shutdownNow()"></a>shutdown() VS shutdownNow()</h3></li>
<li><p>shutdown（） :关闭线程池，线程池的状态变为 SHUTDOWN。线程池不再接受新任务了，但是队列里的任务得执行完毕。</p>
</li>
<li><p>shutdownNow（） :关闭线程池，线程的状态变为 STOP。线程池会终止当前正在运行的任务，并停止处理排队的任务并返回正在等待执行的 List。 shutdownNow的原理是遍历线程池中的工作线程，然后逐个调用线程的interrupt方法来中断线程，所以无法响应中断的任务可能永远无法终止</p>
<h3 id="isTerminated-VS-isShutdown"><a href="#isTerminated-VS-isShutdown" class="headerlink" title="isTerminated() VS isShutdown()"></a>isTerminated() VS isShutdown()</h3></li>
<li><p>isShutDown 当调用 shutdown() 方法后返回为 true。</p>
</li>
<li><p>isTerminated 当调用 shutdown() 方法后，并且所有提交的任务完成后返回为 true</p>
<h2 id="排查死锁"><a href="#排查死锁" class="headerlink" title="排查死锁"></a>排查死锁</h2><p><strong>命令</strong><br>jps -l 查看当前进程运行状况jstack 进程编号 查看该进程信息<br><strong>图形化</strong><br>jconsole 打开线程 ，点击 检测死锁 </p>
<h2 id="说说-sleep-⽅法和-wait-⽅法区别和共同点"><a href="#说说-sleep-⽅法和-wait-⽅法区别和共同点" class="headerlink" title="说说 sleep() ⽅法和 wait() ⽅法区别和共同点?"></a>说说 sleep() ⽅法和 wait() ⽅法区别和共同点?</h2><p>原理： </p>
</li>
<li><p>sleep方法：是Thread类的静态方法，当前线程将睡眠n毫秒，线程进入阻塞状态。当睡眠时间到了，会解除阻塞，进入可运行状态，等待CPU的到来。睡眠不释放锁（如果有的话）。</p>
</li>
<li><p>wait方法：是Object的方法，必须与synchronized关键字一起使用，线程进入阻塞状态，当notify或者notifyall被调用后，会解除阻塞。但是，只有重新占用互斥锁之后才会进入可运行状态。睡眠时，会释放互斥锁。</p>
</li>
</ul>
<p>区别：sleep() ⽅法没有释放锁，⽽ wait() ⽅法释放了锁<br>sleep之后自动苏醒，wait需要notify（）唤醒<br>共同点：两者都可以暂停线程的执⾏。</p>
<h2 id="为什么我们调⽤-start-⽅法时会执⾏-run-⽅法，为什么我们不能直接调⽤-run-⽅法"><a href="#为什么我们调⽤-start-⽅法时会执⾏-run-⽅法，为什么我们不能直接调⽤-run-⽅法" class="headerlink" title="为什么我们调⽤ start() ⽅法时会执⾏ run() ⽅法，为什么我们不能直接调⽤ run() ⽅法"></a>为什么我们调⽤ start() ⽅法时会执⾏ run() ⽅法，为什么我们不能直接调⽤ run() ⽅法</h2><p>直接调用就是main线程的一个普通方法，并不会在某个线程里面执行<br>而new 一个 Thread，线程进入了新建状态; 调用start() ，线程进入了就绪状态，然后获得时间片就可以运行了</p>
<h2 id="Thread类中的yield方法有什么作用？"><a href="#Thread类中的yield方法有什么作用？" class="headerlink" title="Thread类中的yield方法有什么作用？"></a>Thread类中的yield方法有什么作用？</h2><p>暂停当前正在执行的线程对象，让其它有相同优先级的线程执行。它是一个静态方法而且只保证当前线程放弃CPU占用而不能保证使其它线程一定能占用CPU，执行yield()的线程有可能在进入到暂停状态后马上又被执行（我暂停了我又回来了吼吼）。</p>
<h2 id="如何创建线程实例并运行"><a href="#如何创建线程实例并运行" class="headerlink" title="如何创建线程实例并运行"></a>如何创建线程实例并运行</h2><ol>
<li>创建 Thread 的子类并重写 run()</li>
</ol>
<p>run() 方在调用 start() 方法后被执行，而且一旦线程启动后 start() 方法后就会立即返回，而不是等到 run() 方法执行完毕后再返回。</p>
<ol>
<li>实现 Runnable 接口</li>
</ol>
<p>在新建类时实现 Runnable 接口，然后在 Thread 类的构造函数（new Thread的时候传参）中传入 MyRunnable 的实例对象，最后执行 start() 方法即可；</p>
<h2 id="线程阻塞的三种情况"><a href="#线程阻塞的三种情况" class="headerlink" title="线程阻塞的三种情况"></a>线程阻塞的三种情况</h2><ol>
<li><strong>等待阻塞（Object.wait -&gt; 等待队列）</strong></li>
</ol>
<p>RUNNING 状态的线程执行 Object.wait() 方法后，JVM 会将线程放入等待序列（waitting queue）；</p>
<ol>
<li><strong>同步阻塞（lock -&gt; 锁池）</strong></li>
</ol>
<p>RUNNING 状态的线程在获取对象的同步锁时，若该 <strong>同步锁被其他线程占用，则 JVM 将该线程放入锁池（lock pool）中</strong>；</p>
<ol>
<li><strong>其他阻塞（sleep&#x2F;join）</strong></li>
</ol>
<p>RUNNING 状态的线程执行 Thread.sleep(long ms) 或 Thread.join() 方法，或发出 I&#x2F;O 请求时，JVM 会将该线程置为阻塞状态。当 sleep() 状态超时，join() 等待线程终止或超时. 或者 I&#x2F;O 处理完毕时，线程重新转入可运行状态（RUNNABLE）；</p>
<h2 id="线程死亡的三种方式"><a href="#线程死亡的三种方式" class="headerlink" title="线程死亡的三种方式"></a>线程死亡的三种方式</h2><ol>
<li><strong>正常结束</strong></li>
</ol>
<p>run() 或者 call() 方法执行完成后，线程正常结束；</p>
<ol>
<li><strong>异常结束</strong></li>
</ol>
<p>线程抛出一个未捕获的 Exception 或 Error，导致线程异常结束；</p>
<ol>
<li><strong>调用 stop()</strong></li>
</ol>
<p>直接调用线程的 stop() 方法来结束该线程，但是一般不推荐使用该种方式，<strong>因为该方法通常容易导致死锁</strong>；</p>
<h2 id="守护线程是啥？"><a href="#守护线程是啥？" class="headerlink" title="守护线程是啥？"></a>守护线程是啥？</h2><p>运行在后台的一种特殊进程，在 Java 中垃圾回收线程就是特殊的守护线程。</p>
<h2 id="了解Fork-x2F-Join框架吗？"><a href="#了解Fork-x2F-Join框架吗？" class="headerlink" title="了解Fork&#x2F;Join框架吗？"></a>了解Fork&#x2F;Join框架吗？</h2><p>Java7提供 ，用于并行执行任务，把大任务分割成若干个小任务，最终汇总每个小任务结果后得到大任务结果的框架。<br><strong>「分而治之」</strong>和<strong>「工作窃取算法」</strong>。<br><strong>「分而治之」</strong><br><strong>「工作窃取算法」</strong><br>把大任务拆分成小任务，放到不同队列执行，交由不同的线程分别执行时。有的线程优先把自己负责的任务执行完了，其他线程还在慢慢悠悠处理自己的任务，这时候为了充分提高效率，就需要工作盗窃算法啦~<br><img src="https://cdn.nlark.com/yuque/0/2023/gif/226907/1684751100102-13cfdaec-0df9-4904-963b-bd1ba83c68f9.gif#averageHue=%23000000&clientId=ubfd9bb9c-147a-4&from=paste&id=ufc9236fb&originHeight=1&originWidth=1&originalType=url&ratio=1.25&rotation=0&showTitle=false&size=70&status=done&style=none&taskId=u2e150207-f40d-4505-ad1d-d2a1488af63&title=" alt="image.png"><br>工作盗窃算法就是，<strong>「某个线程从其他队列中窃取任务进行执行的过程」</strong>。一般就是指做得快的线程（盗窃线程）抢慢的线程的任务来做，同时为了减少锁竞争，通常使用双端队列，即快线程和慢线程各在一端。</p>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><h3 id="如何保证线程安全"><a href="#如何保证线程安全" class="headerlink" title="如何保证线程安全"></a>如何保证线程安全</h3><p>1、原子:Atomic synchronized<br>2、可见:synchronized volatile<br>3、有序：<br>synchronized lock接口</p>
<h2 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h2><h3 id="说说-synchronized-关键字和-volatile-关键字的区别"><a href="#说说-synchronized-关键字和-volatile-关键字的区别" class="headerlink" title="说说 synchronized 关键字和 volatile 关键字的区别"></a>说说 synchronized 关键字和 volatile 关键字的区别</h3><p>互补 存在<br>1、volatile 只能用于变量，syn可以变量、方法、类级别、代码块<br>2、volatile 关键字能保证数据的可⻅性，但不能保证数据的原⼦性。 synchronized 关键字两者都能保证<br>3、volatile <strong>不会造成线程的阻塞</strong>；synchronized <strong>可能会造成线程的阻塞</strong>。<br>4、volatile 关键字主要⽤于解决变量在多个线程之间的可⻅性，⽽ synchronized 关键字解决的是多个线程之间访问资源的同步性<br>5、volatile 本质是告诉当前变量工作内存中的值是不确定的，需要从主存中读取； synchronized 则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。</p>
<h3 id="synchronized-和-Lock-有什么区别？"><a href="#synchronized-和-Lock-有什么区别？" class="headerlink" title="synchronized 和 Lock 有什么区别？"></a>synchronized 和 Lock 有什么区别？</h3><ul>
<li><p>synchronized 可以给类. 方法. 代码块加锁；而 lock 只能给代码块加锁。</p>
</li>
<li><p>synchronized 不需要手动获取锁和释放锁，使用简单，发生异常会自动释放锁，不会造成死锁；而 lock 需要自己加锁和释放锁，如果使用不当没有 unLock()去释放锁就会造成死锁。</p>
</li>
<li><p>通过 Lock 可以知道有没有成功获取锁，而 synchronized 却无法办到。</p>
<h3 id="synchronized-和-ReentrantLock-区别是什么？"><a href="#synchronized-和-ReentrantLock-区别是什么？" class="headerlink" title="synchronized 和 ReentrantLock 区别是什么？"></a>synchronized 和 ReentrantLock 区别是什么？</h3><p><strong>相同：两者都是可重入锁</strong><br>递归锁，指的是在一个线程中可以多次获取同一把锁，比如： 一个线程在执行一个带锁的方法，该方法中又调用了另一个需要相同锁的方法，则该线程可以直接执行调用的方法，而无需重新获得锁， 两者都是同一个线程每进入一次，锁的计数器都自增1，所以要等到锁的计数器下降为0时才能释放锁。<br><strong>1.synchronized 依赖于 JVM 而 ReentrantLock 依赖于 jdk API</strong></p>
</li>
<li><p>synchronized 是依赖于 JVM 实现的， 虚拟机团队在 JDK1.6 为 synchronized 关键字进行了很多优化，但是这些优化都是在虚拟机层面实现的</p>
</li>
<li><p>ReentrantLock 是 JDK 层面实现的（也就是 API 层面，需要 lock() 和 unlock() 方法配合 try&#x2F;finally 语句块来完成）</p>
</li>
</ul>
<p><strong>2.ReentrantLock 比 synchronized 增加了一些高级功能</strong><br>相比synchronized，ReentrantLock增加了一些高级功能。主要来说主要有三点：①等待可中断；②可实现公平锁；③可实现选择性通知（锁可以绑定多个条件）</p>
<ul>
<li>2.1 等待可中断.通过lock.lockInterruptibly()来实现这个机制。也就是说正在等待的线程可以选择放弃等待，改为处理其他事情。</li>
<li>2.2 ReentrantLock可以指定是公平锁还是非公平锁。而synchronized只能是非公平锁。所谓的公平锁就是先等待的线程先获得锁。 ReentrantLock默认情况是非公平的，可以通过 ReentrantLock类的ReentrantLock(boolean fair)<strong>构造方法</strong>来制定是否是公平的。</li>
<li>2.3 ReentrantLock类线程对象可以注册在指定的Condition中，从而可以有选择性的进行线程通知，在调度线程上更加灵活。 在使用notify()&#x2F;notifyAll()方法进行通知时，被通知的线程是由 JVM 选择的，<strong>用ReentrantLock类结合Condition实例可以实现“选择性通知”</strong></li>
</ul>
<p><strong>4.使用选择</strong></p>
<ul>
<li><p>除非需要使用 ReentrantLock 的高级功能，否则<strong>优先使用 synchronized。</strong></p>
</li>
<li><p>synchronized 是 JVM 实现的一种锁机制，<strong>JVM 原生地支持</strong>它，而 ReentrantLock 不是所有的 JDK 版本都支持。并且使用 synchronized <strong>不用担心没有释放锁而导致死锁问题</strong>，因为 JVM 会确保锁的释放</p>
<h3 id="synchronized的用法有哪些"><a href="#synchronized的用法有哪些" class="headerlink" title="synchronized的用法有哪些?"></a>synchronized的用法有哪些?</h3></li>
<li><p>修饰普通方法:作用于当前对象实例，进入同步代码前要获得当前对象实例的锁</p>
</li>
<li><p>修饰静态方法:作用于当前类，进入同步代码前要获得当前类对象的锁,synchronized 关键字加到 static 静态方法和 synchronized(class)代码块上都是是给 Class 类上锁</p>
</li>
<li><p>修饰代码块:指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁（里面可以写.class（类锁）也可以写this（对象锁））</p>
</li>
</ul>
<p>特别注意：<br>①如果一个线程A调用一个实例对象的非静态 synchronized 方法，而线程B需要调用这个实例对象所属类的静态 synchronized 方法，是允许的，不会发生互斥现象，因为访问静态 synchronized 方法占用的锁是当前类的锁（因为加的不是一把锁）<br>②尽量不要使用 synchronized(String s) ,因为JVM中，字符串常量池具有缓冲功能<br>（就是说由于字符串常量池的原因不同的变量可能引用着同一个对象，锁不同变量的时候会锁成同一个对象，从而造成意料之外的同步，降低效率）</p>
<h3 id="Synchronized的作用有哪些？"><a href="#Synchronized的作用有哪些？" class="headerlink" title="Synchronized的作用有哪些？"></a>Synchronized的作用有哪些？</h3><ol>
<li><p>原子性：确保线程互斥的访问同步代码；</p>
</li>
<li><p>可见性：保证共享变量的修改能够及时可见，其实是通过Java内存模型中的 “<strong>对一个变量unlock操作之前，必须要同步到主内存中；如果对一个变量进行lock操作，则将会清空工作内存中此变量的值，在执行引擎使用此变量前，需要重新从主内存中load操作或assign操作初始化变量值</strong>（lock unlock里面可能对变量有改动）” 来保证的；</p>
</li>
<li><p>有序性：有效解决重排序问题，即 “一个unlock操作先行发生(happen-before)于后面对同一个锁的lock操作”。</p>
<h3 id="说⼀说⾃⼰对于-synchronized-关键字的了解"><a href="#说⼀说⾃⼰对于-synchronized-关键字的了解" class="headerlink" title="说⼀说⾃⼰对于 synchronized 关键字的了解"></a>说⼀说⾃⼰对于 synchronized 关键字的了解</h3><p>属于重量级锁，效率低，线程之间的切换通过操作系统层面，需要从⽤户态转换到内核态，这俩状态之间的转换成本高<br>1.6之后对synchronized引入大量优化，自旋 锁消除（每个线程一把锁）锁粗化（锁的都是一个对象） 偏向 轻量级锁来减少开销</p>
<h3 id="单例模式了解吗？来给我⼿写⼀下！给我解释⼀下双重检验锁⽅式实现单例模式的原理呗！"><a href="#单例模式了解吗？来给我⼿写⼀下！给我解释⼀下双重检验锁⽅式实现单例模式的原理呗！" class="headerlink" title="单例模式了解吗？来给我⼿写⼀下！给我解释⼀下双重检验锁⽅式实现单例模式的原理呗！"></a>单例模式了解吗？来给我⼿写⼀下！给我解释⼀下双重检验锁⽅式实现单例模式的原理呗！</h3><p>两个判断：防止加锁过程对象被其他线程实例化<br>uniqueInstance &#x3D; new Singleton();<br>1、分配内存空间<br>2、初始化<br>3、指向分配地址<br>jvm指令重排 导致线程获得还没初始化的实例，解决办法：volatile 保证多线程无指令重排</p>
<h3 id="构造⽅法可以使⽤-synchronized-关键字修饰么？"><a href="#构造⽅法可以使⽤-synchronized-关键字修饰么？" class="headerlink" title="构造⽅法可以使⽤ synchronized 关键字修饰么？"></a>构造⽅法可以使⽤ synchronized 关键字修饰么？</h3><p>不可</p>
<h3 id="对象锁是啥？"><a href="#对象锁是啥？" class="headerlink" title="对象锁是啥？"></a>对象锁是啥？</h3><p>管程</p>
<h3 id="什么是可重入锁"><a href="#什么是可重入锁" class="headerlink" title="什么是可重入锁"></a>什么是可重入锁</h3><p>同一个线程在外层方法获取锁的时候，再进入该线程的内层方法会自动获取<strong>锁</strong>(前提，锁对象得是同一个对象)，不会因为之前已经获取过还没释放而阻塞。<br>执行monitorenter，如果锁对象计数器0，那么说明没有被其他线程持有，jvm把该锁对象持有线程设为当前线程，当计数器不为0，如果持有线程是当前线程，jvm把计数器+1，否则等待。执行monitorexit时，Java虚拟机则需将锁对象的计数器减1。计数器为零代表锁已被释放。<br>ReentrantLock和synchronized都是可重入锁 （可以避免死锁）<strong>syn隐式，lock unlock显式</strong> 假如lock unlock不成对，单线程情况下问题不大，但多线程下出问题 </p>
<h3 id="讲⼀下-synchronized底层"><a href="#讲⼀下-synchronized底层" class="headerlink" title="讲⼀下 synchronized底层"></a>讲⼀下 synchronized底层</h3><p>反编译带syn的代码块，可以看到，同步代码块开始结束位置有个monitorenter 和 monitorexit，到<strong>monitorenter</strong>这个指令时，会先尝试获取对象的锁，本质上来说，Synchronized其实是通过在对象头上设置标记，锁的计数器就会+1，而当执行到<strong>monitorexit</strong>这个指令时，锁计数器就会-1，直到减到0，这个锁也就被释放了。如果获取对象锁失败，那当前线程就要阻塞等待，直到锁被另外一个线程释放为止<br>synchronized 修饰的方法并没有 monitorenter 指令和 monitorexit 指令，取得代之的确实是 ACC_SYNCHRONIZED 标识，该标识指明了该方法是一个同步方法，JVM 通过该 ACC_SYNCHRONIZED 访问标志来辨别一个方法是否声明为同步方法，从而执行相应的同步调用。</p>
<h4 id="为什么任何一个对象都可以成为一个锁？"><a href="#为什么任何一个对象都可以成为一个锁？" class="headerlink" title="为什么任何一个对象都可以成为一个锁？"></a>为什么任何一个对象都可以成为一个锁？</h4><p>追溯底层可以发现<strong>每个对象天生都带着一个对象监视器</strong>： ObjectMonitor ：记录线程获取锁次数，记录哪个线程持有我</p>
<pre><code>ObjectMonitor() &#123;
  _header       = NULL;
  _count        = 0; // 记录个数
  _waiters      = 0,
  _recursions   = 0;
  _object       = NULL;
  _owner        = NULL;
  _WaitSet      = NULL;  // 处于wait状态的线程，会被加入到_WaitSet
  _WaitSetLock  = 0 ;
  _Responsible  = NULL ;
  _succ         = NULL ;
  _cxq          = NULL ;
  FreeNext      = NULL ;
  _EntryList    = NULL ;  // 处于等待锁block状态的线程，会被加入到该列表
  _SpinFreq     = 0 ;
  _SpinClock    = 0 ;
  OwnerIsThread = 0 ;
&#125;
</code></pre>
<h4 id="synchronized-同步语句块的情况"><a href="#synchronized-同步语句块的情况" class="headerlink" title="synchronized 同步语句块的情况"></a>synchronized 同步语句块的情况</h4><p>synchronized 同步语句块的实现使⽤的是 monitorenter 和 monitorexit 指令，其中monitorenter 指令指向同步代码块的开始位置， monitorexit 指令则指明同步代码块的结束位置。当执⾏ monitorenter 指令时，线程试图获取锁也就是获取 对象监视器 monitor 的持有权。<br>moniter enter –&gt;exit<br>objectmoniter 类owner谁持有谁记录</p>
<h4 id="synchronized-修饰⽅法的的情况"><a href="#synchronized-修饰⽅法的的情况" class="headerlink" title="synchronized 修饰⽅法的的情况"></a>synchronized 修饰⽅法的的情况</h4><p>JVM 通过该ACC_SYNCHRONIZED (true or false)访问标志来辨别⼀个⽅法是否声明为同步⽅法，从⽽执⾏相应的同步调⽤。<br>为什么这俩不一样？ 我的理解：代码块里面锁可以重入 方法不可</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>synchronized 同步语句块的实现使⽤的是 monitorenter 和 monitorexit 指令，其中monitorenter 指令指向同步代码块的开始位置， monitorexit 指令则指明同步代码块的结束位置。 锁的计数器为 0 1 进＋1 出 -1synchronized 修饰的⽅法并没有 monitorenter 指令和 monitorexit 指令，取得代之的确实是<strong>ACC_SYNCHRONIZED</strong> 标识，该标识指明了该⽅法是⼀个同步⽅法。不过两者的本质都是对对象监视器 monitor 的获取。</p>
<h3 id="对象和moniter关联"><a href="#对象和moniter关联" class="headerlink" title="对象和moniter关联"></a>对象和moniter关联</h3><h3 id="多线程中-synchronized-锁升级的原理是什么？"><a href="#多线程中-synchronized-锁升级的原理是什么？" class="headerlink" title="多线程中 synchronized 锁升级的原理是什么？"></a>多线程中 synchronized 锁升级的原理是什么？</h3><h5 id="1、偏向锁"><a href="#1、偏向锁" class="headerlink" title="1、偏向锁"></a>1、偏向锁</h5><p>当一段同步代码一直被同一个线程多次访问，由于只有一个线程访问那么该线程在后续访问时便会自动获得锁。连CAS都无，（目的：防止不停的在用户态和内核态之间切换）<br>在锁对象的对象头里面MarkWord里面存的有当前线程id，第一次进，为空，把id设为自己的，以后每次进的时候没有加锁解锁，直接会去检查锁的MarkWord里面是不是放的自己的线程ID ，是的话，直接进，无CAS，如果不一致，尝试使用CAS来替换MarkWord里面的线程ID为新线程的ID ，竞争成功，表示之前的线程不存在了，MarkWord里面的线程ID为新线程的ID，锁不会升级，仍然为偏向锁； </p>
<h5 id="2、轻量级锁"><a href="#2、轻量级锁" class="headerlink" title="2、轻量级锁"></a>2、轻量级锁</h5><p>（续上）如果竞争失败，这时候会等待一个全局安全点，也就是没有代码执行，暂停原来持有偏向锁的线程，检查偏向锁线程是否处于代码块，处于代码块的话，升级为轻量，此时持有线程的还是之前原持有偏向锁的线程，线程B自旋等待；如果已经退出代码块了，锁设为无锁状态。<br>作用：有线程来参与锁的竞争，但是获取锁的冲突时间极短，本质就是自选锁CAS<br>轻量级锁是为了在线程近乎交替执行同步块时提高性能 ，说白了先自旋，不行才升级阻塞。<br>若一个线程获得锁时发现是轻量级锁，会把锁的MarkWord复制到自己的Displaced Mark Word（JVM会为每个线程在 当前线程的栈帧中创建用于存储锁记录的空间 ）里面。然后线程尝试用CAS将锁的MarkWord替换为指向锁记录的指针。 <strong>总结：就是这里MarkWord存的是指问线程栈中Lock Record的指针</strong><br>java6之后有个【自适应自选锁】：<br>线程如果自旋成功了，那下次自旋的最大次数会增加，因为JVM认为既然上次成功了，那么这一次也很大概率会成功。反之如果很少会自旋成功，那么下次会减少自旋的次数甚至不自旋，避免CPU空转。总之，自适应意味着自选的次数不是固定不变的，而是根据：<strong>同一个锁上一次自旋的时间和拥有锁线程的状态来决定。</strong></p>
<h5 id="轻量锁和偏向锁的区别和不同："><a href="#轻量锁和偏向锁的区别和不同：" class="headerlink" title="轻量锁和偏向锁的区别和不同："></a>轻量锁和偏向锁的区别和不同：</h5></li>
<li><p>争夺轻量级锁失败时，自旋尝试抢占锁</p>
</li>
<li><p>轻量级锁每次退出同步块都需要释放锁，而偏向锁是在竞争发生时才释放锁 </p>
<h5 id="3、重量级锁"><a href="#3、重量级锁" class="headerlink" title="3、重量级锁"></a>3、重量级锁</h5><p>Java中synchronized的重量级锁，是基于进入和退出Monitor对象实现的。在编译时会将同步块的开始位置插入monitor enter指令，在结束位置插入monitor exit指令。当线程执行到monitor enter指令时，会尝试获取对象所对应的Monitor所有权，如果获取到了，即获取到了锁，会在Monitor的owner中存放当前线程的id，这样它将处于锁定状态，除非退出同步块，否则其他线程无法获取到这个Monitor<br>锁的升级的目的：锁升级是为了减低了锁带来的性能消耗。在 Java 6 之后优化 synchronized 的实现方式，使用了偏向锁升级为轻量级锁再升级到重量级锁的方式，从而减低了锁带来的性能消耗。<br>此时Mark Word存的是指向互斥量的指针<br>锁升级为轻量级或重量级锁后，Mark Word中保存的分别是线程栈帧里的锁记录指针和重量级锁指针，己经没有位置再保存哈希码，GC年龄了，那么这些信息被移动到哪里去了呢 </p>
<h3 id="锁升级发生后，hashcode去哪啦"><a href="#锁升级发生后，hashcode去哪啦" class="headerlink" title="锁升级发生后，hashcode去哪啦"></a>锁升级发生后，hashcode去哪啦</h3><p>·1、在无锁状态下，Mark Word中可以存储对象的hashcode值。当对象的hashCode()方法第一次被调用时，JVM会生成对应的identity hash code值并将该值存储到Mark Word中。2、对于偏向锁，在线程获取偏向锁时，会用Thread ID和epoch值覆盖identity hash code所在的位置。如果一个对象的hashCode()方法己经被调用过一次之后，这个对象不能被设置偏向锁。因为如果可以的化，那Mark Word中的identity hash code必然会被偏向线程Id给覆盖，这就会造成同一个对象前后两次调用hashCode()方法得到的结果不一致。3、升级为轻量级锁时，JVM会在当前线程的栈帧中创建一个锁记录(Lock Record)空间，用于存储锁对象的Mark Word拷贝，该拷贝中可以包含identity hash code，所以轻量级锁可以和identity hashcode<strong>共存</strong>，哈希码和GC年龄自然保存在此，释放锁后会将这些信息写回到对象头。（加锁肯定没法访问啊）4、升级为重量级锁后，Mark Word保存的重量级锁指针，代表重量级锁的ObjectMonitor类里有字段记录非加锁状态下的Mark Word，锁释放后也会将信息写回到对象头。 </p>
<h3 id="synchronized-为什么是非公平锁？非公平体现在哪些地方？"><a href="#synchronized-为什么是非公平锁？非公平体现在哪些地方？" class="headerlink" title="synchronized 为什么是非公平锁？非公平体现在哪些地方？"></a><strong>synchronized 为什么是非公平锁？非公平体现在哪些地方？</strong></h3><p>synchronized 的非公平其实在源码中应该有不少地方，因为设计者就没按公平锁来设计，核心有以下几个点：<br>1）当持有锁的线程释放锁时，该线程会执行以下两个重要操作：</p>
</li>
<li><p>先将锁的持有者 owner 属性赋值为 null</p>
</li>
<li><p>唤醒等待链表中的一个线程（假定继承者）。</p>
</li>
</ol>
<p>在1和2之间，如果有其他线程刚好在尝试获取锁（例如自旋），则可以马上获取到锁。<br>2）<strong>当线程尝试获取锁失败，进入阻塞时，放入链表的顺序，和最终被唤醒的顺序是不一致的，也就是说你先进入链表，不代表你就会先被唤醒</strong>。</p>
<h3 id="JVM对synchronized的优化有哪些？"><a href="#JVM对synchronized的优化有哪些？" class="headerlink" title="JVM对synchronized的优化有哪些？"></a>JVM对synchronized的优化有哪些？</h3><h5 id="1-锁膨胀"><a href="#1-锁膨胀" class="headerlink" title="1. 锁膨胀"></a><strong>1. 锁膨胀</strong></h5><p>上面讲到锁有四种状态，并且会因实际情况进行膨胀升级，其膨胀方向是：<strong>无锁——&gt;偏向锁——&gt;轻量级锁——&gt;重量级锁</strong>，并且膨胀方向不可逆。</p>
<h5 id="2-锁消除"><a href="#2-锁消除" class="headerlink" title="2.锁消除"></a>2.锁消除</h5><p>每个线程一把锁 等于没有 直接消除</p>
<h5 id="3-锁粗化"><a href="#3-锁粗化" class="headerlink" title="3.锁粗化"></a>3.锁粗化</h5><p>锁同一个对象 合并<br>4.<strong>自适应自旋锁</strong><br>轻量级锁失败后，因为一个线程持有一把锁的时间并不长，切换线程不值得，因此就自旋等待<br>自适应自旋锁属于进一步优化，它的自旋的次数不再固定，其自旋的次数由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定，这就解决了自旋锁带来的缺点。</p>
<h3 id="synchronized-锁能降级吗？"><a href="#synchronized-锁能降级吗？" class="headerlink" title="synchronized 锁能降级吗？"></a>synchronized 锁能降级吗？</h3><p>可以的。<br>具体的触发时机：在全局安全点（safepoint）中，执行清理任务的时候会触发尝试降级锁。<br>当锁降级时，主要进行了以下操作：<br>1）恢复锁对象的 markword 对象头；（哦哦 原来所说的markword都是锁对象的呀）<br>2）重置 ObjectMonitor，然后将该 ObjectMonitor 放入全局空闲列表，等待后续使用。</p>
<h2 id="中断机制"><a href="#中断机制" class="headerlink" title="中断机制"></a>中断机制</h2><p>一种协作协商机制 ，中断的过程完全需要程序员自己实现 </p>
<h3 id="如何使用中断标识停止线程？"><a href="#如何使用中断标识停止线程？" class="headerlink" title="如何使用中断标识停止线程？"></a>如何使用中断标识停止线程？</h3><p>① 通过一个volatile变量实现<br>volatile保证了可见性，t2修改了标志位后能马上被t1看到<br>② 通过AtomicBoolean（原子布尔型）<br>③ 通过Thread类自带的中断api方法实现<br>interrupt() ：处于正常活动状态，那么会将该线程的中断标志设置为 true 仅此而已<br>如果线程处于被阻塞状态,在别的线程中调用当前线程对象的interrupt方法，那么线程将立即退出被阻塞状态（中断状态将被清除），并抛出一个InterruptedException异常<br>interrupted():1 返回当前线程的中断状态2 将当前线程的中断状态设为false<br><strong>isinterrupt</strong> 只是判断</p>
<h3 id="3种让线程等待和唤醒的方法"><a href="#3种让线程等待和唤醒的方法" class="headerlink" title="3种让线程等待和唤醒的方法"></a>3种让线程等待和唤醒的方法</h3><p>1、wait和notify方法必须要在同步块或者方法里面，且成对出现使用，先wait后notify才OK,顺序 </p>
<h3 id="LockSupport的阻塞唤醒"><a href="#LockSupport的阻塞唤醒" class="headerlink" title="LockSupport的阻塞唤醒"></a>LockSupport的阻塞唤醒</h3><p>3、LockSupport用来创建锁和其他同步类的基本线程阻塞原语 ，Lock Support调用的Unsafe中的native代码 ，使用了一种名为Permit（许可） 的概念来做到阻塞和唤醒线程的功能， 每个线程都有一个许可(permit)， -permit（许可）只有两个值1和0，默认是0。0 是阻塞，1是唤醒 - 可以把许可看成是一种(0,1)信号量（Semaphore），但与 Semaphore 不同的是，许可的累加上限是1<br>许可证只需要一个 先 unpark 再 park无效</p>
<h3 id="为什么可以突破wait-x2F-notify的原有调用顺序"><a href="#为什么可以突破wait-x2F-notify的原有调用顺序" class="headerlink" title="为什么可以突破wait&#x2F;notify的原有调用顺序?"></a>为什么可以突破wait&#x2F;notify的原有调用顺序?</h3><p>因为unpark获得了一个凭证， 之后再调用park方法， 就可以名正言顺的凭证消费， 故不会阻塞。 先发放了凭证后续可以畅通无阻。</p>
<h3 id="为什么唤醒两次后阻塞两次，但最终结果还会阻塞线程"><a href="#为什么唤醒两次后阻塞两次，但最终结果还会阻塞线程" class="headerlink" title="为什么唤醒两次后阻塞两次，但最终结果还会阻塞线程?"></a>为什么唤醒两次后阻塞两次，但最终结果还会阻塞线程?</h3><p>因为凭证的数量最多为1， 连续调用两次un park和调用一次un park效果一样， 只会增加一个凭证； 而调用两次park却需要消费两个凭证， 证不够， 不能放行。 </p>
<h2 id="JMM"><a href="#JMM" class="headerlink" title="JMM"></a>JMM</h2><h3 id="为什么要弄⼀个-CPU-⾼速缓存呢？"><a href="#为什么要弄⼀个-CPU-⾼速缓存呢？" class="headerlink" title="为什么要弄⼀个 CPU ⾼速缓存呢？"></a>为什么要弄⼀个 CPU ⾼速缓存呢？</h3><p><strong>CPU 缓存</strong> 解决 CPU 处理速度和内存处理速度不对等的问题。<br><strong>如何解决内存缓存不⼀致性问题？</strong><br>通过制定缓存⼀致协议</p>
<h3 id="讲⼀下-JMM-Java-内存模型"><a href="#讲⼀下-JMM-Java-内存模型" class="headerlink" title="讲⼀下 JMM(Java 内存模型)"></a>讲⼀下 JMM(Java 内存模型)</h3><p>每个线程都有自己的本地内存，读变量从自己内存里面，写变量，自己先改，改完刷回主存<br>volatile 关键字 除了防⽌ JVM 的指令重排 ，还有⼀个重要的作⽤就是保证变量的可⻅性<br>什么是JMM？<br>通过JMM来实现线程和主内存之间的读写关系，主要围绕三个特性展开<br>三大特性：原子性、可见性和有序性<br>原子性：一个操作是不可中断<br>可见：当一个线程修改了某一个共享变量的值，其他线程能够立即知道该变更 普通的共享变量不保证可见性 线程间变量值的传递均需要通过主内存来完成<br>有序性：指令重排 如果一个操作执行的结果需要对另一个操作可见性或者代码重新排序<br>happens-before：明确指定了一组排序规则，来保证线程间的可见性，这个规则就是happensbefore<br>如果一个操作happens-before另一个操作，那么<strong>第一个操作的执行结果将对第二个操作可见，</strong>而且第一个操作的执行顺序排在第二个操作之前**<br>要想保证 B 操作能够看到 A 操作的结果（无论它们是否在同一个线程），那么 A 和 B 之间必须满足 <strong>Happens-Before 关系</strong>：</p>
<ul>
<li><strong>单线程规则</strong>：一个线程中的每个动作都 happens-before 该线程中后续的每个动作</li>
<li><strong>监视器锁定规则</strong>：监听器的<strong>解锁</strong>动作 happens-before 后续对这个监听器的<strong>锁定</strong>动作 (unlock lock)</li>
<li><strong>volatile 变量规则</strong>：对 volatile 字段的写入动作 happens-before 后续对这个字段的每个读取动作</li>
<li><strong>线程 start 规则</strong>：线程 <strong>start()</strong> 方法的执行 happens-before 一个启动线程内的任意动作</li>
<li><strong>线程 join 规则</strong>：一个线程内的所有动作 happens-before 任意其他线程在该线程 <strong>join()</strong> 成功返回之前</li>
<li><strong>传递性</strong>：如果 A happens-before B, 且 B happens-before C, 那么 A happens-before C</li>
</ul>
<p>八条原则：1次序（unlock lock） 2传递 3线程启动（先写再读） （先start） 4 线程中断规则 (先interrupt() ，再Thread.interrupted()检测中断 ) 5线程终止规则(线程中的所有操作都先行发生于对此线程的终止检测 ) 6对象终结规则 （对象初始化先于finalize）<br><strong>Java 内存模型描述的是多线程对共享内存修改后彼此之间的可见性</strong></p>
<h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><p>volatile只能保证可见性和有序性 </p>
<h3 id="为什么volatile可以实现这些功能呢？-内存屏障"><a href="#为什么volatile可以实现这些功能呢？-内存屏障" class="headerlink" title="为什么volatile可以实现这些功能呢？(内存屏障)"></a>为什么volatile可以实现这些功能呢？(内存屏障)</h3><p>底层就是内存屏障 ,使得之前的所有读写操作都执行后才可以开始执行此点之后的操作 JVM指令<br>写指令后加store屏障 读指令前加load屏障<br>内存屏障之前的所有写操作都要回写到主内存， 内存屏障之后的所有读操作都能获得内存屏障之前的所有写操作的最新结果(实现了可见性)。 </p>
<h3 id="内存屏障能干嘛？"><a href="#内存屏障能干嘛？" class="headerlink" title="内存屏障能干嘛？"></a>内存屏障能干嘛？</h3><h3 id="volatile的内存语义"><a href="#volatile的内存语义" class="headerlink" title="volatile的内存语义"></a>volatile的内存语义</h3><p>volatile的写内存语义是直接刷新到主内存中，读的内存语义是直接从主内存中读取。一句话，volatile修饰的变量在某个工作内存修改后立刻会刷新会主内存，并把其他工作内存的该变量设置为无效。 </p>
<h3 id="读屏障和写屏障"><a href="#读屏障和写屏障" class="headerlink" title="读屏障和写屏障"></a>读屏障和写屏障</h3><p>写屏障：把存储在缓存的数据写回主内存 写屏障之前的写指令全部执行后面指令才能执行<br>读屏障：之后的读操作都需要在读屏障之后操作 保证读最新<br>我先写 你们后面先别读<br>隔断！我重新读主存</p>
<h3 id="happens-before之volatile变量规则"><a href="#happens-before之volatile变量规则" class="headerlink" title="happens-before之volatile变量规则"></a>happens-before之volatile变量规则</h3><p>1读2写</p>
<h3 id="为什么volatile不能保证原子性"><a href="#为什么volatile不能保证原子性" class="headerlink" title="为什么volatile不能保证原子性"></a>为什么volatile不能保证原子性</h3><p>i++<br>大家一起读，一起加一，就看谁提交的快了。提交快的直接让另一个计算失效<br>比如说你在计算的时候，别的线程已经提交了，所以你的计算直接失效了<br>本来是6 变成5<br>总结：第二个线程在第一个线程读取旧值和写回新值期间读取i的阈值，也就造成了线程安全问题 </p>
<h3 id="内存屏障的四大指令"><a href="#内存屏障的四大指令" class="headerlink" title="内存屏障的四大指令"></a>内存屏障的四大指令</h3><p>读屏障在每个volatile读操作的后面插入一个LoadLoad屏障在每个volatile读操作的后面插入一个LoadStore屏障<br>写屏障在每个volatile写操作的前面插入一个StoreStore屏障在每个volatile写操作的后面插入一个StoreLoad屏障 </p>
<h3 id="说说-synchronized-关键字和-volatile-关键字的区别-1"><a href="#说说-synchronized-关键字和-volatile-关键字的区别-1" class="headerlink" title="说说 synchronized 关键字和 volatile 关键字的区别"></a>说说 synchronized 关键字和 volatile 关键字的区别</h3><p>互补 存在<br>1、volatile 只能用于变量，syn可以变量、方法、类级别、代码块<br>2、volatile 关键字能保证数据的可⻅性，但不能保证数据的原⼦性。 synchronized 关键字两者都能保证<br>3、volatile <strong>不会造成线程的阻塞</strong>；synchronized <strong>可能会造成线程的阻塞</strong>。<br>4、volatile 关键字主要⽤于解决变量在多个线程之间的可⻅性，⽽ synchronized 关键字解决的是多个线程之间访问资源的同步性<br>5、volatile 本质是告诉当前变量工作内存中的值是不确定的，需要从主存中读取； synchronized 则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。</p>
<h3 id="策略"><a href="#策略" class="headerlink" title="策略"></a>策略</h3><p>是读用volatile，写用synchronized可以提高性能 </p>
<h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><p>DCL双锁案例 多线程指令重排 new 一个对象 空间–对象 –对象指向空间 解决：volatile</p>
<h3 id="凭什么我们java写了一个volatile关键字系统底层加入内存屏障？两者关系怎么勾搭上的？"><a href="#凭什么我们java写了一个volatile关键字系统底层加入内存屏障？两者关系怎么勾搭上的？" class="headerlink" title="凭什么我们java写了一个volatile关键字系统底层加入内存屏障？两者关系怎么勾搭上的？"></a>凭什么我们java写了一个volatile关键字系统底层加入内存屏障？两者关系怎么勾搭上的？</h3><p>字节码层面javap -c xx.class它其实添加了一个<strong>ACC_VOLATILE</strong></p>
<h2 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h2><h3 id="cas原理"><a href="#cas原理" class="headerlink" title="cas原理"></a>cas原理</h3><p>CAS （CompareAndSwap） CAS有3个操作数，位置内存值V，旧的预期值A，要修改的更新值B。 当且仅当旧的预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做或重来*当它重来重试的这种行为成为—自旋（do while）！ </p>
<h3 id="硬件级别保证"><a href="#硬件级别保证" class="headerlink" title="硬件级别保证"></a>硬件级别保证</h3><p>对总线加锁，效率比synchronized效率高<br>JDK提供的非阻塞原子性操作 <strong>Unsafe提供的CAS方法</strong>&#96;（如compareAndSwapXXX）底层实现即为CPU指令cmpxchg。<br><strong>CAS cpu并发原语</strong> 原子操作<br>AtomicInteger 类主要利用CAS (compare and swap) + volatile和 native 方法来保证原子操作，从而避免 synchronized 的高开销，执行效率大为提升。<br>执行cmpxchg指令的时候，会判断当前系统是否为多核系统，如果是就<strong>给总线加锁* *，</strong>只有一个_线程会对总线加锁<strong>成功，加锁成功之后会执行cas操作，也就是说CAS的原子性实际上是</strong>CPU实现的_</p>
<h3 id="unsafe"><a href="#unsafe" class="headerlink" title="unsafe"></a>unsafe</h3><p>Unsafe类中的方法都直接调用操作系统底层资源执行相应任务 </p>
<h3 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h3><p>尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试*获取锁 </p>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p><strong>1. ABA 问题</strong><br>并发环境下，假设初始条件是A，去修改数据时，发现是A就会执行修改。但是看到的虽然是A，中间可能发生了A变B，B又变回A的情况。此时A已经非彼A，数据即使成功修改，也可能有问题。<br>1、时间戳 2、版本号<br>可以通过AtomicStampedReference<strong>解决ABA问题</strong>，它，一个带有标记的原子引用类，通过控制变量值的版本来保证CAS的正确性。<br><strong>2. 循环时间长开销</strong><br>自旋CAS，如果一直循环执行，一直不成功，会给CPU带来非常大的执行开销。<br>很多时候，CAS思想体现，是有个自旋次数的，就是为了避开这个耗时问题~<br><strong>3. 只能保证一个变量的原子操作。</strong><br>CAS 保证的是对一个变量执行操作的原子性，如果对多个变量操作时，CAS 目前无法直接保证操作的原子性的。<br><strong>可以通过这两个方式解决这个问题</strong>：</p>
<ul>
<li><p>使用互斥锁来保证原子性；</p>
</li>
<li><p>将多个变量封装成对象，通过AtomicReference来保证原子性。</p>
<h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><p>ThreadLocal，即线程本地变量。如果你创建了一个ThreadLocal变量，那么访问这个变量的每个线程都会有这个变量的一个本地拷贝，多个线程操作这个变量的时候，实际是操作自己本地内存里面的变量，从而起到线程隔离的作用，避免了线程安全问题。<br><strong>ThreadLocal的应用场景有</strong></p>
</li>
<li><p>数据库连接池</p>
</li>
<li><p>会话管理中使用</p>
<h3 id="ThreadLocal-了解么？"><a href="#ThreadLocal-了解么？" class="headerlink" title="ThreadLocal 了解么？"></a>ThreadLocal 了解么？</h3></li>
<li><p>Thread类有一个类型为ThreadLocal.ThreadLocalMap的实例变量threadLocals，即每个线程都有一个属于自己的ThreadLocalMap。</p>
</li>
</ul>
<p>每⼀个线程都有⾃⼰的专属本地变量<br>可以使⽤ get 和 set ⽅法来获取默认值或将其值更改为当前线程所存的副本的值<br>最终变量存在ThreadLocalMap 中，key 为当前对象的 Thread 对象，值为 Object 对象 （ThreadLocalMap 是 ThreadLocal 的静态内部类。 ）</p>
<h3 id="ThreadLocal-内存泄露问题了解不？"><a href="#ThreadLocal-内存泄露问题了解不？" class="headerlink" title="ThreadLocal 内存泄露问题了解不？"></a>ThreadLocal 内存泄露问题了解不？</h3><p>ThreadLocalMap 中使⽤的 key 为 ThreadLocal 的弱引⽤,⽽ value 是强引⽤。<br>GC的时候，key变成Null，value无了，ThreadLocalMap 实现中已经考虑了这种情况，在调⽤ set() 、 get() 、 remove() ⽅法的时候，会清理掉 key 为 null的记录。使⽤完 ThreadLocal ⽅法后 最好⼿动调⽤ remove() ⽅法 最好需要手动调用remove方法。</p>
<h2 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h2><h3 id="了解ReentrantLock吗？"><a href="#了解ReentrantLock吗？" class="headerlink" title="了解ReentrantLock吗？"></a>了解ReentrantLock吗？</h3><p>ReetrantLock是一个可重入的独占锁，主要有两个特性，一个是支持公平锁和非公平锁，一个是可重入。 ReetrantLock实现依赖于AQS(AbstractQueuedSynchronizer)。<br>ReetrantLock主要依靠AQS维护一个阻塞队列，多个线程对加锁时，失败则会进入阻塞队列。等待唤醒，重新尝试加锁。</p>
<h3 id="ReadWriteLock是什么？"><a href="#ReadWriteLock是什么？" class="headerlink" title="ReadWriteLock是什么？"></a>ReadWriteLock是什么？</h3><p><strong>一句话 读读不影响</strong><br>首先ReentrantLock某些时候有局限，如果使用ReentrantLock，可能本身是为了防止线程A在写数据、线程B在读数据造成的数据不一致，但这样，如果线程C在读数据、线程D也在读数据，读数据是不会改变数据的，没有必要加锁，但是还是加锁了，降低了程序的性能。<br>因为这个，才诞生了读写锁ReadWriteLock。ReadWriteLock是一个读写锁接口，ReentrantReadWriteLock是ReadWriteLock接口的一个具体实现，实现了读写的分离，读锁是共享的，写锁是独占的，读和读之间不会互斥，读和写、写和读、写和写之间才会互斥，提升了读写的性能</p>
<h3 id="为什么要⽤线程池？"><a href="#为什么要⽤线程池？" class="headerlink" title="为什么要⽤线程池？"></a>为什么要⽤线程池？</h3><p>（线程池、数据库连接池、 Http 连接池 ）<br>主要是为了减少每次获取资源的消耗，提⾼对资源的利⽤率。<br>1、降低资源消耗：服用线程<br>2、提高速度：任务来的时候不用创建直接执行<br>3、使⽤线程池可以进⾏统⼀的分配，调优和监控。 </p>
<h2 id="Atomic"><a href="#Atomic" class="headerlink" title="Atomic"></a>Atomic</h2><h3 id="介绍⼀下-Atomic-原⼦类"><a href="#介绍⼀下-Atomic-原⼦类" class="headerlink" title="介绍⼀下 Atomic 原⼦类"></a>介绍⼀下 Atomic 原⼦类</h3><p>具有原⼦&#x2F;原⼦操作特征的类 </p>
<h3 id="JUC-包中的原⼦类是哪-4-类"><a href="#JUC-包中的原⼦类是哪-4-类" class="headerlink" title="JUC 包中的原⼦类是哪 4 类?"></a>JUC 包中的原⼦类是哪 4 类?</h3><p>4个类型 基本 数组 引用 属性修改<br>基本：Integer Long Boolean<br>数组： 后面加个Array<br>引用：去掉基本类型 加reference stampleReference<br>属性修改：基本后面加FileldUpdater</p>
<h3 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h3><p>AtomicInteger ：整形原⼦类AtomicLong ：⻓整型原⼦类AtomicBoolean ：布尔型原⼦类 </p>
<h3 id="数组类型"><a href="#数组类型" class="headerlink" title="数组类型"></a>数组类型</h3><p>使⽤原⼦的⽅式更新数组⾥的某个元素AtomicIntegerArray ：整形数组原⼦类AtomicLongArray ：⻓整形数组原⼦类AtomicReferenceArray ：引⽤类型数组原⼦类</p>
<h3 id="引⽤类型"><a href="#引⽤类型" class="headerlink" title="引⽤类型"></a>引⽤类型</h3><p>AtomicReference ：引⽤类型原⼦类AtomicStampedReference ：原⼦更新<strong>带有版本号</strong>的引⽤类型。该类将整数值与引⽤关联起来，可⽤于解决原⼦的更新数据和数据的版本号，可以解决使⽤ CAS 进⾏原⼦更新时可能出现的 ABA 问题。AtomicMarkableReference ：原⼦更新带有标记位的引⽤类型</p>
<h3 id="对象的属性修改类型"><a href="#对象的属性修改类型" class="headerlink" title="对象的属性修改类型"></a>对象的属性修改类型</h3><p>AtomicIntegerFieldUpdater ：原⼦更新整形字段的更新器AtomicLongFieldUpdater ：原⼦更新⻓整形字段的更新器AtomicReferenceFieldUpdater ：原⼦更新引⽤类型字段的更新器 </p>
<h3 id="Longadder"><a href="#Longadder" class="headerlink" title="Longadder"></a>Longadder</h3><p><strong>AtomicLong</strong>线程安全，可允许一些性能损耗，要求高精度时可使用AtomicLong是多个线程针对单个热点值value进行原子操作<strong>LongAdder</strong>当需要在高并发下有较好的性能表现，且对值的精确度要求不高时，可以使用保证性能，精度代价LongAdder是每个线程拥有自己的槽，各个线程一般只对自己槽中的那个值进行CAS操作<strong>小总结AtomicLong</strong>原理:CAS+自旋incrementAndGet场景:低并发下的全局计算AtomicLong能保证并发情况下计数的准确性，其内部通过<strong>CAS</strong>来解决并发安全性的问题缺陷高并发后性能急剧下降why?AtomicLong的自旋会称为瓶颈（N个线程CAS操作修改线程的值，每次只有一个成功过，其它N -1失败，失败的不停的自旋直到成功，这样大量失败自旋的情况，一下子cpu就打高了。）<strong>LongAdder</strong>原理CAS+Base+Cell数组分散空间换时间并分散了热点数据场景高并发的全局计算缺陷sum求和后还有计算线程修改结果的话，最后结果不够准确</p>
<h2 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h2><h3 id="AQS-了解么？"><a href="#AQS-了解么？" class="headerlink" title="AQS 了解么？"></a>AQS 了解么？</h3><p>AbstractQueuedSynchronizer<br>AbstractQueuedSynchronizer(AQS)提供了一套可用于实现锁同步机制的框架，不夸张地说，AQS是JUC同步框架的基石。AQS通过一个FIFO队列维护线程同步状态，实现类只需要继承该类，并重写指定方法即可实现一套线程同步机制。<br>AQS根据资源互斥级别提供了<strong>独占和共享</strong>两种资源访问模式；同时其定义Condition结构提供了wait&#x2F;signal等待唤醒机制。在JUC中，诸如ReentrantLock、CountDownLatch等都基于AQS实现。<br>抽象（基石）队列Queue（）同步器</p>
<h3 id="AQS原理概况"><a href="#AQS原理概况" class="headerlink" title="AQS原理概况"></a>AQS原理概况</h3><p>如果当前线程访问的资源空闲，将线程设置为有效工作线程，否则需要一套线程阻塞等待唤醒的机制，这个机制是由CLH队列（双向队列）实现的，即将暂时获取不到锁的线程加⼊到队列中。<br>AQS的原理并不复杂，AQS维护了一个volatile int state变量和一个CLH(三个人名缩写)双向队列，队列中的节点持有线程引用，每个节点均可通过getState()、setState()和compareAndSetState()对state进行修改和访问。<br>当线程获取锁时，即试图对state变量做修改，如修改成功则获取锁；如修改失败则包装为节点挂载到队列中，等待持有锁的线程释放锁并唤醒队列中的节点。<br><img src="https://cdn.nlark.com/yuque/0/2023/webp/226907/1684751100181-5421c582-3c61-4e25-adc5-98f4ffc5781d.webp#averageHue=%23121210&clientId=ubfd9bb9c-147a-4&from=paste&id=u005f7167&originHeight=456&originWidth=1154&originalType=url&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&taskId=uc6bde927-8fee-439f-8d05-21318e920ae&title="></p>
<h3 id="AQS-对资源的共享⽅式"><a href="#AQS-对资源的共享⽅式" class="headerlink" title="AQS 对资源的共享⽅式"></a>AQS 对资源的共享⽅式</h3><ol>
<li>独占</li>
</ol>
<p>如reentrantLock<br>分为非公平（谁抢到是谁）和公平（排队顺序）</p>
<ol>
<li>共享</li>
</ol>
<p>CountDownLatch 、 Semaphore<br>ReentrantReadWriteLock 可以看成是组合式，因为 ReentrantReadWriteLock 也就是读写锁允许多个线程同时对某⼀资源进⾏读。 </p>
<h3 id="AQS-底层使⽤了模板⽅法模式"><a href="#AQS-底层使⽤了模板⽅法模式" class="headerlink" title="AQS 底层使⽤了模板⽅法模式"></a>AQS 底层使⽤了模板⽅法模式</h3><ol>
<li>⾃定义同步器时 ，使⽤者继承 AbstractQueuedSynchronizer 并重写指定的⽅法 </li>
<li>将AQS组合在自定义同步组件的实现中，并调用其模板方法，而这些模板方法会调用使用者重写的方法。</li>
<li><strong>AQS使用了模板方法模式，自定义同步器时需要重写下面几个AQS提供的模板方法：</strong><pre><code>isHeldExclusively()//该线程是否正在独占资源。只有用到condition才需要去实现它。
 tryAcquire(int)//独占方式。尝试获取资源，成功则返回true，失败则返回false。
 tryRelease(int)//独占方式。尝试释放资源，成功则返回true，失败则返回false。
 tryAcquireShared(int)//共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。
 tryReleaseShared(int)//共享方式。尝试释放资源，成功则返回true，失败则返回false。
</code></pre>
</li>
</ol>
<h3 id="⽤过-CountDownLatch-么？什么场景下⽤的？"><a href="#⽤过-CountDownLatch-么？什么场景下⽤的？" class="headerlink" title="⽤过 CountDownLatch 么？什么场景下⽤的？"></a>⽤过 CountDownLatch 么？什么场景下⽤的？</h3><p>允许 count 个线程阻塞在⼀个地⽅，直⾄所有线程的任务都执⾏完毕。<br>Service:十个service注入，多线程</p>
<h3 id="AQS-组件了解吗"><a href="#AQS-组件了解吗" class="headerlink" title="AQS 组件了解吗?"></a>AQS 组件了解吗?</h3><ul>
<li><strong>Semaphore(信号量)-允许多个线程同时访问：</strong> synchronized 和 ReentrantLock 都是一次只允许一个线程访问某个资源，Semaphore(信号量)可以指定多个线程同时访问某个资源。</li>
<li><strong>CountDownLatch （倒计时器）：</strong> CountDownLatch是一个同步工具类，用来协调多个线程之间的同步。这个工具通常用来控制线程等待，它可以让某一个线程等待直到倒计时结束，再开始执行。</li>
<li><strong>CyclicBarrier(循环栅栏)：</strong> CyclicBarrier 和 CountDownLatch 非常类似，它也可以实现线程间的技术等待，但是它的功能比 CountDownLatch 更加复杂和强大。主要应用场景和 CountDownLatch 类似。CyclicBarrier 的字面意思是可循环使用（Cyclic）的屏障（Barrier）。它要做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活。CyclicBarrier默认的构造方法是 CyclicBarrier(int parties)，其参数表示屏障拦截的线程数量，每个线程调用await方法告诉 CyclicBarrier 我已经到达了屏障，然后当前线程被阻塞。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://viacheung.github.io/2023/06/04/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="ViaCheung">
      <meta itemprop="description" content="el psy congroo">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="命运石之门">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/06/04/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
	  <span class="post-time">

	  
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-06-04 00:56:20 / 修改时间：00:56:21" itemprop="dateCreated datePublished" datetime="2023-06-04T00:56:20+08:00">2023-06-04</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="什么是操作系统？"><a href="#什么是操作系统？" class="headerlink" title="什么是操作系统？"></a>什么是操作系统？</h2><p>管理计算机硬件与软件资源的程序<br>屏蔽了硬件层的复杂性<br>内核负责系统的内存管理，硬件设备的管理，⽂件系统的管理以及应⽤程序的管理。 </p>
<h2 id="系统调⽤"><a href="#系统调⽤" class="headerlink" title="系统调⽤"></a>系统调⽤</h2><p>用户态内核态<br>⽤户程序中，凡是与系统态级别的资源有关的操作（如⽂件管理、进程控制、内存管理等)，都必须通过系统调⽤⽅式向操作系统提出服务请求，并由操作系统代为完成。 </p>
<h2 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h2><ul>
<li><p>调度：进程是资源管理的基本单位，线程是程序执行的基本单位。</p>
</li>
<li><p>切换：线程上下文切换比进程上下文切换要快得多。</p>
</li>
<li><p>拥有资源： 进程是拥有资源的一个独立单位，线程不拥有系统资源，但是可以访问隶属于进程的资源。</p>
</li>
<li><p>系统开销： 创建或撤销进程时，系统都要为之分配或回收系统资源，如内存空间，I&#x2F;O设备等，OS所付出的开销显著大于在创建或撤销线程时的开销，进程切换的开销也远大于线程切换的开销。</p>
<h2 id="协程与线程的区别？"><a href="#协程与线程的区别？" class="headerlink" title="协程与线程的区别？"></a>协程与线程的区别？</h2></li>
<li><p>线程和进程都是同步机制，而协程是异步机制。</p>
</li>
<li><p>线程是抢占式，而协程是非抢占式的。需要用户释放使用权切换到其他协程，因此同一时间其实只有一个协程拥有运行权，相当于单线程的能力。</p>
</li>
<li><p>一个线程可以有多个协程，一个进程也可以有多个协程(包含关系)。</p>
</li>
<li><p>协程不被操作系统内核管理，而完全是由程序控制。线程是被分割的CPU资源，协程是组织好的代码流程，线程是协程的资源。但协程不会直接使用线程，协程直接利用的是执行器关联任意线程或线程池。</p>
</li>
<li><p>协程能保留上一次调用时的状态。</p>
<h2 id="并发和并行有什么区别？"><a href="#并发和并行有什么区别？" class="headerlink" title="并发和并行有什么区别？"></a><a target="_blank" rel="noopener" href="https://www.javalearn.cn/#/doc/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E9%9D%A2%E8%AF%95%E9%A2%98?id=_3-%E5%B9%B6%E5%8F%91%E5%92%8C%E5%B9%B6%E8%A1%8C%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F">并发和并行有什么区别？</a></h2><p>并发：1、一段时间，有多个任务在执行； 但某一时刻 ，只有一个任务在执行 本质是因为进程切换时间片足够块来达到同时多个程序在运行的错觉<br>并行：2、同一时刻，确实有多个任务在执行。需要多核处理器才能完成，不同的程序被放到不同的处理器上运行</p>
<h2 id="进程与线程的切换流程？"><a href="#进程与线程的切换流程？" class="headerlink" title="进程与线程的切换流程？"></a><a target="_blank" rel="noopener" href="https://www.javalearn.cn/#/doc/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E9%9D%A2%E8%AF%95%E9%A2%98?id=_4-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%87%E6%8D%A2%E6%B5%81%E7%A8%8B%EF%BC%9F">进程与线程的切换流程？</a></h2><p>进程切换分两步：<br>1、切换<strong>页表</strong>以使用新的地址空间（换其他线程的虚拟地址空间），一旦去切换上下文，处理器中所有已经缓存的内存地址一瞬间都作废了。（虚拟地址空间转换）<br>2、切换内核栈和硬件上下文。<br>线程只有：<br>切换内核栈和硬件上下文。<br>因为每个进程都有自己的虚拟地址空间，而线程是共享所在进程的虚拟地址空间的，因此同一个进程中的线程进行线程切换时不涉及虚拟地址空间的转换。</p>
<h2 id="为什么虚拟地址空间切换会比较耗时？"><a href="#为什么虚拟地址空间切换会比较耗时？" class="headerlink" title="为什么虚拟地址空间切换会比较耗时？"></a><a target="_blank" rel="noopener" href="https://www.javalearn.cn/#/doc/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E9%9D%A2%E8%AF%95%E9%A2%98?id=_5-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E5%88%87%E6%8D%A2%E4%BC%9A%E6%AF%94%E8%BE%83%E8%80%97%E6%97%B6%EF%BC%9F">为什么虚拟地址空间切换会比较耗时？</a></h2><p>进程都有自己的虚拟地址空间，把虚拟地址转换为物理地址需要查找页表，页表查找是一个很慢的过程，因此通常使用Cache来缓存常用的地址映射，这样可以加速页表查找，这个Cache就是TLB（translation Lookaside Buffer，TLB本质上就是一个Cache，是用来加速页表查找的）。<br>由于每个进程都有自己的虚拟地址空间，那么显然每个进程都有自己的页表，那么<strong>当进程切换后页表也要进行切换，页表切换后TLB就失效了</strong>，Cache失效导致命中率降低，那么虚拟地址转换为物理地址就会变慢，表现出来的就是程序运行会变慢，而线程切换则不会导致TLB失效，因为线程无需切换地址空间，因此我们通常说线程切换要比较进程切换块，原因就在这里。<br>总结：虚拟地址到物理地址需要用到页表进行转换，为了加速转换，一般把页表放到Cache（TLB）里面 进程切换后页表也要进行切换，页表切换后TLB就失效了，所以这个转换就变慢了</p>
<h2 id="进程间通信方式有哪些？"><a href="#进程间通信方式有哪些？" class="headerlink" title="进程间通信方式有哪些？"></a>进程间通信方式有哪些？</h2></li>
<li><p>管道：管道这种通讯方式有两种限制，一是半双工的通信，数据只能单向流动，二是只能在具有亲缘关系的进程间(父子进程关系)。管道可以分为两类：匿名管道和命名管道。匿名管道是单向的，只能在有亲缘关系的进程间通信；命名管道以磁盘文件的方式存在，可以实现本机任意两个进程通信。</p>
</li>
<li><p>信号 ： 信号是一种比较复杂的通信方式，信号可以在任何时候发给某一进程，而无需知道该进程的状态。</p>
</li>
<li><p>Socket：与其他通信机制不同的是，它可用于不同机器间的进程通信。</p>
</li>
<li><p>消息队列：消息队列克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺点。</p>
</li>
<li><p>共享内存：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号量，配合使用，来实现进程间的同步和通信。</p>
</li>
<li><p>信号量：信号量是一个<strong>计数器</strong>，可以用来控制多个进程对共享资源的访问。它常作为一种<strong>锁机制</strong>，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。</p>
</li>
</ul>
<p><strong>优缺点</strong>：</p>
<ul>
<li><p>管道：速度慢，容量有限；</p>
</li>
<li><p>Socket：任何进程间都能通讯，但速度慢；</p>
</li>
<li><p>消息队列：容量受到系统限制，且要注意第一次读的时候，要考虑上一次没有读完数据的问题；</p>
</li>
<li><p>信号量：不能传递复杂消息，只能用来同步；</p>
</li>
<li><p>共享内存区：能够很容易控制容量，速度快，但要保持同步，比如一个进程在写的时候，另一个进程要注意读写的问题，相当于线程中的线程安全，当然，共享内存区同样可以用作线程间通讯，不过没这个必要，线程间本来就已经共享了同一进程内的一块内存。</p>
<h2 id="进程间的通信⽅式总结："><a href="#进程间的通信⽅式总结：" class="headerlink" title="进程间的通信⽅式总结："></a>进程间的通信⽅式总结：</h2><p>管道&#x2F;匿名管道(Pipes)<br>信号(Signal)<br>消息队列(Message Queuing)<br>信号量(Semaphores) ：计数器，⽤于多进程对共享数据的访问<br>共享内存(Shared memory)<br>套接字(Sockets) : 客户端和服务器之间通过⽹络进⾏通信 </p>
<h2 id="进程间同步的方式有哪些？"><a href="#进程间同步的方式有哪些？" class="headerlink" title="进程间同步的方式有哪些？"></a><a target="_blank" rel="noopener" href="https://www.javalearn.cn/#/doc/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E9%9D%A2%E8%AF%95%E9%A2%98?id=_7-%E8%BF%9B%E7%A8%8B%E9%97%B4%E5%90%8C%E6%AD%A5%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F">进程间同步的方式有哪些？</a></h2><p>1、<strong>临界区</strong>：通过多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问。（只能同步本进程内的线程）<br>优点：保证在某一时刻只有一个线程能访问数据的简便办法。<br>缺点：虽然临界区同步速度很快，但却只能用来同步本进程内的线程，而不可用来同步多个进程中的线程。<br>2、<strong>互斥量</strong>（锁）：为协调共同对一个共享资源的单独访问而设计的。互斥量跟临界区很相似，比临界区复杂，互斥对象只有一个，只有拥有互斥对象的线程才具有访问资源的权限。（可以在不同进程的线程之间进行同步）<br>优点：使用互斥不仅仅能够在同一应用程序不同线程中实现资源的安全共享，而且可以在不同应用程序的线程之间实现对资源的安全共享。<br>缺点：</p>
</li>
<li><p>互斥量是可以命名的，也就是说它可以跨越进程使用，所以创建互斥量需要的资源更多，所以如果只为了在进程内部是用的话使用临界区会带来速度上的优势并能够减少资源占用量。（跨进程 需要资源多）</p>
</li>
<li><p>通过互斥量可以指定资源被独占的方式使用，但如果有下面一种情况通过互斥量就无法处理，比如现在一位用户购买了一份三个并发访问许可的数据库系统，可以根据用户购买的访问许可数量来决定有多少个线程&#x2F;进程能同时进行数据库操作，这时候如果利用互斥量就没有办法完成这个要求，信号量对象可以说是一种资源计数器。（无法处理多个线程一起同步的问题 要用到信号量）</p>
</li>
</ul>
<p>3、<strong>信号量</strong>：为控制一个具有有限数量用户资源而设计。它允许多个线程在同一时刻访问同一资源，但是需要限制在同一时刻访问此资源的最大线程数目。互斥量是信号量的一种特殊情况，当信号量的最大资源数&#x3D;1就是互斥量了。<br>优点：适用于对Socket（套接字）程序中线程的同步。<br>缺点:</p>
<ul>
<li>信号量机制必须有公共内存，<strong>不能用于分布式操作系统</strong>，这是它最大的弱点；</li>
<li>信号量机制功能强大，但使用时对信号量的操作分散， 而且难以控制，读写和维护都很困难，加重了程序员的编码负担；</li>
<li>核心操作P-V分散在各用户程序的代码中，不易控制和管理，一旦错误，后果严重，且不易发现和纠正。</li>
</ul>
<p>4、<strong>事件</strong>： 用来通知线程有一些事件已发生，从而启动后继任务的开始。<br>优点：事件对象通过通知操作的方式来保持线程的同步，并且<strong>可以实现不同进程中的线程同步操作</strong>。</p>
<h2 id="线程间的同步的⽅式"><a href="#线程间的同步的⽅式" class="headerlink" title="线程间的同步的⽅式"></a>线程间的同步的⽅式</h2><p>1、临界区（同进程）：当多个线程访问一个独占性共享资源时，可以使用临界区对象。拥有临界区的线程可以访问被保护起来的资源或代码段，其他线程若想访问，则被挂起，直到拥有临界区的线程放弃临界区为止，以此达到用原子方式操 作共享资源的目的。<br>2、事件：事件机制，则允许一个线程在处理完一个任务后，主动唤醒另外一个线程执行任务。<br>3、互斥量：互斥对象和临界区对象非常相似，<strong>只是其允许在进程间使用</strong>（可以不同进程的线程同步），而临界区只限制与同一进程的各个线程之间使用，但是更节省资源，更有效率。<br>（ Java 中的synchronized 关键词和各种 Lock 都是这种机制。）<br>4、信号量：当需要一个计数器来限制可以使用某共享资源的线程数目时，可以使用“信号量”对象。<br>区别：</p>
<ul>
<li><p>互斥量与临界区的作用非常相似，但互斥量是可以命名的，也就是说互斥量可以跨越进程使用，但创建互斥量需要的资源更多，所以如果只为了在进程内部是用的话使用临界区会带来速度上的优势并能够减少资源占用量 。因为互斥量是跨进程的互斥量一旦被创建，就可以通过名字打开它。</p>
</li>
<li><p>互斥量，信号量，事件都可以被跨越进程使用来进行同步数据操作</p>
<h2 id="线程的分类？"><a href="#线程的分类？" class="headerlink" title="线程的分类？"></a>线程的分类？</h2><p>从线程的运行空间来说，分为用户级线程（user-level thread, ULT）和内核级线程（kernel-level, KLT）<br><strong>内核级线程</strong>：这类线程依赖于内核，又称为内核支持的线程或轻量级进程。无论是在用户程序中的线程还是系统进程中的线程，它们的<strong>创建、撤销和切换都由内核实现</strong>。比如英特尔i5-8250U是4核8线程，这里的线程就是内核级线程<br><strong>用户级线程</strong>：它仅存在于用户级中，这种线程是<strong>不依赖于操作系统核心</strong>的。应用进程利用<strong>线程库来完成其创建和管理</strong>，速度比较快，<strong>操作系统内核无法感知用户级线程的存在</strong>。</p>
<h2 id="什么是临界区，如何解决冲突？"><a href="#什么是临界区，如何解决冲突？" class="headerlink" title="什么是临界区，如何解决冲突？"></a>什么是临界区，如何解决冲突？</h2><p><strong>每个进程中访问临界资源的那段程序</strong>称为临界区，<strong>一次仅允许一个进程使用的资源称为临界资源。</strong><br>解决冲突的办法：</p>
</li>
<li><p>【一次只允许一个进程进入，其他进程在外面等】如果有若干进程要求进入空闲的临界区，<strong>一次仅允许一个进程进入</strong>，如已有进程进入自己的临界区，则其它所有试图进入临界区的进程必须等待；</p>
</li>
<li><p>【进入时间优先】进入临界区的进程要在<strong>有限时间内退出</strong>。</p>
</li>
<li><p>【进不去的话 让出CPU，避免出现忙等】如果进程不能进入自己的临界区，则应<strong>让出CPU</strong>，避免进程出现“忙等”现象。</p>
<h2 id="什么是死锁？死锁产生的条件？"><a href="#什么是死锁？死锁产生的条件？" class="headerlink" title="什么是死锁？死锁产生的条件？"></a>什么是死锁？死锁产生的条件？</h2><p><strong>什么是死锁</strong>：<br>两个或者多个进程持有某种资源而又等待其它进程释放现在保持着的资源，然后形成一种无限期的阻塞、相互等待的一种状态。<br><strong>死锁产生的四个必要条件</strong>：（有一个条件不成立，则不会产生死锁）</p>
</li>
<li><p>互斥条件：一个资源一次只能被一个进程使用</p>
</li>
<li><p>请求与保持条件：一个进程因请求资源而阻塞时，对已获得资源保持不放</p>
</li>
<li><p>不剥夺条件：进程获得的资源，在未完全使用完之前，不能强行剥夺</p>
</li>
<li><p>循环等待条件：若干进程之间形成一种头尾相接的环形等待资源关系</p>
<h3 id="如何处理死锁问题"><a href="#如何处理死锁问题" class="headerlink" title="如何处理死锁问题"></a><a target="_blank" rel="noopener" href="https://www.javalearn.cn/#/doc/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E9%9D%A2%E8%AF%95%E9%A2%98?id=%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E6%AD%BB%E9%94%81%E9%97%AE%E9%A2%98">如何处理死锁问题</a></h3><p>常用的处理死锁的方法有：死锁预防、死锁避免、死锁检测、死锁解除、鸵鸟策略。<br><strong>（1）死锁的预防：</strong>基本思想就是确保死锁发生的四个必要条件中至少有一个不成立：</p>
</li>
<li><p>① 破除资源互斥条件：无法破坏</p>
</li>
<li><p>② 破除“请求与保持”条件：进程在运行之前，必须一次性获取所有的资源。缺点：在很多情况下，无法预知进程执行前所需的全部资源，因为进程是动态执行的，同时也会降低资源利用率，导致降低了进程的并发性。</p>
</li>
<li><p>③ 破除“不可剥夺”条件：允许进程强行从占有者那里夺取某些资源。当一个已经保持了某些不可被抢占资源的进程，提出新的资源请求而不能得到满足时，它必须释放已经保持的所有资源，待以后需要时再重新申请。这意味着进程已经占有的资源会被暂时被释放，或者说被抢占了。</p>
</li>
<li><p>④ 破除“循环等待”条件：对所有资源排序编号，按照顺序获取资源，将紧缺的，稀少的采用较大的编号，在申请资源时必须按照编号的顺序进行，一个进程只有获得较小编号的进程才能申请较大编号的进程。（申请资源有序 释放资源反序）</p>
</li>
</ul>
<p><strong>（2）死锁避免：</strong><br>死锁避免则允许前三个必要条件，但是通过动态地检测资源分配状态，以确保循环等待条件不成立，从而确保系统处于安全状态。<br>所谓安全状态是指：如果系统能按某个顺序为每个进程分配资源（不超过其最大值），那么系统状态是安全的，换句话说就是，如果存在一个安全序列，那么系统处于安全状态。银行家算法是经典的死锁避免的算法。<br><strong>（3）死锁检测：</strong><br>死锁预防策略是非常保守的，他们通过限制访问资源和在进程上强加约束来解决死锁的问题。死锁检测则是完全相反，它不限制资源访问或约束进程行为，只要有可能，被请求的资源就被授权给进程。但是操作系统会周期性地执行一个算法检测前面的循环等待的条件。<strong>死锁检测算法是通过资源分配图来检测是否存在环来实现，从一个节点出发进行深度优先搜索，对访问过的节点进行标记，如果访问了已经标记的节点，就表示有存在环，也就是检测到死锁的发生</strong>。<br>dfs</p>
<ul>
<li>（1）如果进程-资源分配图中无环路，此时系统没有死锁。</li>
<li>（2）如果进程-资源分配图中有环路，且每个资源类中只有一个资源，则系统发生死锁。</li>
<li>（3）如果进程-资源分配图中有环路，且所涉及的资源类有多个资源，则不一定会发生死锁。（因为不止一个资源嘛 你再访问也没事）</li>
</ul>
<p><strong>（4）死锁解除：</strong><br>死锁解除的常用方法就是终止进程和资源抢占，回滚。所谓进程终止就是简单地终止一个或多个进程以打破循环等待，包括两种方式：终止所有死锁进程和一次只终止一个进程直到取消死锁循环为止；所谓资源抢占就是从一个或者多个死锁进程那里抢占一个或多个资源。<br><strong>（5）鸵鸟策略：</strong><br>把头埋在沙子里，假装根本没发生问题。因为解决死锁问题的代价很高，因此鸵鸟策略这种不采取任何措施的方案会获得更高的性能。<strong>当发生死锁时不会对用户造成多大影响，或发生死锁的概率很低，可以采用鸵鸟策略</strong>。大多数操作系统，包括 Unix，Linux 和 Windows，处理死锁问题的办法仅仅是忽略它。</p>
<h2 id="进程的调度算法"><a href="#进程的调度算法" class="headerlink" title="进程的调度算法"></a>进程的调度算法</h2><ul>
<li><p><strong>先来先服务</strong>：非抢占式的调度算法，按照请求的顺序进行调度。有利于长作业，但不利于短作业，因为短作业必须一直等待前面的长作业执行完毕才能执行，而长作业又需要执行很长时间，造成了短作业等待时间过长。另外，对I&#x2F;O密集型进程也不利，因为这种进程每次进行I&#x2F;O操作之后又得重新排队。</p>
</li>
<li><p><strong>短作业优先</strong>：非抢占式的调度算法，按估计运行时间最短的顺序进行调度。长作业有可能会饿死，处于一直等待短作业执行完毕的状态。因为如果一直有短作业到来，那么长作业永远得不到调度。</p>
</li>
<li><p><strong>最短剩余时间优先</strong>：最短作业优先的抢占式版本，按剩余运行时间的顺序进行调度。 当一个新的作业到达时，其整个运行时间与当前进程的剩余时间作比较。如果新的进程需要的时间更少，则挂起当前进程，运行新的进程。否则新的进程等待。</p>
</li>
<li><p><strong>时间片轮转</strong>：将所有就绪进程按 FCFS 的原则排成一个队列，每次调度时，把 CPU 时间分配给队首进程，该进程可以执行一个时间片。当时间片用完时，由计时器发出时钟中断，调度程序便停止该进程的执行，并将它送往就绪队列的末尾，同时继续把 CPU 时间分配给队首的进程。时间片轮转算法的效率和时间片的大小有很大关系：因为进程切换都要保存进程的信息并且载入新进程的信息，如果时间片太小，会导致进程切换得太频繁，在进程切换上就会花过多时间。 而如果时间片过长，那么实时性就不能得到保证。</p>
</li>
<li><p><strong>优先级调度</strong>：为每个进程分配一个优先级，按优先级进行调度。为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级。</p>
<h2 id="进程有哪些状态？"><a href="#进程有哪些状态？" class="headerlink" title="进程有哪些状态？"></a>进程有哪些状态？</h2><p>进程一共有5种状态，分别是创建、就绪、运行（执行）、终止、阻塞。<br><img src="https://raw.githubusercontent.com/viacheung/img/main/image/A61F5B5322ED49038C64BDD82D341987#from=url&id=jBcZh&originHeight=256&originWidth=500&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
</li>
<li><p>运行状态就是进程正在CPU上运行。在单处理机环境下，每一时刻最多只有一个进程处于运行状态。</p>
</li>
<li><p>就绪状态就是说进程已处于准备运行的状态，即进程获得了除CPU之外的一切所需资源，一旦得到CPU即可运行。</p>
</li>
<li><p>阻塞状态就是进程正在等待某一事件而暂停运行，比如等待某资源为可用或等待I&#x2F;O完成。即使CPU空闲，该进程也不能运行。</p>
</li>
</ul>
<p><strong>运行态→阻塞态</strong>：往往是由于等待外设，等待主存等资源分配或等待人工干预而引起的。<br><strong>阻塞态→就绪态</strong>：则是等待的条件已满足，只需分配到处理器后就能运行。<br><strong>运行态→就绪态</strong>：不是由于自身原因，而是由外界原因使运行状态的进程让出处理器，这时候就变成就绪态。例如时间片用完，或有更高优先级的进程来抢占处理器等。<br><strong>就绪态→运行态</strong>：系统按某种策略选中就绪队列中的一个进程占用处理器，此时就变成了运行态。</p>
<h2 id="什么是分页？"><a href="#什么是分页？" class="headerlink" title="什么是分页？"></a>什么是分页？</h2><p>把内存空间划分为<strong>大小相等且固定的块</strong>，作为主存的基本单位。因为程序数据存储在不同的页面中，而页面又离散的分布在内存中，<strong>因此需要一个页表来记录映射关系，以实现从页号到物理块号的映射。</strong><br>访问分页系统中内存数据需要<strong>两次的内存访问</strong> (一次是从内存中访问页表，从中找到指定的物理块号，加上页内偏移得到实际物理地址(页号*每页块数+页内偏移量&#x3D;物理块号)；第二次就是根据第一次得到的物理地址访问内存取出数据)。<br><img src="https://raw.githubusercontent.com/viacheung/img/main/image/image-20210610173249387.png#from=url&id=nkII6&originHeight=402&originWidth=707&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<h2 id="什么是分段？"><a href="#什么是分段？" class="headerlink" title="什么是分段？"></a>什么是分段？</h2><p><strong>分页是为了提高内存利用率，而分段是为了满足程序员在编写代码的时候的一些逻辑需求(比如数据共享，数据保护，动态链接等)。</strong><br>分段内存管理当中，<strong>地址是二维的，一维是段号，二维是段内地址；其中每个段的长度是不一样的，而且每个段内部都是从0开始编址的</strong>。由于分段管理中，每个段内部是连续内存分配，但是段和段之间是<strong>离散分配</strong>的，因此也存在一个逻辑地址到物理地址的映射关系，相应的就是段表机制。<br>基址+偏移量（看看有没有超过段长 超过说明越界了）<br>根据段号确认基址，加上偏移量 （还要判断是否越界）<br><img src="https://raw.githubusercontent.com/viacheung/img/main/image/image-20230330225823075.png#from=url&id=gy2nR&originHeight=493&originWidth=1166&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<h2 id="分页和分段有什区别？"><a href="#分页和分段有什区别？" class="headerlink" title="分页和分段有什区别？"></a>分页和分段有什区别？</h2><ul>
<li>（分页透明 分段不透明 需要自己显式划分）分页对程序员是透明的，但是分段需要程序员显式划分每个段。</li>
<li>分页的地址空间是一维地址空间，分段是二维的。（一个给地址就行 一个需要给段码+段内地址）</li>
</ul>
<p>解释：分页之所以是一维的，原因在于分页的大小是固定的，且页码之间是连续的，操作的时候只需给出一个地址，就能够根据所给地址的大小与页面大小计算出在页码和页内地址，粗略举例，比如页面大小是4KB，给一个地址为5000，可以算出所在页码是2，页内地址是5000-4000&#x3D;1000，即在第二页的第1000个位置。而分段的因为每段的长度不一样，必须给出段码和段内地址</p>
<ul>
<li><p><strong>页的大小不可变，段的大小可以动态改变</strong>。</p>
</li>
<li><p>分页主要用于实现虚拟内存，从而获得更大的地址空间（for max）；分段主要是为了使程序和数据可以被划分为逻辑上独立的地址空间并且有助于共享和保护(独立化)。</p>
<h2 id="什么是交换空间？"><a href="#什么是交换空间？" class="headerlink" title="什么是交换空间？"></a>什么是交换空间？</h2><p>操作系统把物理内存(physical RAM)分成一块一块的小内存，每一块内存被称为<strong>页(page)。当内存资源不足时，</strong>Linux把某些页的内容转移至硬盘上的一块空间上，以释放内存空间<strong>。硬盘上的那块空间叫做</strong>交换空间**(swap space),而这一过程被称为交换(swapping)。**物理内存和交换空间的总容量就是虚拟内存的可用容量。<br>用途：</p>
</li>
<li><p>物理内存不足时一些不常用的页可以被交换出去，腾给系统。</p>
</li>
<li><p>程序启动时很多内存页被用来初始化，之后便不再需要，可以交换出去。</p>
<h2 id="物理地址、逻辑地址（有效地址）、虚拟地址（线性地址）的区别"><a href="#物理地址、逻辑地址（有效地址）、虚拟地址（线性地址）的区别" class="headerlink" title="物理地址、逻辑地址（有效地址）、虚拟地址（线性地址）的区别?"></a>物理地址、逻辑地址（有效地址）、虚拟地址（线性地址）的区别?</h2><p>物理地址就是内存中<strong>真正的地址</strong>，具有唯一性。<strong>不管哪种地址，最终都会映射为物理地址</strong>。<br>在实模式下，段基址 + 段内偏移经过地址加法器的处理，经过地址总线传输，最终也会转换为物理地址。<br>但是在保护模式下，段基址 + 段内偏移被称为线性地址，不过此时的段基址不能称为真正的地址，而是会被称作为一个选择子的东西，选择子就是个索引，相当于数组的下标，通过这个索引能够在 GDT 中找到相应的段描述符，段描述符记录了<strong>段的起始、段的大小</strong>等信息，这样便得到了基地址。如果此时没有开启内存分页功能，那么这个线性地址可以直接当做物理地址来使用，直接访问内存。如果开启了分页功能，那么这个线性地址又多了一个名字，这个名字就是虚拟地址。<br>不论在实模式还是保护模式下，段内偏移地址都叫做有效地址。有效地址也是逻辑地址。<br>线性地址可以看作是虚拟地址，虚拟地址不是真正的物理地址，但是虚拟地址会最终被映射为物理地址。下面是虚拟地址 -&gt; 物理地址的映射。<br><img src="https://raw.githubusercontent.com/viacheung/img/main/image/image-20210807152300643.png#from=url&id=xE3ri&originHeight=594&originWidth=500&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<h2 id="什么是缓冲区溢出？有什么危害？"><a href="#什么是缓冲区溢出？有什么危害？" class="headerlink" title="什么是缓冲区溢出？有什么危害？"></a>什么是缓冲区溢出？有什么危害？</h2><p>缓冲区溢出是指当计算机向缓冲区填充数据时超出了缓冲区本身的容量，溢出的数据覆盖在合法数据上。<br>危害有以下两点：</p>
</li>
<li><p>程序崩溃，导致拒绝服务</p>
</li>
<li><p>跳转并且执行一段恶意代码</p>
</li>
</ul>
<p>造成缓冲区溢出的主要原因是程序中没有仔细检查用户输入。</p>
<h2 id="什么是虚拟内存？"><a href="#什么是虚拟内存？" class="headerlink" title="什么是虚拟内存？"></a>什么是虚拟内存？</h2><p>因为只加载进程的一部分进入内存 然后用页面置换技术就完事<br>虚拟内存就是说，让物理内存扩充成更大的逻辑内存，从而让程序获得更多的可用内存。虚拟内存使用部分加载的技术，让一个进程或者资源的<strong>某些</strong>页面加载进内存，从而能够加载更多的进程，甚至能加载比内存大的进程，这样看起来好像内存变大了，这部分内存其实包含了磁盘或者硬盘，并且就叫做虚拟内存。</p>
<h2 id="虚拟内存的实现方式有哪些"><a href="#虚拟内存的实现方式有哪些" class="headerlink" title="虚拟内存的实现方式有哪些?"></a>虚拟内存的实现方式有哪些?</h2><p>虚拟内存中，允许将一个作业分多次调入内存。釆用连续分配方式时，会使相当一部分内存空间都处于暂时或永久的空闲状态，造成内存资源的严重浪费，而且也无法从逻辑上扩大内存容量。因此，虚拟内存的实需要建立在<strong>离散分配</strong>的内存管理方式的基础上。虚拟内存的实现有以下三种方式：<br>肯定要离散呀 连续的话 那相当于没有虚拟内存 使用起始位置+偏移量 </p>
<ul>
<li>请求分页存储管理。（分页）</li>
<li>请求分段存储管理。(分段)</li>
<li>请求段页式存储管理。（段页）</li>
</ul>
<p>感觉主要是这个离散分配让虚拟内存好像范围大了很多</p>
<h2 id="讲一讲IO多路复用"><a href="#讲一讲IO多路复用" class="headerlink" title="讲一讲IO多路复用"></a>讲一讲IO多路复用</h2><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6882984260672847879">https://juejin.cn/post/6882984260672847879</a><br><strong>IO多路复用是指内核一旦发现进程指定的一个或者多个IO条件准备读取，它就通知该进程。IO多路复用适用如下场合</strong>：</p>
<ul>
<li>当客户处理多个描述字时（一般是交互式输入和网络套接口），必须使用I&#x2F;O复用。</li>
<li>当一个客户同时处理多个套接口时，而这种情况是可能的，但很少出现。</li>
<li>如果一个TCP服务器既要处理监听套接口，又要处理已连接套接口，一般也要用到I&#x2F;O复用。</li>
<li>如果一个服务器即要处理TCP，又要处理UDP，一般要使用I&#x2F;O复用。</li>
<li>如果一个服务器要处理多个服务或多个协议，一般要使用I&#x2F;O复用。</li>
<li>与多进程和多线程技术相比，I&#x2F;O多路复用技术的最大优势是系统开销小，系统不必创建进程&#x2F;线程，也不必维护这些进程&#x2F;线程，从而大大减小了系统的开销<h2 id="硬链接和软链接有什么区别？"><a href="#硬链接和软链接有什么区别？" class="headerlink" title="硬链接和软链接有什么区别？"></a>硬链接和软链接有什么区别？</h2><h3 id="inode"><a href="#inode" class="headerlink" title="inode"></a>inode</h3>inode 是一个描述文件或目录属性的数据库，如元信息、硬盘物理地址等。通过 inode，操作系统可以检索文件权限信息、物理地址等信息。当一个文件从一个文件夹移到另一个文件夹，文件将被移动到硬盘的另一个位置，文件的 inode 值也会自动发生变化。<h3 id="硬连接"><a href="#硬连接" class="headerlink" title="硬连接"></a>硬连接</h3>硬连接直接通过 inode 引用文件。硬连接只能用于文件，而不能用于目录。<br>硬连接（Hard Link）扮演着源文件拷贝或镜像的角色。可以访问源文件的数据，如果源文件被删除，硬连接依然可以访问源文件的数据。<h3 id="软连接"><a href="#软连接" class="headerlink" title="软连接"></a>软连接</h3>软连接本质上是源文件的一个快捷方式，指向源文件本身，而不是源文件的 inode 值。软连接可以同时用于文件和目录，也可以在不同的硬盘或容器之间使用。<br>软连接（Soft Link 或 Symbolic Link）扮演着源文件指针的角色。不可以访问源文件数据，如果源文件被删除，软连接将会指向一个不再存在的文件地址。<br><img src="https://cdn.nlark.com/yuque/0/2023/webp/226907/1684914769452-d1ec9390-2694-4a1e-85d1-4594b50d186d.webp#averageHue=%23444444&clientId=u15dd87e7-faa6-4&from=paste&id=u25a05d06&originHeight=384&originWidth=1360&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u089da635-2956-4e20-bb53-94160fc2d03&title="><br>硬连接直接引用源文件引用的 inode，软连接则直接引用源文件。<br><img src="https://raw.githubusercontent.com/viacheung/img/main/image/image-20230331214416885.png#from=url&id=UiATJ&originHeight=350&originWidth=780&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><h2 id="中断的处理过程"><a href="#中断的处理过程" class="headerlink" title="中断的处理过程?"></a>中断的处理过程?</h2></li>
</ul>
<ol>
<li>保护现场：将当前执行程序的相关数据保存在寄存器中，然后入栈。</li>
<li>开中断：以便执行中断时能响应较高级别的中断请求。</li>
<li>中断处理</li>
<li>关中断：保证恢复现场时不被新中断打扰</li>
<li>恢复现场：从堆栈中按序取出程序数据，恢复中断前的执行状态。<h2 id="中断和轮询有什么区别？"><a href="#中断和轮询有什么区别？" class="headerlink" title="中断和轮询有什么区别？"></a>中断和轮询有什么区别？</h2></li>
</ol>
<ul>
<li><p>轮询：CPU对<strong>特定设备</strong>轮流询问。中断：通过<strong>特定事件</strong>提醒CPU。</p>
</li>
<li><p>轮询：效率低等待时间长，CPU利用率不高。中断：容易遗漏问题，CPU利用率不高。</p>
<h2 id="什么是用户态和内核态？"><a href="#什么是用户态和内核态？" class="headerlink" title="什么是用户态和内核态？"></a>什么是用户态和内核态？</h2><p>用户态和系统态是操作系统的两种运行状态：</p>
</li>
<li><p>内核态：内核态运行的程序可以访问计算机的任何数据和资源，不受限制，包括外围设备，比如网卡、硬盘等。处于内核态的 CPU 可以从一个程序切换到另外一个程序，并且占用 CPU 不会发生抢占情况。</p>
</li>
<li><p>用户态：用户态运行的程序只能受限地访问内存，只能直接读取用户程序的数据，并且不允许访问外围设备，用户态下的 CPU 不允许独占，也就是说 CPU 能够被其他程序获取。</p>
</li>
</ul>
<p>将操作系统的运行状态分为用户态和内核态，主要是为了对访问能力进行限制，<strong>防止随意进行一些比较危险的操作导致系统的崩溃</strong>，比如设置时钟、内存清理，这些都需要在内核态下完成 。</p>
<h2 id="用户态和内核态是如何切换的"><a href="#用户态和内核态是如何切换的" class="headerlink" title="用户态和内核态是如何切换的?"></a>用户态和内核态是如何切换的?</h2><p>所有的用户进程都是运行在用户态的，但是我们上面也说了，用户程序的访问能力有限，一些比较重要的比如从硬盘读取数据，从键盘获取数据的操作则是内核态才能做的事情，而这些数据却又对用户程序来说非常重要。所以就涉及到两种模式下的转换，即<strong>用户态 -&gt; 内核态 -&gt; 用户态</strong>，而唯一能够做这些操作的只有 系统调用，而能够执行系统调用的就只有 操作系统。<br>一般用户态 -&gt; 内核态的转换我们都称之为 trap 进内核，也被称之为 陷阱指令(trap instruction)。<br>他们的工作流程如下：<br><img src="https://raw.githubusercontent.com/viacheung/img/main/image/image-20210807152619210.png#from=url&id=eR7m5&originHeight=576&originWidth=761&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<ul>
<li><p>首先用户程序会调用 glibc 库，glibc 是一个标准库，同时也是一套核心库，库中定义了很多关键 API。</p>
</li>
<li><p>glibc 库知道针对不同体系结构调用系统调用的正确方法，它会根据体系结构应用程序的二进制接口设置用户进程传递的参数，来准备系统调用。</p>
</li>
<li><p>然后，glibc 库调用软件中断指令(SWI) ，这个指令通过更新 CPSR 寄存器将模式改为超级用户模式，然后跳转到地址 0x08 处。</p>
</li>
<li><p>到目前为止，整个过程仍处于用户态下，在执行 SWI 指令后，允许进程执行内核代码，MMU 现在允许内核虚拟内存访问</p>
</li>
<li><p>从地址 0x08 开始，进程执行加载并跳转到中断处理程序，这个程序就是 ARM 中的 vector_swi()。</p>
</li>
<li><p>在 vector_swi() 处，从 SWI 指令中提取系统调用号 SCNO，然后使用 SCNO 作为系统调用表 sys_call_table 的索引，调转到系统调用函数。</p>
</li>
<li><p>执行系统调用完成后，将还原用户模式寄存器，然后再以用户模式执行。</p>
<h2 id="Unix-常见的IO模型"><a href="#Unix-常见的IO模型" class="headerlink" title="Unix 常见的IO模型"></a>Unix 常见的IO模型</h2><p>对于一次IO访问（以read举例），数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。所以说，当一个read操作发生时，它会经历两个阶段：</p>
</li>
<li><p>等待数据准备就绪 (Waiting for the data to be ready)</p>
</li>
<li><p>将数据从内核拷贝到进程中 (Copying the data from the kernel to the process)</p>
</li>
</ul>
<p>正式因为这两个阶段，linux系统产生了下面五种网络模式的方案：</p>
<ul>
<li>阻塞式IO模型(blocking IO model)</li>
<li>非阻塞式IO模型(noblocking IO model)</li>
<li>IO复用式IO模型(IO multiplexing model)</li>
<li>信号驱动式IO模型(signal-driven IO model)</li>
<li>异步IO式IO模型(asynchronous IO model)</li>
</ul>
<p>对于这几种 IO 模型的详细说明，可以参考这篇文章：<a target="_blank" rel="noopener" href="https://juejin.cn/post/6942686874301857800#heading-13">https://juejin.cn/post/6942686874301857800#heading-13</a><br>其中，IO多路复用模型指的是：使用单个进程同时处理多个网络连接IO，他的原理就是select、poll、epoll 不断轮询所负责的所有 socket，当某个socket有数据到达了，就通知用户进程。该模型的优势并不是对于单个连接能处理得更快，而是在于能处理更多的连接。</p>
<h2 id="select、poll-和-epoll-之间的区别"><a href="#select、poll-和-epoll-之间的区别" class="headerlink" title="select、poll 和 epoll 之间的区别?"></a>select、poll 和 epoll 之间的区别?</h2><p>（1）select：时间复杂度 O(n)<br>select 仅仅知道有 I&#x2F;O 事件发生，但并不知道是哪几个流，所以只能<strong>无差别轮询所有流</strong>，找出能读出数据或者写入数据的流，并对其进行操作。所以 select 具有 O(n) 的无差别轮询复杂度，同时处理的流越多，无差别轮询时间就越长。<br>（2）poll：时间复杂度 O(n)<br>poll 本质上和 select 没有区别，它将用户传入的数组拷贝到内核空间，然后查询每个 fd 对应的设备状态， 但是它<strong>没有最大连接数的限制</strong>，原因是它是基于<strong>链表</strong>来存储的。<br>（3）epoll：时间复杂度 O(1)<br>epoll 可以理解为 event poll，不同于忙轮询和无差别轮询，epoll 会把哪个流发生了怎样的 I&#x2F;O 事件通知我们。所以说 epoll 实际上是事件驱动（每个事件关联上 fd）的。<br>select，poll，epoll 都是 IO 多路复用的机制。I&#x2F;O 多路复用就是通过一种机制监视多个描述符，<strong>一旦某个描述符就绪（一般是读就绪或者写就绪）</strong>，就通知程序进行相应的读写操作。但 select，poll，epoll 本质上都是同步 I&#x2F;O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的，而异步 I&#x2F;O 则无需自己负责进行读写，异步 I&#x2F;O 的实现会负责把数据从内核拷贝到用户空间。</p>
<h2 id="操作系统的内存管理主要是做什么"><a href="#操作系统的内存管理主要是做什么" class="headerlink" title="操作系统的内存管理主要是做什么"></a>操作系统的内存管理主要是做什么</h2><p>主要负责内存的分配与回收 </p>
<h2 id="常⻅的⼏种内存管理机制"><a href="#常⻅的⼏种内存管理机制" class="headerlink" title="常⻅的⼏种内存管理机制"></a>常⻅的⼏种内存管理机制</h2><p>块式管理 ：碎⽚<br>⻚式管理 ： 提⾼了内存利⽤率，减少了碎⽚<br>段式管理 ：实际意义的 </p>
<h2 id="快表和多级⻚表"><a href="#快表和多级⻚表" class="headerlink" title="快表和多级⻚表"></a>快表和多级⻚表</h2><p><strong>解决了⻚表管理中很重要的两个问题</strong></p>
<ol>
<li>虚拟地址到物理地址的转换要快。</li>
<li>解决虚拟地址空间⼤，⻚表也会很⼤的问题。</li>
</ol>
<p>快表 (类似缓存)<br>\1.根据虚拟地址中的⻚号查快表；\2. 如果该⻚在快表中，直接从快表中读取相应的物理地址；\3. 如果该⻚不在快表中，就访问内存中的⻚表，再从⻚表中得到物理地址，同时将⻚表中的该映射表项添加到快表中；\4. 当快表填满后，⼜要登记新⻚时，就按照⼀定的淘汰策略淘汰掉快表中的⼀个⻚。<br>多级⻚表<br>时间换空间 </p>
<h2 id="分⻚机制和分段机制的共同点和区别"><a href="#分⻚机制和分段机制的共同点和区别" class="headerlink" title="分⻚机制和分段机制的共同点和区别"></a>分⻚机制和分段机制的共同点和区别</h2><p>共同点 ：1、都是为了提⾼内存利⽤率，较少内存碎⽚。2、每个⻚和段中的内存是连续的。<br>区别 ：<br>1、⻚的⼤⼩是固定的，由操作系统决定；⽽段的⼤⼩不固定，取决于我们当前运⾏的程序。<br>2、分⻚仅仅是为了满⾜操作系统内存管理的需求，⽽段是逻辑信息的单位， </p>
<h2 id="逻辑-虚拟-地址和物理地址"><a href="#逻辑-虚拟-地址和物理地址" class="headerlink" title="逻辑(虚拟)地址和物理地址"></a>逻辑(虚拟)地址和物理地址</h2><p>逻辑地址：指针⾥⾯存储的数值<br>物理地址指的是真实物理内存中地址 （内存地址寄存器 ）</p>
<h2 id="CPU-寻址了解吗-为什么需要虚拟地址空间"><a href="#CPU-寻址了解吗-为什么需要虚拟地址空间" class="headerlink" title="CPU 寻址了解吗?为什么需要虚拟地址空间?"></a>CPU 寻址了解吗?为什么需要虚拟地址空间?</h2><p>如果直接把物理地址暴露出来的话会带来严重问题，⽐如可能对操作系统造成伤害以及给同时运⾏多个程序造成困难。 </p>
<h2 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h2><p>只是多个进程被分割为多个物理内存块（还有部分暂时存储在外部磁盘存储器上，在需要时进⾏数据交换。 ） 感觉上是独享主存 </p>
<h2 id="局部性原理"><a href="#局部性原理" class="headerlink" title="局部性原理"></a>局部性原理</h2><p>时间局部：如果程序中的某条指令⼀旦执⾏，不久以后该指令可能再次执⾏<br>空间局部性 ：⼀旦程序访问了某个存储单元，在不久之后，其附近的存储单元也将被访问， </p>
<h2 id="⻚⾯置换算法"><a href="#⻚⾯置换算法" class="headerlink" title="⻚⾯置换算法"></a>⻚⾯置换算法</h2><p><img src="https://raw.githubusercontent.com/viacheung/img/main/image/image-20210807152232136.png#from=url&id=KjuOS&originHeight=431&originWidth=807&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>OPT ⻚⾯置换算法（最佳⻚⾯置换算法） ：最⻓时间内不再被访问的⻚⾯<br>FIFO（First In First Out） ⻚⾯置换算法（先进先出⻚⾯置换算法） : 总是淘汰最先进⼊内存的⻚⾯，即选择在内存中驻留时间最久的⻚⾯进⾏淘汰<br>LRU （Least Currently Used）⻚⾯置换算法（最近最久未使⽤⻚⾯置换算法）<br>LFU （Least Frequently Used）⻚⾯置换算法（最少使⽤⻚⾯置换算法） </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://viacheung.github.io/2023/06/04/Spring/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="ViaCheung">
      <meta itemprop="description" content="el psy congroo">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="命运石之门">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/06/04/Spring/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
	  <span class="post-time">

	  
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-06-04 00:55:37 / 修改时间：00:55:38" itemprop="dateCreated datePublished" datetime="2023-06-04T00:55:37+08:00">2023-06-04</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="使用Spring框架的好处是什么？"><a href="#使用Spring框架的好处是什么？" class="headerlink" title="使用Spring框架的好处是什么？"></a>使用Spring框架的好处是什么？</h2><ul>
<li><strong>轻量：</strong>Spring 是轻量的，基本的版本大约2MB</li>
<li><strong>控制反转：</strong>Spring通过控制反转实现了松散耦合，对象们给出它们的依赖，而不是创建或查找依赖的对象们</li>
<li><strong>面向切面的编程(AOP)：</strong>Spring支持面向切面的编程，并且把应用业务逻辑和系统服务分开</li>
<li><strong>容器：</strong>Spring 包含并管理应用中对象的生命周期和配置</li>
<li><strong>MVC框架：</strong>Spring的WEB框架是个精心设计的框架，是Web框架的一个很好的替代品</li>
<li><strong>事务管理：</strong>Spring 提供一个持续的事务管理接口，可以扩展到上至本地事务下至全局事务（JTA）</li>
<li><strong>异常处理：</strong>Spring 提供方便的API把具体技术相关的异常（比如由JDBC，Hibernate or JDO抛出的）转化为一致的unchecked 异常。 <h2 id="spring开发步骤"><a href="#spring开发步骤" class="headerlink" title="spring开发步骤"></a>spring开发步骤</h2>Spring的开发步骤① 导入坐标（context ）② 创建Bean（编写Dao接口和实现类 ）③ 创建applicationContext.xml（类路径下（resources） ）④ 在配置文件中进行配置（&lt;bean id&#x3D;”userDao” class&#x3D;”com.itheima.dao.impl.UserDaoImp ）⑤ 创建ApplicationContext对象getBean <pre><code>ApplicationContext applicationContext = new   ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);
UserDao userDao = (UserDao) applicationContext.getBean(&quot;userDao&quot;);
userDao.save();
</code></pre>
<h2 id="Bean"><a href="#Bean" class="headerlink" title="Bean"></a>Bean</h2>用于配置对象交由Spring 来创建。默认情况下它调用的是类中的无参构造函数，如果没有无参构造函数则不能创建成功。<br>id： Bean实例在Spring容器中class： Bean的全限定名称<br>默认值，单例的<br><img src="https://raw.githubusercontent.com/viacheung/img/main/image/image-20230317204511492.png#from=url&id=lsa6u&originHeight=553&originWidth=1010&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>init-method：指定类中的初始化方法名称<br>destroy-method：指定类中销毁方法名称 <h3 id="Bean实例化三种方式"><a href="#Bean实例化三种方式" class="headerlink" title="Bean实例化三种方式"></a>Bean实例化三种方式</h3>无参构造方法实例化工厂静态方法实例化工厂实例方法实例化 <h3 id="Bean的依赖注入"><a href="#Bean的依赖注入" class="headerlink" title="Bean的依赖注入"></a>Bean的依赖注入</h3>通过控制反转，把对象的创建交给了 Spring，但IOC 解耦只是降低他们的依赖关系，但不会消除。例如：业务层仍会调用持久层的方法。那这种业务层和持久层的依赖关系，在使用 Spring 之后，就让 Spring 来维护了。简单的说，就是坐等框架把持久层对象传入业务层，而不用我们自己去获取<br>对象注入哪几种方式？<br>1、<strong>构造函数注入</strong><br><img src="https://raw.githubusercontent.com/viacheung/img/main/image/image-20230410165353388.png#from=url&id=Ap8gl&originHeight=117&originWidth=514&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>好处：<br><img src="https://raw.githubusercontent.com/viacheung/img/main/image/image-20230410165421975.png#from=url&id=EQZIj&originHeight=83&originWidth=608&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>2、<strong>setter 注入</strong>（在XML中写入，然后在set方法中注入。<br><bean id="userService" class="com.lyu.spring.service.impl.UserService"><!-- 写法一 --><!-- <property name="UserDao" ref="userDaoMyBatis"></property> --><br>&#96;&#96;&#96;<br>private IUserDao userDao1;</bean></li>
</ul>
<p>public void setUserDao(IUserDao userDao1) {&#x2F;&#x2F;这里注意，name方法与类中成员变量名和方法的参数名都无关，只与set方法名有关<br>    this.userDao1 &#x3D; userDao1;<br>}</p>
<pre><code>![](https://raw.githubusercontent.com/viacheung/img/main/image/image-20230410165552733.png#from=url&amp;id=qhPDP&amp;originHeight=80&amp;originWidth=735&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=)
3、接口注入（**注解注入**）
前面两种都可以检测出循环依赖
![](https://raw.githubusercontent.com/viacheung/img/main/image/image-20230410165617392.png#from=url&amp;id=aqfil&amp;originHeight=58&amp;originWidth=378&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=)
![](https://raw.githubusercontent.com/viacheung/img/main/image/image-20230410165642347.png#from=url&amp;id=NdBYf&amp;originHeight=96&amp;originWidth=540&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=)
### 构造注入vs setter注入
| **构造函数注入** | **setter 注入** |
| --- | --- |
| 没有部分注入 | 有部分注入 |
| 不会覆盖 setter 属性 | 会覆盖 setter 属性 |
| 任意修改都会创建一个新实例 | 任意修改不会创建一个新实例 |
| 适用于设置很多属性 | 适用于设置少量属性 |

普通属性呢？
 普通数据类型 引用数据类型 集合数据类型
![](https://raw.githubusercontent.com/viacheung/img/main/image/image-20230317210715447.png#from=url&amp;id=Va4E5&amp;originHeight=233&amp;originWidth=866&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=)
一样 也是 set方法 this.age=age,然后直接输出age
### getBean
![](https://raw.githubusercontent.com/viacheung/img/main/image/image-20230317211005500.png#from=url&amp;id=D3Zve&amp;originHeight=667&amp;originWidth=1065&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=)
容器中某一类型的Bean有多个--用id
有一个--用class
### 区分 BeanFactory 和 ApplicationContext？
| **BeanFactory** | **ApplicationContext** |
| --- | --- |
| 它使用懒加载 | 它使用即时加载 |
| 它使用语法显式提供资源对象 | 它自己创建和管理资源对象 |
| 不支持国际化 | 支持国际化 |
| 不支持基于依赖的注解 | 支持基于依赖的注解 |

BeanFactory和ApplicationContext的优缺点分析：
BeanFactory的优缺点：

- 优点：应用启动的时候占用资源很少，对资源要求较高的应用，比较有优势；
- 缺点：运行速度会相对来说慢一些。而且有可能会出现空指针异常的错误，而且通过Bean工厂创建的Bean生命周期会简单一些。

ApplicationContext的优缺点：

- 优点
- 1、启动即加载所有Bean
- 2、系统运行的速度快
- 3、在系统启动的时候，可以发现系统中的配置问题
- 缺点
- 1、所有的对象都预加载，缺点就是内存占用较大。
### spring提供了哪些配置方式

- 基于 xml 配置

bean 所需的依赖项和服务在 XML 格式的配置文件中指定。这些配置文件通常包含许多 bean 定义和特定于应用程序的配置选项。它们通常以 bean 标签开头。
</code></pre>
<bean id="studentbean" class="org.edureka.firstSpring.StudentBean">
 <property name="name" value="Edureka"></property>
</bean>
```

<ul>
<li>基于注解配置</li>
</ul>
<p>通过在相关的类，方法或字段声明上使用注解，将 bean 配置为组件类本身，而不是使用 XML 来描述 bean 装配。默认情况下，Spring 容器中未打开注解装配。因此需要在使用它之前在 Spring 配置文件中启用它。例如：</p>
<pre><code>&lt;beans&gt; 
    &lt;context:annotation-config/&gt; 
    &lt;!-- bean definitions go here --&gt; 
&lt;/beans&gt;
</code></pre>
<ul>
<li>基于 Java API 配置</li>
</ul>
<p>Spring 的 Java 配置是通过使用 @Bean 和 @Configuration 来实现。</p>
<ol>
<li><p>@Bean 注解扮演与 <bean> 元素相同的角色。</bean></p>
</li>
<li><p>@Configuration 类允许通过简单地调用同一个类中的其他 @Bean 方法来定义 bean 间依赖关系。</p>
<pre><code>@Configuration
public class StudentConfig &#123;
 @Bean
 public StudentBean myStudent() &#123;
     return new StudentBean();
 &#125;
&#125;
</code></pre>
<h2 id="AOP工作流程"><a href="#AOP工作流程" class="headerlink" title="AOP工作流程"></a>AOP工作流程</h2></li>
<li><p>Spring容器启动</p>
</li>
<li><p>读取切面的所有切入点（没使用的切入点不会形成切面）</p>
</li>
<li><p>Spring初始化bean，会判断bean对应的类中方法是否匹配到任意切入点，若匹配成功，说明与AOP无关，创建对象；若匹配失败，创建原始对象的代理对象</p>
</li>
<li><p>获取bean执行方法，若不是代理对象，则与AOP无关，调用方法并执行，完成操作；若是代理对象，则根据代理对象的运行模式运行原始方法与增强的内容，完成操作</p>
</li>
</ol>
<p>AOP 的底层是通过 Spring 提供的的动态代理技术实现的。在运行期间， Spring通过动态代理技术动态的生成代理对象，代理对象方法执行时进行增强功能的介入，在去调用目标对象的方法，从而完成功能的增强<br>在 spring 中，框架会根据目标类是否实现了接口来决定采用哪种动态代理的方式<br><img src="https://raw.githubusercontent.com/viacheung/img/main/image/image-20230317214126458.png#from=url&id=ZMtcx&originHeight=470&originWidth=1568&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br><img src="https://raw.githubusercontent.com/viacheung/img/main/image/image-20230317214459819.png#from=url&id=kb2rR&originHeight=370&originWidth=1114&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>对切入点Pointcut进行通知也就形成了一个切面<br>面向切面编程，将公共的代码逻辑抽象出来变成一个切面，然后注入到目标对象（具体业务）中去，通过动态代理的方式，将需要注入切面的对象进行代理，在进行调用的时候，将公共的逻辑直接添加进去，而不需要修改原有业务的逻辑代码，只需要在原来的业务逻辑基础之上做一些增强功能即可。<br>Spring AOP就是基于动态代理的，<br>如果要代理的对象，实现了某个接⼝，那么Spring AOP会使（基于代理对象的接口）⽤JDK Proxy，去创建代理对象，⽽对于没有实现接⼝的对象， 会使⽤ Cglib ⽣成⼀个被代理对象的⼦类来作为代理，如下图所示： （基于代理对象的子类）</p>
<h3 id="基于注解的aop开发步骤："><a href="#基于注解的aop开发步骤：" class="headerlink" title="基于注解的aop开发步骤："></a>基于注解的aop开发步骤：</h3><p>① 创建目标接口和目标类（内部有切点）(一个接口 一个实现类)② 创建切面类（内部有增强方法）③ 将目标类和切面类的对象创建权交给 spring（xml 或者 注解）④ 在切面类中使用注解配置织入关系（定义是哪个切面 目标类的方法用的切面类的哪个增强方法）⑤ 在配置文件中开启组件扫描和 AOP 的自动代理⑥ 测试 </p>
<h3 id="AOP-有哪些实现方式？"><a href="#AOP-有哪些实现方式？" class="headerlink" title="AOP 有哪些实现方式？"></a>AOP 有哪些实现方式？</h3><p>主要分为两大类：</p>
<ul>
<li><p>静态代理 - 指使用 AOP 框架提供的命令进行编译，从而在编译阶段就可生成 AOP 代理类，因此也称为编译时增强；</p>
<ul>
<li>编译时编织（特殊编译器实现）</li>
<li>类加载时编织（特殊的类加载器实现）。</li>
</ul>
</li>
<li><p>动态代理 - 在运行时在内存中“临时”生成 AOP 动态代理类，因此也被称为运行时增强。</p>
<ul>
<li>JDK 动态代理：通过反射来接收被代理的类，并且要求被代理的类必须实现一个接口 。JDK 动态代理的核心是 InvocationHandler 接口和 Proxy 类 。</li>
<li>CGLIB动态代理： 如果目标类没有实现接口，那么 Spring AOP 会选择使用 CGLIB 来动态代理目标类 。CGLIB （ Code Generation Library ），是一个代码生成的类库，可以在运行时动态的生成某个类的子类，注意， CGLIB 是通过继承的方式做的动态代理，因此如果某个类被标记为 final ，那么它是无法使用 CGLIB 做动态代理的。<h3 id="Spring-AOP-和-AspectJ-AOP-有什么区别？"><a href="#Spring-AOP-和-AspectJ-AOP-有什么区别？" class="headerlink" title="Spring AOP 和 AspectJ AOP 有什么区别？"></a>Spring AOP 和 AspectJ AOP 有什么区别？</h3>Spring AOP 属于运⾏时增强，⽽ AspectJ 是编译时增强。 <h2 id="IOC工作流程"><a href="#IOC工作流程" class="headerlink" title="IOC工作流程"></a>IOC工作流程</h2>设计思想 ：原本在程序中⼿动创建对象的控制权，交由Spring框架来管理<br><strong>IoC 容器实际上就是个Map</strong>（key， value） ,Map 中存放的是各种对象。 IoC 容器类似⼯⼚，当需要创建⼀个对象的时候，只需要配置好配置⽂件&#x2F;注解即可<br><img src="https://raw.githubusercontent.com/viacheung/img/main/image/image-20230314005000935.png#from=url&id=wzKcX&originHeight=158&originWidth=745&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>解析xml注册到beanFactory<br>IoC，即控制反转，的核心思想是把对象的管理权限交给容器，应用程序如果需要使用某个对象的实例，直接从IOC容器里获取就可以了。这种设计的好处在于，降低了程序中对象之间的耦合性。<br>Spring提供了很多方式声明bean，比如xml、注解等方式去声明。Spring启动时会解析这些bean并保存到IOC容器里</li>
</ul>
</li>
<li><p>第一阶段：IOC容器的初始化，这个阶段主要是根据xml或者注解声明的bean，通过解析和加载后生成beanDefinition，包含一些bean的定义属性等，然后把beanDefinition保存到一个map集合里，注册到IOC容器里，从而完成IOC的初始化</p>
</li>
<li><p>第二阶段：完成bean的初始化和依赖注入。主要有两个操作，一个是通过反射去针对没有设置lazy-init属性的单例bean进行初始化，另一个是完成bean的依赖注入</p>
</li>
<li><p>第三阶段：使用。通常我们通过@Autowired或者BeanFactory.getBean从IOC获得bean的实例，另外，设置了lazy-init属性，或者非单例bean的实例化，是在每一次获取bean对象的时候，调用bean的初始化方法完成实例化的，IOC不会管理这些bean</p>
<h2 id="bean注入的方式"><a href="#bean注入的方式" class="headerlink" title="bean注入的方式"></a>bean注入的方式</h2></li>
</ul>
<ol>
<li>xml方式，Spring容器启动时会加载并解析xml，把bean加载到IOC容器</li>
<li>@CompontScan注解扫描声明了@Controller、@Service、@Repository、@Component的类</li>
<li>@Configuration+@Bean</li>
<li>@Import导入配置类或者普通的bean</li>
<li>FactoryBean构造bean实例</li>
<li>ImportBeanDefinition-Registrar接口，可以动态注入bean，这个在Springboot启动类注解里用到了</li>
<li>ImportSelector接口，动态批量注入配置类、bean对象，在SpringBoot的自动装配机制里用到</li>
<li>@AutoWired @Qualifier @Resource @Inject<h2 id="Spring三级缓存解决循环依赖"><a href="#Spring三级缓存解决循环依赖" class="headerlink" title="Spring三级缓存解决循环依赖"></a>Spring三级缓存解决循环依赖</h2>Spring设计了三级缓存来解决循环依赖问题<br>第一级缓存里面存储完整的bean实例，这些实例是可以直接被使用的<br>第二级缓存里存储的是实例化以后，但是还没有设置属性值的bean实例，也就是依赖注入还没有做<br>第三季缓存是用来存放bean工厂，它主要用来生成原始bean对象，并放入二级缓存<br>三级缓存的核心思想就是把bean的实例化和bean里面的依赖注入进行分离，采用一级缓存储存完整的bean实例，采用二级缓存存储不完整的bean实例，通过不完整的bean实例作为突破口，解决循环依赖问题，至于第三级缓存，主要解决代理对象的循环依赖问题<h2 id="如何理解IoC和DI？"><a href="#如何理解IoC和DI？" class="headerlink" title="如何理解IoC和DI？"></a>如何理解IoC和DI？</h2><strong>IOC</strong><br>就是控制反转，通俗的说就是我们不用自己创建实例对象，这些都交给Spring的bean工厂帮我们创建管理。<br>这也是Spring的核心思想，通过面向接口编程的方式来是实现对业务组件的动态依赖。这就意味着IOC是Spring针对解决程序耦合而存在的。在实际应用中，Spring通过配置文件（xml或者properties）指定需要实例化的java类（类名的完整字符串），包括这些java类的一组初始化值，通过加载读取配置文件，用Spring提供的方法（getBean()）就可以获取到我们想要的根据指定配置进行初始化的实例对象。</li>
</ol>
<ul>
<li>优点：IOC或依赖注入减少了应用程序的代码量。它使得应用程序的测试很简单，因为在单元测试中不再需要单例或JNDI查找机制。简单的实现以及较少的干扰机制使得松耦合得以实现。IOC容器支持勤性单例及延迟加载服务。</li>
</ul>
<p><strong>DI：DI—Dependency</strong> Injection，即“依赖注入”：组件之间依赖关系由容器在运行期决定，形象的说，即由容器动态的将某个依赖关系注入到组件之中。依赖注入的目的并非为软件系统带来更多功能，而是为了提升组件重用的频率，并为系统搭建一个灵活、可扩展的平台。通过依赖注入机制，我们只需要通过简单的配置，而无需任何代码就可指定目标需要的资源，完成自身的业务逻辑，而不需要关心具体的资源来自何处，由谁实现。</p>
<h2 id="spring特征"><a href="#spring特征" class="headerlink" title="spring特征"></a>spring特征</h2><p>核⼼技术 ：依赖注⼊(DI)， AOP，事件(events)，资源， 验证，数据绑定，测试 ： Spring MVC 测试， 数据访问 ：事务， DAO⽀持， JDBC， ORM，XML。Web⽀持 : Spring MVC和Spring WebFlux Web框架。集成 ：远程处理， 电⼦邮件，任务，调度，缓存。</p>
<h2 id="列举⼀些重要的Spring模块？"><a href="#列举⼀些重要的Spring模块？" class="headerlink" title="列举⼀些重要的Spring模块？"></a>列举⼀些重要的Spring模块？</h2><p>Spring Core： 基础,可以说 Spring 其他所有的功能都需要依赖于该类库。主要提供 IoC 依赖注⼊功能。Spring Aspects ： 该模块为与AspectJ的集成提供⽀持。Spring AOP ：提供了⾯向切⾯的编程实现。Spring JDBC : Java数据库连接。Spring JMS ： Java消息服务。Spring ORM : ⽤于⽀持Hibernate等ORM⼯具。Spring Web : 为创建Web应⽤程序提供⽀持。Spring Test : 提供了对 JUnit 和 TestNG 测试的⽀持。 </p>
<h2 id="Spring-中的-bean-的作⽤域有哪些"><a href="#Spring-中的-bean-的作⽤域有哪些" class="headerlink" title="Spring 中的 bean 的作⽤域有哪些?"></a>Spring 中的 bean 的作⽤域有哪些?</h2><p>singleton : 唯⼀ bean 实例， Spring 中的 bean 默认都是单例的。prototype : 每次请求都会创建⼀个新的 bean 实例。request : 每⼀次HTTP请求都会产⽣⼀个新的bean，该bean仅在当前HTTP request内有效。session : 每⼀次HTTP请求都会产⽣⼀个新的 bean，该bean仅在当前 HTTP session 内有效。</p>
<h2 id="Spring-中的单例-bean-的线程安全问题了解吗（Threadlocal）？"><a href="#Spring-中的单例-bean-的线程安全问题了解吗（Threadlocal）？" class="headerlink" title="Spring 中的单例 bean 的线程安全问题了解吗（Threadlocal）？"></a>Spring 中的单例 bean 的线程安全问题了解吗（Threadlocal）？</h2><p>主要是因为当多个线程操作同⼀个对象的时候，对这个对象的⾮静态成员变量的写操作会存在线程安全问题。<strong>常⻅的有两种解决办法：</strong><br>在类中定义⼀个ThreadLocal成员变量，将⾮静态成员变量保存在 ThreadLocal 中（推荐的⼀种⽅式）。 作线程隔离</p>
<h2 id="Component-和-Bean-的区别是什么？"><a href="#Component-和-Bean-的区别是什么？" class="headerlink" title="@Component 和 @Bean 的区别是什么？"></a>@Component 和 @Bean 的区别是什么？</h2><p>@Component 注解作⽤于类，⽽ @Bean 注解作⽤于⽅法。<br>@Component 通常是通过类路径扫描⾃动装配到Spring容器中（ @ComponentScan 注解定义要扫描的路径)Spring 的 bean 容器中）<br>引⽤第三⽅库中的类需要装配到 Spring 容器时，则只能通过@Bean 来实现 </p>
<h2 id="自动注入"><a href="#自动注入" class="headerlink" title="自动注入"></a>自动注入</h2><p>resource 按name<br>autowired 按类型 +quirfy 按name</p>
<h2 id="将⼀个类声明为Spring的-bean-的注解有哪些"><a href="#将⼀个类声明为Spring的-bean-的注解有哪些" class="headerlink" title="将⼀个类声明为Spring的 bean 的注解有哪些?"></a>将⼀个类声明为Spring的 bean 的注解有哪些?</h2><p>我们一般使用 @Autowired 注解自动装配 bean，要想把类标识成可用于 @Autowired 注解自动装配的 bean 的类,采用以下注解可实现：</p>
<ul>
<li><p>@Component ：通用的注解，可标注任意类为 Spring 组件。如果一个Bean不知道属于哪个层，可以使用@Component 注解标注。 8 @Repository : 对应持久层即 Dao 层，主要用于数据库相关操作。</p>
</li>
<li><p>@Service : 对应服务层，主要涉及一些复杂的逻辑，需要用到 Dao层。</p>
</li>
<li><p>@Controller : 对应 Spring MVC 控制层，主要用户接受用户请求并调用 Service 层返回数据给前端页面。</p>
<h2 id="Spring-中的-bean-⽣命周期"><a href="#Spring-中的-bean-⽣命周期" class="headerlink" title="Spring 中的 bean ⽣命周期?"></a>Spring 中的 bean ⽣命周期?</h2><p>实例化—-设置属性–前置处理 -init–后置处理–destory方法<br><img src="https://raw.githubusercontent.com/viacheung/img/main/image/image-20230314112152047.png#from=url&id=yM32t&originHeight=365&originWidth=481&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br><img src="https://raw.githubusercontent.com/viacheung/img/main/image/image-20230314112157474.png#from=url&id=vnq71&originHeight=333&originWidth=656&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<h4 id="创建过程"><a href="#创建过程" class="headerlink" title="创建过程"></a>创建过程</h4></li>
<li><p>1、实例化 Instantiation</p>
<ul>
<li>对于BeanFactory容器，当客户向容器请求一个尚未初始化的bean时，或初始化bean的时候需要注入另一尚未初始化的依赖时，容器会调用createBean进行实例化。</li>
<li><font color="red">对于ApplicationContext容器，当容器启动结束后，通过获取BeanDefinition对象中的信息，实例化所有的bean。</font></li>
</ul>
</li>
<li><p>2、属性赋值（依赖注入）</p>
<ul>
<li>实例化后的对象被封装在BeanWrapper对象中，Spring根据BeanDefinition中的信息以及通过BeanWrapper提供的设置属性的接口完成属性设置与依赖注入。</li>
</ul>
</li>
<li><p>3、处理Aware接口：可以让我们拿到Spring容器的一些资源：</p>
<ul>
<li>Spring会检测该对象是否实现了xxxAware接口，通过Aware类型的接口，</li>
<li>① 如果这个Bean实现了BeanNameAware接口，会调用它实现的setBeanName（String beanid）方法，传入Bean的名字；</li>
<li>② 如果这个Bean实现了BeanClassLoaderAware接口，调用setBeanClassLoader（）方法，传入ClassLoader对象的实例。</li>
<li>③ 如果这个Bean实现了BeanFactoryAware接口，会调用它是实现的setBeanFactory（）方法，传递的是Spring工厂自身。</li>
<li>④ 如果这个Bean实现了ApplicationContextAware接口，会调用 setApplicationContext（ApplicationContext）方法，传入Spring上下文；</li>
</ul>
</li>
<li><p>初始化</p>
<ul>
<li>4、调用Aware接口相关的方法：invokeAwareMethod(完成beanName, beanClassLoader, beanFactory对象的属性设置)</li>
<li>5、调用beanPostProcessor中的前置处理方法postProcessBeforeInitializ（Object obj，String s）</li>
<li>6、判断是否实现了initializingBean接口，如果有，调用afterPropertiesSet方法，没有就不调用</li>
<li>6.调用InitMethod方法：invokeInitMethod()<ul>
<li>如果Bean在Spring配置文件中配置了init-method属性，则会自动调用其配置的初始化方法，调用了别的一些方法，也就是回调</li>
</ul>
</li>
<li>7、调用BeanPostProcessor后置处理方法 。postProcessAfterInitiazation（Object obj，String s）<ul>
<li>Spring 的Aop就是在此处实现的</li>
</ul>
</li>
</ul>
</li>
<li><p>销毁</p>
<ul>
<li>8、DisposableBean当Bean不再需要时，会经过清理阶段，如果Bean实现了DisposableBean这个接口，会调用其实现的destroy（）方法</li>
<li>9、destory-method如果这个Bean的Spring配置中配置了destroy-method属性，会自动调用其配置的销毁方法，也就是回调<h2 id="Spring-MVC-⼯作原理了解吗"><a href="#Spring-MVC-⼯作原理了解吗" class="headerlink" title="Spring MVC ⼯作原理了解吗?"></a>Spring MVC ⼯作原理了解吗?</h2>客户端–request—disoatcherservelt–Handler–HandlerAdapter—由处理器适配器处理业务 返回一个modelandview对象，model返回数据 view视图渲染 返回浏览器<br><img src="https://raw.githubusercontent.com/viacheung/img/main/image/image-20230314112406771.png#from=url&id=Hsicx&originHeight=348&originWidth=638&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br><img src="https://raw.githubusercontent.com/viacheung/img/main/image/image-20230314112250270.png#from=url&id=jbg5J&originHeight=350&originWidth=648&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br><img src="https://raw.githubusercontent.com/viacheung/img/main/image/image-20230317212450925.png#from=url&id=uzldk&originHeight=450&originWidth=986&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br><img src="https://raw.githubusercontent.com/viacheung/img/main/image/image-20230317212500883.png#from=url&id=D2cWx&originHeight=382&originWidth=941&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>HandlerMapping负责根据用户请求找到Handler即处理器，<br>SpringMVC基于Spring容器，所以在进行SpringMVC操作时，需要将Controller存储到Spring容器中<h3 id="简单介绍-Spring-MVC-的核心组件"><a href="#简单介绍-Spring-MVC-的核心组件" class="headerlink" title="简单介绍 Spring MVC 的核心组件"></a>简单介绍 Spring MVC 的核心组件</h3><table>
<thead>
<tr>
<th><strong>组件</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td>DispatcherServlet</td>
<td>Spring MVC 的核心组件，是请求的入口，负责协调各个组件工作</td>
</tr>
<tr>
<td>MultipartResolver</td>
<td>内容类型( Content-Type )为 multipart&#x2F;* 的请求的解析器，例如解析处理文件上传的请求，便于获取参数信息以及上传的文件</td>
</tr>
<tr>
<td>HandlerMapping</td>
<td>请求的处理器匹配器，负责为请求找到合适的 HandlerExecutionChain 处理器执行链，包含处理器（handler）和拦截器们（interceptors）</td>
</tr>
<tr>
<td>HandlerAdapter</td>
<td>处理器的适配器。因为处理器 handler 的类型是 Object 类型，需要有一个调用者来实现 handler 是怎么被执行。Spring 中的处理器的实现多变，比如用户处理器可以实现 Controller 接口、HttpRequestHandler 接口，也可以用 @RequestMapping 注解将方法作为一个处理器等，这就导致 Spring MVC 无法直接执行这个处理器。所以这里需要一个处理器适配器，由它去执行处理器</td>
</tr>
<tr>
<td>HandlerExceptionResolver</td>
<td>处理器异常解析器，将处理器（ handler ）执行时发生的异常，解析( 转换 )成对应的 ModelAndView 结果</td>
</tr>
<tr>
<td>RequestToViewNameTranslator</td>
<td>视图名称转换器，用于解析出请求的默认视图名</td>
</tr>
<tr>
<td>LocaleResolver</td>
<td>本地化（国际化）解析器，提供国际化支持</td>
</tr>
<tr>
<td>ThemeResolver</td>
<td>主题解析器，提供可设置应用整体样式风格的支持</td>
</tr>
<tr>
<td>ViewResolver</td>
<td>视图解析器，根据视图名和国际化，获得最终的视图 View 对象</td>
</tr>
<tr>
<td>FlashMapManager</td>
<td>FlashMap 管理器，负责重定向时，保存参数至临时存储（默认 Session）</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
</ul>
<p>Spring MVC 对各个组件的职责划分的比较清晰。DispatcherServlet 负责协调，其他组件则各自做分内之事，互不干扰。</p>
<h2 id="什么是-spring-的内部-bean？"><a href="#什么是-spring-的内部-bean？" class="headerlink" title="什么是 spring 的内部 bean？"></a>什么是 spring 的内部 bean？</h2><p>将 bean 用作另一个 bean 的属性时，才能将 bean 声明为内部 bean，假设我们有一个 Student 类，其中引用了 Person 类，就可以这样。</p>
<h2 id="什么是-spring-装配？"><a href="#什么是-spring-装配？" class="headerlink" title="什么是 spring 装配？"></a>什么是 spring 装配？</h2><p>当 bean 在 Spring 容器中组合在一起时，它被称为装配或 bean 装配。 Spring 容器需要知道需要什么 bean 以及容器应该如何使用依赖注入来将 bean 绑定在一起，同时装配 bean。<br>Spring 容器能够自动装配 bean。也就是说，可以通过检查 BeanFactory 的内容让 Spring 自动解析 bean 的协作者。<br>自动装配的不同模式：</p>
<ul>
<li><p><strong>no</strong> - 这是默认设置，表示没有自动装配。应使用显式 bean 引用进行装配。</p>
</li>
<li><p><strong>byName</strong> - 它根据 bean 的名称注入对象依赖项。它匹配并装配其属性与 XML 文件中由相同名称定义的 bean。</p>
</li>
<li><p><strong>byType</strong> - 它根据类型注入对象依赖项。如果属性的类型与 XML 文件中的一个 bean 名称匹配，则匹配并装配属性。</p>
</li>
<li><p><strong>构造函数</strong> - 它通过调用类的构造函数来注入依赖项。它有大量的参数。</p>
</li>
<li><p><strong>autodetect</strong> - 首先容器尝试通过构造函数使用 autowire 装配，如果不能，则尝试通过 byType 自动装配。</p>
<h2 id="自动装配有什么局限？"><a href="#自动装配有什么局限？" class="headerlink" title="自动装配有什么局限？"></a>自动装配有什么局限？</h2></li>
<li><p>覆盖的可能性 - 您始终可以使用 <constructor-arg> 和 <property> 设置指定依赖项，这将覆盖自动装配。</property></constructor-arg></p>
</li>
<li><p>基本元数据类型 - 简单属性（如原数据类型，字符串和类）无法自动装配。</p>
</li>
<li><p>令人困惑的性质 - 总是喜欢使用明确的装配，因为自动装配不太精确。</p>
<h2 id="Spring中出现同名bean怎么办？"><a href="#Spring中出现同名bean怎么办？" class="headerlink" title="Spring中出现同名bean怎么办？"></a>Spring中出现同名bean怎么办？</h2></li>
<li><p>同一个配置文件内同名的Bean，以最上面定义的为准</p>
</li>
<li><p>不同配置文件中存在同名Bean，后解析的配置文件会覆盖先解析的配置文件</p>
</li>
<li><p>同文件中ComponentScan和@Bean出现同名Bean。同文件下@Bean的会生效，@ComponentScan扫描进来不会生效。通过@ComponentScan扫描进来的优先级是最低的，原因就是它扫描进来的Bean定义是最先被注册的~</p>
<h2 id="Spring-怎么解决循环依赖问题？"><a href="#Spring-怎么解决循环依赖问题？" class="headerlink" title="Spring 怎么解决循环依赖问题？"></a>Spring 怎么解决循环依赖问题？</h2><p>spring对循环依赖的处理有三种情况：<br>①构造器的循环依赖：这种依赖spring是处理不了的，直 接抛出BeanCurrentlylnCreationException异常。<br>②单例模式下的setter循环依赖：通过“三级缓存”处理循环依赖。<br>③非单例循环依赖：无法处理。<br><strong>所以只针对2</strong><br><img src="https://raw.githubusercontent.com/viacheung/img/main/image/image-20230318003242035.png#from=url&id=UaCNT&originHeight=393&originWidth=574&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>spring对象实例三步<br>（1）createBeanInstance：实例化，其实也就是调用对象的构造方法实例化对象<br>（2）populateBean：填充属性，这一步主要是多bean的依赖属性进行填充<br>（3）initializeBean：调用spring xml中的init 方法。<br>三级缓存（对应上面进行哪一步了）<br><img src="https://raw.githubusercontent.com/viacheung/img/main/image/image-20230318003344460.png#from=url&id=djuJt&originHeight=187&originWidth=837&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>A的某个field或者setter依赖了B的实例对象，同时B的某个field或者setter依赖了A的实例对象”这种循环依赖的情况。</p>
</li>
</ul>
<ol>
<li>A首先完成了初始化的第一步（createBeanINstance实例化），并且将自己提前曝光到singletonFactories（三级缓存）中。</li>
<li>此时进行初始化的第二步，发现自己依赖对象B，此时就尝试去get(B)，发现B还没有被create，所以走create流程，B在初始化第一步的时候发现自己依赖了对象A，于是尝试get(A)，尝试一级缓存singletonObjects(肯定没有，因为A还没初始化完全)，尝试二级缓存earlySingletonObjects（也没有），尝试三级缓存singletonFactories，由于A通过ObjectFactory将自己提前曝光了，所以B能够通过ObjectFactory.getObject拿到A对象(虽然A还没有初始化完全，但是总比没有好呀)，B拿到A对象后顺利完成了初始化阶段1、2、3，完全初始化之后将自己放入到一级缓存singletonObjects中。</li>
<li>此时返回A中，A此时能拿到B的对象顺利完成自己的初始化阶段2、3，最终A也完成了初始化，进去了一级缓存singletonObjects中，而且更加幸运的是，由于B拿到了A的对象引用，所以B现在hold住的A对象完成了初始化。<h2 id="Spring-中的单例-bean-的线程安全问题？"><a href="#Spring-中的单例-bean-的线程安全问题？" class="headerlink" title="Spring 中的单例 bean 的线程安全问题？"></a>Spring 中的单例 bean 的线程安全问题？</h2>当多个用户同时请求一个服务时，容器会给每一个请求分配一个线程，这时多个线程会并发执行该请求对应的业务逻辑（成员方法），此时就要注意了，如果该处理逻辑中有对单例状态的修改（体现为该单例的成员属性），则必须考虑线程同步问题。 <strong>线程安全问题都是由全局变量及静态变量引起的。</strong> 若每个线程中对全局变量、静态变量只有读操作，而无写操作，一般来说，这个全局变量是线程安全的；若有多个线程同时执行写操作，一般都需要考虑线程同步，否则就可能影响线程安全.<br><strong>无状态bean和有状态bean</strong></li>
</ol>
<ul>
<li>有状态就是有数据存储功能。有状态对象(Stateful Bean)，就是有实例变量的对象，可以保存数据，是非线程安全的。在不同方法调用间不保留任何状态。</li>
<li>无状态就是一次操作，不能保存数据。无状态对象(Stateless Bean)，就是没有实例变量的对象 .不能保存数据，是不变类，是线程安全的。</li>
</ul>
<p>在spring中无状态的Bean适合用不变模式，就是单例模式，这样可以共享实例提高性能。有状态的Bean在多线程环境下不安全，适合用Prototype原型模式。 Spring使用ThreadLocal解决线程安全问题。如果你的Bean有多种状态的话（比如 View Model 对象），就需要自行保证线程安全 。</p>
<h2 id="Spring-框架中⽤到了哪些设计模式？"><a href="#Spring-框架中⽤到了哪些设计模式？" class="headerlink" title="Spring 框架中⽤到了哪些设计模式？"></a>Spring 框架中⽤到了哪些设计模式？</h2><p>⼯⼚设计模式 : Spring使⽤⼯⼚模式通过 <strong>BeanFactory</strong> 、 <strong>ApplicationContext</strong>(应用上下文) 创建 bean 对象。代理设计模式 : Spring AOP 功能（动态代理）的实现。单例设计模式 : Spring 中的 Bean 默认都是单例的。包装器设计模式 : 我们的项⽬需要连接多个数据库，⽽且不同的客户在每次访问中根据需要会去访问不同的数据库。这种模式让我们可以根据客户的需求能够动态切换不同的数据源。观察者模式: Spring 事件驱动模型就是观察者模式很经典的⼀个应⽤。(消息队列的发布订阅)适配器模式 :Spring AOP 的增强或通知(Advice)使⽤到了适配器模式、 spring MVC 中也是⽤到了适配器模式适配 Controller 。 </p>
<h2 id="Spring-事务"><a href="#Spring-事务" class="headerlink" title="Spring 事务"></a>Spring 事务</h2><p>PlatformTransactionManager ：是 spring 的事务管理器，它里面提供了我们常用的操作事务的方法 getTransaction commit rollback</p>
<h3 id="Spring-管理事务的⽅式有⼏种？"><a href="#Spring-管理事务的⽅式有⼏种？" class="headerlink" title="Spring 管理事务的⽅式有⼏种？"></a>Spring 管理事务的⽅式有⼏种？</h3><p>编程式事务，在代码中硬编码。 (不推荐使⽤)声明式事务，在配置⽂件中配置（推荐使⽤） （分为基于xml 和基于注解）<br>声明式作用：事务管理不侵入开发的组件 事务管理是属于系统层面的服务，而不是业务逻辑的一部分 在不需要事务管理的时候，只要在设定文件上修改一下，即可移去事务管理服务，无需改变代码重新编译，这样维护起来极其方便<br>注意： <strong>Spring 声明式事务控制底层就是AOP。</strong><br>基于xml<br> 平台事务管理器配置 事务通知的配置 事务aop织入的配置<br><strong>基于注解</strong><br><img src="https://raw.githubusercontent.com/viacheung/img/main/image/image-20230317221224522.png#from=url&id=C277n&originHeight=219&originWidth=1091&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br> 平台事务管理器配置（xml方式） 事务通知的配置（@Transactional注解配置） 事务注解驱动的配置 tx:annotation-driven&#x2F;</p>
<h3 id="Spring-事务中的隔离级别有哪⼏种"><a href="#Spring-事务中的隔离级别有哪⼏种" class="headerlink" title="Spring 事务中的隔离级别有哪⼏种?"></a>Spring 事务中的隔离级别有哪⼏种?</h3><p>1、使⽤后端数据库默认的隔离级别<br>2、读未提交<br>3、读已提交<br>4、可重复读<br>5、串行化（将严重影响程序的性能 ）</p>
<h3 id="Spring框架的事务管理有哪些优点？"><a href="#Spring框架的事务管理有哪些优点？" class="headerlink" title="Spring框架的事务管理有哪些优点？"></a>Spring框架的事务管理有哪些优点？</h3><ul>
<li><p>它提供了跨不同事务api（如JTA、JDBC、Hibernate、JPA和JDO）的一致编程模型。</p>
</li>
<li><p>它为编程事务管理提供了比JTA等许多复杂事务API更简单的API。</p>
</li>
<li><p>它支持声明式事务管理。</p>
</li>
<li><p>它很好地集成了Spring的各种数据访问抽象。</p>
<h3 id="Spring-事务中哪⼏种事务传播⾏为"><a href="#Spring-事务中哪⼏种事务传播⾏为" class="headerlink" title="Spring 事务中哪⼏种事务传播⾏为?"></a>Spring 事务中哪⼏种事务传播⾏为?</h3><p><img src="https://raw.githubusercontent.com/viacheung/img/main/image/image-20230317220702593.png#from=url&id=Zx7zR&originHeight=450&originWidth=1308&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br><strong>⽀持当前事务的情况 ：</strong><br>如果当前存在事务 加入该事务，否则（1、创建⼀个新的事务 2、以⾮事务的⽅式继续运⾏ 3、抛出异常）<br><strong>不⽀持当前事务 ：</strong><br>把当前事务挂起 然后：<br>1、创建⼀个新的事务 2、以⾮事务的⽅式继续运⾏ 3、抛出异常</p>
<h3 id="Spring-事务传播行为"><a href="#Spring-事务传播行为" class="headerlink" title="Spring 事务传播行为"></a>Spring 事务传播行为</h3></li>
<li><p>1.TransactionDefinition.PROPAGATION_REQUIRED如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。</p>
</li>
<li><p>2.TransactionDefinition.PROPAGATION_REQUIRES_NEW创建一个新的事务，如果当前存在事务，则把当前事务挂起。</p>
</li>
<li><p>3.TransactionDefinition.PROPAGATION_NESTED如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于默认的</p>
</li>
<li><p>4.TransactionDefinition.PROPAGATION_MANDATORY如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。</p>
</li>
<li><p>5 TransactionDefinition.PROPAGATION_SUPPORTS: 如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。</p>
</li>
<li><p>6 TransactionDefinition.PROPAGATION_NOT_SUPPORTED: 以非事务方式运行，如果当前存在事务，则把当前事务挂起。</p>
</li>
<li><p>7 TransactionDefinition.PROPAGATION_NEVER: 以非事务方式运行，如果当前存在事务，则抛出异常。</p>
<h3 id="spring事务不生效的场景"><a href="#spring事务不生效的场景" class="headerlink" title="spring事务不生效的场景"></a>spring事务不生效的场景</h3><p><img src="https://cdn.nlark.com/yuque/0/2023/webp/226907/1684915047847-3921a115-8de1-4131-acbb-975573911a50.webp#averageHue=%23fefdfd&clientId=u6ebde6c7-a18a-4&from=paste&id=ud2a448b0&originHeight=1015&originWidth=1512&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ucd44e6fd-f8f6-40f5-afeb-026d5bd567f&title="></p>
<h4 id="1、spring框架配置"><a href="#1、spring框架配置" class="headerlink" title="1、spring框架配置"></a>1、spring框架配置</h4><h5 id="你的service类没有被Spring管理"><a href="#你的service类没有被Spring管理" class="headerlink" title="你的service类没有被Spring管理"></a>你<strong>的service类没有被Spring管理</strong></h5><p>@Service注解注释之后，spring事务（@Transactional）没有生效，因为Spring事务是由AOP机制实现的，也就是说从Spring IOC容器获取bean时，Spring会为目标类创建代理，来支持事务的。但是@Service被注释后，你的service类都不是spring管理的，<strong>那怎么创建代理类来支持事务呢</strong>。</p>
<h4 id="2、AOP代理"><a href="#2、AOP代理" class="headerlink" title="2、AOP代理"></a>2、AOP代理</h4><h5 id="事务方法被final、static关键字修饰"><a href="#事务方法被final、static关键字修饰" class="headerlink" title="事务方法被final、static关键字修饰"></a><strong>事务方法被final、static关键字修饰</strong></h5><p>如果一个方法被声明为final或者static，则该方法不能被子类重写，也就是说无法在该方法上进行动态代理，这会导致Spring无法生成事务代理对象来管理事务。</p>
<h5 id="同一个类中，方法内部调用"><a href="#同一个类中，方法内部调用" class="headerlink" title="同一个类中，方法内部调用"></a>同一个类中，方法内部调用</h5><p><strong>事务不生效的原因</strong>: 事务是通过Spring AOP代理来实现的，而在同一个类中，一个方法调用另一个方法时，<strong>调用方法直接调用目标方法的代码，而不是通过代理类进行调用</strong>。即以上代码，调用目标executeAddTianLuo方法不是通过代理类进行的，因此事务不生效。</p>
<h5 id="方法的访问权限不是public"><a href="#方法的访问权限不是public" class="headerlink" title="方法的访问权限不是public"></a>方法的访问权限不是public</h5><p>spring事务方法addTianLuo的访问权限不是public，所以事务就不生效啦，因为Spring事务是由AOP机制实现的，AOP机制的本质就是动态代理，而代理的事务方法不是public的话，computeTransactionAttribute()就会返回null，也就是这时事务属性不存在了。</p>
<h4 id="3、-数据库的存储引擎不支持事务"><a href="#3、-数据库的存储引擎不支持事务" class="headerlink" title="3、 数据库的存储引擎不支持事务"></a>3、 数据库的存储引擎不支持事务</h4><p>Spring事务的底层，还是依赖于数据库本身的事务支持。在MySQL中，MyISAM存储引擎是不支持事务的，InnoDB引擎才支持事务。因此开发阶段设计表的时候，<strong>确认你的选择的存储引擎是支持事务的</strong>。</p>
<h4 id="4、Transational配置问题"><a href="#4、Transational配置问题" class="headerlink" title="4、Transational配置问题"></a>4、Transational配置问题</h4><h5 id="4-1-事务超时时间设置过短"><a href="#4-1-事务超时时间设置过短" class="headerlink" title="4.1 事务超时时间设置过短"></a>4.1 事务超时时间设置过短</h5><pre><code>@Transactional(timeout = 1)
public void doSomething() &#123;
  //...
&#125;
复制代码
</code></pre>
</li>
<li><p><strong>事务不生效的原因</strong>：在上面的例子中，timeout属性被设置为1秒，这意味着如果事务在1秒内无法完成，则报事务超时了。</p>
<h5 id="4-2-使用了错误的事务传播机制"><a href="#4-2-使用了错误的事务传播机制" class="headerlink" title="4.2 使用了错误的事务传播机制"></a>4.2 使用了错误的事务传播机制</h5><p>&#96;&#96;&#96;<br>@Service<br>public class TianLuoServiceImpl {</p>
<p>  @Autowired<br>  private TianLuoMapper tianLuoMapper;<br>  @Autowired<br>  private TianLuoFlowMapper tianLuoFlowMapper;</p>
<p>  @Transactional(propagation &#x3D; Propagation.NOT_SUPPORTED)<br>  public  void doInsertTianluo(TianLuo tianluo) throws Exception {<br>  tianLuoMapper.save(tianluo);<br>  tianLuoFlowMapper.saveFlow(buildFlowByTianLuo(tianluo));<br>  }</p>
</li>
</ul>
<p>}<br>复制代码</p>
<pre><code>
- **事务不生效的原因**：Propagation.NOT_SUPPORTED传播特性不支持事务。
- **解决方案**：选择正确的事务传播机制。
#### 5 事务多线程调用
**事务失效原因**：这是因为Spring事务是基于线程绑定的，**每个线程都有自己的事务上下文**，而多线程环境下可能会存在多个线程共享同一个事务上下文的情况，导致事务失效。Spring事务管理器通过使用线程本地变量（ThreadLocal）来实现线程安全。大家有兴趣的话，可以去看下源码哈.
在Spring事务管理器中，通过TransactionSynchronizationManager类来管理事务上下文。TransactionSynchronizationManager内部维护了一个ThreadLocal对象，用来存储当前线程的事务上下文。在事务开始时，TransactionSynchronizationManager会将事务上下文绑定到当前线程的ThreadLocal对象中，当事务结束时，TransactionSynchronizationManager会将事务上下文从ThreadLocal对象中移除。
### @Controller 注解有什么用？
标记一个类为 Spring Web MVC **控制器** Controller，springmvc扫描到有该注解的类，然后这个类有@RequestMapping注解的方法，为这个方法生成一个处理器对象
### @RequestMapping 注解有什么用？
将请求和方法进行映射，可以作用于类也可以作用于方法，作用于类的话一般就是控制器URI前缀、
### @RestController 和 @Controller 有什么区别？
@RestController =@Controller + @ResponseBody ，更加适合目前前后端分离的架构下，提供 Restful API ，返回例如 JSON 数据格式。
当然，返回什么样的数据格式，根据客户端的 ACCEPT 请求头来决定。
### @RequestMapping 和 @GetMapping 注解的不同之处在哪里？

1. @RequestMapping：可注解在类和方法上；@GetMapping 仅可注册在方法上
2. @RequestMapping： GET、POST、PUT、DELETE 等请求方法都可以用@GetMapping 是 @RequestMapping 的 GET 请求方法的特例，目的是为了提高区分度。
### @RequestParam 和 @PathVariable 两个注解的区别
两个注解都用于方法参数，获取参数值的方式不同，@RequestParam 注解的参数从请求携带的参数中获取（请求头），而 @PathVariable 注解从请求的 URI 中（？后面的参数）
参数绑定注解@requestParam 
![](https://raw.githubusercontent.com/viacheung/img/main/image/image-20230317213825953.png#from=url&amp;id=Ok0Tb&amp;originHeight=108&amp;originWidth=914&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=)
### @RestController vs @Controller 
@Controller 返回⼀个⻚⾯ 
只返回视图 属于⽐较传统的Spring MVC 的应⽤，对应于前后端不分离的情况 
@RestController 返回JSON 或 XML 形式数据 
只返回对象，以 JSON 或 XML 形式写⼊ Response中，（前后端分离）。 
@Controller +@ResponseBody =@RestController 
**@ResponseBody ** ：Controller 的⽅法返回的对象通过适当的转换器转换为指定的格式（json xml）之后，写⼊到HTTP 响应(Response)对象的 body 中， 
### restful
 GET：用于获取资源 POST：用于新建资源 PUT：用于更新资源 DELETE：用于删除资源 
### 返回 JSON 格式使用什么注解？
**@ResponseBody** 注解，or **@RestController**(ResponseBody+Controller)
### @Transactional(rollbackFor = Exception.class)注解了解吗？ 
当 @Transactional 注解作⽤于类上时，该类的所有 public ⽅法将都具有该类型的事务属性，如果类或者⽅法加了这个注解，那么这个类⾥⾯的⽅法抛出异常，就会回滚，数据库⾥⾯的数据也会回滚。
如果不配置 rollbackFor 属性,那么事物只会在遇到 RuntimeException 的时候才会回滚,加上 rollbackFor=Exception.class ,可以让事物在遇到⾮运⾏时异常时也回滚。
### 注解开发
替代xml里面的配置 xml里面一个个都是容器 然后注入就是拿容器返回的值（getBean）
![](https://raw.githubusercontent.com/viacheung/img/main/image/image-20230317211552909.png#from=url&amp;id=u4zg0&amp;originHeight=765&amp;originWidth=1229&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=)
![](https://raw.githubusercontent.com/viacheung/img/main/image/image-20230317211721760.png#from=url&amp;id=P7HOr&amp;originHeight=718&amp;originWidth=1450&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=)
获取容器 ------也就是获取上下文
</code></pre>
<p>ApplicationContext ac &#x3D; new ClassPathXmlApplicationContext(“bean.xml”);<br>IAccountService as &#x3D; ac.getBean(“accountService”,IAccountService.class);</p>
<pre><code>## 什么是springmvc拦截器以及如何使用它？
Spring的处理程序映射机制包括处理程序拦截器，当你希望将特定功能应用于某些请求时，例如，检查用户主题时，这些拦截器非常有用。拦截器必须实现org.springframework.web.servlet包的HandlerInterceptor。此接口定义了三种方法：

- preHandle：在执行实际处理程序之前调用。
- postHandle：在执行完实际程序之后调用。
- afterCompletion：在完成请求后调用。
## Spring MVC 和 Struts2 的异同？
**入口**不同

- Spring MVC 的入门是一个 Servlet **控制器**。
- Struts2 入门是一个 Filter **过滤器**。

**配置映射**不同，

- Spring MVC 是基于**方法**开发，传递参数是通过**方法形参**，一般设置为**单例**。
- Struts2 是基于**类**开发，传递参数是通过**类的属性**，只能设计为**多例**。

**视图**不同

- Spring MVC 通过参数解析器是将 Request 对象内容进行解析成方法形参，将响应数据和页面封装成 **ModelAndView** 对象，最后又将模型数据通过 **Request** 对象传输到页面。其中，如果视图使用 JSP 时，默认使用 **JSTL** 。
- Struts2 采用**值栈**存储请求和响应的数据，通过 **OGNL** 存取数据。
## REST
### [REST 代表着什么?](https://www.javalearn.cn/#/doc/Spring/%E9%9D%A2%E8%AF%95%E9%A2%98?id=_35-rest-%E4%BB%A3%E8%A1%A8%E7%9D%80%E4%BB%80%E4%B9%88)
REST 代表着抽象状态转移，它是根据 HTTP 协议从客户端发送数据到服务端，例如：服务端的一本书可以以 XML 或 JSON 格式传递到客户端
## [什么是安全的 REST 操作?](https://www.javalearn.cn/#/doc/Spring/%E9%9D%A2%E8%AF%95%E9%A2%98?id=_36-%E4%BB%80%E4%B9%88%E6%98%AF%E5%AE%89%E5%85%A8%E7%9A%84-rest-%E6%93%8D%E4%BD%9C)
REST 接口是通过 HTTP 方法完成操作

- GET 和 HEAD 安全，因为它不能在服务端修改资源
- PUT、POST 和 DELETE 是不安全的，因为他们能修改服务端的资源

所以，是否安全的界限，在于**是否修改**服务端的资源
### [REST API 是无状态的吗?](https://www.javalearn.cn/#/doc/Spring/%E9%9D%A2%E8%AF%95%E9%A2%98?id=_37-rest-api-%E6%98%AF%E6%97%A0%E7%8A%B6%E6%80%81%E7%9A%84%E5%90%97)
**是的**，REST API 应该是无状态的，因为它是基于 HTTP 的，它也是无状态的
REST API 中的请求应该包含处理它所需的所有细节。它**不应该**依赖于以前或下一个请求或服务器端维护的一些数据，例如会话
**REST 规范为使其无状态设置了一个约束，在设计 REST API 时，你应该记住这一点**
### [REST安全吗? 你能做什么来保护它?](https://www.javalearn.cn/#/doc/Spring/%E9%9D%A2%E8%AF%95%E9%A2%98?id=_38-rest%E5%AE%89%E5%85%A8%E5%90%97-%E4%BD%A0%E8%83%BD%E5%81%9A%E4%BB%80%E4%B9%88%E6%9D%A5%E4%BF%9D%E6%8A%A4%E5%AE%83)
安全是一个宽泛的术语。它可能意味着消息的安全性，这是通过认证和授权提供的加密或访问限制提供的
REST 通常不是安全的，需要开发人员自己实现安全机制
## 补充
### spring中出现异步调用的方式？
1、注解（我项目里面用的）
配置类上加上@EnableAsync启动异步调用，使用了@Async标记的异步方法，可以带参可以带返回值
返回值必须以下类型：
![](https://raw.githubusercontent.com/viacheung/img/main/image/image-20230410171205483.png#from=url&amp;id=oEt7J&amp;originHeight=253&amp;originWidth=528&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=)
2、内置线程池
![](https://raw.githubusercontent.com/viacheung/img/main/image/image-20230410171626618.png#from=url&amp;id=xpDjr&amp;originHeight=344&amp;originWidth=680&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=)
3、自定义线程池
</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/5/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/7/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="ViaCheung"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">ViaCheung</p>
  <div class="site-description" itemprop="description">el psy congroo</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">32</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/viacheung" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;viacheung" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:viacheung5@gmail.com" title="E-Mail → mailto:viacheung5@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/zh-CN" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ViaCheung</span>
</div>

<!--
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div> -->

<!-- 网站运行时间的设置 -->
<span id="timeDate">载入天数...</span>
<span id="times">载入时分秒...</span>
<script>
    var now = new Date();
    function createtime() {
        var grt= new Date("03/01/2023 10:00:00"); //此处修改你的建站时间或者网站上线时间
        now.setTime(now.getTime()+250);
        days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days);
        hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours);
        if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);
        mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;}
        seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
        snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;}
        document.getElementById("timeDate").innerHTML = "本站已安全运行 "+dnum+" 天 ";
        document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒.";
    }
setInterval("createtime()",250);
</script>
        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>

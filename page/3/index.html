<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.1.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"viacheung.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="el psy congroo">
<meta property="og:type" content="website">
<meta property="og:title" content="命运石之门">
<meta property="og:url" content="http://viacheung.github.io/page/3/index.html">
<meta property="og:site_name" content="命运石之门">
<meta property="og:description" content="el psy congroo">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="ViaCheung">
<meta property="article:tag" content="Java,python">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://viacheung.github.io/page/3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>命运石之门</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">命运石之门</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">欢迎来到我的博客空间🙇</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-schedule">

    <a href="/schedule/" rel="section"><i class="fa fa-calendar fa-fw"></i>日程表</a>

  </li>
        <li class="menu-item menu-item-sitemap">

    <a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>站点地图</a>

  </li>
        <li class="menu-item menu-item-commonweal">

    <a href="/404/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>公益 404</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/viacheung" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://viacheung.github.io/2023/06/04/%E5%AD%97%E7%AC%A6%E4%B8%B2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="ViaCheung">
      <meta itemprop="description" content="el psy congroo">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="命运石之门">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/06/04/%E5%AD%97%E7%AC%A6%E4%B8%B2/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
	  <span class="post-time">

	  
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-06-04 01:02:24" itemprop="dateCreated datePublished" datetime="2023-06-04T01:02:24+08:00">2023-06-04</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><p>利于记忆<br><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903845227659271">https://juejin.cn/post/6844903845227659271</a><br>可视化<br><a target="_blank" rel="noopener" href="https://regexper.com/">https://regexper.com/</a><br>String是直接+</p>
<pre><code>1、return s.substring(n, s.length()) + s.substring(0, n);
 2、
 String res = &quot;&quot;;
 res += s.charAt(i % s.length())
</code></pre>
<p>StringBulider是append</p>
<pre><code>StringBuilder res = new StringBuilder();
 res.append(s.charAt(i % s.length()));
 return res.toString();
</code></pre>
<p>append和+的区别：<br><strong>append</strong>:StringBuilder是可变对象，每轮遍历拼接字符时，只是向列表尾部添加一个新的字符元素。最终拼接转化为字符串时，系统 <strong>仅申请一次内存</strong> 。(√)<br>**+**：字符串是 “不可变对象” 。因此，每轮遍历拼接字符时，都需要新建一个字符串；因此，系统 <strong>需申请 N 次内存</strong> ，数据量较大时效率低下。<br><strong>int和字符串互转</strong></p>
<pre><code>//int-&gt;String
 String s=Integer.toString(n)
 String s=String.valueOf(n); 
 //String-&gt; int
 int n=Integer.parseInt(s);
</code></pre>
<p><strong>字符串和字符数组转化</strong></p>
<pre><code>//char[]-&gt;String
 String s=String.valueOf(chars)
 //String-&gt;char[]
 char[] chars=s.toCharArray();
</code></pre>
<h2 id="重复的子字符串"><a href="#重复的子字符串" class="headerlink" title="重复的子字符串"></a>重复的子字符串</h2><p>给定一个非空的字符串 s ，检查是否可以通过由它的一个子串重复多次构成。<br><strong>方法一：枚举</strong></p>
<pre><code>class Solution &#123;
     public boolean repeatedSubstringPattern(String s) &#123;
         // return (s+s).indexOf(s,1) != s.length();
         // 如果一个长度为 n 的字符串 s 可以由它的一个长度为 n′ 的子串 s′ 重复多次构成
         // n&#39;范围 1到n/2     且n′必须要被n整除
         int n=s.length();
         for(int i=1;i&lt;=n/2;i++)&#123;
             if(n%i==0)&#123;
                 boolean ans=true;
                 for(int j=i;j&lt;n;j++)&#123;
                     if(s.charAt(j)!=s.charAt(j-i))&#123;
                         ans=false;
                         break;
                     &#125;
                 &#125;
                 if(ans) return ans;
             &#125;
         &#125;
         return false;
     &#125;
 &#125;
</code></pre>
<p><strong>方法二：字符串匹配</strong>（这个）<br><img src="https://raw.githubusercontent.com/viacheung/img/main/image/image-20221023224136692.png#from=url&id=DJr2o&originHeight=477&originWidth=876&originalType=binary&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&title="></p>
<pre><code>class Solution &#123;
     public boolean repeatedSubstringPattern(String s) &#123;
      // (s + s).indexOf(s, 1) : 返回从 1 位置开始查找指定字符s在字符串s+s中第一次出现处的索引，如果此字符串中没有这样的字符，则返回 -1。
         return (s + s).indexOf(s, 1) != s.length();
     &#125;
 &#125;
</code></pre>
<p><strong>方法三 ： KMP</strong></p>
<h2 id="28-实现-strStr"><a href="#28-实现-strStr" class="headerlink" title="28. 实现 strStr()"></a>28. 实现 strStr()</h2><p>给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串的第一个匹配项的下标（下标从 0 开始）。如果 needle 不是 haystack 的一部分，则返回 -1<br><strong>暴力</strong></p>
<pre><code>class Solution &#123;
     public int strStr(String haystack, String needle) &#123;
         // haystack 原串    needle匹配串
         int h=haystack.length();
         int n=needle.length();
         for(int i=0;i&lt;=h-n;i++)&#123;
             //a从0  b从i
             int a=0,b=i;
             while(a&lt;n &amp;&amp; haystack.charAt(b)==needle.charAt(a))&#123;
                 a++;
                 b++;
             &#125;
             //说明匹配到了
             if(a==n) return i;
         &#125;
         return -1;
     &#125;
 &#125;
</code></pre>
<h3 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h3><p>图和代码略有不符 理解即可<br><img src="https://raw.githubusercontent.com/viacheung/img/main/image/image-20221023164358460.png#from=url&id=mP4ap&originHeight=610&originWidth=827&originalType=binary&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&title="><br><img src="https://raw.githubusercontent.com/viacheung/img/main/image/image-20221025171752387.png#from=url&id=PnJwi&originHeight=255&originWidth=643&originalType=binary&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&title="><br>我的理解：<br>next数组可以理解为最长相等前缀所处的位置，j所指向的位置也可以理解为最长相等前缀所处的位置<br>构建：首先i j所指位置如果相等， next[i] &#x3D; j，二者都向后移动，如果不相等，回退，找相等的时候再赋值，如果一直不相等，next[i] &#x3D; 0;然后i继续往后移动<br>匹配：和构建过程一样，不同的是1、对原串进行迭代 2、每次循环后判断j是否等于匹配串长度</p>
<pre><code>class Solution &#123;
     public int strStr(String haystack, String needle) &#123;
         // KMP算法：如果已经匹配的字符串包含相同的前缀和后缀，遇到下一个不匹配的位置时，指向needle的指针跳转到前缀的后一个位置，还是不匹配的话，再往前跳转后继续比较；先构造一个next数组来记录needle指针跳转的位置
         int n=haystack.length(), m=needle.length();
         if(m==0) return 0;
         // 先构造next数组，next数组中的元素表示当前两个元素不匹配时，needle指针要跳转的位置
         // haystack: [a, b, e, a, b, a, b, e, a, b, f]
         // needle:   [a, b, e, a, b, f]
         // next:     [0, 0, 0, 1, 2, 0]
         我的理解 Next的意思就是如果下一个位置不匹配的话 我可以靠到位置几再进行匹配
          int[] next = new int[m];
         for(int i=1,j=0; i&lt;m; i++)&#123;
               // 匹配不成功的话，j = next(j-1)
             while(j&gt;0 &amp;&amp; needle.charAt(i)!=needle.charAt(j)) j = next[j-1]; 
            // 一直和前一位置的值比较，直到遇到相等的字符或者j=0；j通过next[j-1]来回退
             // 匹配成功的话，先让 j++
             if(needle.charAt(i)==needle.charAt(j)) j++;
             // 更新 next[i]，结束本次循环，i++
             next[i] = j;//因为i最后再移动，所以最后再更新
         &#125;
         // 利用next数组进行跳转匹配，不再需要回退haystack的指针i
         for(int i=0,j=0; i&lt;n; i++)&#123;
             // 匹配不成功，needle指针j回退并继续比较
             while(j&gt;0 &amp;&amp; haystack.charAt(i)!=needle.charAt(j)) j = next[j-1];  
             if(haystack.charAt(i)==needle.charAt(j)) j++;
             //匹配成功的话，先让 j++，结束本次循环后 i++
             // 整一段匹配成功，直接返回下标
             if(j==m) return i - m + 1;
         &#125;
         return -1;
     &#125;
 &#125;
</code></pre>
<h2 id="左旋转字符串"><a href="#左旋转字符串" class="headerlink" title="左旋转字符串"></a>左旋转字符串</h2><p>字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串”abcdefg”和数字2，该函数将返回左旋转两位得到的结果”cdefgab”<br><strong>方法一：字符串切片</strong><br> return s.substring(n, s.length()) + s.substring(0, n);<br><strong>方法二：列表遍历拼接</strong>（若面试规定不允许使用 <strong>切片函数</strong> ，则使用此方法）</p>
<pre><code>class Solution &#123;
     public String reverseLeftWords(String s, int n) &#123;
         StringBuilder res = new StringBuilder();
         for(int i = n; i &lt; n + s.length(); i++)
             res.append(s.charAt(i % s.length()));
         return res.toString();
     &#125;
 &#125;//利用求余运算，可以简化代码
</code></pre>
<p><strong>方法三：字符串遍历拼接</strong>(不用StringBulider)</p>
<pre><code>class Solution &#123;
     public String reverseLeftWords(String s, int n) &#123;
         String res = &quot;&quot;;
         for(int i = n; i &lt; s.length(); i++)
             res += s.charAt(i);
         for(int i = 0; i &lt; n; i++)
             res += s.charAt(i);
         return res;
     &#125;
 &#125;
</code></pre>
<h2 id="翻转字符串里的单词"><a href="#翻转字符串里的单词" class="headerlink" title="翻转字符串里的单词"></a>翻转字符串里的单词</h2><p>split+reverse+join<br><img src="https://raw.githubusercontent.com/viacheung/img/main/image/image-20221019213126600.png#from=url&id=Uxazr&originalType=binary&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&title=">、</p>
<pre><code>class Solution &#123;
     public String reverseWords(String s) &#123;
         // 除去开头和末尾的空白字符
         s = s.trim();
         // 正则匹配连续的空白字符作为分隔符分割
         List&lt;String&gt; wordList = Arrays.asList(s.split(&quot;\\s+&quot;));
         Collections.reverse(wordList);
         return String.join(&quot; &quot;, wordList);//用啥连接这些
     &#125;
 &#125;
</code></pre>
<p><img src="https://raw.githubusercontent.com/viacheung/img/main/image/image-20221019214203980.png#from=url&id=m2arV&originalType=binary&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&title="></p>
<h2 id="替换空格"><a href="#替换空格" class="headerlink" title="替换空格"></a>替换空格</h2><pre><code>return s.replace(&quot; &quot;, &quot;%20&quot;);//第一种，直接api
</code></pre>
<pre><code>//第二种 循环
 class Solution &#123;
     public String replaceSpace(String s) &#123;
         StringBuilder sb=new StringBuilder();
         for(char c:s.toCharArray())&#123;
             if(c==&#39; &#39;)&#123;
                 sb.append(&quot;%20&quot;);
             &#125;else&#123;
                 sb.append(c);
             &#125;
         &#125;
         return sb.toString();
     &#125;
 &#125;
</code></pre>
<h2 id="反转字符串"><a href="#反转字符串" class="headerlink" title="反转字符串"></a>反转字符串</h2><p>双指针：</p>
<pre><code>class Solution &#123;
     public void reverseString(char[] s) &#123;
         int l=0,r=s.length-1;
         while(l&lt;r)&#123;
             char temp=s[l];
             s[l]=s[r];
             s[r]=temp;
             l++;
             r--;
         &#125;
     &#125;
 &#125;
</code></pre>
<h2 id="反转字符串II"><a href="#反转字符串II" class="headerlink" title="反转字符串II"></a>反转字符串II</h2><p>给定一个字符串 s 和一个整数 k，从字符串开头算起，每计数至 2k 个字符，就反转这 2k 字符中的前 k 个字符。<br>如果剩余字符少于 k 个，则将剩余字符全部反转。如果剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符，其余字符保持原样。</p>
<pre><code>class Solution &#123;
     public String reverseStr(String s, int k) &#123;
         char[] str=s.toCharArray();
         for(int i=0;i&lt;s.length();i+=2*k)&#123;
             //少于k的情况考虑了
             reverse(str,i,Math.min(s.length()-1,i+k-1));
         &#125;
         return new String(str);
     &#125;
     public void reverse(char[] str,int l,int r)&#123;
         while(l&lt;r)&#123;
             char temp=str[l];
             str[l]=str[r];
             str[r]=temp;
             l++;
             r--;
         &#125;
     &#125;
 &#125;
</code></pre>
<h2 id="回文子串"><a href="#回文子串" class="headerlink" title="回文子串"></a>回文子串</h2><p>给你一个字符串 s ，请你统计并返回这个字符串中 回文子串 的数目。回文字符串 是正着读和倒过来读一样的字符串。子字符串 是字符串中的由连续字符组成的一个序列。具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。<br>中心拓展：<br>对于位置i,回文中心有i和(i,i+1),但最后一个元素只有i，否则越界 因此2n-1</p>
<pre><code>我对于2n-1的理解  对于位置i,回文中心有i和(i,i+1)，但是最后一个只有i没有(i,i+1),i+1越界了
     所以是2n-1个回文中心
 class Solution &#123;
     public int countSubstrings(String s) &#123;
         int n = s.length();
         int count = 0;
         for(int i = 0; i&lt; 2*n-1; i++)&#123;
             int l = i / 2,r = i / 2 + i % 2;//    + i % 2是为了奇偶校验
             while(l &gt;= 0 &amp;&amp; r &lt; n &amp;&amp; s.charAt(l) == s.charAt(r))&#123;
                 count++;
                 l--;
                 r++;
             &#125;
         &#125;
         return count;
     &#125;
 &#125;
</code></pre>
<p>dp</p>
<pre><code>class Solution &#123;
     public int countSubstrings(String s) &#123;
         int len, ans = 0;
         if (s == null || (len = s.length()) &lt; 1) return 0;
         //dp[i][j]：s字符串下标i到下标j的字串是否是一个回文串，即s[i, j]
         boolean[][] dp = new boolean[len][len];
         for (int j = 0; j &lt; len; j++) &#123;
             for (int i = 0; i &lt;= j; i++) &#123;
                 //当两端字母一样时，才可以两端收缩进一步判断
                 if (s.charAt(i) == s.charAt(j)) &#123;
                     //i++，j--，即两端收缩之后i,j指针指向同一个字符或者i超过j了,必然是一个回文串
                     if (j - i &lt; 3) &#123;
                         dp[i][j] = true;
                     &#125; else &#123;
                         //否则通过收缩之后的字串判断
                         dp[i][j] = dp[i + 1][j - 1];
                     &#125;
                 &#125; else &#123;//两端字符不一样，不是回文串
                     dp[i][j] = false;
                 &#125;
             &#125;
         &#125;
         //遍历每一个字串，统计回文串个数
         for (int i = 0; i &lt; len; i++) &#123;
             for (int j = 0; j &lt; len; j++) &#123;
                 if (dp[i][j]) ans++;
             &#125;
         &#125;
         return ans;
     &#125;
 &#125;
</code></pre>
<h2 id="438寻找字母异位词"><a href="#438寻找字母异位词" class="headerlink" title="438寻找字母异位词"></a>438寻找字母异位词</h2><p>给定两个字符串 s 和 p，找到 s 中所有 p 的 异位词 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。<br>异位词 指由相同字母重排列形成的字符串（包括相同的字符串）。<br>思路：滑动窗口，首先维护两个数组 记录当前s要和p匹配的以及p的每种字符数量<br>然后移动滑动窗口 每次都比较一下 equals的话即符合条件 存入结果集<br>方法一<br><img src="https://raw.githubusercontent.com/viacheung/img/main/image/image-20221006155802666.png#from=url&id=iW64u&originalType=binary&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&title="></p>
<pre><code>class Solution &#123;
     public List&lt;Integer&gt; findAnagrams(String s, String p) &#123;
         int sLen = s.length(), pLen = p.length();
         
         if (sLen &lt; pLen) &#123;
             return new ArrayList&lt;Integer&gt;();
         &#125;
         
         List&lt;Integer&gt; ans = new ArrayList&lt;Integer&gt;();
         int[] sCount = new int[26];
         int[] pCount = new int[26];
         //初始滑动窗口内记录各字母数目
         for (int i = 0; i &lt; pLen; ++i) &#123;
             ++sCount[s.charAt(i) - &#39;a&#39;];
             ++pCount[p.charAt(i) - &#39;a&#39;];//这个不会变了
         &#125;
         //判断数组是否相等
         if (Arrays.equals(sCount, pCount)) &#123;
             ans.add(0);
         &#125;
         //左出右进 scount要变 
         for (int i = 0; i &lt; sLen - pLen; ++i) &#123;
             --sCount[s.charAt(i) - &#39;a&#39;];//左边出去的
             ++sCount[s.charAt(i + pLen) - &#39;a&#39;];//右边进来的
             //再判断
             if (Arrays.equals(sCount, pCount)) &#123;
                 ans.add(i + 1);
             &#125;
         &#125;
 
         return ans;
     &#125;
 &#125;
</code></pre>
<p><img src="https://raw.githubusercontent.com/viacheung/img/main/image/image-20221006160224094.png#from=url&id=QOiiP&originalType=binary&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&title="></p>
<pre><code>class Solution &#123;
     public List&lt;Integer&gt; findAnagrams(String s, String p) &#123;
         int sLen = s.length(), pLen = p.length();
 
         if (sLen &lt; pLen) &#123;
             return new ArrayList&lt;Integer&gt;();
         &#125;
 
         List&lt;Integer&gt; ans = new ArrayList&lt;Integer&gt;();
         int[] count = new int[26];
         //初始滑动窗口
         for (int i = 0; i &lt; pLen; ++i) &#123;
             ++count[s.charAt(i) - &#39;a&#39;];
             --count[p.charAt(i) - &#39;a&#39;];
         &#125;
         //count代表滑动窗口中每种字母的数量与字符串p中每种字母的数量差值
         //differ代表当前窗口与p不同字母个数
         int differ = 0;
         for (int j = 0; j &lt; 26; ++j) &#123;
             if (count[j] != 0) &#123;
                 ++differ;
             &#125;
         &#125;
 
         if (differ == 0) &#123;
             ans.add(0);
         &#125;
 
         for (int i = 0; i &lt; sLen - pLen; ++i) &#123;
             //因为是要去除一个元素，且count是滑动窗口里面的s减去p ，去除元素只会让count减少，因此只有1-&gt;0 或者0-&gt;-1才能让differ变化
             if (count[s.charAt(i) - &#39;a&#39;] == 1) &#123;  //1-&gt;0  --differ
                 --differ;
             &#125; else if (count[s.charAt(i) - &#39;a&#39;] == 0) &#123;  //0-&gt;1   ++differ
                 ++differ;
             &#125;
             --count[s.charAt(i) - &#39;a&#39;];
             //因为是要增加一个元素，且count是滑动窗口里面的s减去p ，增加元素只会让count增加，因此只有-1-&gt;0 或者0-&gt;1才能让differ变化
             if (count[s.charAt(i + pLen) - &#39;a&#39;] == -1) &#123;  // -1-&gt;0  --differ
                 --differ;
             &#125; else if (count[s.charAt(i + pLen) - &#39;a&#39;] == 0) &#123;  // 0-&gt;1   ++differ
                 ++differ;
             &#125;
             ++count[s.charAt(i + pLen) - &#39;a&#39;];
             
             if (differ == 0) &#123;
                 ans.add(i + 1);
             &#125;
         &#125;
 
         return ans;
     &#125;
 &#125;
</code></pre>
<h3 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h3><p>滑动窗口总结：<br>初始化滑动窗口<br>开始滑动</p>
<h2 id="字符串解码"><a href="#字符串解码" class="headerlink" title="字符串解码"></a>字符串解码</h2><pre><code>输入：s = &quot;3[a2[c]]&quot;
 输出：&quot;accaccacc&quot;
</code></pre>
<p><strong>解法一：辅助栈法</strong><br><img src="https://raw.githubusercontent.com/viacheung/img/main/image/image-20221001100508616.png#from=url&id=C1qPQ&originHeight=662&originWidth=968&originalType=binary&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&title="><br><img src="https://raw.githubusercontent.com/viacheung/img/main/image/ezgif-5-e7185c1cac.gif#from=url&id=xXzkj&originHeight=328&originWidth=600&originalType=binary&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&title="><br>举例：3 [ a 2 [ c ] ]<br>维护两个stack 前一个是数字 后一个res<br>3：muti&#x3D;3<br>[ : 分别把3和”” 入栈，(3,””) 并把res和muti置为空<br>a: res&#x3D;a<br>2: muti &#x3D;2<br>[ : 分别把2和”a” 入栈，(3,””) (2,”a”)&#x3D;&#x3D;&#x3D;实际上是【3，2 】 【”“，”a”】，并把res和muti置为空<br>c: res&#x3D;c<br>]:出栈，res&#x3D;a+2<em>res<br>]: 出栈，res&#x3D;””+3</em>res<br>我的理解：维护一个数字栈和字母栈 左括号前把东西记录进muti和res，出现左括号就muti res清空，清空这个很秒，首先后面的括号也要用res和muti作为临时存储 ，其次我情空但是然后后面入了数字栈和字母栈 所以res依然保留着，出现右括号就计算当前括号的res </p>
<pre><code>class Solution &#123;
     public String decodeString(String s) &#123;
         StringBuilder res = new StringBuilder();
         int multi = 0;
         LinkedList&lt;Integer&gt; stack_multi = new LinkedList&lt;&gt;();
         LinkedList&lt;String&gt; stack_res = new LinkedList&lt;&gt;();
         for(Character c : s.toCharArray()) &#123;
             if(c == &#39;[&#39;) &#123;
                 stack_multi.addLast(multi);//放到尾部
                 stack_res.addLast(res.toString());
                 //这俩置为0和空
                 multi = 0;
                 res = new StringBuilder();
             &#125;
             else if(c == &#39;]&#39;) &#123;
                 StringBuilder tmp = new StringBuilder();
                 int cur_multi = stack_multi.removeLast();
                 for(int i = 0; i &lt; cur_multi; i++) tmp.append(res);
                 res = new StringBuilder(stack_res.removeLast() + tmp);
             &#125;
             else if(c &gt;= &#39;0&#39; &amp;&amp; c &lt;= &#39;9&#39;) multi = multi * 10 + Integer.parseInt(c + &quot;&quot;);//防止有连续的数字
             else res.append(c);
         &#125;
         return res.toString();
     &#125;
 &#125;
</code></pre>
<pre><code>for(int i=0;i&lt;muti_stack.pop();i++)&#123;
     tmp.append(res);
 &#125;
 这样写会报错的原因是每次循环后muti_stack.pop()都会执行一次，最终导致EmptyStackException
 正确方法是用一个变量保存它
</code></pre>
<h2 id="长按键入"><a href="#长按键入" class="headerlink" title="长按键入"></a>长按键入</h2><p>你的朋友正在使用键盘输入他的名字 name。偶尔，在键入字符 c 时，按键可能会被_长按_，而字符可能被输入 1 次或多次。<br>你将会检查键盘输入的字符 typed。如果它对应的可能是你的朋友的名字（其中一些字符可能被长按），那么就返回 True。<br>题解：模拟同时遍历两个数组，进行对比就可以了。</p>
<pre><code>class Solution &#123;
     public boolean isLongPressedName(String name, String typed) &#123;
         int i=0,j=0;
         int n1=name.length();
         int n2=typed.length();
         while(i&lt;n1&amp;&amp;j&lt;n2)&#123;
             // 对应字符匹配
             if(name.charAt(i)==typed.charAt(j))&#123;
                 i++;
                 j++;
             &#125;else&#123;
                 // 如果键入字符是第一个 直接返回false
                 if(j==0) return false;
                 // j开始跨越重复项
                 //这里要注意 因为如果满足条件的话 j会++ 所以j&lt;n2-1
                 while(j&lt;n2-1&amp;&amp;typed.charAt(j)==typed.charAt(j-1))&#123;
                     j++;
                 &#125;
                 // 再判断字符是否匹配
                 if(name.charAt(i)==typed.charAt(j))&#123;
                     i++;
                     j++;
                 &#125;else&#123;
                     // 不匹配直接false
                     return false;
                 &#125;
             &#125;
         &#125;
         // name没用完 typed到头了 必然不符合要求
         if(i&lt;n1) return false;
         //typed多余 那必须后面元素都要和当前j处字符一样才符合要求
         while(j&lt;n2)&#123;
             if(typed.charAt(j)==typed.charAt(j-1))&#123;
                 j++;
             &#125;else&#123;
                 return false;
             &#125;
         &#125;
         return true;
 
         
     &#125;
 &#125;
</code></pre>
<h2 id="比较含退格的字符串"><a href="#比较含退格的字符串" class="headerlink" title="比较含退格的字符串"></a>比较含退格的字符串</h2><p>给定 s 和 t 两个字符串，当它们分别被输入到空白的文本编辑器后，如果两者相等，返回 true 。# 代表退格字符。<br><strong>注意：</strong>如果对空文本输入退格字符，文本继续为空。</p>
<pre><code>// 普通方法（使用栈的思路）
 class Solution &#123;
     public boolean backspaceCompare(String s, String t) &#123;
         StringBuilder ssb = new StringBuilder(); // 模拟栈
         StringBuilder tsb = new StringBuilder(); // 模拟栈
         // 分别处理两个 String
         for (char c : s.toCharArray()) &#123;
             if (c != &#39;#&#39;) &#123;
                 ssb.append(c); // 模拟入栈
             &#125; else if (ssb.length() &gt; 0)&#123; // 栈非空才能弹栈
                 ssb.deleteCharAt(ssb.length() - 1); // 模拟弹栈
             &#125;
         &#125;
         for (char c : t.toCharArray()) &#123;
             if (c != &#39;#&#39;) &#123;
                 tsb.append(c); // 模拟入栈
             &#125; else if (tsb.length() &gt; 0)&#123; // 栈非空才能弹栈
                 tsb.deleteCharAt(tsb.length() - 1); // 模拟弹栈
             &#125;
         &#125;
         return ssb.toString().equals(tsb.toString());
     &#125;
 &#125;
</code></pre>
<h2 id="反转字符串中的单词-III"><a href="#反转字符串中的单词-III" class="headerlink" title="反转字符串中的单词 III"></a>反转字符串中的单词 III</h2><p>给定一个字符串 s ，你需要反转字符串中每个单词的字符顺序，同时仍保留空格和单词的初始顺序。<br>思路：<br>开辟一个新字符串StringBuilder。然后从头到尾遍历原字符串，直到找到空格为止，此时找到了一个单词，并能得到单词的起止位置。随后，根据单词的起止位置，可以将该单词逆序放到新字符串当中。如此循环多次，直到遍历完原字符串，就能得到翻转后的结果。<br>这里逆序：(i-1-j+start) 可以想象是从i-1—-0开始 所以i-1依次减去j-start（j从start到i）</p>
<pre><code>class Solution &#123;
     public String reverseWords(String s) &#123;
         StringBuilder sb=new StringBuilder();
         int n=s.length();
         int i=0;
         while(i&lt;n)&#123;
             int start=i;
             while(i&lt;n&amp;&amp;s.charAt(i)!=&#39; &#39;) i++;
             for(int j=start;j&lt;i;j++)&#123;
                 sb.append(s.charAt(i-1-j+start));
             &#125;
             while(i&lt;n&amp;&amp;s.charAt(i)==&#39; &#39;)&#123;
                 i++;
                 sb.append(&#39; &#39;);
             &#125;
         &#125;
         return sb.toString();
     &#125;
 &#125;
</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://viacheung.github.io/2023/06/04/%E4%BA%8C%E5%8F%89%E6%A0%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="ViaCheung">
      <meta itemprop="description" content="el psy congroo">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="命运石之门">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/06/04/%E4%BA%8C%E5%8F%89%E6%A0%91/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
	  <span class="post-time">

	  
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-06-04 01:02:11" itemprop="dateCreated datePublished" datetime="2023-06-04T01:02:11+08:00">2023-06-04</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="相关知识"><a href="#相关知识" class="headerlink" title="相关知识"></a>相关知识</h2><p>完全二叉树： 从满二叉树最后一个结点往前删除<br>二叉搜索树：左小右大 带数值<br>平衡二叉搜索树：AVL 高度差值小于2<br>存储方式：数组 链式 <strong>如果父节点的数组下标是 i，那么它的左孩子就是 i * 2 + 1，右孩子就是 i * 2 + 2。</strong>想012就行<br>遍历方式：深度：前中后 迭代 递归 栈<br>                 广度 层次 迭代 队列<br>定义：</p>
<pre><code>public class TreeNode &#123;
     int val;
     TreeNode left;
     TreeNode right;
     TreeNode() &#123;&#125;
     TreeNode(int val) &#123; this.val = val; &#125;
     TreeNode(int val, TreeNode left, TreeNode right) &#123;
             this.val = val;
             this.left = left;
             this.right = right;
     &#125;
 &#125;
</code></pre>
<p>二叉排序<a target="_blank" rel="noopener" href="http://data.biancheng.net/view/313.html">树</a>（Binary Sort Tree，简称 BST ）又叫二叉查找树和二叉搜索树，是一种实现动态查找表的树形存储结构。</p>
<ul>
<li>节点的左子树仅包含键 <strong>小于</strong> 节点键的节点。</li>
<li>节点的右子树仅包含键 <strong>大于</strong> 节点键的节点。</li>
<li>左右子树也必须是二叉搜索树。<strong>递归思路：</strong></li>
</ul>
<ol>
<li><p><strong>确定递归函数的参数和返回值：</strong> 确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数， 并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。</p>
</li>
<li><p><strong>确定终止条件：</strong> 写完了递归算法, 运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对，操作系统也是用一个栈的结构来保存每一层递归的信息，如果递归没有终止，操作系统的内存栈必然就会溢出。</p>
</li>
<li><p><strong>确定单层递归的逻辑：</strong> 确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程。</p>
<h2 id="对称二叉树"><a href="#对称二叉树" class="headerlink" title="对称二叉树"></a>对称二叉树</h2><p>给你一个二叉树的根节点 root ， 检查它是否轴对称。<br>我们可以实现这样一个递归函数，通过「同步移动」两个指针的方法来遍历这棵树，p指针和 q 指针一开始都指向这棵树的根，随后 p 右移时，q 左移 p 左移时，q 右移。每次检查当前 p 和 q 节点的值是否相等，如果相等再判断左右子树是否对称。<br>&#96;&#96;&#96;<br>class Solution {<br>  public boolean isSymmetric(TreeNode root) {<br>  return check(root, root);<br>  }</p>
<p>  public boolean check(TreeNode p, TreeNode q) {<br>  if (p &#x3D;&#x3D; null &amp;&amp; q &#x3D;&#x3D; null) {<br>      return true;<br>  }<br>  if (p &#x3D;&#x3D; null || q &#x3D;&#x3D; null) {<br>      return false;<br>  }<br>  return p.val &#x3D;&#x3D; q.val &amp;&amp; check(p.left, q.right) &amp;&amp; check(p.right, q.left);<br>  }</p>
</li>
</ol>
<p> }</p>
<pre><code>## 二叉树的最大深度
给定一个二叉树，找出其最大深度。 二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。
</code></pre>
<p>class Solution {<br>     public int maxDepth(TreeNode root) {<br>         if (root &#x3D;&#x3D; null) {<br>             return 0;<br>         } else {<br>             int leftHeight &#x3D; maxDepth(root.left);<br>             int rightHeight &#x3D; maxDepth(root.right);<br>             return Math.max(leftHeight, rightHeight) + 1;<br>         }<br>     }<br> }</p>
<p> &#x2F;&#x2F;return root &#x3D;&#x3D; null ? 0 : Math.max(this.maxDepth(root.left), this.maxDepth(root.right)) + 1;</p>
<pre><code>
</code></pre>
<p>public int maxDepth (TreeNode root) {<br>         &#x2F;&#x2F; write code here<br>         if(root&#x3D;&#x3D;null) return 0;<br>         return Math.max(maxDepth(root.left),maxDepth(root.right))+1;<br>     }</p>
<pre><code>## 二叉树最小深度
给定一个二叉树，找出其最小深度。
最小深度是从根节点到最近叶子节点的最短路径上的节点数量。（注意这里 和求最大深度不一样）
![](https://raw.githubusercontent.com/viacheung/img/main/image/20210203155800503.png#from=url&amp;id=SnAFW&amp;originHeight=748&amp;originWidth=958&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=)
</code></pre>
<p>class Solution {<br>     public int minDepth(TreeNode root) {<br>         if (root &#x3D;&#x3D; null) return 0;<br>         &#x2F;&#x2F;这两个else if 很重要 就是为了防止出现上图所示情况<br>         else if (root.left &#x3D;&#x3D; null) return minDepth(root.right) + 1;<br>         else if (root.right &#x3D;&#x3D; null) return minDepth(root.left) + 1;<br>         else return Math.min(minDepth(root.left), minDepth(root.right)) + 1;<br>     }<br> }</p>
<pre><code>## 完全二叉树的节点个数(×)
给你一棵 **完全二叉树** 的根节点 root ，求出该树的节点个数。
![](https://raw.githubusercontent.com/viacheung/img/main/image/image-20221029171009163.png#from=url&amp;id=E8WGB&amp;originHeight=735&amp;originWidth=882&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=)
![](https://raw.githubusercontent.com/viacheung/img/main/image/image-20221031151200655.png#from=url&amp;id=LtIHX&amp;originHeight=429&amp;originWidth=874&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=)
</code></pre>
<p>class Solution {<br>     public int countNodes(TreeNode root) {<br>         if(root &#x3D;&#x3D; null) {<br>             return 0;<br>         }<br>         int left &#x3D; countNodes(root.left);<br>         int right &#x3D; countNodes(root.right);</p>
<pre><code>     return left+right+1;
     
 &#125;
</code></pre>
<p> }</p>
<pre><code>遍历树来统计节点是一种时间复杂度为 O(n) 的简单解决方案。你可以设计一个更快的算法吗
</code></pre>
<p>class Solution {<br>     public int countNodes(TreeNode root) {<br>         if (root &#x3D;&#x3D; null) {<br>             return 0;<br>         }<br>         int level &#x3D; 0;<br>         TreeNode node &#x3D; root;<br>         &#x2F;&#x2F;去最下左结点  记录下结点和层数<br>         while (node.left !&#x3D; null) {<br>             level++;<br>             node &#x3D; node.left;<br>         }<br>         &#x2F;&#x2F;          2^level<br>         &#x2F;&#x2F;当 0≤i&lt;h 时，第 i层包含 2^i 个节点，最底层包含的节点数最少为 1，最多为 2^h。<br>         int low &#x3D; 1 &lt;&lt; level, high &#x3D; (1 &lt;&lt; (level + 1)) - 1;<br>         while (low &lt; high) {<br>             &#x2F;&#x2F; 这一句一用就会超时  原因是防止溢出，可能出现两者相加超过int表示范围<br>             int mid &#x3D; (high - low + 1) &#x2F; 2 + low;<br>             if (exists(root, level, mid)) {<br>                 low &#x3D; mid;<br>             } else {<br>                 high &#x3D; mid - 1;<br>             }<br>         }<br>         return low;<br>     }<br>     bits:1000-&gt; 100&gt; 10 &gt;1<br>     k:1100 右 左 左<br>     public boolean exists(TreeNode root, int level, int k) {<br>         int bits &#x3D; 1 &lt;&lt; (level - 1);<br>         TreeNode node &#x3D; root;<br>         while (node !&#x3D; null &amp;&amp; bits &gt; 0) {<br>             if ((bits &amp; k) &#x3D;&#x3D; 0) {<br>                 node &#x3D; node.left;<br>             } else {<br>                 node &#x3D; node.right;<br>             }<br>             bits &gt;&gt;&#x3D; 1;<br>         }<br>         return node !&#x3D; null;<br>     }<br> }</p>
<pre><code>## 二叉树的所有路径
给你一个二叉树的根节点 root ，按 **任意顺序** ，返回所有从根节点到叶子节点的路径。
**叶子节点** 是指没有子节点的节点。
</code></pre>
<p>&#x2F;&#x2F;我写的 那就选这个！<br> class Solution {<br>     List<String> ans&#x3D;new ArrayList&lt;&gt;();<br>     public List<String> binaryTreePaths(TreeNode root) {<br>         StringBuilder sb&#x3D;new StringBuilder();<br>         dfs(root,sb);<br>         return ans;<br>     }<br>     public void dfs(TreeNode root, StringBuilder sb){<br>         if(root&#x3D;&#x3D;null) return;<br>         if(sb.length()&#x3D;&#x3D;0){<br>             sb.append(root.val);<br>         }else{<br>             sb.append(“-&gt;”).append(root.val);<br>         }<br>         if(root.left&#x3D;&#x3D;null&amp;&amp;root.right&#x3D;&#x3D;null){<br>             ans.add(sb.toString());<br>             return;<br>         }<br>         &#x2F;&#x2F;注意这里 一定要new StringBuilder 递归左子树之后再传入右子树的sb已经变成左子树的路径了，因此不能用sb了，而应该把前面sb的值copy来<br>         dfs(root.left,new StringBuilder(sb));<br>         dfs(root.right,new StringBuilder(sb));</String></String></p>
<pre><code> &#125;
</code></pre>
<p> }</p>
<pre><code>
</code></pre>
<p>&#x2F;&#x2F;还有一种方法，就是回溯。<br>     private void dfs(TreeNode root, StringBuilder cur, List<String> paths) {<br>         if (root &#x3D;&#x3D; null) return;<br>         if (root.left &#x3D;&#x3D; null &amp;&amp; root.right &#x3D;&#x3D; null) {<br>             paths.add(cur.toString() + root.val);<br>             return;<br>         }<br>         int sz &#x3D; cur.length();<br>         cur.append(root.val).append(“-&gt;”);<br>         dfs(root.left, cur);<br>         dfs(root.right, cur);<br>         cur.delete(sz, cur.length());&#x2F;&#x2F;在这里已经定义了dfs的回溯，因此dfs(root.left, cur);执行完毕就已经是回溯的了，也就不会影响        dfs(root.right, cur);的路径了！ 完美！<br>     }</String></p>
<pre><code>## 平衡二叉树
给定一个二叉树，判断它是否是高度平衡的二叉树。
本题中，一棵高度平衡二叉树定义为：一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1 。
**方法一：自顶向下的递归**（选这个）
![](https://raw.githubusercontent.com/viacheung/img/main/image/image-20221101131731698.png#from=url&amp;id=iYLI8&amp;originHeight=197&amp;originWidth=805&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=)
</code></pre>
<p>class Solution {<br>     public boolean isBalanced(TreeNode root) {<br>         if(root&#x3D;&#x3D;null) return true;<br>         &#x2F;&#x2F;这个&amp;&amp;开始没想到 根节点高度满足还需要后面节点也都是如此<br>         return Math.abs(getDepth(root.right)-getDepth(root.left))&lt;2&amp;&amp;isBalanced(root.right)&amp;&amp;isBalanced(root.left);<br>     }<br>     public int getDepth(TreeNode root){<br>         if(root&#x3D;&#x3D;null) return 0;<br>         return Math.max(getDepth(root.left),getDepth(root.right))+1;<br>     }<br> }<br> O(n^2)</p>
<pre><code>![](https://raw.githubusercontent.com/viacheung/img/main/image/image-20221101131921565.png#from=url&amp;id=N1EiN&amp;originHeight=198&amp;originWidth=817&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=)
</code></pre>
<p>class Solution {<br>     public boolean isBalanced(TreeNode root) {<br>         return height(root) &gt;&#x3D; 0;<br>     }</p>
<pre><code> public int height(TreeNode root) &#123;
     if (root == null) &#123;
         return 0;
     &#125;
     int leftHeight = height(root.left);
     int rightHeight = height(root.right);
     if (leftHeight == -1 || rightHeight == -1 || Math.abs(leftHeight - rightHeight) &gt; 1) &#123;
         return -1;
     &#125; else &#123;
         return Math.max(leftHeight, rightHeight) + 1;
     &#125;
 &#125;
</code></pre>
<p> }<br> O(n)<br>     自底向上的递归就是及时止损 自顶向下的递归就是不管三七二十一先把所有的高度算一遍</p>
<pre><code>## 左叶子之和
题目：计算二叉树左叶子的和
左叶子 是节点的左节点不为空且左节点的左右节点都为空 
1、出口：节点空或者节点无子节点
2、判断为左节点 加到ans
</code></pre>
<p>&#x2F;&#x2F;我的题解 我选择用自己的<br> class Solution {<br>     int ans&#x3D;0;<br>     public int sumOfLeftLeaves(TreeNode root) {<br>         dfs(root);<br>         return ans;<br>     }<br>     public void dfs(TreeNode root){<br>         &#x2F;&#x2F;出口<br>         if(root&#x3D;&#x3D;null||(root.left&#x3D;&#x3D;null&amp;&amp;root.right&#x3D;&#x3D;null)) return;<br>         &#x2F;&#x2F;左节点存在且为叶节点<br>         if(root.left!&#x3D;null&amp;&amp;root.left.left&#x3D;&#x3D;null&amp;&amp;root.left.right&#x3D;&#x3D;null){<br>             ans+&#x3D;root.left.val;<br>         }<br>         &#x2F;&#x2F;递归到左右节点<br>         dfs(root.left);<br>         dfs(root.right);<br>     }<br> }</p>
<pre><code>## 找树左下角的值
给定一个二叉树的 **根节点**root，请找出该二叉树的 **最底层 最左边** 节点的值。
假设二叉树中至少有一个节点。
</code></pre>
<p>class Solution {<br>     &#x2F;&#x2F;维护当前树高度和值<br>     int curval&#x3D;0;<br>     int curheight&#x3D;0;<br>     public int findBottomLeftValue(TreeNode root) {<br>         dfs(root,0);<br>         return curval;<br>     }<br>     public void dfs(TreeNode root,int height){<br>         if(root&#x3D;&#x3D;null) return;<br>         height++;&#x2F;&#x2F;向下递归一层加一<br>         &#x2F;&#x2F;也就是说到最深高度且先遍历左边就能保证找到了左下角的节点值<br>         if(height&gt;curheight){<br>             curheight&#x3D;height;<br>             curval&#x3D;root.val;<br>         }<br>         &#x2F;&#x2F;因为是先左后右 相同高度左边结点优先遍历到<br>         &#x2F;&#x2F;这个想法没问题 但是int数据表示范围32位有限 出现内存溢出 所以还是Left在前</p>
<pre><code>     // if(height==curheight)&#123;
     //     Math.min(curval,root.val);
     // &#125;
     dfs(root.left,height);
     dfs(root.right,height);

 &#125;
</code></pre>
<p> }</p>
<pre><code>## 路径总和
给你二叉树的根节点 root 和一个表示目标和的整数 targetSum 。判断该树中是否存在 **根节点到叶子节点** 的路径，这条路径上所有节点值相加等于目标和 targetSum 。如果存在，返回 true ；否则，返回 false 。
</code></pre>
<p>class Solution {<br>    &#x2F;&#x2F;有待改进 需要剪枝。。。 因为就算找到targetSum&#x3D;&#x3D;0 递归还在继续<br>     boolean ans&#x3D;false;<br>     public boolean hasPathSum(TreeNode root, int targetSum) {<br>         dfs(root,targetSum);<br>         return ans;<br>     }<br>     public void dfs(TreeNode root,int targetSum){<br>         if(root&#x3D;&#x3D;null) return;<br>         targetSum&#x3D;targetSum-root.val;<br>         if(root.left&#x3D;&#x3D;null&amp;&amp;root.right&#x3D;&#x3D;null){<br>             if(targetSum&#x3D;&#x3D;0){<br>                 ans&#x3D;true;<br>                 return;<br>             }<br>         }<br>         dfs(root.left,targetSum);<br>         dfs(root.right,targetSum);<br>     }<br> }</p>
<pre><code>官方题解：简洁！
</code></pre>
<p>class Solution {<br>     public boolean hasPathSum(TreeNode root, int sum) {<br>         if (root &#x3D;&#x3D; null) {<br>             return false;<br>         }<br>         &#x2F;&#x2F;递归到最后一层   最后只需要判断sum&#x3D;&#x3D;root.val就行<br>         if (root.left &#x3D;&#x3D; null &amp;&amp; root.right &#x3D;&#x3D; null) {<br>             return sum &#x3D;&#x3D; root.val;<br>         }<br>         &#x2F;&#x2F;一直递归到最后一层  sum - root.val（传参到sum）一直在减少<br>         return hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val);<br>     }<br> }</p>
<pre><code>## 从中序与后序遍历序列构造二叉树
给定两个整数数组 inorder 和 postorder ，其中 inorder 是二叉树的中序遍历， postorder 是同一棵树的后序遍历，请你构造并返回这颗 _二叉树_ 。
</code></pre>
<p>class Solution {<br>     int post_idx;<br>     int[] postorder;<br>     int[] inorder;<br>     Map&lt;Integer, Integer&gt; idx_map &#x3D; new HashMap&lt;Integer, Integer&gt;();</p>
<pre><code> public TreeNode buildTree(int[] inorder, int[] postorder) &#123;
     this.postorder = postorder;
     this.inorder = inorder;
     // 从后序遍历的最后一个元素开始
     post_idx = postorder.length - 1;

     // 建立（元素，下标）键值对的哈希表
     int idx = 0;
     for (Integer val : inorder) &#123;
         idx_map.put(val, idx++);
     &#125;
     
     return helper(0, inorder.length - 1);
 &#125;
 
 public TreeNode helper(int in_left, int in_right) &#123;
     // 如果这里没有节点构造二叉树了，就结束
     if (in_left &gt; in_right) &#123;
         return null;
     &#125;

     // 选择 post_idx 位置的元素作为当前子树根节点
     int root_val = postorder[post_idx];
     TreeNode root = new TreeNode(root_val);
     // 根据 root 所在位置分成左右两棵子树
     int index = idx_map.get(root_val);
     // 下标减一
     post_idx--;
     // 构造右子树
     root.right = helper(index + 1, in_right);
     // 构造左子树
     root.left = helper(in_left, index - 1);
     return root;
 &#125;
</code></pre>
<p> }</p>
<pre><code>## 最大二叉树
给定一个不重复的整数数组 nums 。 **最大二叉树** 可以用下面的算法从 nums 递归地构建:

1. 创建一个根节点，其值为 nums 中的最大值。
2. 递归地在最大值 **左边** 的 **子数组前缀上** 构建左子树。
3. 递归地在最大值 **右边** 的 **子数组后缀上** 构建右子树。

返回 _nums 构建的_***最大二叉树*** 。
**递归**
</code></pre>
<p>&#x2F;&#x2F;我最初的解法<br> class Solution {<br>     int[] nums;<br>     public TreeNode constructMaximumBinaryTree(int[] nums) {<br>         this.nums&#x3D;nums;<br>         return buildTreee(0,nums.length-1);<br>     }<br>     public TreeNode buildTreee(int left,int right){<br>         if(left&gt;right) return null;<br>         int index&#x3D;getMaxNumIndex(left,right);<br>         TreeNode root&#x3D;new TreeNode(nums[index]);<br>         root.left&#x3D;buildTreee(left,index-1);<br>         root.right&#x3D;buildTreee(index+1,right);<br>         return root;<br>     }<br>     public int getMaxNumIndex(int left,int right){<br>         int max&#x3D;Integer.MIN_VALUE;<br>         int index&#x3D;0;<br>         for(int i&#x3D;left;i&lt;&#x3D;right;i++){<br>             if(nums[i]&gt;max){<br>                 max&#x3D;nums[i];<br>                 index&#x3D;i;<br>             }<br>         }<br>         return index;<br>     }<br> }<br> &#x2F;&#x2F;优化后<br> class Solution {<br>     int[] nums;<br>     public TreeNode constructMaximumBinaryTree(int[] nums) {<br>         this.nums&#x3D;nums;<br>         return buildTreee(0,nums.length-1);<br>     }<br>     public TreeNode buildTreee(int left,int right){<br>         if(left&gt;right) return null;<br>         int best&#x3D;left;<br>         for (int i &#x3D; left + 1; i &lt;&#x3D; right; ++i) {<br>             if (nums[i] &gt; nums[best]) {<br>                 best &#x3D; i;<br>             }<br>         }<br>         TreeNode root&#x3D;new TreeNode(nums[best]);<br>         root.left&#x3D;buildTreee(left,best-1);<br>         root.right&#x3D;buildTreee(best+1,right);<br>         return root;<br>     }<br> }</p>
<pre><code>**单调栈**
## 验证二叉搜索树
给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。
**有效** 二叉搜索树定义如下：

- 节点的左子树只包含 **小于** 当前节点的数。
- 节点的右子树只包含 **大于** 当前节点的数。
- 所有左子树和右子树自身必须也是二叉搜索树。
</code></pre>
<p>class Solution {<br>     public boolean isValidBST(TreeNode root) {<br>         return dfs(root,Long.MIN_VALUE,Long.MAX_VALUE);<br>     }<br>     public boolean dfs(TreeNode root,long l,long r){<br>         if(root&#x3D;&#x3D;null) return true;<br>         if(root.val&lt;&#x3D;l||root.val&gt;&#x3D;r) return false;<br>         return dfs(root.left,l,root.val)&amp;&amp;dfs(root.right,root.val,r);<br>     }<br> }</p>
<pre><code>
## 二叉搜索树的最小绝对差
</code></pre>
<p>class Solution {<br>     int ans&#x3D;Integer.MAX_VALUE;<br>     public int getMinimumDifference(TreeNode root) {<br>         dfs(root);<br>         return ans;<br>     }<br>     public void dfs(TreeNode root){<br>         if(root&#x3D;&#x3D;null) return;<br>         &#x2F;&#x2F;我的题解：寻找左子树里最大值和右子树里面最小值 然后同根节点做差求Min<br>         &#x2F;&#x2F;左子树里最大值就是左孩子的最右结点 右子树同理<br>         TreeNode node_l&#x3D;root.left,node_r&#x3D;root.right;<br>         while(node_l!&#x3D;null&amp;&amp;node_l.right!&#x3D;null){<br>             node_l&#x3D;node_l.right;<br>         }<br>         while(node_r!&#x3D;null&amp;&amp;node_r.left!&#x3D;null){<br>             node_r&#x3D;node_r.left;<br>         }<br>         int l&#x3D;node_l&#x3D;&#x3D;null?Integer.MAX_VALUE:root.val-node_l.val;<br>         int r&#x3D;node_r&#x3D;&#x3D;null?Integer.MAX_VALUE:node_r.val-root.val;<br>         ans&#x3D;Math.min(Math.min(l,r),ans);<br>         dfs(root.left);<br>         dfs(root.right);<br>     }<br> }</p>
<pre><code>![](https://raw.githubusercontent.com/viacheung/img/main/image/image-20221104202039345.png#from=url&amp;id=wt3OW&amp;originHeight=634&amp;originWidth=908&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=)
</code></pre>
<p>class Solution {<br>     int pre;<br>     int ans;<br>     public int getMinimumDifference(TreeNode root) {<br>         ans &#x3D; Integer.MAX_VALUE;<br>         pre &#x3D; -1;<br>         dfs(root);<br>         return ans;<br>     }<br>     public void dfs(TreeNode root) {<br>         if (root &#x3D;&#x3D; null) {<br>             return;<br>         }<br>         &#x2F;&#x2F;中序 左根右  有序<br>         &#x2F;&#x2F;只需要计算相邻结点差值的最小值就可<br>         dfs(root.left);<br>         if (pre &#x3D;&#x3D; -1) {<br>             pre &#x3D; root.val;<br>         } else {<br>             ans &#x3D; Math.min(ans, root.val - pre);<br>             pre &#x3D; root.val;<br>         }<br>         dfs(root.right);<br>     }<br> }<br> 优雅！！！！！！！！</p>
<pre><code>## 二叉搜索树中的众数
给你一个含重复值的二叉搜索树（BST）的根节点 root ，找出并返回 BST 中的所有 [众数](https://baike.baidu.com/item/%E4%BC%97%E6%95%B0/44796)（即，出现频率最高的元素）。
如果树中有不止一个众数，可以按 **任意顺序** 返回。
假定 BST 满足如下定义：

- 结点左子树中所含节点的值 **小于等于** 当前节点的值
- 结点右子树中所含节点的值 **大于等于** 当前节点的值
- 左子树和右子树都是二叉搜索树

我的思路：
哈希表 dfs遍历结点 map存储结点以及结点出现个数，然后每个entrySet取value 打擂台的方式，最后得出最大的value以及key 然后根据value再遍历一次 看看有无相等的 有就加入结果集List but不想实现。。。。。
![](https://raw.githubusercontent.com/viacheung/img/main/image/image-20221106213939182.png#from=url&amp;id=KQHNh&amp;originHeight=1174&amp;originWidth=918&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=)
</code></pre>
<p>class Solution {<br>     &#x2F;&#x2F;记录众数<br>     List<Integer> answer&#x3D;new ArrayList&lt;&gt;();<br>     &#x2F;&#x2F;  当前数字 出现个数   最大出现个数<br>     int base,count,maxcount;</Integer></p>
<pre><code> public int[] findMode(TreeNode root) &#123;
     dfs(root);
     int[] ans=new int[answer.size()];
     for(int i=0;i&lt;answer.size();i++)&#123;
         ans[i]=answer.get(i);
     &#125;
     return ans;
 &#125;
 public void dfs(TreeNode root)&#123;
 //中序遍历 使得递增顺序
     if(root==null) return;
     dfs(root.left);
     update(root.val);
     dfs(root.right);
 &#125;
 public void update(int val)&#123;
     if(val==base)&#123;
         count++;
     &#125;else&#123;
         count=1;
         base=val;
     &#125;
     if(count==maxcount)&#123;
         answer.add(val);
     &#125;
     if(count&gt;maxcount)&#123;
         answer.clear();
         maxcount=count;
         answer.add(val);
     &#125;
 &#125;
</code></pre>
<p> }</p>
<pre><code>## 二叉树前序遍历
**递归**（本质栈）
</code></pre>
<p>class Solution {<br>     public List<Integer> preorderTraversal(TreeNode root) {<br>         List<Integer> res &#x3D; new ArrayList<Integer>();<br>         preorder(root, res);<br>         return res;<br>     }</Integer></Integer></Integer></p>
<pre><code> public void preorder(TreeNode root, List&lt;Integer&gt; res) &#123;
     if (root == null) &#123;
         return;
     &#125;
     res.add(root.val);
     preorder(root.left, res);
     preorder(root.right, res);
 &#125;
</code></pre>
<p> }</p>
<pre><code>**迭代**（利用栈）
</code></pre>
<p>class Solution {<br>     public List<Integer> preorderTraversal(TreeNode root) {<br>         List<Integer> res &#x3D; new ArrayList<Integer>();<br>         if (root &#x3D;&#x3D; null) {<br>             return res;<br>         }</Integer></Integer></Integer></p>
<pre><code>     Deque&lt;TreeNode&gt; stack = new LinkedList&lt;TreeNode&gt;();
     TreeNode node = root;
     //结束条件：栈为空且node为Null
     while (!stack.isEmpty() || node != null) &#123;
         //到达最左
         while (node != null) &#123;
             res.add(node.val);
             stack.push(node);
             node = node.left;
         &#125;
         //到达最左后，node为Null，此时要出栈（也就是返回父结点）
         node = stack.pop();
         //遍历右结点
         node = node.right;
     &#125;
     return res;
 &#125;
</code></pre>
<p> }</p>
<pre><code>**Morris 遍历**
[https://blog.csdn.net/liujia2115/article/details/109215284](https://blog.csdn.net/liujia2115/article/details/109215284)
</code></pre>
<p>class Solution {<br>     public List<Integer> preorderTraversal(TreeNode root) {<br>         return morrisMethod(root);<br>     }</Integer></p>
<pre><code> /**
  * Morris遍历
  * @param root
  * @return
  */
 private List&lt;Integer&gt; morrisMethod(TreeNode root) &#123;
     List&lt;Integer&gt; list = new ArrayList&lt;&gt;();
     if (root == null) &#123;
         return list;
     &#125;
     TreeNode cur = root;
     TreeNode mostRight = null;
     while (cur != null) &#123;
         mostRight = cur.left;
         if (mostRight != null) &#123; 
             //左子树最右结点 mostRight.right != cur防止循环回去了
             while (mostRight.right != null &amp;&amp; mostRight.right != cur) &#123;
                 mostRight = mostRight.right;
             &#125;
             //第一次来
             if (mostRight.right == null) &#123;
                 mostRight.right = cur;
                 list.add(cur.val); // 第一次到的时候打印
                 cur = cur.left;
                 continue;
             &#125; else &#123;//第二次来
                 mostRight.right = null; // 第二次到的时候不打印
             &#125;
         &#125; else &#123; // cur.left为空 直接add cur的值
             list.add(cur.val);
         &#125;
         cur = cur.right;
         &#125;
     return list;
 &#125;
</code></pre>
<p> }</p>
<pre><code>morris中序遍历就是在第一次到的时候不打印 第二次到的时候打印 list.add(cur.val);移到 mostRight.right = null; 后面
## 合并二叉树
![](https://raw.githubusercontent.com/viacheung/img/main/image/image-20221009174111479.png#from=url&amp;id=XEdCx&amp;originHeight=303&amp;originWidth=970&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=)
</code></pre>
<p>class Solution {<br>     public TreeNode mergeTrees(TreeNode root1, TreeNode root2) {<br>         if(root1 &#x3D;&#x3D; null) return root2;<br>         if(root2 &#x3D;&#x3D; null) return root1;<br>         TreeNode merged &#x3D; new TreeNode(root1.val + root2.val);&#x2F;&#x2F;返回结点<br>         merged.left&#x3D;mergeTrees(root1.left, root2.left);&#x2F;&#x2F;构造左边是啥<br>         merged.right&#x3D;mergeTrees(root1.right, root2.right);&#x2F;&#x2F;构造右边是啥<br>         return merged;<br>     }<br> }</p>
<pre><code>## 二叉搜索数转累加数
给出二叉 搜索 树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），使每个节点 node 的新值等于原树中大于或等于 node.val 的值之和。
</code></pre>
<p>class Solution {<br>     int sum &#x3D; 0;<br>     public TreeNode convertBST(TreeNode root) {<br>         dfs(root);<br>         return root;<br>     }<br>     void dfs(TreeNode node) {<br>         if (node &#x3D;&#x3D; null) return;<br>         dfs(node.right);<br>         sum +&#x3D; node.val;<br>         node.val &#x3D; sum;<br>         dfs(node.left);<br>     }<br> }</p>
<pre><code>我对于本题递归的理解：dfs(node.right)直接递归到最右下结点，sum=最右下结点的值，赋给最右下结点值， dfs(node.left); 判断为空 return出来
dfs(node.right)执行完毕，进入上一递归，此时为上一层根结点，然后sum += node.val;node.val = sum;此时算的是根结点的累加值，同理，dfs(node.left)；
递归不要人肉递归，还是要套模板，只需要关注![](https://raw.githubusercontent.com/viacheung/img/main/image/image-20221007210341362.png#from=url&amp;id=L7OCa&amp;originHeight=188&amp;originWidth=295&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=)
这一部分内容就行，让变量具有普适性
## 二叉树遍历题和二叉树展开为链表题的对比（均为迭代）
做二叉树首先要想到用递归（and迭代）
</code></pre>
<p>二叉树遍历<br> class Solution {<br>     public List<Integer> inorderTraversal(TreeNode root) {<br>         List<Integer> res &#x3D; new ArrayList<Integer>();<br>         Deque<TreeNode> stk &#x3D; new LinkedList<TreeNode>();<br>         while (root !&#x3D; null || !stk.isEmpty()) {<br>             while (root !&#x3D; null) {<br>                 stk.push(root);<br>                 root &#x3D; root.left;<br>             }<br>             root &#x3D; stk.pop();<br>             res.add(root.val);<br>             root &#x3D; root.right;<br>         }<br>         return res;<br>     }<br> }<br> 二叉树展开为链表<br>     class Solution {<br>         &#x2F;&#x2F;同中序遍历的题进行对比<br>         public void flatten(TreeNode root) {<br>             List<TreeNode> list &#x3D; new ArrayList&lt;&gt;();<br>             Deque<TreeNode> stk &#x3D; new LinkedList&lt;&gt;();<br>             while (root !&#x3D; null || !stk.isEmpty()) {<br>                 while (root !&#x3D; null) {<br>                     list.add(root);&#x2F;&#x2F;和中序比较多了这一行<br>                     stk.push(root);<br>                     root &#x3D; root.left;<br>                 }<br>                 root &#x3D; stk.pop();<br>                 &#x2F;&#x2F;少了一行list.add(root.val);<br>                 root &#x3D; root.right;<br>             }<br>             int size &#x3D; list.size();<br>             for (int i &#x3D; 1; i &lt; size; i++) {<br>                 TreeNode pre &#x3D; list.get(i - 1), cur &#x3D; list.get(i);<br>                 pre.left &#x3D; null;<br>                 pre.right &#x3D; cur;<br>             }</TreeNode></TreeNode></TreeNode></TreeNode></Integer></Integer></Integer></p>
<pre><code>     &#125;
</code></pre>
<pre><code>## 二叉树的最近公共祖先
![](https://raw.githubusercontent.com/viacheung/img/main/image/image-20220919202400688.png#from=url&amp;id=j4cbY&amp;originHeight=569&amp;originWidth=1108&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=)
</code></pre>
<p>*&#x2F;<br> class Solution {<br>     private TreeNode ans;<br>     public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {<br> &#x2F;&#x2F;        TreeNode ans&#x3D;null;   &#x2F;&#x2F;这一句不能有，有的话，ans&#x3D;root就无法覆盖ans的值，ans&#x3D;root只能识别到 private TreeNode ans;   如果有的话 下面必须return this.ans才行 把外面的引进来作为成员变量<br>         dfs(root,p,q);<br>         return ans;&#x2F;&#x2F;想引用外面的变量需要加this.<br>     }<br>     private boolean dfs(TreeNode root, TreeNode p, TreeNode q){<br>         if(root&#x3D;&#x3D;null) return false;<br>         boolean lson&#x3D;dfs(root.left,p,q);&#x2F;&#x2F;这里必须加数据类型呀，因为lson rson第一次出现，都没初始化呢，要指定其数据类型<br>         boolean rson&#x3D;dfs(root.right,p,q);<br>         if((lson&amp;&amp;rson)||(p.val&#x3D;&#x3D;root.val||q.val&#x3D;&#x3D;root.val)&amp;&amp;(lson||rson)){<br>             ans&#x3D;root;<br>             System.out.println(ans);<br>         }<br>         return root.val&#x3D;&#x3D;p.val||root.val&#x3D;&#x3D;q.val||lson||rson;<br>     }<br> }</p>
<pre><code>## 二叉搜索树最近公共祖先
方法一：不用二叉搜索树的性质，直接用二叉树的也可以过。
**方法二：一次遍历**
![](https://raw.githubusercontent.com/viacheung/img/main/image/image-20221107120758813.png#from=url&amp;id=lNLxA&amp;originHeight=569&amp;originWidth=850&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=)
</code></pre>
<p>class Solution {<br>     public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {<br>         TreeNode ancestor &#x3D; root;<br>         while (true) {<br>             if (p.val &lt; ancestor.val &amp;&amp; q.val &lt; ancestor.val) {<br>                 ancestor &#x3D; ancestor.left;<br>             } else if (p.val &gt; ancestor.val &amp;&amp; q.val &gt; ancestor.val) {<br>                 ancestor &#x3D; ancestor.right;<br>             } else {<br>                 break;<br>             }<br>         }<br>         return ancestor;<br>     }<br> }</p>
<pre><code>## 二叉搜索树中的插入操作
给定二叉搜索树（BST）的根节点 root 和要插入树中的值 value ，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据 **保证** ，新值和原始二叉搜索树中的任意节点值都不同。
**注意**，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回 **任意有效的结果** 。
</code></pre>
<p>class Solution {<br>     public TreeNode insertIntoBST(TreeNode root, int val) {<br>         &#x2F;&#x2F;为空建一个返回<br>         if(root&#x3D;&#x3D;null) return new TreeNode(val);<br>         dfs(root,val);<br>         return root;<br>     }<br>     public void dfs(TreeNode root, int val){<br>         &#x2F;&#x2F;大于的话 需要插入到左子树 看左节点是否为空，空的话直接加入，然后返回， 否则递归到左子树<br>         if(root.val&gt;val){<br>             if(root.left&#x3D;&#x3D;null){<br>                 root.left&#x3D;new TreeNode(val);<br>                 return;<br>             }<br>             dfs(root.left,val);<br>         }else{<br>             if(root.right&#x3D;&#x3D;null){<br>                 root.right&#x3D;new TreeNode(val);<br>                 return;<br>             }<br>             dfs(root.right,val);<br>         }<br>     }<br> }</p>
<pre><code>## 删除二叉搜索树的节点
![](https://raw.githubusercontent.com/viacheung/img/main/image/image-20221108190047074.png#from=url&amp;id=FBOgA&amp;originHeight=189&amp;originWidth=1029&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=)
</code></pre>
<p>class Solution {<br>     public TreeNode deleteNode(TreeNode root, int key) {<br>         if(root&#x3D;&#x3D;null) return null;<br>         if(key&lt;root.val){<br>             root.left&#x3D;deleteNode(root.left,key);<br>             return root;<br>         }<br>         if(key&gt;root.val){<br>             root.right&#x3D;deleteNode(root.right,key);<br>             return root;<br>         }<br>         &#x2F;&#x2F;key&#x3D;&#x3D;root.val<br>         &#x2F;&#x2F;左右都空<br>         if(key&#x3D;&#x3D;root.val){<br>             if(root.right&#x3D;&#x3D;null&amp;&amp;root.left&#x3D;&#x3D;null){<br>                 return null;<br>             }<br>             &#x2F;&#x2F;左子树为空<br>             if(root.left&#x3D;&#x3D;null){<br>                 return root.right;<br>             }<br>             &#x2F;&#x2F;右子树为空<br>             if(root.right&#x3D;&#x3D;null){<br>                 return root.left;<br>             }<br>             &#x2F;&#x2F;左右都不为空<br>             if(root.right!&#x3D;null&amp;&amp;root.left!&#x3D;null){<br>                 &#x2F;&#x2F;寻找左子树最大结点值val<br>                 int val&#x3D;getMaxInLeft(root.left);<br>                 &#x2F;&#x2F;对根节点赋值val<br>                 root.val&#x3D;val;<br>                 &#x2F;&#x2F;删除等于val的那个结点，并更新左结点<br>                 root.left&#x3D;deleteNode(root.left,val);<br>                 return root;<br>             }<br>         }<br>         return root;</p>
<pre><code> &#125;
  //找到左子树中最大的值
 public int getMaxInLeft(TreeNode root)&#123;
     //递归
     // if(root.right==null&amp;&amp;root.left==null) return root.val;
     // //右子树为空 必然最大的就是根节点
     // if(root.right==null) return root.val;
     // return getMaxInLeft(root.right);
     TreeNode node=root;
     while(node.right!=null)&#123;
         node=node.right;
     &#125;
     return node.val;
 &#125;
</code></pre>
<pre><code>## 修剪二叉搜索树
给你二叉搜索树的根节点 root ，同时给定最小边界low 和最大边界 high。通过修剪二叉搜索树，使得所有节点的值在[low, high]中。修剪树 **不应该** 改变保留在树中的元素的相对结构 (即，如果没有被移除，原有的父代子代关系都应当保留)。 可以证明，存在 **唯一的答案** 。
所以结果应当返回修剪好的二叉搜索树的新的根节点。注意，根节点可能会根据给定的边界发生改变。
![](https://raw.githubusercontent.com/viacheung/img/main/image/image-20221109113639092.png#from=url&amp;id=YMNuv&amp;originHeight=217&amp;originWidth=821&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=)
</code></pre>
<p>class Solution {<br>     public TreeNode trimBST(TreeNode root, int low, int high) {<br>         &#x2F;&#x2F;在根结点把三种情况解决掉了 套用递归解决问题<br>         if(root&#x3D;&#x3D;null) return null;<br>         if(root.val&gt;high){<br>             return trimBST(root.left,low,high);<br>         }else if(root.val&lt;low){<br>             return trimBST(root.right,low,high);<br>         }else{<br>             root.right&#x3D;trimBST(root.right,low,high);<br>             root.left&#x3D;trimBST(root.left,low,high);<br>             return root;<br>         }<br>     }<br> }</p>
<pre><code>## 将有序数组转换为二叉搜索树
给你一个整数数组 nums ，其中元素已经按 **升序** 排列，请你将其转换为一棵 **高度平衡** 二叉搜索树。
**高度平衡** 二叉树是一棵满足「每个节点的左右两个子树的高度差的绝对值不超过 1 」的二叉树。
</code></pre>
<p>class Solution {</p>
<pre><code> public TreeNode sortedArrayToBST(int[] nums) &#123;
     return dfs(nums,0,nums.length-1);
 &#125;
 public TreeNode dfs(int[] nums,int begin,int end)&#123;
     //越界返回空
     if(begin&gt;end) return null;
     //二分确定根结点
     int index=(begin+end)/2;
     int val=nums[index];
     //创建结点
     TreeNode root=new TreeNode(val);
     //递归  创建树
     root.right=dfs(nums,index+1,end);
     root.left=dfs(nums,begin,index-1);
     return root;
 &#125;
</code></pre>
<p> }</p>
<pre><code>## 把二叉搜索树转换为累加树
给出二叉 **搜索** 树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），使每个节点 node 的新值等于原树中大于或等于 node.val 的值之和。
提醒一下，二叉搜索树满足下列约束条件：

- 节点的左子树仅包含键 **小于** 节点键的节点。
- 节点的右子树仅包含键 **大于** 节点键的节点。
- 左右子树也必须是二叉搜索树。

**方法一：反序中序遍历**
思路及算法
本题中要求我们将每个节点的值修改为原来的节点值加上所有大于它的节点值之和。这样我们只需要反序中序遍历该二叉搜索树，记录过程中的节点值之和，并不断更新当前遍历到的节点的节点值，即可得到题目要求的累加树。
</code></pre>
<p>class Solution {<br>     int sum&#x3D;0;<br>     public TreeNode convertBST(TreeNode root) {<br>         dfs(root);<br>         return root;<br>     }<br>     public void dfs(TreeNode root){<br>         if(root&#x3D;&#x3D;null) return;<br>         dfs(root.right);<br>         sum+&#x3D;root.val;<br>         root.val&#x3D;sum;<br>         dfs(root.left);<br>     }<br> }</p>
<pre><code>## 翻转二叉树
**递归**
深度优先
![](https://raw.githubusercontent.com/viacheung/img/main/image/0f91f7cbf5740de86e881eb7427c6c3993f4eca3624ca275d71e21c5e3e2c550-226_2.gif#from=url&amp;id=jhlMl&amp;originHeight=543&amp;originWidth=773&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=)
</code></pre>
<p>自顶向下(好理解  优先这个)<br> class Solution {<br>     public TreeNode invertTree(TreeNode root) {<br>         &#x2F;&#x2F;递归函数的终止条件，节点为空时返回<br>         if(root&#x3D;&#x3D;null) {<br>             return null;<br>         }<br>         &#x2F;&#x2F;下面三句是将当前节点的左右子树交换<br>         TreeNode tmp &#x3D; root.right;<br>         root.right &#x3D; root.left;<br>         root.left &#x3D; tmp;<br>         &#x2F;&#x2F;递归交换当前节点的 左子树<br>         invertTree(root.left);<br>         &#x2F;&#x2F;递归交换当前节点的 右子树<br>         invertTree(root.right);<br>         &#x2F;&#x2F;函数返回时就表示当前这个节点，以及它的左右子树<br>         &#x2F;&#x2F;都已经交换完了<br>         return root;<br>     }<br> }<br> 自底向上(代码简洁)<br> class Solution {<br>     public TreeNode invertTree(TreeNode root) {<br>         if (root &#x3D;&#x3D; null) {<br>             return null;<br>         }<br>         TreeNode left &#x3D; invertTree(root.left);<br>         TreeNode right &#x3D; invertTree(root.right);<br>         root.left &#x3D; right;<br>         root.right &#x3D; left;<br>         return root;<br>     }<br> }</p>
<pre><code>**迭代**
广度优先
![](https://raw.githubusercontent.com/viacheung/img/main/image/f9e06159617cbf8372b544daee37be70286c3d9b762c016664e225044fc4d479-226_%E8%BF%AD%E4%BB%A3.gif#from=url&amp;id=VSsgm&amp;originHeight=700&amp;originWidth=905&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=)
</code></pre>
<p>class Solution {<br>     public TreeNode invertTree(TreeNode root) {<br>         if(root&#x3D;&#x3D;null) {<br>             return null;<br>         }<br>         &#x2F;&#x2F;将二叉树中的节点逐层放入队列中，再迭代处理队列中的元素<br>         LinkedList<TreeNode> queue &#x3D; new LinkedList<TreeNode>();<br>         queue.add(root);<br>         while(!queue.isEmpty()) {<br>             &#x2F;&#x2F;每次都从队列中拿一个节点，并交换这个节点的左右子树<br>             TreeNode tmp &#x3D; queue.poll();<br>             TreeNode left &#x3D; tmp.left;<br>             tmp.left &#x3D; tmp.right;<br>             tmp.right &#x3D; left;<br>             &#x2F;&#x2F;如果当前节点的左子树不为空，则放入队列等待后续处理<br>             if(tmp.left!&#x3D;null) {<br>                 queue.add(tmp.left);<br>             }<br>             &#x2F;&#x2F;如果当前节点的右子树不为空，则放入队列等待后续处理<br>             if(tmp.right!&#x3D;null) {<br>                 queue.add(tmp.right);<br>             }</TreeNode></TreeNode></p>
<pre><code>     &#125;
     //返回处理完的根节点
     return root;
 &#125;
</code></pre>
<p> }</p>
<pre><code>## 二叉树的序列化和反序列化
题目：
![](https://raw.githubusercontent.com/viacheung/img/main/image/image-20220923172523030.png#from=url&amp;id=ofY5U&amp;originHeight=219&amp;originWidth=987&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=)
算法：
![](https://raw.githubusercontent.com/viacheung/img/main/image/image-20220923172455790.png#from=url&amp;id=OkRty&amp;originHeight=373&amp;originWidth=1118&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=)
![](https://raw.githubusercontent.com/viacheung/img/main/image/image-20220923172606089.png#from=url&amp;id=gsjbZ&amp;originHeight=381&amp;originWidth=1028&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=)
</code></pre>
<p>public class Codec {<br>     public String serialize(TreeNode root) {<br>         return rserialize(root, “”);<br>     }</p>
<pre><code> public TreeNode deserialize(String data) &#123;
     String[] dataArray = data.split(&quot;,&quot;);
     List&lt;String&gt; dataList = new LinkedList&lt;String&gt;(Arrays.asList(dataArray));
     return rdeserialize(dataList);
 &#125;

 public String rserialize(TreeNode root, String str) &#123;
     if (root == null) &#123;
         str += &quot;None,&quot;;
     &#125; else &#123;
         str += str.valueOf(root.val) + &quot;,&quot;;//或者这样写 str+=String.valueOf(root.val)+&quot;,&quot;;  把root.val转成String类型
         str = rserialize(root.left, str);
         str = rserialize(root.right, str);
     &#125;
     return str;
 &#125;

 public TreeNode rdeserialize(List&lt;String&gt; dataList) &#123;
     if (dataList.get(0).equals(&quot;None&quot;)) &#123;
         dataList.remove(0);
         return null;
     &#125;

     TreeNode root = new TreeNode(Integer.valueOf(dataList.get(0)));
     dataList.remove(0);
     root.left = rdeserialize(dataList);
     root.right = rdeserialize(dataList);
 
     return root;
 &#125;
</code></pre>
<p> }</p>
<pre><code>## 总结
![img](https://raw.githubusercontent.com/viacheung/img/main/image/20211030125421.png)![](https://raw.githubusercontent.com/viacheung/img/main/image/20211030125421.png#from=url&amp;id=XlSHO&amp;originHeight=1050&amp;originWidth=1660&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=)
## 二叉树的前序遍历
1、递归
</code></pre>
<p>public class Solution {<br>     &#x2F;**<br>      * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可<br>      *<br>      *<br>      * @param root TreeNode类<br>      * @return int整型一维数组<br>      *&#x2F;<br>     List<Integer> ans&#x3D;new ArrayList&lt;&gt;();;<br>     public int[] preorderTraversal (TreeNode root) {<br>         &#x2F;&#x2F; write code here<br>         dfs(root);<br>         int[] res&#x3D;new int[ans.size()];<br>         for(int i&#x3D;0;i&lt;ans.size();i++){<br>             res[i]&#x3D;ans.get(i);<br>         }<br>         return res;</Integer></p>
<pre><code> &#125;
 public void dfs(TreeNode root)&#123;
     if(root==null) return;
     ans.add(root.val);
     dfs(root.left);
     dfs(root.right);
 &#125;
</code></pre>
<p> }</p>
<pre><code>2、迭代
![](https://raw.githubusercontent.com/viacheung/img/main/image/717C18C1D3175AB683DE7E050A4236ED#from=url&amp;id=GQb4Z&amp;originHeight=1506&amp;originWidth=2682&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=)
</code></pre>
<p>public int[] preorderTraversal (TreeNode root) {<br>         List<Integer> ans&#x3D;new ArrayList&lt;&gt;();<br>         Stack<TreeNode> stack&#x3D;new Stack&lt;&gt;();<br>         &#x2F;&#x2F; 判空<br>         if(root&#x3D;&#x3D;null) return new int[0];<br>         stack.push(root);<br>         while(!stack.isEmpty()){<br>             TreeNode node&#x3D;stack.pop();<br>             ans.add(node.val);<br>             &#x2F;&#x2F; 栈先进后出<br>             if(node.right!&#x3D;null) stack.push(node.right);<br>             if(node.left!&#x3D;null) stack.push(node.left);<br>         }<br>         int[] finnal_ans&#x3D;new int[ans.size()];<br>         for(int i&#x3D;0;i&lt;ans.size();i++){<br>             finnal_ans[i]&#x3D;ans.get(i);<br>         }<br>         return finnal_ans;<br>     }</TreeNode></Integer></p>
<pre><code>## 二叉树中序遍历
### 递归
换个顺序就行
### 迭代
![](https://raw.githubusercontent.com/viacheung/img/main/image/23368751A430C010C582743B0E2F9414#from=url&amp;id=Y5GO6&amp;originHeight=1530&amp;originWidth=2390&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=)
</code></pre>
<p>public class Solution {<br>     &#x2F;**<br>      * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可<br>      *<br>      *<br>      * @param root TreeNode类<br>      * @return int整型一维数组<br>      *&#x2F;<br>     public int[] inorderTraversal (TreeNode root) {<br>         &#x2F;&#x2F; write code here<br>         List<Integer> list&#x3D;new ArrayList&lt;&gt;();<br>         Stack<TreeNode> stack&#x3D;new Stack&lt;&gt;();<br>         if(root&#x3D;&#x3D;null) return new int[0];<br>         while(!stack.isEmpty()||root!&#x3D;null){<br>             while(root!&#x3D;null){<br>                 stack.push(root);<br>                 root&#x3D;root.left;<br>             }<br>             TreeNode node&#x3D;stack.pop();<br>             list.add(node.val);<br>             root&#x3D;node.right;<br>         }<br>         int[] res&#x3D;new int[list.size()];<br>         for(int i&#x3D;0;i&lt;list.size();i++){<br>             res[i]&#x3D;list.get(i);<br>         }<br>         return res;<br>     }<br> }</TreeNode></Integer></p>
<pre><code>## 二叉树的后序遍历
### 迭代

- step 1：开辟一个辅助栈，用于记录要访问的子节点，开辟一个前序指针pre。
- step 2：从根节点开始，每次优先进入每棵的子树的最左边一个节点，我们将其不断加入栈中，用来保存父问题。
- step 3：弹出一个栈元素，看成该子树的根，判断这个根的右边有没有节点或是有没有被访问过，如果没有右节点或是被访问过了，可以访问这个根，并将前序节点标记为这个根。
- step 4：如果没有被访问，那这个根必须入栈，进入右子树继续访问，只有右子树结束了回到这里才能继续访问根。

![](https://raw.githubusercontent.com/viacheung/img/main/image/05EE17BA6FA1FB90EDDEF5A26D0FEEF4#from=url&amp;id=lTtZd&amp;originHeight=1560&amp;originWidth=2618&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=)
</code></pre>
<p>import java.util.*;</p>
<p> &#x2F;*</p>
<ul>
<li>public class TreeNode {</li>
<li>int val &#x3D; 0;</li>
<li>TreeNode left &#x3D; null;</li>
<li>TreeNode right &#x3D; null;</li>
<li>public TreeNode(int val) {</li>
<li><pre><code>this.val = val;
</code></pre>
</li>
<li>}</li>
<li>}<br>  *&#x2F;</li>
</ul>
<p> public class Solution {<br>     &#x2F;**<br>      * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可<br>      *<br>      *<br>      * @param root TreeNode类<br>      * @return int整型一维数组<br>      *&#x2F;<br>     public int[] postorderTraversal (TreeNode root) {<br>         &#x2F;&#x2F; write code here<br>         &#x2F;&#x2F; 牢记栈的特性  先入栈后访问<br>         TreeNode pre&#x3D;null;&#x2F;&#x2F;标记这个是访问过的前序节点<br>         List<Integer> list&#x3D;new ArrayList&lt;&gt;();<br>         Stack<TreeNode> stack&#x3D;new Stack&lt;&gt;();<br>         while(!stack.isEmpty()||root!&#x3D;null){<br>             &#x2F;&#x2F; 找最左边节点<br>             while(root!&#x3D;null){<br>                 stack.push(root);<br>                 root&#x3D;root.left;<br>             }<br>             TreeNode node&#x3D;stack.pop();<br>             &#x2F;&#x2F; 如果右节点为空或者已经被访问了<br>             if(node.right&#x3D;&#x3D;null||node.right&#x3D;&#x3D;pre){<br>                 list.add(node.val);<br>                 pre&#x3D;node;<br>             }else{<br>                 &#x2F;&#x2F;该节点入栈<br>                 stack.push(node);<br>                 &#x2F;&#x2F;先访问右边<br>                 root&#x3D;node.right;<br>             }<br>         }<br>         int[] res&#x3D;new int[list.size()];<br>         for(int i&#x3D;0;i&lt;list.size();i++){<br>             res[i]&#x3D;list.get(i);<br>         }<br>         return res;<br>     }<br> }</TreeNode></Integer></p>
<pre><code>## 求二叉树的层序遍历

- step 1：首先判断二叉树是否为空，空树没有遍历结果。
- step 2：建立辅助队列，根节点首先进入队列。不管层次怎么访问，根节点一定是第一个，那它肯定排在队伍的最前面。
- step 3：每次进入一层，统计队列中元素的个数。因为每当访问完一层，下一层作为这一层的子节点，一定都加入队列，而再下一层还没有加入，因此此时队列中的元素个数就是这一层的元素个数。
- step 4：每次遍历这一层这么多的节点数，将其依次从队列中弹出，然后加入这一行的一维数组中，如果它们有子节点，依次加入队列排队等待访问。
- step 5：访问完这一层的元素后，将这个一维数组加入二维数组中，再访问下一层。

![](https://raw.githubusercontent.com/viacheung/img/main/image/07986E476EB2CECD3C5F81D0BCADBE12#from=url&amp;id=g6qHU&amp;originHeight=1080&amp;originWidth=1920&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=)
### 迭代
</code></pre>
<p>import java.util.*;</p>
<p> &#x2F;*</p>
<ul>
<li>public class TreeNode {</li>
<li>int val &#x3D; 0;</li>
<li>TreeNode left &#x3D; null;</li>
<li>TreeNode right &#x3D; null;</li>
<li>}<br>  *&#x2F;</li>
</ul>
<p> public class Solution {<br>     &#x2F;**<br>      *<br>      * @param root TreeNode类<br>      * @return int整型ArrayList&lt;ArrayList&lt;&gt;&gt;<br>      *&#x2F;<br>     public ArrayList&lt;ArrayList<Integer>&gt; levelOrder (TreeNode root) {<br>         &#x2F;&#x2F; write code here<br>         Queue<TreeNode> queue&#x3D;new LinkedList&lt;&gt;();<br>         ArrayList&lt;ArrayList<Integer>&gt; ans&#x3D;new ArrayList();<br>          &#x2F;&#x2F;如果是空，则直接返回空数组<br>         if(root&#x3D;&#x3D;null) return ans;<br>         &#x2F;&#x2F; 根加进去<br>         queue.add(root);<br>         while(!queue.isEmpty()){<br>             &#x2F;&#x2F; 当前层个数<br>             int n&#x3D;queue.size();<br>             &#x2F;&#x2F; 当前层的集合<br>             ArrayList<Integer> temp &#x3D; new ArrayList();<br>             for(int i&#x3D;0;i&lt;n;i++){<br>                 &#x2F;&#x2F; poll出来<br>                 TreeNode node&#x3D;queue.poll();<br>                 temp.add(node.val);<br>                 &#x2F;&#x2F;若是左右孩子存在，则存入左右孩子作为下一个层次<br>                 if(node.left!&#x3D;null) queue.add(node.left);<br>                 if(node.right!&#x3D;null) queue.add(node.right);<br>             }<br>             &#x2F;&#x2F; 每一层加进结果集<br>             ans.add(temp);<br>         }<br>         return ans;<br>     }<br> }</Integer></Integer></TreeNode></Integer></p>
<pre><code>## 按之字形顺序打印二叉树
给定一个二叉树，返回该二叉树的之字形层序遍历，（第一层从左向右，下一层从右向左，一直这样交替）
和二叉树层序遍历一样 无非就是加一个flag进行一个奇偶判断
注意一个API 
 Collections.reverse();//反转集合
</code></pre>
<p>import java.util.*;</p>
<p> &#x2F;*<br> public class TreeNode {<br>     int val &#x3D; 0;<br>     TreeNode left &#x3D; null;<br>     TreeNode right &#x3D; null;</p>
<pre><code> public TreeNode(int val) &#123;
     this.val = val;

 &#125;
</code></pre>
<p> }<br> *&#x2F;<br> public class Solution {<br>     public ArrayList&lt;ArrayList<Integer> &gt; Print(TreeNode pRoot) {<br>         Queue<TreeNode> queue&#x3D;new LinkedList&lt;&gt;();<br>         ArrayList&lt;ArrayList<Integer>&gt; ans&#x3D;new ArrayList();<br>          &#x2F;&#x2F;如果是空，则直接返回空数组<br>         if(pRoot&#x3D;&#x3D;null) return ans;<br>         &#x2F;&#x2F; 根加进去<br>         queue.add(pRoot);<br>         boolean flag&#x3D;true;<br>         while(!queue.isEmpty()){<br>             &#x2F;&#x2F; 当前层个数<br>             int n&#x3D;queue.size();<br>             &#x2F;&#x2F; 当前层的集合<br>             ArrayList<Integer> temp &#x3D; new ArrayList();<br>             for(int i&#x3D;0;i&lt;n;i++){<br>                 &#x2F;&#x2F; poll出来<br>                 TreeNode node&#x3D;queue.poll();<br>                 temp.add(node.val);<br>                 &#x2F;&#x2F;若是左右孩子存在，则存入左右孩子作为下一个层次<br>                 if(node.left!&#x3D;null) queue.add(node.left);<br>                 if(node.right!&#x3D;null) queue.add(node.right);<br>             }<br>             &#x2F;&#x2F; 每一层加进结果集<br>             if(flag) ans.add(temp);<br>             else {<br>                 Collections.reverse(temp);<br>                 ans.add(temp);<br>             }<br>             flag&#x3D;!flag;<br>         }<br>         return ans;<br>     }</Integer></Integer></TreeNode></Integer></p>
<p> }</p>
<pre><code>## 求根节点到叶节点数字之和
给你一个二叉树的根节点 root ，树中每个节点都存放有一个 0 到 9 之间的数字。
每条从根节点到叶节点的路径都代表一个数字：

- 例如，从根节点到叶节点的路径 1 -&gt; 2 -&gt; 3 表示数字 123 。

计算从根节点到叶节点生成的 **所有数字之和** 。
**叶节点** 是指没有子节点的节点。
</code></pre>
<p>&#x2F;&#x2F;  思路 我把这题类比二叉树的所有路径那题  append的时候简单了 不用加&#x3D;&gt;  最后用一下Integer.parseInt(s)把字符串转为数字 然后求和就行！<br> class Solution {<br>     List<String> ans&#x3D;new ArrayList&lt;&gt;();<br>     int sum&#x3D;0;<br>     public int sumNumbers(TreeNode root) {<br>         StringBuilder sb&#x3D;new StringBuilder();<br>         dfs(root,sb);<br>         for(String s:ans){<br>             int i&#x3D;Integer.parseInt(s);<br>             sum+&#x3D;i;<br>         }<br>         return sum;<br>     }<br>     public void dfs(TreeNode root,StringBuilder sb){<br>         if(root&#x3D;&#x3D;null) return;<br>         sb.append(root.val);<br>         if(root.right&#x3D;&#x3D;null&amp;&amp;root.left&#x3D;&#x3D;null){<br>             ans.add(sb.toString());<br>         }<br>         dfs(root.left,new StringBuilder(sb));<br>         dfs(root.right,new StringBuilder(sb));<br>     }<br> }</String></p>
<pre><code>## 将二叉搜索树变平衡
给你一棵二叉搜索树，请你返回一棵 **平衡后** 的二叉搜索树，新生成的树应该与原来的树有着相同的节点值。如果有多种构造方法，请你返回任意一种。
如果一棵二叉搜索树中，每个节点的两棵子树高度差不超过 1 ，我们就称这棵二叉搜索树是 **平衡的** 。
题解 中序遍历把二叉树转变为有序数组，然后在根据有序数组构造平衡二叉搜索树。
</code></pre>
<p>class Solution {<br>     List<Integer> res&#x3D;new ArrayList&lt;&gt;();<br>     public TreeNode balanceBST(TreeNode root) {<br>         &#x2F;&#x2F; 中序遍历把二叉树转变为有序数组，然后在根据有序数组构造平衡二叉搜索树。<br>         tranval(root);<br>         return getTree(0,res.size()-1);<br>     }<br>     &#x2F;&#x2F; 有序树转成有序数组<br>     public void tranval(TreeNode root){<br>         if(root&#x3D;&#x3D;null) return;<br>         tranval(root.left);<br>         res.add(root.val);<br>         tranval(root.right);<br>     }<br>     &#x2F;&#x2F; 有序数组转成平衡二叉树<br>     public TreeNode getTree(int left,int right){<br>         if(left&gt;right) return null;<br>         &#x2F;&#x2F; 二分<br>         int mid&#x3D;(left+right)&#x2F;2;<br>         &#x2F;&#x2F; 创建结点<br>         TreeNode root&#x3D;new TreeNode(res.get(mid));<br>         root.left&#x3D;getTree(left,mid-1);<br>         root.right&#x3D;getTree(mid+1,right);<br>         return root;<br>     }<br> }</Integer></p>
<pre><code>## 相同的树
给你两棵二叉树的根节点 p 和 q ，编写一个函数来检验这两棵树是否相同。
如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。
题解:和对称树基本一样
</code></pre>
<p>class Solution {<br>     public boolean isSameTree(TreeNode p, TreeNode q) {<br>         if(p&#x3D;&#x3D;null&amp;&amp;q&#x3D;&#x3D;null) return true;<br>         if(p&#x3D;&#x3D;null||q&#x3D;&#x3D;null) return false;<br>         return p.val&#x3D;&#x3D;q.val&amp;&amp;isSameTree(p.left,q.left)&amp;&amp;isSameTree(p.right,q.right);<br>     }<br> }</p>
<pre><code>## 填充每个节点的下一个右侧节点指针
给定一个 **完美二叉树** ，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：
填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。
初始状态下，所有 next 指针都被设置为 NULL。
题解：递归
</code></pre>
<p>if (cur.left !&#x3D; null) cur.left.next &#x3D; cur.right; &#x2F;&#x2F; 操作1<br>         if (cur.right !&#x3D; null) {<br>             if(cur.next !&#x3D; null) cur.right.next &#x3D; cur.next.left; &#x2F;&#x2F;操作2<br>             else cur.right.next &#x3D; null;<br>         }</p>
<pre><code>最终答案
</code></pre>
<p>&#x2F;&#x2F; 递归法<br> class Solution {<br>     public void traversal(Node cur) {<br>         if (cur &#x3D;&#x3D; null) return;<br>         if (cur.left !&#x3D; null) cur.left.next &#x3D; cur.right; &#x2F;&#x2F; 操作1<br>         if (cur.right !&#x3D; null) {<br>             if(cur.next !&#x3D; null) cur.right.next &#x3D; cur.next.left; &#x2F;&#x2F;操作2<br>             else cur.right.next &#x3D; null;<br>         }<br>         traversal(cur.left);  &#x2F;&#x2F; 左<br>         traversal(cur.right); &#x2F;&#x2F;右<br>     }<br>     public Node connect(Node root) {<br>         traversal(root);<br>         return root;<br>     }<br> }</p>
<pre><code>## **二叉树中和为某一值的路径(一)**
给定一个二叉树root和一个值 sum ，判断是否有从根节点到叶子节点的节点值之和等于 sum 的路径。
</code></pre>
<p>import java.util.*;</p>
<p> &#x2F;*</p>
<ul>
<li>public class TreeNode {</li>
<li>int val &#x3D; 0;</li>
<li>TreeNode left &#x3D; null;</li>
<li>TreeNode right &#x3D; null;</li>
<li>}<br>  *&#x2F;</li>
</ul>
<p> public class Solution {<br>     &#x2F;**<br>      *<br>      * @param root TreeNode类<br>      * @param sum int整型<br>      * @return bool布尔型<br>      *&#x2F;<br>     public boolean hasPathSum (TreeNode root, int sum) {<br>         &#x2F;&#x2F; write code here<br>         if(root&#x3D;&#x3D;null) return false;<br>         if(root.right&#x3D;&#x3D;null&amp;&amp;root.left&#x3D;&#x3D;null&amp;&amp;sum-root.val&#x3D;&#x3D;0) return true;<br>         return hasPathSum(root.left,sum-root.val)||hasPathSum(root.right,sum-root.val);<br>     }</p>
<p> }</p>
<pre><code>## 二叉搜索树与双向链表
输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表
**思路：**
二叉搜索树最左端的元素一定最小，最右端的元素一定最大，符合“左中右”的特性，因此二叉搜索树的中序遍历就是一个递增序列，我们只要对它中序遍历就可以组装称为递增双向链表。每次遍历的时候构造好双向链表，注意次序；
**具体做法：**

- step 1：创建两个指针，一个指向题目中要求的链表头（head），一个指向当前遍历的前一节点（pre)。
- step 2：首先递归到最左，初始化head与pre。
- step 3：然后处理中间根节点，依次连接pre与当前节点，连接后更新pre为当前节点。
- step 4：最后递归进入右子树，继续处理。
- step 5：递归出口即是节点为空则返回。
</code></pre>
<p>public class Solution {<br>     &#x2F;&#x2F;返回的第一个指针，即为最小值，先定为null<br>     public TreeNode head &#x3D; null;<br>     &#x2F;&#x2F;中序遍历当前值的上一位，初值为最小值，先定为null<br>     public TreeNode pre &#x3D; null;<br>     public TreeNode Convert(TreeNode pRootOfTree) {<br>         if(pRootOfTree&#x3D;&#x3D;null) return null;<br>         &#x2F;&#x2F; 首先递归到最左最小值  中序的顺序<br>         Convert(pRootOfTree.left);<br>         &#x2F;&#x2F;初始化<br>         if(pre&#x3D;&#x3D;null){<br>             pre&#x3D;pRootOfTree;<br>             head&#x3D;pRootOfTree;&#x2F;&#x2F;初始化头结点<br>         }<br>         else {<br>             &#x2F;&#x2F;总之保证Pre在pRootOfTree的前面<br>             pre.right&#x3D;pRootOfTree;<br>             pRootOfTree.left&#x3D;pre;<br>             pre&#x3D;pRootOfTree;<br>         }<br>         Convert(pRootOfTree.right);<br>         return head;<br>     }<br> }</p>
<pre><code># BFS&amp;DFS
DFS 遍历使用递归：
</code></pre>
<p>void dfs(TreeNode root) {<br>    if (root &#x3D;&#x3D; null) {<br>        return;<br>    }<br>    dfs(root.left);&#x2F;&#x2F;递归到最后一层最左边节点，左右节点为空，return出来，到最后一层第二个节点<br>    dfs(root.right);<br>}</p>
<pre><code>BFS 遍历使用队列数据结构：
</code></pre>
<p>void bfs(TreeNode root) {<br>    Queue<TreeNode> queue &#x3D; new ArrayDeque&lt;&gt;();<br>    queue.add(root);<br>    while (!queue.isEmpty()) {<br>        TreeNode node &#x3D; queue.poll(); &#x2F;&#x2F; Java 的 pop 写作 poll()<br>        if (node.left !&#x3D; null) {<br>            queue.add(node.left);&#x2F;&#x2F;队列先进后出，所以是按层往外扩，一直从左往右遍历<br>        }<br>        if (node.right !&#x3D; null) {<br>            queue.add(node.right);<br>        }<br>    }<br>}</TreeNode></p>
<pre><code>![](https://raw.githubusercontent.com/viacheung/img/main/image/fdcd3bd27f4008948084f6ec86b58535e71f66862bd89a34bd6fe4cc42d68e89-16578569951531.gif#from=url&amp;id=z1lRO&amp;originHeight=500&amp;originWidth=1200&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=)
## **BFS 的应用一：层序遍历**
给定一个二叉树，返回其按层序遍历得到的节点值。 层序遍历即逐层地、从左到右访问所有结点。
层序遍历要求的输入结果和 BFS 是不同的。层序遍历要求我们区分每一层，也就是返回一个二维数组。而 BFS 的遍历结果是一个一维数组，无法区分每一层。
![](https://raw.githubusercontent.com/viacheung/img/main/image/fd1d63037d0e2f787d2140fee406e109094a4f66ab0837a7273f8b371eef8096.jpg#from=url&amp;id=PiTE8&amp;originHeight=500&amp;originWidth=1200&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=)
截取 BFS 遍历过程中的某个时刻：
![](https://raw.githubusercontent.com/viacheung/img/main/image/4529bf559c6a2d84d550eebaee027c3b7ae25069e4ec91f27b29a4c6358d6662.gif#from=url&amp;id=upSXy&amp;originHeight=500&amp;originWidth=1200&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=)
BFS 遍历中某个时刻队列的状态
![](https://raw.githubusercontent.com/viacheung/img/main/image/9f178b56ff1c94388d893f2fb48e9e77e186aba7cfd7483637776359062d68b8.jpg#from=url&amp;id=vTrDJ&amp;originHeight=500&amp;originWidth=1200&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=)
可以看到，此时队列中的结点是 3、4、5，分别来自第 1 层和第 2 层。这个时候，第 1 层的结点还没出完，第 2 层的结点就进来了，而且两层的结点在队列中紧挨在一起，我们无法区分队列中的结点来自哪一层。
因此，我们需要稍微修改一下代码，在每一层遍历开始前，先记录队列中的结点数量 n（也就是这一层的结点数量），然后一口气处理完这一层的 n 个结点。
</code></pre>
<p>&#x2F;&#x2F; 二叉树的层序遍历<br>void bfs(TreeNode root) {<br>    Queue<TreeNode> queue &#x3D; new ArrayDeque&lt;&gt;();<br>    queue.add(root);<br>    while (!queue.isEmpty()) {<br>        int n &#x3D; queue.size();<br>        for (int i &#x3D; 0; i &lt; n; i++) {<br>            &#x2F;&#x2F; 变量 i 无实际意义，只是为了循环 n 次<br>            TreeNode node &#x3D; queue.poll();<br>            if (node.left !&#x3D; null) {<br>                queue.add(node.left);<br>            }<br>            if (node.right !&#x3D; null) {<br>                queue.add(node.right);<br>            }<br>        }<br>    }<br>}</TreeNode></p>
<pre><code>这样，我们就将 BFS 遍历改造成了层序遍历。在遍历的过程中，结点进队列和出队列的过程为：
![](https://raw.githubusercontent.com/viacheung/img/main/image/94cd1fa999df0276f1dae77a9cca83f4cabda9e2e0b8571cd9550a8ee3545f56.gif#from=url&amp;id=dM647&amp;originHeight=500&amp;originWidth=1200&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=)
可以看到，在 while 循环的每一轮中，都是将当前层的所有结点出队列，再将下一层的所有结点入队列，这样就实现了层序遍历。
最终我们得到的题解代码为：
</code></pre>
<p>public List&lt;List<Integer>&gt; levelOrder(TreeNode root) {<br>    List&lt;List<Integer>&gt; res &#x3D; new ArrayList&lt;&gt;();</Integer></Integer></p>
<pre><code>Queue&lt;TreeNode&gt; queue = new ArrayDeque&lt;&gt;();
if (root != null) &#123;
    queue.add(root);
&#125;
while (!queue.isEmpty()) &#123;
    int n = queue.size();
    List&lt;Integer&gt; level = new ArrayList&lt;&gt;();
    for (int i = 0; i &lt; n; i++) &#123; 
        TreeNode node = queue.poll();//弹出队头n次 正好就是把上一层的结点全部弹出 剩下的就是这一层的节点数量 
        level.add(node.val);//level放每一层的值
        if (node.left != null) &#123;
            queue.add(node.left);
        &#125;
        if (node.right != null) &#123;
            queue.add(node.right);
        &#125;
    &#125;
    res.add(level);//加入结果集
&#125;

return res;
</code></pre>
<p>}</p>
<pre><code>
 
# 递归
我的理解：
主要函数里面return一个自定义函数，自定义函数里面前一部分写好递归的统一模板，然后开始递归下一层。
甩锅给后面的过程，然后得有一个出口。
![image.png](https://cdn.nlark.com/yuque/0/2023/png/226907/1685799400993-fcd546a8-e08a-44c6-ada3-220be1d8330a.png#clientId=u5d472611-2419-4&amp;from=paste&amp;id=ud8dca7da&amp;originalType=url&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=159429&amp;status=done&amp;style=none&amp;taskId=u25c6154d-b67e-45c5-8a42-037f9a36d2a&amp;title=)
</code></pre>
<p>&#x2F;**</p>
<ul>
<li>合并两有序链表  递归方法 代码少 但效率不行<br> <em>&#x2F;<br>public ListNode mergeTwoLists(ListNode list1,ListNode list2){<br> if(list1&#x3D;&#x3D;null||list2&#x3D;&#x3D;null){<br> return list1&#x3D;&#x3D;null?list2:list1;<br> }else if(list1.val&lt;list2.val){<br> list1.next&#x3D;mergeTwoLists(list1.next,list2);<br> return list1;<br> }else{<br> list2.next&#x3D;mergeTwoLists(list2.next,list1);<br> return list2;<br> }<br>}<br>&#x2F;</em>*</li>
<li>普通方法 代码多 但效率快<br> <em>&#x2F;<br>&#x2F;</em><br>public ListNode mergeTwoLists(ListNode list1,ListNode list2){<br> if(list1&#x3D;&#x3D;null||list2&#x3D;&#x3D;null){<br> return list1&#x3D;&#x3D;null?list2:list1;<br> }<br> ListNode head&#x3D;new ListNode(0);<br> ListNode tail&#x3D;head,aptr&#x3D;list1,bptr&#x3D;list2;<br> while (list1!&#x3D;null&amp;&amp;list2!&#x3D;null){<br> if(list1.val&lt;list2.val){<br>     tail.next&#x3D;list1;<br>     list1&#x3D;list1.next;<br> }else{<br>     tail.next&#x3D;list2;<br>     list2&#x3D;list2.next;<br> }<br> tail&#x3D;tail.next;<br> }<br> tail.next&#x3D;list1!&#x3D;null?list1:list2;<br> return head.next;<br>}<br> *&#x2F;<br>&#96;&#96;&#96;</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://viacheung.github.io/2023/06/04/%E8%B4%AA%E5%BF%83/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="ViaCheung">
      <meta itemprop="description" content="el psy congroo">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="命运石之门">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/06/04/%E8%B4%AA%E5%BF%83/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
	  <span class="post-time">

	  
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-06-04 01:02:05 / 修改时间：01:02:06" itemprop="dateCreated datePublished" datetime="2023-06-04T01:02:05+08:00">2023-06-04</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ol>
<li>贪心本来就没有套路，也没有框架，所以各种常规解法需要多接触多练习，自然而然才会想到。</li>
<li>局部最优可以推出全局最优，如果找不出局部最优，那可能就是一道模拟题。</li>
<li>在出现两个维度相互影响的情况时，两边一起考虑一定会顾此失彼，要先确定一个维度，再确定另一个一个维度。</li>
<li>股票问题用dp</li>
<li>题目不要做一遍，要多练！</li>
<li>区间问题，各种覆盖各种去重。<h2 id="分发饼干"><a href="#分发饼干" class="headerlink" title="分发饼干"></a>分发饼干</h2>假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。<br>对每个孩子 i，都有一个胃口值 g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 s[j] 。如果 s[j] &gt;&#x3D; g[i]，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。<br><strong>贪心策略：这里的局部最优就是小饼干喂给胃口小的，充分利用饼干尺寸喂饱一个，全局最优就是喂饱尽可能多的小孩</strong>。<pre><code>class Solution &#123;
  public int findContentChildren(int[] g, int[] s) &#123;
      //先排序
      Arrays.sort(g);
      Arrays.sort(s);
      int start=0,count=0;
      //遍历饼干尺寸
      for(int i=0;i&lt;s.length&amp;&amp;start&lt;g.length;i++)&#123;
          //找到第一个大于等于g数组的s值
          if(s[i]&gt;=g[start])&#123;
              start++;
              count++;
          &#125;
      &#125;
      return count;
  &#125;   
 &#125;
</code></pre>
<h2 id="摆动序列"><a href="#摆动序列" class="headerlink" title="摆动序列"></a>摆动序列</h2>如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为 <strong>摆动序列 。</strong>第一个差（如果存在的话）可能是正数或负数。仅有一个元素或者含两个不等元素的序列也视作摆动序列。</li>
</ol>
<ul>
<li>例如， [1, 7, 4, 9, 2, 5] 是一个 <strong>摆动序列</strong> ，因为差值 (6, -3, 5, -7, 3) 是正负交替出现的。</li>
<li>相反，[1, 4, 7, 2, 5] 和 [1, 7, 4, 5, 5] 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。</li>
</ul>
<p><strong>子序列</strong> 可以通过从原始序列中删除一些（也可以不删除）元素来获得，剩下的元素保持其原始顺序。<br>给你一个整数数组 nums ，返回 nums 中作为 <strong>摆动序列</strong> 的 <strong>最长子序列的长度</strong> 。<br>贪心策略:局部最优,删除单调坡度上的节点（不包括单调坡度两端的节点），那么这个坡度就可以有两个局部峰值。<br><img src="https://raw.githubusercontent.com/viacheung/img/main/image/20201124174327597.png#from=url&id=J0zJG&originHeight=502&originWidth=1300&originalType=binary&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&title="></p>
<pre><code>class Solution &#123;
     public int wiggleMaxLength(int[] nums) &#123;
         int n=nums.length;
         if(n&lt;2) return n;
         int pre=nums[1]-nums[0];
         int count=pre!=0?2:1;
         for(int i=2;i&lt;nums.length;i++)&#123;
             int cur=nums[i]-nums[i-1];
             //前面差值可以为0 但当前不可
             if((cur&gt;0&amp;&amp;pre&lt;=0)||(cur&lt;0&amp;&amp;pre&gt;=0))&#123;
                 count++;
                 pre=cur;
             &#125;
         &#125;
         return count;
     &#125;
 &#125;
</code></pre>
<h2 id="最大子数组和"><a href="#最大子数组和" class="headerlink" title="最大子数组和"></a>最大子数组和</h2><p>给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。<br><strong>子数组</strong> 是数组中的一个连续部分。<br><strong>方法一</strong><br><img src="https://raw.githubusercontent.com/viacheung/img/main/image/image-20221120103615752.png#from=url&id=aYp9L&originHeight=599&originWidth=778&originalType=binary&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&title="></p>
<pre><code>fi表示以第 i个数结尾的「连续子数组的最大和」
 class Solution &#123;
     public int maxSubArray(int[] nums) &#123;
         int maxAns=nums[0],pre=0;
         for(int x:nums)&#123;
             //求出每个位置的fi
             //加入前一段还是单独成一段
             pre=Math.max(pre+x,x);
             //维护一个最大值
             maxAns=Math.max(maxAns,pre);
         &#125;
         return maxAns;
 
     &#125;
 &#125;
 //我觉得这道题目的思想是： 走完这一生 如果我和你在一起会变得更好，那我们就在一起，否则我就丢下你。 我回顾我最光辉的时刻就是和不同人在一起，变得更好的最长连续时刻
</code></pre>
<p><strong>方法二</strong><br>当前“连续和”为负数的时候立刻放弃，从下一个元素重新计算“连续和”，因为负数加上下一个元素 “连续和”只会越来越小。<strong>局部最优的情况下，并记录最大的“连续和”，可以推出全局最优</strong>。<strong>这相当于是暴力解法中的不断调整最大子序和区间的起始位置</strong>。<br><img src="https://raw.githubusercontent.com/viacheung/img/main/image/53.%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C.gif#from=url&id=R3tZL&originHeight=322&originWidth=416&originalType=binary&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&title="></p>
<pre><code>class Solution &#123;
     public int maxSubArray(int[] nums) &#123;
         int sum=Integer.MIN_VALUE;
         int count=0;
         for(int i=0;i&lt;nums.length;i++)&#123;
             //当前连续子数组和
             count+=nums[i];
             //维护结果
             sum=Math.max(sum,count);
             //当前连续子数组和&lt;0.置为0
             if(count&lt;0) count=0;
         &#125;
         return sum;
     &#125;
 &#125;
</code></pre>
<h2 id="买卖股票的最佳时机-II"><a href="#买卖股票的最佳时机-II" class="headerlink" title="买卖股票的最佳时机 II"></a>买卖股票的最佳时机 II</h2><p>给你一个整数数组 prices ，其中 prices[i] 表示某支股票第 i 天的价格。<br>在每一天，你可以决定是否购买和&#x2F;或出售股票。你在任何时候 <strong>最多</strong> 只能持有 <strong>一股</strong> 股票。你也可以先购买，然后在 <strong>同一天</strong> 出售。<br>返回 <em>你能获得的 <strong>最大</strong> 利润</em> 。<br><img src="https://raw.githubusercontent.com/viacheung/img/main/image/2020112917480858.png#from=url&id=BSBmy&originHeight=572&originWidth=978&originalType=binary&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&title="><br>从图中可以发现，其实我们需要收集每天的正利润就可以，<strong>收集正利润的区间，就是股票买卖的区间，而我们只需要关注最终利润，不需要记录区间</strong>。<br><strong>局部最优：收集每天的正利润，全局最优：求得最大利润</strong>。</p>
<pre><code>class Solution &#123;
         public int maxProfit(int[] prices) &#123;
             int ans=0;
             for(int i=1;i&lt;prices.length;i++)&#123;
                 ans+=Math.max(prices[i]-prices[i-1],0);
             &#125;
             return ans;
         &#125;
     &#125;
</code></pre>
<h2 id="跳跃游戏"><a href="#跳跃游戏" class="headerlink" title="跳跃游戏"></a>跳跃游戏</h2><p>给定一个非负整数数组 nums ，你最初位于数组的 <strong>第一个下标</strong> 。<br>数组中的每个元素代表你在该位置可以跳跃的最大长度。<br><strong>判断</strong>你是否能够到达最后一个下标。<br><strong>贪心算法局部最优解：每次取最大跳跃步数（取最大覆盖范围），整体最优解：最后得到整体最大覆盖范围，看是否能到终点</strong>。<br><img src="https://raw.githubusercontent.com/viacheung/img/main/image/20201124154758229.png#from=url&id=lLOqp&originHeight=740&originWidth=1332&originalType=binary&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&title="></p>
<pre><code>class Solution &#123;
     public boolean canJump(int[] nums) &#123;
         int coverRange=0;
         
        //在覆盖范围内寻找最大覆盖范围
         //覆盖范围指的是最远到达下标 只要最远到达下标大于集合长度 就返回true
         for(int i=0;i&lt;=coverRange;i++)&#123;
             coverRange=Math.max(coverRange,i+nums[i]);
             if(coverRange&gt;=nums.length-1) return true;
         &#125;
         return false;
     &#125;
 &#125;
</code></pre>
<h2 id="跳跃游戏-1"><a href="#跳跃游戏-1" class="headerlink" title="跳跃游戏"></a>跳跃游戏</h2><p>给定一个非负整数数组，你最初位于数组的第一个位置。数组中的每个元素代表你在该位置可以跳跃的最大长度。<br>你的目标是<strong>使用最少的跳跃次数</strong>到达数组的最后一个位置。<br><strong>贪心策略</strong>：当前可移动距离尽可能多走，如果还没到终点，步数再加一。整体最优：一步尽可能多走，从而达到最小步数。<br>我的理解：<br>当前覆盖的最大区域：下一步可达的最大区域<br><img src="https://raw.githubusercontent.com/viacheung/img/main/image/20201201232309103.png#from=url&id=S3uS6&originHeight=806&originWidth=816&originalType=binary&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&title="></p>
<pre><code>class Solution &#123;
     public int jump(int[] nums) &#123;
         if (nums == null || nums.length == 0 || nums.length == 1) &#123;
             return 0;
         &#125;
         //记录跳跃的次数
         int count=0;
         //当前的覆盖最大区域
         int curDistance = 0;
         //最大的覆盖区域
         int maxDistance = 0;
         for (int i = 0; i &lt; nums.length; i++) &#123;
             //在可覆盖区域内更新最大的覆盖区域
             maxDistance = Math.max(maxDistance,i+nums[i]);
             //说明当前一步，再跳一步就到达了末尾
             if (maxDistance&gt;=nums.length-1)&#123;
                 count++;
                 break;
             &#125;
             //走到当前覆盖的最大区域时，更新下一步可达的最大区域  说明此时还没有跳到最后一个位置，那么步数需要+1
             if (i==curDistance)&#123;
                 curDistance = maxDistance;
                 count++;
             &#125;
         &#125;
         return count;
     &#125;
 &#125;
</code></pre>
<h2 id="K-次取反后最大化的数组和"><a href="#K-次取反后最大化的数组和" class="headerlink" title="K 次取反后最大化的数组和"></a>K 次取反后最大化的数组和</h2><p>给你一个整数数组 nums 和一个整数 k ，按以下方法修改该数组：<br>选择某个下标 i 并将 nums[i] 替换为 -nums[i] 。重复这个过程恰好 k 次。可以多次选择同一个下标 i 。以这种方式修改数组后，返回数组 <strong>可能的最大和</strong> 。<br><strong>题解：</strong></p>
<ul>
<li><p>第一步：将数组按照绝对值大小从大到小排序，<strong>注意要按照绝对值的大小</strong></p>
</li>
<li><p>第二步：从前向后遍历，遇到负数将其变为正数，同时K–</p>
</li>
<li><p>第三步：如果K还大于0，那么反复转变数值最小的元素，将K用完</p>
</li>
<li><p>第四步：求和</p>
<pre><code>class Solution &#123;
   public int largestSumAfterKNegations(int[] nums, int k) &#123;
       //将数组按照绝对值大小从大到小排序，注意要按照绝对值的大小
       nums = IntStream.of(nums)
            .boxed()
            .sorted((o1, o2) -&gt; Math.abs(o2) - Math.abs(o1))
            .mapToInt(Integer::intValue).toArray();
       //从前向后遍历，遇到负数将其变为正数，同时K--
       for(int i=0;i&lt;nums.length;i++)&#123;
           if(nums[i]&lt;0&amp;&amp;k&gt;0) &#123;
               nums[i]*=-1;
               k--;
           &#125;
       &#125;
       // 如果K还大于0，那么反复转变数值最小的元素，将K用完
       if(k%2==1) nums[nums.length-1]*=-1;
       int ans=0;
       for(int num:nums)&#123;
           ans+=num;
       &#125;
       return ans;
   &#125;
 &#125;
</code></pre>
<h2 id="加油站"><a href="#加油站" class="headerlink" title="加油站"></a>加油站</h2><p>在一条环路上有 n 个加油站，其中第 i 个加油站有汽油 gas[i] 升。<br>你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。<br>给定两个整数数组 gas 和 cost ，如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1 。如果存在解，则 <strong>保证</strong> 它是 <strong>唯一</strong> 的。<br><strong>思路：</strong><br>如果总油量减去总消耗大于等于零那么一定可以跑完一圈，说明 各个站点的加油站 剩油量rest[i]相加一定是大于等于零的。<br>每个加油站的剩余量rest[i]为gas[i] - cost[i]。<br>i从0开始累加rest[i]，和记为curSum，一旦curSum小于零，说明[0, i]区间都不能作为起始位置，起始位置从i+1算起，再从0计算curSum。<br>为什么[0, i]区间都不能作为起始位置？我的理解：首先0肯定是不能作为起始位置的，假设存在0&lt;j&lt;i，使得j可以作为起始位置，那么[j,i]的curSum肯定大于0，又[0,i]curSum小于0，则[0,j]的curSum必小于0，与第一次出现小于01矛盾，所以不存在0&lt;j&lt;i，使得j可以作为起始位置</p>
<pre><code>class Solution &#123;
   public int canCompleteCircuit(int[] gas, int[] cost) &#123;
       //当rest累加为负数，就从i+1重新开始，cur归0 最后判断总油是不是小于0
       int curgas=0,sumgas=0,index=0;
       for(int i=0;i&lt;gas.length;i++)&#123;
           curgas+=gas[i]-cost[i];
           sumgas+=gas[i]-cost[i];
           if(curgas&lt;0)&#123;
               index=(i+1)%gas.length;
               curgas=0;
           &#125;
       &#125;
       if(sumgas&lt;0)&#123;
           return -1;
       &#125;else&#123;
           return index;
       &#125;
   &#125;
 &#125;
</code></pre>
<h2 id="分发糖果"><a href="#分发糖果" class="headerlink" title="分发糖果"></a>分发糖果</h2><p>n 个孩子站成一排。给你一个整数数组 ratings 表示每个孩子的评分。<br>你需要按照以下要求，给这些孩子分发糖果：</p>
</li>
<li><p>每个孩子至少分配到 1 个糖果。</p>
</li>
<li><p>相邻两个孩子评分更高的孩子会获得更多的糖果。</p>
</li>
</ul>
<p>请你给每个孩子分发糖果，计算并返回需要准备的 <strong>最少糖果数目</strong> 。<br><strong>题解：</strong><br><strong>遇到两个维度权衡的时候，一定要先确定一个维度，再确定另一个维度。</strong><br><strong>右边评分大于左边的情况（从前向后遍历）</strong><br>局部最优：只要右边评分比左边大，右边的孩子就多一个糖果，全局最优：相邻的孩子中，评分高的右孩子获得比左边孩子更多的糖果<br>局部最优可以推出全局最优。<br>如果ratings[i] &gt; ratings[i - 1] 那么[i]的糖 一定要比[i - 1]的糖多一个，所以贪心：candyVec[i] &#x3D; candyVec[i - 1] + 1<br><img src="https://raw.githubusercontent.com/viacheung/img/main/image/20201117114916878.png#from=url&id=ZE4g7&originHeight=464&originWidth=1210&originalType=binary&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&title="><br><strong>左孩子大于右孩子的情况（从后向前遍历）</strong><br>局部最优：如果 ratings[i] &gt; ratings[i + 1]，取candyVec[i + 1] + 1 （从右边这个加1得到的糖果数量）和 candyVec[i] （之前比较右孩子大于左孩子得到的糖果数量）。最大的糖果数量，保证第i个小孩的糖果数量即大于左边的也大于右边的。全局最优：相邻的孩子中，评分高的孩子获得更多的糖果。<br>局部最优可以推出全局最优。<br>所以就取candyVec[i + 1] + 1 和 candyVec[i] 最大的糖果数量，<strong>candyVec[i]只有取最大的才能既保持对左边candyVec[i - 1]的糖果多，也比右边candyVec[i + 1]的糖果多</strong>。<br><img src="https://raw.githubusercontent.com/viacheung/img/main/image/20201117115658791.png#from=url&id=NkMxS&originHeight=982&originWidth=1236&originalType=binary&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&title="></p>
<pre><code>class Solution &#123;
     public int candy(int[] ratings) &#123;
         int n=ratings.length;
         int[] candyVec=new int[n];
         candyVec[0]=1;
         for(int i=1;i&lt;n;i++)&#123;
             candyVec[i]=(ratings[i]&gt;ratings[i-1])?candyVec[i-1]+1:1;
         &#125;
         // for(int i=0;i&lt;n;i++)&#123;
         //     if(ratings[i]&gt;ratings[i+1])&#123;
         //         //这就是为什么比较左大于右情况时不能从前往后的原因，因为用到的candyVec[i+1]不是最新的
         //         candyVec[i]=Math.max(candyVec[i],candyVec[i+1]+1);
         //     &#125;
         // &#125;
         for(int i=n-2;i&gt;=0;i--)&#123;
             if(ratings[i]&gt;ratings[i+1])&#123;
                 candyVec[i]=Math.max(candyVec[i],candyVec[i+1]+1);
             &#125;
         &#125;
         int ans=0;
         for(int candy:candyVec)&#123;
             ans+=candy;
         &#125;
         return ans;
     &#125;
 &#125;
</code></pre>
<h2 id="柠檬水找零"><a href="#柠檬水找零" class="headerlink" title="柠檬水找零"></a>柠檬水找零</h2><p>在柠檬水摊上，每一杯柠檬水的售价为 5 美元。顾客排队购买你的产品，（按账单 bills 支付的顺序）一次购买一杯。<br>每位顾客只买一杯柠檬水，然后向你付 5 美元、10 美元或 20 美元。你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付 5 美元。<br>注意，一开始你手头没有任何零钱。<br>给你一个整数数组 bills ，其中 bills[i] 是第 i 位顾客付的账。如果你能给每位顾客正确找零，返回 true ，否则返回 false 。</p>
<pre><code>/**
 题解：
 贪心策略：20美元情况优先找一个10元和5元 switch和if else都可 
 我最开始还定义一个num_20 后来发现这个变量只有增加，所以可以去掉
 **/
 class Solution &#123;
     public boolean lemonadeChange(int[] bills) &#123;
         int num_5=0,num_10=0;
         for(int i=0;i&lt;bills.length;i++)&#123;
             switch(bills[i])&#123;
                 case 5:
                 num_5++;
                 break;
 
                 case 10:
                 num_5--;
                 num_10++;
                 break;
 
                 case 20:
                 if(num_10&gt;=1)&#123;
                     num_10--;
                     num_5--;
                 &#125;else&#123;
                     num_5-=3;
                 &#125;;
                 break;
                 default:
             &#125;
             if(num_10&lt;0||num_5&lt;0) return false;
         &#125;
         return true;
     &#125;
 &#125;
</code></pre>
<h2 id="根据身高重建队列"><a href="#根据身高重建队列" class="headerlink" title="根据身高重建队列"></a>根据身高重建队列</h2><p>排序里面做过</p>
<h2 id="用最少数量的箭引爆气球"><a href="#用最少数量的箭引爆气球" class="headerlink" title="用最少数量的箭引爆气球"></a>用最少数量的箭引爆气球</h2><p>有一些球形气球贴在一堵用 XY 平面表示的墙面上。墙面上的气球记录在整数数组 points ，其中points[i] &#x3D; [xstart, xend] 表示水平直径在 xstart 和 xend之间的气球。你不知道气球的确切 y 坐标。<br>一支弓箭可以沿着 x 轴从不同点 <strong>完全垂直</strong> 地射出。在坐标 x 处射出一支箭，若有一个气球的直径的开始和结束坐标为 x<code>start，x</code>end， 且满足 xstart ≤ x ≤ x&#96;&#96;end，则该气球会被 <strong>引爆</strong> 。可以射出的弓箭的数量 <strong>没有限制</strong> 。 弓箭一旦被射出之后，可以无限地前进。<br>给你一个数组 points ，<em>返回引爆所有气球所必须射出的 <strong>最小</strong> 弓箭数</em> 。<br><img src="https://raw.githubusercontent.com/viacheung/img/main/image/20201123101929791.png#from=url&id=o4yAR&originHeight=512&originWidth=812&originalType=binary&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&title="></p>
<pre><code>class Solution &#123;
     public int findMinArrowShots(int[][] points) &#123;
         Arrays.sort(points,new Comparator&lt;int[]&gt;()&#123;
             public int compare(int[] point1,int[] point2)&#123;
                 //按照左边界排序就行
                 //这里这么写 是为了防止溢出，做减法可能导致数值溢出 要直接比较
                 return point1[0]&gt;point2[0]?1:-1;
             &#125;
         &#125;);
         //需要箭个数
         int count=0;
         int i=0;
         while(i&lt;points.length)&#123;
             int index=1;
             int minright=points[i][1];
             //因为已经保证了左边界有序，因此只需要下一个int[]0位置要小于等于最小右边界就可以放在一起被引爆
             while(i+index&lt;points.length&amp;&amp;minright&gt;=points[i+index][0])&#123;
                 minright=Math.min(minright, points[i+index][1]);//维护有边界最小值               
                 index++;
             &#125;
             i=i+index;
             count++;
         &#125;
         return count;
     &#125;
 &#125;
 //代码随想录
 class Solution &#123;
     public int findMinArrowShots(int[][] points) &#123;
         // 根据气球直径的开始坐标从小到大排序
         // 使用Integer内置比较方法，不会溢出
         Arrays.sort(points, (a, b) -&gt; Integer.compare(a[0], b[0]));
         int count = 1;  // points 不为空至少需要一支箭
         for (int i = 1; i &lt; points.length; i++) &#123;
             if (points[i][0] &gt; points[i - 1][1]) &#123;  // 气球i和气球i-1不挨着，注意这里不是&gt;=
                 count++; // 需要一支箭
             &#125; else &#123;  // 气球i和气球i-1挨着、
                 //points[i][1] 存的是i及之前的最小右边界
                 points[i][1] = Math.min(points[i][1], points[i - 1][1]); // 更新重叠气球最小右边界
             &#125;
         &#125;
         return count;
     &#125;
 &#125;
</code></pre>
<h2 id="无重叠区间"><a href="#无重叠区间" class="headerlink" title="无重叠区间"></a>无重叠区间</h2><p>给定一个区间的集合 intervals ，其中 intervals[i] &#x3D; [starti, endi] 。返回 <em>需要移除区间的最小数量，使剩余区间互不重叠</em> 。<br>题解：和上一题很像<br>右边界排序之后，局部最优：优先选右边界小的区间，所以从左向右遍历，留给下一个区间的空间大一些，从而尽量避免交叉。全局最优：选取最多的非交叉区间。<br><img src="https://raw.githubusercontent.com/viacheung/img/main/image/20201221201553618.png#from=url&id=Ln20e&originHeight=496&originWidth=780&originalType=binary&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&title="></p>
<pre><code>class Solution &#123;
     public int eraseOverlapIntervals(int[][] intervals) &#123;
         //按照右边界排序  升序排
         Arrays.sort(intervals,(a,b)-&gt;Integer.compare(a[1],b[1]));
         //需要移除区间的最小数量
         int count=0;
         int minRight=Integer.MIN_VALUE;
         for(int i=0;i&lt;intervals.length;i++)&#123;
             //后一个的左边界如果大于前一个右边界  更新minright   
             if(minRight&lt;=intervals[i][0])&#123;
                 minRight=intervals[i][1];
             &#125;else&#123;
                 //需要移除重叠的区域,为了保证更多不相交区间,右边界尽量小
                 count++;
             &#125;
         &#125;
         return count;
     &#125;
 &#125;
</code></pre>
<h2 id="划分字母区间"><a href="#划分字母区间" class="headerlink" title="划分字母区间"></a>划分字母区间</h2><p>字符串 S 由小写字母组成。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。返回一个表示每个字符串片段的长度的列表。<br><img src="https://raw.githubusercontent.com/viacheung/img/main/image/20201222191924417.png#from=url&id=VrqTv&originHeight=564&originWidth=1430&originalType=binary&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&title="></p>
<pre><code>class Solution &#123;
     public List&lt;Integer&gt; partitionLabels(String s) &#123;
         // 统计每一个字符最后出现的位置  因为是26个字母 所以长度26 位置0对应就是a字符出现最远位置
         int[] hash=new int[26];
         for(int i=0;i&lt;s.length();i++)&#123;
             //更新最远距离 可以覆盖的
             hash[s.charAt(i)-&#39;a&#39;]=i;
         &#125;
         int start=0,end=0;//左右边界
         List&lt;Integer&gt; ans=new ArrayList&lt;&gt;();
         for(int i=0;i&lt;s.length();i++)&#123;
             // 更新当前出现的最远出现下标
             end=Math.max(end,hash[s.charAt(i)-&#39;a&#39;]);
             // 如果找到字符最远出现位置下标和当前下标相等了，则找到了分割点
             if(end==i)&#123;
                 ans.add(end-start+1);
                 // 调整start
                 start=i+1;
             &#125;
         &#125;
         return ans;
 
     &#125;
 &#125;
</code></pre>
<h2 id="合并区间"><a href="#合并区间" class="headerlink" title="合并区间"></a>合并区间</h2><p>以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] &#x3D; [starti, endi] 。请你合并所有重叠的区间，并返回 <em>一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间</em> 。<br>题解：</p>
<pre><code>class Solution &#123;
     public int[][] merge(int[][] intervals) &#123;
         List&lt;int[]&gt; res = new LinkedList&lt;&gt;();
         //按照左边界排序
         Arrays.sort(intervals, (x, y) -&gt; Integer.compare(x[0], y[0]));
         //initial start 是最小左边界
         int start = intervals[0][0];
         int rightmostRightBound = intervals[0][1];
         for (int i = 1; i &lt; intervals.length; i++) &#123;
             //如果左边界大于最大右边界
             if (intervals[i][0] &gt; rightmostRightBound) &#123;
                 //加入区间 并且更新start
                 res.add(new int[]&#123;start, rightmostRightBound&#125;);
                 start = intervals[i][0];
                 rightmostRightBound = intervals[i][1];
             &#125; else &#123;
                 //更新最大右边界
                 rightmostRightBound = Math.max(rightmostRightBound, intervals[i][1]);
             &#125;
         &#125;
         res.add(new int[]&#123;start, rightmostRightBound&#125;);
         return res.toArray(new int[res.size()][]);
     &#125;
 &#125;
 &#125;
</code></pre>
<pre><code>//相当简洁
 class Solution &#123;
     public int[][] merge(int[][] intervals) &#123;
         Arrays.sort(intervals, (x, y) -&gt; Integer.compare(x[0], y[0]));
         List&lt;int[]&gt; ans=new ArrayList&lt;&gt;();
         int n=intervals.length;
         for(int i=0;i&lt;n;i++)&#123;
             // 第一次加入或者区间不相交，直接加入集合
             if(ans.size()==0||intervals[i][0]&gt;ans.get(ans.size()-1)[1])&#123;
                 ans.add(intervals[i]);
             &#125;else&#123;
                 // 否则更改前一个元素的右边界，注意这里直接修改，也就避免再添加了
                 ans.get(ans.size()-1)[1]=Math.max(intervals[i][1],ans.get(ans.size()-1)[1]);
             &#125;
         &#125;
         return ans.toArray(new int[ans.size()][]);//转成数组要指定大小
 
     &#125;
 &#125;
</code></pre>
<h2 id="单调递增的数字"><a href="#单调递增的数字" class="headerlink" title="单调递增的数字"></a>单调递增的数字</h2><p>当且仅当每个相邻位数上的数字 x 和 y 满足 x &lt;&#x3D; y 时，我们称这个整数是<strong>单调递增**的。<br>给定一个整数 n ，返回 <em>小于或等于 n 的最大数字，且数字呈 <strong>单调递增</strong></em> 。<br>题解：<br>**局部最优：遇到strNum[i - 1] &gt; strNum[i]的情况，让strNum[i - 1]–，然后strNum[i]给为9，可以保证这两位变成最大单调递增整数</strong>。<br><strong>但这里局部最优推出全局最优，还需要其他条件，即遍历顺序，和标记从哪一位开始统一改成9</strong>。<br><strong>又因为从前后向遍历会改变已经遍历过的结果，所以从后往前遍历</strong></p>
<pre><code>class Solution &#123;
     public int monotoneIncreasingDigits(int n) &#123;
         char[] chars = Integer.toString(n).toCharArray();
         // start用来标记赋值9从哪里开始
         // 设置为这个默认值，为了防止第二个for循环在start没有被赋值的情况下执行
         //初始化 ，start 表示要开始填充&#39;9&#39;的位置
         int start=chars.length;
         for(int i=chars.length-1;i&gt;0;i--)&#123;
             if(chars[i-1]&gt;chars[i])&#123;
                 chars[i-1]--;
                 start=i;
             &#125;
         &#125;
         // 从start开始一直往后填充&#39;9&#39;
         for(int i=start;i&lt;chars.length;i++)&#123;
             chars[i]=&#39;9&#39;;
         &#125;
         // 类型转换
         return Integer.parseInt(String.valueOf(chars));
     &#125;
 &#125;
</code></pre>
<h2 id="监控二叉树"><a href="#监控二叉树" class="headerlink" title="监控二叉树"></a>监控二叉树</h2><p>给定一个二叉树，我们在树的节点上安装摄像头。<br>节点上的每个摄影头都可以监视<strong>其父对象、自身及其直接子对象。</strong><br>计算监控树的所有节点所需的最小摄像头数量。<br><img src="https://raw.githubusercontent.com/viacheung/img/main/image/bst_cameras_01.png#from=url&id=nefy8&originHeight=163&originWidth=138&originalType=binary&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&title="><br><strong>后序遍历</strong>：叶子节点放不放摄像头省下了的摄像头数量是指数阶别的,所以让叶子节点的父节点安摄像头，所用摄像头最少，选择后序遍历<br><strong>如何隔两个节点放一个摄像头</strong> ：状态转移</p>
<ul>
<li>0：该节点无覆盖</li>
<li>1：本节点有摄像头</li>
<li>2：本节点有覆盖</li>
</ul>
<ol>
<li>情况一：左孩子有覆盖，右孩子有覆盖，那么此时中间节点应该就是无覆盖的状态了。</li>
<li>情况2：左右节点至少有一个无覆盖的情况，如果是以下情况，此时摄像头的数量要加一，并且return 1，代表中间节点放摄像头。</li>
<li>情况3：左右节点至少有一个有摄像头，其父节点就应该是2<pre><code>class Solution &#123;
  int count=0;
  public int minCameraCover(TreeNode root) &#123;
  //     0 表示无覆盖 
  //    1 表示 有摄像头
  //    2 表示有覆盖       
      if(mincame(root)==0) count++;
      return count;
  &#125;
  public int mincame(TreeNode root)&#123;
      //空节点默认为 有覆盖状态，避免在叶子节点上放摄像头 
      if(root==null) return 2;
      // 优先遍历叶子结点  因为让叶子节点的父节点安摄像头，所用摄像头最少  用后序遍历
      int left=mincame(root.left);
      int right=mincame(root.right);
      if(left==2&amp;&amp;right==2)&#123;
          return 0;
      &#125;else if(left==0||right==0)&#123;
          count++;
          return 1;
      &#125;else&#123;
          return 2;
      &#125;
  &#125;
 &#125;
</code></pre>
<h2 id="最长递增子序列（也可dp）"><a href="#最长递增子序列（也可dp）" class="headerlink" title="最长递增子序列（也可dp）"></a>最长递增子序列（也可dp）</h2>考虑一个简单的贪心，如果我们要使上升子序列尽可能的长，则我们需要让序列上升得尽可能慢，因此我们希望每次在上升子序列最后加上的那个数尽可能的小。<br>基于上面的贪心思路，我们维护一个数组 d[i]，表示长度为 i的最长上升子序列的末尾元素的最小值，用 len记录目前最长上升子序列的长度，起始时 len 为 1，d[1]&#x3D;nums[0]<br>同时我们可以注意到 d[i] 是关于 i 单调递增的。（显而易见）根据 ddd 数组的单调性，我们可以使用二分查找寻找下标 i，优化时间复杂度。<br><img src="https://raw.githubusercontent.com/viacheung/img/main/image/image-20220924191640236.png#from=url&id=Sdf9R&originHeight=508&originWidth=1060&originalType=binary&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&title="><pre><code>class Solution &#123;
  public int lengthOfLIS(int[] nums) &#123;
      int len = 1, n = nums.length;
      if (n == 0) &#123;
          return 0;
      &#125;
      //细节 d代表长度为i的最长上升子序列的末尾元素的最小值，d[0……n]因此共n+1个数 所以是new int[n + 1]
      int[] d = new int[n + 1];
      d[len] = nums[0];
      for (int i = 1; i &lt; n; ++i) &#123;
          if (nums[i] &gt; d[len]) &#123;
              d[++len] = nums[i];//先++
          &#125; else &#123;
              int l = 1, r = len, pos = 0; // 如果找不到说明所有的数都比 nums[i] 大，此时要更新 d[1]，所以这里将 pos 设为 0  
              while (l &lt;= r) &#123;
                  int mid = (l + r) &gt;&gt; 1;
                  //目的是找到第一个比num[i]小的数字，也就是小于nums[i]的数字里面最接近nums[i]的数字
                  if (d[mid] &lt; nums[i]) &#123;
                      pos = mid;//更新pos
                      l = mid + 1;
                  &#125; else &#123;
                      r = mid - 1;
                  &#125;
              &#125;
              d[pos + 1] = nums[i];//更新 
          &#125;
      &#125;
      return len;
  &#125;
 &#125;
</code></pre>
</li>
</ol>
<h2 id="Dota2-参议院"><a href="#Dota2-参议院" class="headerlink" title="Dota2 参议院"></a>Dota2 参议院</h2><p>Dota2 的世界里有两个阵营：Radiant（天辉）和 Dire（夜魇）<br>Dota2 参议院由来自两派的参议员组成。现在参议院希望对一个 Dota2 游戏里的改变作出决定。他们以一个基于轮为过程的投票进行。在每一轮中，每一位参议员都可以行使两项权利中的 <strong>一</strong> 项：</p>
<ul>
<li><strong>禁止一名参议员的权利</strong>：参议员可以让另一位参议员在这一轮和随后的几轮中丧失 <strong>所有的权利</strong> 。</li>
<li><strong>宣布胜利</strong>：如果参议员发现有权利投票的参议员都是 <strong>同一个阵营的</strong> ，他可以宣布胜利并决定在游戏中的有关变化。</li>
</ul>
<p>给你一个字符串 senate 代表每个参议员的阵营。字母 ‘R’ 和 ‘D’分别代表了 Radiant（天辉）和 Dire（夜魇）。然后，如果有 n 个参议员，给定字符串的大小将是 n。<br>以轮为基础的过程从给定顺序的第一个参议员开始到最后一个参议员结束。这一过程将持续到投票结束。所有失去权利的参议员将在过程中被跳过。<br>假设每一位参议员都足够聪明，会为自己的政党做出最好的策略，你需要预测哪一方最终会宣布胜利并在 Dota2 游戏中决定改变。输出应该是 “Radiant” 或 “Dire” 。<br>题解：<br>例如：RDDRD<br>第一轮：senate[0]的R消灭senate[1]的D，那么senate[2]的D，是消灭senate[0]的R还是消灭senate[3]的R呢？<br>当然是消灭senate[3]的R，因为当轮到这个R的时候，它可以消灭senate[4]的D。<br><strong>所以消灭的策略是，尽量消灭自己后面的对手，因为前面的对手已经使用过权利了，而后序的对手依然可以使用权利消灭自己的同伴！</strong></p>
<pre><code>class Solution &#123;
     public String predictPartyVictory(String senateStr) &#123;
         // R = true表示本轮循环结束后，字符串里依然有R。D同理
         Boolean R = true, D = true;
         // 当flag大于0时，R在D前出现，R可以消灭D。当flag小于0时，D在R前出现，D可以消灭R
         int flag = 0;
         byte[] senate =  senateStr.getBytes();
         while (R &amp;&amp; D) &#123; // 一旦R或者D为false，就结束循环，说明本轮结束后只剩下R或者D了
             R = false;
             D = false;
             for (int i = 0; i &lt; senate.length; i++) &#123;
                 if (senate[i] == &#39;R&#39;) &#123;
                     if (flag &lt; 0) senate[i] = 0; // 消灭R，R此时为false
                     else R = true; // 如果没被消灭，本轮循环结束有R
                     flag++;
                 &#125;
                 if (senate[i] == &#39;D&#39;) &#123;
                     if (flag &gt; 0) senate[i] = 0;
                     else D = true;
                     flag--;
                 &#125;
             &#125;
         &#125;
         // 循环结束之后，R和D只能有一个为true
         return R == true ? &quot;Radiant&quot; : &quot;Dire&quot;;
     &#125;
 &#125;
</code></pre>
<h2 id="分割平衡字符串"><a href="#分割平衡字符串" class="headerlink" title="分割平衡字符串"></a>分割平衡字符串</h2><p><strong>平衡字符串</strong> 中，’L’ 和 ‘R’ 字符的数量是相同的。<br>给你一个平衡字符串 s，请你将它分割成尽可能多的子字符串，并满足：</p>
<ul>
<li>每个子字符串都是平衡字符串。</li>
</ul>
<p>返回可以通过分割得到的平衡字符串的 <strong>最大数量。</strong><br>简单 直接做出来</p>
<pre><code>class Solution &#123;
     int count=0;
     public int balancedStringSplit(String s) &#123;
         int Lcount=0,Rcount=0;
         for(int i=0;i&lt;s.length();i++)&#123;
             if(s.charAt(i)==&#39;L&#39;)&#123;
                 Lcount++;
             &#125;
             if(s.charAt(i)==&#39;R&#39;)&#123;
                 Rcount++;
             &#125;
             if(Lcount==Rcount)&#123;
                 count++;
             &#125;
         &#125; 
         return count;
     &#125;
 &#125;
</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://viacheung.github.io/2023/06/04/%E5%9B%9E%E6%BA%AF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="ViaCheung">
      <meta itemprop="description" content="el psy congroo">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="命运石之门">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/06/04/%E5%9B%9E%E6%BA%AF/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
	  <span class="post-time">

	  
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-06-04 01:01:57 / 修改时间：01:01:58" itemprop="dateCreated datePublished" datetime="2023-06-04T01:01:57+08:00">2023-06-04</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/325665309/answer/2245817776">https://www.zhihu.com/question/325665309/answer/2245817776</a><br><strong>很多需要列举所有可能性的题需要用回溯</strong></p>
<pre><code>def backtrack(...):
     for 选择 in 选择列表:
         做选择
         backtrack(...)
         撤销选择
</code></pre>
<pre><code>1、路径：也就是已经做出的选择。
 
 2、选择列表：也就是你当前可以做的选择。
 
 3、结束条件：也就是到达决策树底层，无法再做选择的条件。
 result = []
 def backtrack(路径, 选择列表):
     if 满足结束条件:
         result.add(路径)
         return
 
     for 选择 in 选择列表:
         做选择
         backtrack(路径, 选择列表)
         撤销选择
</code></pre>
<p>一般涉及到做选择的问题都可以考虑用回溯法，写回溯的题的时候，方法参数可以先空着，用到什么加什么、<br>当只有两个选择的时候，就不用for循环了，直接写出来就行，比如+- ()这种<br><img src="https://raw.githubusercontent.com/viacheung/img/main/image/20210130173631174.png#from=url&id=jgAaG&originHeight=736&originWidth=1558&originalType=binary&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&title="></p>
<h3 id="去重问题"><a href="#去重问题" class="headerlink" title="去重问题"></a>去重问题</h3><p>for循环外面定义一个HashSet for循环里面判断是否重复并continue</p>
<h3 id="为什么定义为全局变量"><a href="#为什么定义为全局变量" class="headerlink" title="为什么定义为全局变量"></a>为什么定义为全局变量</h3><p>当然把参数放进函数里传进去也是可以的，我是尽量控制函数里参数的长度。</p>
<h3 id="递归返回值问题"><a href="#递归返回值问题" class="headerlink" title="递归返回值问题"></a>递归返回值问题</h3><p><img src="https://raw.githubusercontent.com/viacheung/img/main/image/image-20221115155029111.png#from=url&id=ANKNE&originHeight=377&originWidth=878&originalType=binary&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&title="></p>
<h2 id="组合问题："><a href="#组合问题：" class="headerlink" title="组合问题："></a>组合问题：</h2><h2 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h2><p>给定两个整数 n 和 k，返回范围 [1, n] 中所有可能的 k 个数的组合。<br>你可以按 <strong>任何顺序</strong> 返回答案。</p>
<pre><code>class Solution &#123;
     List&lt;List&lt;Integer&gt;&gt; ans=new ArrayList&lt;&gt;();
     public List&lt;List&lt;Integer&gt;&gt; combine(int n, int k) &#123;
         List&lt;Integer&gt; cur=new ArrayList&lt;&gt;();
         backtrack(1,cur,n,k);
         return ans;
     &#125;
     public void backtrack(int start,List&lt;Integer&gt; cur,int n,int k)&#123;
         //长度为K
         if(cur.size()==k)&#123;
             ans.add(new ArrayList(cur));
             return;
         &#125;
         //选择列表
         for(int i=start;i&lt;=n-(k-cur.size())+1;i++)&#123;
             cur.add(i);
             //这个地方是i+1 不是start+1!!!!(自己最开始bug就这个)
             backtrack(i+1,cur,n,k);
             //回溯
             cur.remove(cur.size()-1);
         &#125;
     &#125;
 &#125;
</code></pre>
<h2 id="组合问题之剪枝"><a href="#组合问题之剪枝" class="headerlink" title="组合问题之剪枝"></a>组合问题之剪枝</h2><p><strong>如果for循环我们选择的起始位置之后的元素个数 已经不足 我们需要的元素个数了，那么就没有必要搜索了</strong>。<br>举个例子，n &#x3D; 4，k &#x3D; 3， 目前已经选取的元素为0（path.size为0），n - (k - 0) + 1 即 4 - ( 3 - 0) + 1 &#x3D; 2。<br>从2开始搜索都是合理的，可以是组合[2, 3, 4]。 因为k是3 如果选择从3开始 最多3 4 依然不满足<br>组合问题可以套用<br>k是当前组合元素个数 n是i的范围<br>  i &lt;&#x3D; n - (k - path.size()) + 1</p>
<h2 id="组合总和"><a href="#组合总和" class="headerlink" title="组合总和"></a>组合总和</h2><pre><code>//给你一个 无重复元素 的整数数组 candidates 和一个目标整数 target ，找出 candidates 中可以使数字和为目标数 target 的
 // 所有 不同组合 ，并以列表形式返回。你可以按 任意顺序 返回这些组合。
</code></pre>
<pre><code>class Solution &#123;
     public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) &#123;
         List&lt;List&lt;Integer&gt;&gt; ans=new ArrayList&lt;&gt;();
         List&lt;Integer&gt; cur=new ArrayList&lt;&gt;();
         backtrack(candidates,target,ans,cur,0,0);
         return ans;
     &#125;
     public void backtrack(int[] candidates,int target,List&lt;List&lt;Integer&gt;&gt; ans,List&lt;Integer&gt; cur,int sum,int index) &#123;
         if (sum == target) &#123;
             ans.add(new ArrayList&lt;Integer&gt;(cur));
             //此处为啥不是ans.add(cur)？
             //答案：因为cur是数组的引用地址，直接add最后是空的
 
             return;
         &#125;
 
         if (sum &lt; target) &#123;
             //index的作用是为了使得不出现 测试结果:[[2,2,3],[2,3,2],[3,2,2],[7]] 期望结果:[[2,2,3],[7]]
             //这种情况，保持数组cur升序，也就避免了重复
                 for (int i = index; i &lt; candidates.length; i++) &#123;
                 cur.add(candidates[i]);
                 sum = sum + candidates[i];
                 backtrack(candidates, target, ans, cur, sum,i);//i传进去
                 cur.remove(cur.size() - 1);
                 sum = sum - candidates[i];//剪枝操作 返回回原来状态 否则sum只会越来越大
             &#125;
         &#125;
     &#125;
 
 &#125;
</code></pre>
<h2 id="组合总和II"><a href="#组合总和II" class="headerlink" title="组合总和II"></a>组合总和II</h2><p>给定一个候选人编号的集合 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。<br>candidates 中的每个数字在每个组合中只能使用 <strong>一次</strong> 。</p>
<pre><code>class Solution &#123;
     List&lt;List&lt;Integer&gt;&gt; ans=new ArrayList&lt;&gt;();
     public List&lt;List&lt;Integer&gt;&gt; combinationSum2(int[] candidates, int target) &#123;
         List&lt;Integer&gt; cur=new ArrayList&lt;&gt;();
         //排序
         Arrays.sort(candidates);
         backtrack(target,0,cur,0,candidates);
         return ans;
 
     &#125;
     public void backtrack(int target,int sum,List&lt;Integer&gt; cur,int start,int[] candidates)&#123;
         if(sum==target)&#123;
             ans.add(new ArrayList&lt;&gt;(cur));
             return;
         &#125;
         //这个地方剪枝很关键，sum+candidates[i]&lt;= target 判断一下是不是超过Num，超过的话就不执行
         for(int i=start;i&lt;candidates.length&amp;&amp;sum+candidates[i]&lt;= target;i++)&#123;
             //去重  比如 1125  会出现两个125 我们所以到第二个1就不执行
             if(i!=start&amp;&amp;candidates[i]==candidates[i-1]) continue;
             cur.add(candidates[i]);
             sum+=candidates[i];
             backtrack(target,sum,cur,i+1,candidates);
             cur.remove(cur.size()-1);
             sum-=candidates[i];
         &#125;
     &#125;
 &#125;
</code></pre>
<h2 id="组合总和III"><a href="#组合总和III" class="headerlink" title="组合总和III"></a>组合总和III</h2><p>找出所有相加之和为 n 的 k 个数的组合，且满足下列条件：</p>
<ul>
<li>只使用数字1到9</li>
<li>每个数字 <strong>最多使用一次</strong></li>
</ul>
<p>返回 <em>所有可能的有效组合的列表</em> 。该列表不能包含相同的组合两次，组合可以以任何顺序返回。</p>
<pre><code>class Solution &#123;
     List&lt;List&lt;Integer&gt;&gt; ans=new ArrayList&lt;&gt;();
     public List&lt;List&lt;Integer&gt;&gt; combinationSum3(int k, int n) &#123;
         List&lt;Integer&gt; cur=new ArrayList&lt;&gt;();
         backtrack(k,n,0,1,cur);
         return ans;
     &#125;
     public void backtrack(int k, int n,int sum,int start,List&lt;Integer&gt; cur)&#123;
         //出口
         if(cur.size()==k)&#123;
             if(n==sum)&#123;
                 ans.add(new ArrayList&lt;&gt;(cur));
             &#125;
             return;
         &#125;
         for(int i=start;i&lt;=9-(k-cur.size())+1;i++)&#123;
             cur.add(i);
             sum=sum+i;
             backtrack(k,n,sum,i+1,cur);
             //sum和cur都回溯
             cur.remove(cur.size()-1);
             sum=sum-i;
         &#125;
     &#125;
 &#125;
</code></pre>
<h2 id="电话号码的字母组合"><a href="#电话号码的字母组合" class="headerlink" title="电话号码的字母组合"></a>电话号码的字母组合</h2><p><img src="https://raw.githubusercontent.com/viacheung/img/main/image/image-20221110215820412.png#from=url&id=bz8BW&originHeight=314&originWidth=815&originalType=binary&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&title="></p>
<pre><code>class Solution &#123;
     List&lt;String&gt; ans=new ArrayList&lt;&gt;();
     public List&lt;String&gt; letterCombinations(String digits) &#123;
         Map&lt;Character,String&gt; map=new HashMap&lt;&gt;()&#123;
             &#123;
                 put(&#39;2&#39;, &quot;abc&quot;);
                 put(&#39;3&#39;, &quot;def&quot;);
                 put(&#39;4&#39;, &quot;ghi&quot;);
                 put(&#39;5&#39;, &quot;jkl&quot;);
                 put(&#39;6&#39;, &quot;mno&quot;);
                 put(&#39;7&#39;, &quot;pqrs&quot;);
                 put(&#39;8&#39;, &quot;tuv&quot;);
                 put(&#39;9&#39;, &quot;wxyz&quot;);
             &#125;
         &#125;;
         StringBuilder cur=new StringBuilder();
         backtrack(digits,map,0,cur);
         return ans;
     &#125;
     public void backtrack(String digits,Map&lt;Character,String&gt; map,int index,StringBuilder cur)&#123;
         //digits空的情况
         if(digits.length()==0) return;
         if(index==digits.length())&#123;
             ans.add(cur.toString());
             return;
         &#125;
         char dight=digits.charAt(index);
         String letters=map.get(dight);
         for(int i=0;i&lt;letters.length();i++)&#123;
             cur.append(letters.charAt(i));
             backtrack(digits,map,index+1,cur);
             cur.deleteCharAt(index);
         &#125;
     &#125;
 &#125;
</code></pre>
<h2 id="分割问题："><a href="#分割问题：" class="headerlink" title="分割问题："></a>分割问题：</h2><p>我们来分析一下切割，<strong>其实切割问题类似组合问题</strong>。<br>例如对于字符串abcdef：</p>
<ul>
<li>组合问题：选取一个a之后，在bcdef中再去选取第二个，选取b之后在cdef中在选组第三个…..。</li>
<li>切割问题：切割一个a之后，在bcdef中再去切割第二段，切割b之后在cdef中在切割第三段…..。</li>
</ul>
<p>感受出来了不？<br>所以切割问题，也可以抽象为一棵树形结构，如图：<br><img src="https://raw.githubusercontent.com/viacheung/img/main/image/131.%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2.jpg#from=url&id=pbWqz&originHeight=840&originWidth=1456&originalType=binary&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&title="><br>递归用来纵向遍历，for循环用来横向遍历，切割线（就是图中的红线）切割到字符串的结尾位置，说明找到了一个切割方法。<br>此时可以发现，切割问题的回溯搜索的过程和组合问题的回溯搜索的过程是差不多的。</p>
<h2 id="分割回文串"><a href="#分割回文串" class="headerlink" title="分割回文串"></a>分割回文串</h2><p>给你一个字符串 s，请你将 s 分割成一些子串，使每个子串都是 <strong>回文串</strong> 。返回 s 所有可能的分割方案。<br><strong>回文串</strong> 是正着读和反着读都一样的字符串。</p>
<pre><code>class Solution &#123;
     List&lt;List&lt;String&gt;&gt; ans=new ArrayList&lt;&gt;();
     List&lt;String&gt; cur=new ArrayList&lt;&gt;();
     public List&lt;List&lt;String&gt;&gt; partition(String s) &#123;
         backtrack(0,s);
         return ans;        
     &#125;
     public void backtrack(int start,String s)&#123;
         //出口 切割到头就结束
         if(start==s.length())&#123;
             ans.add(new ArrayList&lt;&gt;(cur));
             return;
         &#125;
         for(int i=start;i&lt;s.length();i++)&#123;
             String substring=s.substring(start,i+1);
             if(isPalindrome(substring))&#123;
                 cur.add(substring);
                 backtrack(i+1,s);
                 cur.remove(cur.size()-1);
             &#125;
         &#125;
     &#125;
     //判断是否为回文串
     public  boolean isPalindrome(String s)&#123;
         for(int i=0,j=s.length()-1;i&lt;j;i++,j--)&#123;
             if(s.charAt(i)!=s.charAt(j)) return false;
         &#125;
         return true;
     &#125;
 &#125;
</code></pre>
<h2 id="复原-IP-地址"><a href="#复原-IP-地址" class="headerlink" title="复原 IP 地址"></a>复原 IP 地址</h2><p><strong>有效 IP 地址</strong> 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 0），整数之间用 ‘.’ 分隔。</p>
<ul>
<li>例如：”0.1.2.201” 和”192.168.1.1” 是 <strong>有效</strong> IP 地址，但是 “0.011.255.245”、”192.168.1.312” 和 “<a href="mailto:&#49;&#57;&#50;&#x2e;&#x31;&#54;&#56;&#x40;&#49;&#x2e;&#x31;">&#49;&#57;&#50;&#x2e;&#x31;&#54;&#56;&#x40;&#49;&#x2e;&#x31;</a>“ 是 <strong>无效</strong> IP 地址。</li>
</ul>
<p>给定一个只包含数字的字符串 s ，用以表示一个 IP 地址，返回所有可能的<strong>有效 IP 地址</strong>，这些地址可以通过在 s 中插入 ‘.’ 来形成。你 <strong>不能</strong> 重新排序或删除 s 中的任何数字。你可以按 <strong>任何</strong> 顺序返回答案。</p>
<pre><code>class Solution &#123;
     //事实证明 结果集和当前集都放外面即可
     List&lt;String&gt; ans=new ArrayList&lt;&gt;();
     StringBuilder sb=new StringBuilder();
     // List&lt;String&gt; temp=new ArrayList();
     public List&lt;String&gt; restoreIpAddresses(String s) &#123;
         backtrack(s,0,0);
         return ans;
     &#125;
     public void backtrack(String s,int start,int sum)&#123;
         //四个数且到头了
         if(sum==4&amp;&amp;start==s.length())&#123;
             ans.add(new String(sb));
             // ans.add(String.join(&quot;.&quot;,temp));
             return;
         &#125;
         //i&lt;start+3是剪支
         for(int i=start;i&lt;start+3&amp;&amp;i&lt;s.length();i++)&#123;
             String substring=s.substring(start,i+1);
             if(islegal(substring))&#123;
                 int sz = sb.length();
                 if(sb.length()==0)&#123;
                     sb.append(substring);
                 &#125;else&#123;
                     sb.append(&quot;.&quot;).append(substring);
                 &#125;
                 // temp.add(substring);
                 sum+=1;
                 backtrack(s,i+1,sum);
                 // temp.remove(temp.size()-1);
                 sb.delete(sz,sb.length());
                 sum-=1;
             &#125;
         &#125;
     &#125;
     public boolean islegal(String s)&#123;
         if(s.charAt(0)==&#39;0&#39;&amp;&amp;s.length()&gt;1) return false;
         for(char c:s.toCharArray())&#123;
             if(!Character.isDigit(c)) return false;
         &#125;
         long number=Long.parseLong(s);
         if(number&gt;255) return false;
         return true;
     &#125;
 &#125;
</code></pre>
<h3 id="结果有符号问题"><a href="#结果有符号问题" class="headerlink" title="结果有符号问题"></a>结果有符号问题</h3><p>遇到这种需要加中间符号分割的题目 两种解决办法：<br>第一种我的想法：</p>
<pre><code>if(sb.length()==0)&#123;
 sb.append(substring);
 &#125;else&#123;
 sb.append(&quot;.&quot;).append(substring);
 &#125;
</code></pre>
<p>第二种先放到一个tmp集合里面<br>然后<br>  ans.add(String.join(“.”,temp));</p>
<h3 id="回溯需要注意的地方"><a href="#回溯需要注意的地方" class="headerlink" title="回溯需要注意的地方"></a>回溯需要注意的地方</h3><p>进括号了就不用再回溯，因为进括号后，相当于我当前未作选择<br>所以要么</p>
<pre><code>sum+=1;
 backtrack(s,i+1,sum);
 sum-=1;
</code></pre>
<p>要么<br> backtrack(s,i+1,sum+1);<br>StringBuilder回溯:</p>
<pre><code>int sz = sb.length();
 sb.delete(sz,sb.length());
</code></pre>
<h2 id="子集问题："><a href="#子集问题：" class="headerlink" title="子集问题："></a>子集问题：</h2><p>求子集问题和<a target="_blank" rel="noopener" href="https://programmercarl.com/0077.%E7%BB%84%E5%90%88.html">77.组合</a><a target="_blank" rel="noopener" href="https://programmercarl.com/0077.%E7%BB%84%E5%90%88.html">(opens new window)</a>和<a target="_blank" rel="noopener" href="https://programmercarl.com/0131.%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2.html">131.分割回文串</a><br><a target="_blank" rel="noopener" href="https://programmercarl.com/0131.%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2.html">(opens new window)</a>又不一样了。<br>如果把 子集问题、组合问题、分割问题都抽象为一棵树的话，<strong>那么组合问题和分割问题都是收集树的叶子节点，而子集问题是找树的所有节点！</strong><br>其实子集也是一种组合问题，因为它的集合是无序的，子集{1,2} 和 子集{2,1}是一样的。<br><strong>那么既然是无序，取过的元素不会重复取，写回溯算法的时候，for就要从startIndex开始，而不是从0开始！</strong><br>什么时候for可以从0开始呢？求排列问题的时候，就要从0开始，因为集合是有序的，{1, 2} 和{2, 1}是两个集合，排列问题我们后续的文章就会讲到的。<br>以示例中nums &#x3D; [1,2,3]为例把求子集抽象为树型结构，如下：<br><img src="https://raw.githubusercontent.com/viacheung/img/main/image/202011232041348.png#from=url&id=WUNeC&originHeight=902&originWidth=1546&originalType=binary&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&title="></p>
<h2 id="子集"><a href="#子集" class="headerlink" title="子集"></a>子集</h2><p>给你一个整数数组 nums ，数组中的元素 <strong>互不相同</strong> 。返回该数组所有可能的子集（幂集）。<br>解集 <strong>不能</strong> 包含重复的子集。你可以按 <strong>任意顺序</strong> 返回解集。</p>
<pre><code>class Solution &#123;
     List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;();
     List&lt;Integer&gt; cur = new ArrayList&lt;&gt;();
     public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) &#123;
         backtrack(0,nums);
         return ans;
     &#125;
     public void backtrack(int start,int[] nums)&#123;
         // 收集子集，要放在终止添加的上面，否则会漏掉自己
         ans.add(new ArrayList&lt;Integer&gt;(cur));
         // 下面三行可以不写 因为本来我们就要遍历整棵树。代码随想录具体有讲解
         if(start==nums.length)&#123;
             return;
         &#125;
         for(int i=start;i&lt;nums.length;i++)&#123;
             cur.add(nums[i]);
             backtrack(i+1,nums);
             cur.remove(cur.size()-1);
         &#125;
     &#125;
 &#125;
</code></pre>
<h2 id="子集II"><a href="#子集II" class="headerlink" title="子集II"></a>子集II</h2><p>给你一个整数数组 nums ，其中可能包含重复元素，请你返回该数组所有可能的子集（幂集）。<br>解集 <strong>不能</strong> 包含重复的子集。返回的解集中，子集可以按 <strong>任意顺序</strong> 排列。<br><strong>和1不同的是要去重</strong></p>
<pre><code>class Solution &#123;
     //Set去重
     Set&lt;List&lt;Integer&gt;&gt; set = new HashSet&lt;&gt;();
     List&lt;Integer&gt; cur = new ArrayList&lt;&gt;();
     public List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(int[] nums) &#123;
         //先排序 
         Arrays.sort(nums);
         backtrack(0,nums);
         return new ArrayList(set);
     &#125;
     public void backtrack(int start,int[] nums)&#123;
         // 收集子集，要放在终止添加的上面，否则会漏掉自己
         set.add(new ArrayList&lt;Integer&gt;(cur));
         // 下面三行可以不写 因为本来我们就要遍历整棵树。代码随想录具体有讲解
         if(start==nums.length)&#123;
             return;
         &#125;
         for(int i=start;i&lt;nums.length;i++)&#123;
             // 另一种去重方法  
             // if (i &gt; start &amp;&amp; nums[i] == nums[i - 1]) continue;
             cur.add(nums[i]);
             backtrack(i+1,nums);
             cur.remove(cur.size()-1);
         &#125;
     &#125;
 &#125;
</code></pre>
<h2 id="递增子序列"><a href="#递增子序列" class="headerlink" title="递增子序列"></a>递增子序列</h2><p>给你一个整数数组 nums ，找出并返回所有该数组中不同的递增子序列，递增子序列中 <strong>至少有两个元素</strong> 。你可以按 <strong>任意顺序</strong> 返回答案。<br>数组中可能含有重复元素，如出现两个整数相等，也可以视作递增序列的一种特殊情况。<br><img src="https://raw.githubusercontent.com/viacheung/img/main/image/20201124200229824.png#from=url&id=tBgPw&originHeight=942&originWidth=1960&originalType=binary&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&title="></p>
<pre><code>class Solution &#123;
     List&lt;List&lt;Integer&gt;&gt; ans=new ArrayList&lt;&gt;();
     List&lt;Integer&gt; cur=new ArrayList&lt;&gt;();
     public List&lt;List&lt;Integer&gt;&gt; findSubsequences(int[] nums) &#123;
         backtrack(nums,0);
         return ans;
     &#125;
     public void backtrack(int[] nums,int start)&#123;
         if(cur.size()&gt;=2)&#123;
             ans.add(new ArrayList&lt;&gt;(cur));
         &#125;
         //记录当前层的结点  只在当前层有效  到下一层又初始化了 因此达到了去重当前层的效果
         Set&lt;Integer&gt; seen=new HashSet&lt;&gt;();
         for(int i=start;i&lt;nums.length;i++)&#123;
             //先写continue的部分
             //保证递增
             if(cur.size()!=0&amp;&amp;nums[i]&lt;cur.get(cur.size()-1)) continue;
             //去重   例如 446   46 46会重复 所以需要记录当前层的结点也就是第一个4取了之后 后一个4就不要取了
             if(seen.contains(nums[i])) continue;
             //for循环结束就无了
             seen.add(nums[i]);
             cur.add(nums[i]);
             backtrack(nums,i+1);
             cur.remove(cur.size()-1);
             
         &#125;
     &#125;
 &#125;
</code></pre>
<h2 id="排列问题："><a href="#排列问题：" class="headerlink" title="排列问题："></a>排列问题：</h2><p><img src="https://raw.githubusercontent.com/viacheung/img/main/image/20211027181706.png#from=url&id=MQ19g&originHeight=956&originWidth=1884&originalType=binary&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&title="><br>1、for循环里不用start，而用0<br>2、出口： f (path.size() &#x3D;&#x3D; nums.size())<br>3、使用used数组，其实就是记录此时path里都有哪些元素使用了，一个排列里一个元素只能使用一次。</p>
<h2 id="全排列"><a href="#全排列" class="headerlink" title="全排列"></a>全排列</h2><p>给定一个不含重复数字的数组 nums ，返回其 <em>所有可能的全排列</em> 。你可以 <strong>按任意顺序</strong> 返回答案。</p>
<pre><code>class Solution &#123;
     List&lt;List&lt;Integer&gt;&gt; ans=new ArrayList&lt;&gt;();
     List&lt;Integer&gt; cur=new ArrayList&lt;&gt;();
     boolean[] used;
     public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) &#123;
         //used数组  因为for从0开始   123 选了1递归进去防止还选1
         used=new boolean[nums.length]; 
         backtrack(nums);
         return ans;
     &#125;
     public void backtrack(int[] nums)&#123;
         if(cur.size()==nums.length)&#123;
             ans.add(new ArrayList&lt;&gt;(cur));
             return;
         &#125;
         for(int i=0;i&lt;nums.length;i++)&#123;
             if(used[i]==true) continue;
             cur.add(nums[i]);
             used[i]=true;
             backtrack(nums);
             used[i]=false;
             cur.remove(cur.size()-1);
         &#125;
 
     &#125;
 &#125;
</code></pre>
<h2 id="全排列-II"><a href="#全排列-II" class="headerlink" title="全排列 II"></a>全排列 II</h2><p>给定一个可包含重复数字的序列 nums ，**<em>按任意顺序</em>** 返回所有不重复的全排列。</p>
<pre><code>class Solution &#123;
     List&lt;List&lt;Integer&gt;&gt; ans=new ArrayList&lt;&gt;();
     List&lt;Integer&gt; cur=new ArrayList&lt;&gt;();
     boolean[] used;
     public List&lt;List&lt;Integer&gt;&gt; permuteUnique(int[] nums) &#123;
         used=new boolean[nums.length]; 
         backtrack(nums);
         return ans;
     &#125;
     public void backtrack(int[] nums)&#123;
     if(cur.size()==nums.length)&#123;
         ans.add(new ArrayList&lt;&gt;(cur));
         return;
     &#125;
     Set&lt;Integer&gt; seen=new HashSet&lt;&gt;();
     for(int i=0;i&lt;nums.length;i++)&#123;
         if(used[i]==true) continue;
         //记录当前层结点 为了去重      这是含有重复元素去重的一个重要技巧
         if(seen.contains(nums[i])) continue;
         seen.add(nums[i]);
         cur.add(nums[i]);
         used[i]=true;
         backtrack(nums);
         used[i]=false;
         cur.remove(cur.size()-1);
     &#125;
 
 &#125;
 &#125;
</code></pre>
<h2 id="重新安排行程"><a href="#重新安排行程" class="headerlink" title="重新安排行程"></a>重新安排行程</h2><p><img src="https://raw.githubusercontent.com/viacheung/img/main/image/image-20221115191220877.png#from=url&id=OiV9y&originHeight=704&originWidth=1019&originalType=binary&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&title="><br><img src="https://raw.githubusercontent.com/viacheung/img/main/image/2020111518065555.png#from=url&id=G04QB&originHeight=946&originWidth=1306&originalType=binary&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&title="></p>
<pre><code>class Solution &#123;
     List&lt;String&gt; res=new ArrayList&lt;&gt;();
     List&lt;String&gt; cur = new ArrayList&lt;&gt;();
     boolean[] used;
     public List&lt;String&gt; findItinerary(List&lt;List&lt;String&gt;&gt; tickets) &#123;
         //按照字母顺序排目的地的顺序
         Collections.sort(tickets, (a, b) -&gt; a.get(1).compareTo(b.get(1)));
         System.out.println(tickets);
         cur.add(&quot;JFK&quot;);
         used = new boolean[tickets.size()];
         backtrack(tickets);
         return res;
     &#125;
     public boolean backtrack(List&lt;List&lt;String&gt;&gt; tickets) &#123;
         //个数等于行程数+1
         if (cur.size() == tickets.size() + 1) &#123;
             res = new ArrayList(cur);
             return true;
         &#125;
         for (int i = 0; i &lt; tickets.size(); i++) &#123;
             // 避免反身性和保证前一个航班的到后一个航班的正确性
             //这里不用考虑下标 因为cur已经添加了jfk
             if (!used[i] &amp;&amp; tickets.get(i).get(0).equals(cur.get(cur.size()-1))) &#123;
                 //当前ticket出发地和cur最后一个元素等的话就可以加
                 cur.add(tickets.get(i).get(1));
                 used[i] = true;
                 //只要找到一个就Ok 相当于剪枝
                 if (backtrack(tickets)) &#123;
                     return true;
                 &#125;
                 used[i] = false;
                 cur.remove(cur.size()-1);
             &#125;
         &#125;
         return false;
     &#125;
 &#125;
</code></pre>
<h2 id="N皇后"><a href="#N皇后" class="headerlink" title="N皇后"></a>N皇后</h2><p>按照国际象棋的规则，皇后可以攻击与之处在同一行或同一列或同一斜线上的棋子。<br><strong>n 皇后问题</strong> 研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。<br>给你一个整数 n ，返回所有不同的 <strong>n 皇后问题</strong> 的解决方案。<br>每一种解法包含一个不同的 <strong>n 皇后问题</strong> 的棋子放置方案，该方案中 ‘Q’ 和 ‘.’ 分别代表了皇后和空位。<br>例如：<br><img src="https://raw.githubusercontent.com/viacheung/img/main/image/20211020232201.png#from=url&id=VYiOB&originHeight=400&originWidth=866&originalType=binary&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&title="><br>输出：[[“.Q..”,”…Q”,”Q…”,”..Q.”],[“..Q.”,”Q…”,”…Q”,”.Q..”]]<br><img src="https://raw.githubusercontent.com/viacheung/img/main/image/20210130182532303.jpg#from=url&id=rONju&originHeight=1154&originWidth=1432&originalType=binary&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&title="></p>
<pre><code>class Solution &#123;
     List&lt;List&lt;String&gt;&gt; ans=new ArrayList&lt;&gt;();
     //row行 col列
     public List&lt;List&lt;String&gt;&gt; solveNQueens(int n) &#123;
         char[][] board=new char[n][n];
         //初始化
         for(char[] c:board)&#123;
             //数组填充
             Arrays.fill(c,&#39;.&#39;);
         &#125;
         backtrack(n,0,board);
         return ans;
     &#125;
     public void backtrack(int n,int row,char[][] board)&#123;
         //出口
         if(row==n)&#123;
             //char[][] 转ArrayList
             ans.add(toArrayList(board));
             return;
         &#125;
         for(int col=0;col&lt;n;col++)&#123;
             //满足条件
             if(isValid(row,col,board,n))&#123;
                 board[row][col]=&#39;Q&#39;;
                 //row+1传进去就不用回溯row了
                 backtrack(n,row+1,board);
                 //回溯
                 board[row][col]=&#39;.&#39;;
             &#125;
         &#125;
     &#125;
     //char转ArrayList
     public List toArrayList(char[][] board)&#123;
         List&lt;String&gt; list=new ArrayList&lt;&gt;();
         for(char[] c:board)&#123;
             list.add(String.copyValueOf(c));
         &#125;
         return list;
     &#125;
     //保证正上方   左上斜线  右上斜线  没有重复就行
     public boolean isValid(int row,int col,char[][] board,int n)&#123;
         //当前列正上方 
         for(int i=0;i&lt;row;i++)&#123;
             if(board[i][col]==&#39;Q&#39;)&#123;
                 return false;
             &#125;
         &#125;
         //左上方
         for(int i=row-1,j=col-1;i&gt;=0&amp;&amp;j&gt;=0;i--,j--)&#123;
             if(board[i][j]==&#39;Q&#39;)&#123;
                 return false;
             &#125;
         &#125;
         //右上方
         for(int i=row-1,j=col+1;i&gt;=0&amp;&amp;j&lt;n;i--,j++)&#123;
             if(board[i][j]==&#39;Q&#39;)&#123;
                 return false;
             &#125;
         &#125;
         return true;
     &#125;
 &#125;
</code></pre>
<h2 id="解数独"><a href="#解数独" class="headerlink" title="解数独"></a>解数独</h2><p>编写一个程序，通过填充空格来解决数独问题。<br>数独的解法需 <strong>遵循如下规则</strong>：<br>数字 1-9 在每一行只能出现一次。数字 1-9 在每一列只能出现一次。数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。<br>数独部分空格内已填入了数字，空白格用 ‘.’ 表示。<br>1、可以理解为二维递归<br><strong>2、为什么递归函数的返回值需要是bool类型</strong><br>因为解数独找到一个符合的条件（就在树的叶子节点上）立刻就返回，相当于找从根节点到叶子节点一条唯一路径，所以需要使用bool返回值。</p>
<pre><code>class Solution &#123;
     public void solveSudoku(char[][] board) &#123;
         backrtrack(board);
     &#125;
     public boolean backrtrack(char[][] board)&#123;
         for(int i=0;i&lt;9;i++)&#123;
             for(int j=0;j&lt;9;j++)&#123;
                 //如果不是. 跳过这个数字
                 if(board[i][j]!=&#39;.&#39;) continue;
                 for(char k=&#39;1&#39;;k&lt;=&#39;9&#39;;k++)&#123;
                     //符合要求
                     if(isValid(i,j,k,board))&#123;
                         board[i][j]=k;
                         //填完这个如果符合要求 那么赶紧return true;
                         if(backrtrack(board)) return true;
                         board[i][j]=&#39;.&#39;;
                     &#125;
                 &#125;
                 //既然到这里了，说明都试了一次，且都不成功，因此返回false;
                 return false;
             &#125;
         &#125;
         //都到这里了 说明全部遍历了一次 且没有返回false 直接返回true
         return true;
     &#125;
     public boolean isValid(int row,int col,char k,char[][] board)&#123;
         //行是否符合要求 这里不能剪枝 因为后面也有原本的数字
         for(int i=0;i&lt;9;i++)&#123;
             if(board[row][i]==k) return false;
         &#125;
         //列是否符合要求
         for(int j=0;j&lt;9;j++)&#123;
             if(board[j][col]==k) return false;
         &#125;
         //算九宫格左上角的位置  row/3 前面有几个3的倍数(向下取整)
         int startRow=(row/3)*3;
         int startCol=(col/3)*3;
         for(int i=startRow;i&lt;startRow+3;i++)&#123;
             for(int j=startCol;j&lt;startCol+3;j++)&#123;
                 if(board[i][j]==k) return false;
             &#125;
         &#125;
         return true;
     &#125;
 &#125;
</code></pre>
<h2 id="目标和"><a href="#目标和" class="headerlink" title="目标和"></a>目标和</h2><p><img src="https://raw.githubusercontent.com/viacheung/img/main/image/image-20221006230012446.png#from=url&id=tMDTv&originHeight=179&originWidth=667&originalType=binary&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&title="></p>
<pre><code>class Solution &#123;
     int count=0;
     public int findTargetSumWays(int[] nums, int target) &#123;
         backtrack(nums, 0, 0, target);
         return count;
     &#125;
     private void backtrack(int[] nums, int i, int sum, int target)&#123;
         //结束条件
         if(i == nums.length)&#123;   
             if(sum == target)&#123;
                 count++;
             &#125;
             return;
         &#125;else&#123;
             //两个选择
             backtrack(nums,i+1,sum+nums[i],target);
             backtrack(nums,i+1,sum-nums[i],target);
         &#125;
     &#125;
 &#125;
</code></pre>
<p>我的理解：讲道理这个就是递归呀 相当于二叉树递归</p>
<h2 id="删除无效括号"><a href="#删除无效括号" class="headerlink" title="删除无效括号"></a>删除无效括号</h2><p>给你一个由若干括号和字母组成的字符串 s ，删除最小数量的无效括号，使得输入的字符串有效。<br>返回所有可能的结果。答案可以按 <strong>任意顺序</strong> 返回。<br><img src="https://raw.githubusercontent.com/viacheung/img/main/image/image-20220926152136279.png#from=url&id=iTy9v&originHeight=1125&originWidth=924&originalType=binary&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&title="></p>
<pre><code>class Solution &#123;
     List&lt;String&gt; res=new ArrayList&lt;&gt;();
     public List&lt;String&gt; removeInvalidParentheses(String s) &#123;
         int lremove=0,rremove=0;
         
         //统计最少需要去除的左括号以及右括号
         for(int i=0;i&lt;s.length();i++)&#123;
             if(s.charAt(i)==&#39;(&#39;)&#123;
                 lremove++;
             &#125;else if(s.charAt(i)==&#39;)&#39;)&#123;//注意审题 有字母 所以 不能直接else 需要elseif 后面也是一样
                 if(lremove==0)&#123;
                     rremove++;
                 &#125;else&#123;
                     lremove--;
                 &#125;
             &#125;
         &#125;
         //进行回溯
         backtrack(s,0,lremove,rremove);
         return res;
     &#125;
     public void backtrack(String str,int start,int lremove,int rremove)&#123;
         //结束条件
         if(lremove==0&amp;&amp;rremove==0)&#123;
             //判断是否有效
             if(isValid(str))&#123;
                 res.add(str);
             &#125;
             return;
         &#125;
         for(int i=start;i&lt;str.length();i++)&#123;
             //剪枝 有连着重复的括号 跳过回溯 因为第一个已经回溯了 后面没必要了
             我们在每次进行搜索时，如果遇到连续相同的括号我们只需要搜索一次即可，比如当前遇到的字符串为 &quot;(((())&quot;，去掉前四个左括号中的任意一个，生成的字符串是一样的，均为 &quot;((())&quot;，因此我们在尝试搜索时，只需去掉一个左括号进行下一轮搜索，不需要将前四个左括号都尝试一遍。
             if(i!=start&amp;&amp;str.charAt(i)==str.charAt(i-1)) continue;
             //剪枝 需要去除括号大于所剩长度 直接返回
             if(lremove+rremove&gt;str.length()-i) return;
             //去除一个(   再加上后面一个元素 下标还是i，不会改变  因此“去除(”可以理解为选择 i++即为取消选择(即老子不去除这个括号)
             if(lremove&gt;0&amp;&amp;str.charAt(i)==&#39;(&#39;)&#123;
                 //substring 左开右闭
                 backtrack(str.substring(0,i)+str.substring(i+1),i,lremove-1,rremove);
             &#125;                   
             if(rremove&gt;0&amp;&amp;str.charAt(i)==&#39;)&#39;)&#123;
                 backtrack(str.substring(0,i)+str.substring(i+1),i,lremove,rremove-1);
             &#125;
         &#125;
 
     &#125;
  
     public boolean isValid(String str)&#123;
         int cnt=0;
         for(int i=0;i&lt;str.length();i++)&#123;
             if(str.charAt(i)==&#39;(&#39;)&#123;
                 cnt++;
             &#125;else if(str.charAt(i)==&#39;)&#39;)&#123;
                 if(cnt==0)&#123;
                     return false;
                 &#125;else &#123;
                     cnt--;
                 &#125;
             &#125;
         &#125;
         return cnt==0;
     &#125;
 &#125;
</code></pre>
<h2 id="括号匹配"><a href="#括号匹配" class="headerlink" title="括号匹配"></a>括号匹配</h2><p><strong>if的两个选择 括号匹配</strong><br>![image-20220422101329099](C:\Users\viacheung\OneDrive\ZWY{��.assets\image-20220422101329099.png)</p>
<h2 id="例题3"><a href="#例题3" class="headerlink" title="例题3"></a>例题3</h2><pre><code>vector&lt;int&gt; t;
 void dfs(int cur, int n) &#123;
     if (cur == n) &#123;
         // 记录答案
         // ...
         return;
     &#125;
     // 考虑选择当前位置
     t.push_back(cur);
     dfs(cur + 1, n, k);
     t.pop_back();
     // 考虑不选择当前位置
     dfs(cur + 1, n, k);
 &#125;
</code></pre>
<p> ![image-20220531161347850](C:\Users\viacheung\OneDrive\ZWY{��.assets\image-20220531161347850.png)</p>
<h2 id="N-皇后-II"><a href="#N-皇后-II" class="headerlink" title="N 皇后 II"></a>N 皇后 II</h2><p><strong>n 皇后问题</strong> 研究的是如何将 n 个皇后放置在 n × n 的棋盘上，并且使皇后彼此之间不能相互攻击。<br>给你一个整数 n ，返回 <strong>n 皇后问题</strong> 不同的解决方案的数量<br>题解：和N皇后1一样 简化了 1要求解的集合，而2只求数量 也就是1是维护一个List 2是count</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://viacheung.github.io/2023/06/04/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="ViaCheung">
      <meta itemprop="description" content="el psy congroo">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="命运石之门">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/06/04/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
	  <span class="post-time">

	  
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-06-04 01:01:51 / 修改时间：01:01:52" itemprop="dateCreated datePublished" datetime="2023-06-04T01:01:51+08:00">2023-06-04</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="经验"><a href="#经验" class="headerlink" title="经验"></a>经验</h2><p>不用管最优子结构啊和重叠子问题</p>
<ol>
<li>确定dp数组（dp table）以及下标的含义</li>
<li>确定递推公式</li>
<li>dp数组如何初始化（递推公式决定了dp数组要如何初始化）</li>
<li>确定遍历顺序</li>
<li>举例推导dp数组</li>
</ol>
<p><strong>如何debug</strong><br>_做动规的题目，写代码之前一定要把状态转移在dp数组的上具体情况模拟一遍，心中有数，确定最后推出的是想要的结果_。<br>然后再写代码，如果代码没通过就打印dp数组，看看是不是和自己预先推导的哪里不一样。如果打印出来和自己预先模拟推导是一样的，那么就是自己的递归公式、初始化或者遍历顺序有问题了。如果和自己预先模拟推导的不一样，那么就是代码实现细节有问题。</p>
<ul>
<li>这道题目我举例推导状态转移公式了么？</li>
<li>我打印dp数组的日志了么？</li>
<li>打印出来了dp数组和我想的一样么？</li>
</ul>
<p><strong>动态规划的三大步骤</strong><br>利用历史记录，来避免重复计算。而这些历史记录，我们得需要一些变量来保存，一般是用一维数组或者[二维数组](<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=">https://www.zhihu.com/search?q=二维数组&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="ViaCheung"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">ViaCheung</p>
  <div class="site-description" itemprop="description">el psy congroo</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">32</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/viacheung" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;viacheung" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:viacheung5@gmail.com" title="E-Mail → mailto:viacheung5@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/zh-CN" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ViaCheung</span>
</div>

<!--
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div> -->

<!-- 网站运行时间的设置 -->
<span id="timeDate">载入天数...</span>
<span id="times">载入时分秒...</span>
<script>
    var now = new Date();
    function createtime() {
        var grt= new Date("03/01/2023 10:00:00"); //此处修改你的建站时间或者网站上线时间
        now.setTime(now.getTime()+250);
        days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days);
        hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours);
        if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);
        mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;}
        seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
        snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;}
        document.getElementById("timeDate").innerHTML = "本站已安全运行 "+dnum+" 天 ";
        document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒.";
    }
setInterval("createtime()",250);
</script>
        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>

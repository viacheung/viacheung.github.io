<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.1.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"viacheung.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="el psy congroo">
<meta property="og:type" content="website">
<meta property="og:title" content="命运石之门">
<meta property="og:url" content="http://viacheung.github.io/page/4/index.html">
<meta property="og:site_name" content="命运石之门">
<meta property="og:description" content="el psy congroo">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="ViaCheung">
<meta property="article:tag" content="Java,python">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://viacheung.github.io/page/4/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>命运石之门</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">命运石之门</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">欢迎来到我的博客空间🙇</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-schedule">

    <a href="/schedule/" rel="section"><i class="fa fa-calendar fa-fw"></i>日程表</a>

  </li>
        <li class="menu-item menu-item-sitemap">

    <a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>站点地图</a>

  </li>
        <li class="menu-item menu-item-commonweal">

    <a href="/404/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>公益 404</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/viacheung" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://viacheung.github.io/2023/06/04/%E6%95%B0%E5%AD%A6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="ViaCheung">
      <meta itemprop="description" content="el psy congroo">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="命运石之门">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/06/04/%E6%95%B0%E5%AD%A6/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
	  <span class="post-time">

	  
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-06-04 01:01:44 / 修改时间：01:01:45" itemprop="dateCreated datePublished" datetime="2023-06-04T01:01:44+08:00">2023-06-04</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Pow-x-n"><a href="#Pow-x-n" class="headerlink" title="Pow(x, n)"></a>Pow(x, n)</h2><p>实现 <a target="_blank" rel="noopener" href="https://www.cplusplus.com/reference/valarray/pow/">pow(x,n)</a> ，即计算 x 的整数 n 次幂函数（即，xn ）。<br><strong>题解：</strong><br>本质就是递归算法，不用一个个乘，比如要计算x^64 可以计算x—x2—x4—x8—x16—x32—x65<br>如果n为奇数再乘以个x，为0的话结果为1</p>
<pre><code>class Solution &#123;
    public double myPow(double x, int n) &#123;
        // 判断正负
        return n&gt;=0?quickMul(x,n):1.0/quickMul(x,-n);
    &#125;
    public double quickMul(double x,int n)&#123;
        if(n==0) return 1.0;
        // 计算n/2的值
        double y=quickMul(x,n/2);
        return n%2==0?y*y:y*y*x;
    &#125;
&#125;
</code></pre>
<h2 id="回文数"><a href="#回文数" class="headerlink" title="回文数"></a>回文数</h2><p>给你一个整数 x ，如果 x 是一个回文整数，返回 true ；否则，返回 false 。<br>回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。</p>
<ul>
<li>例如，121 是回文，而 123 不是。</li>
</ul>
<p><strong>题解：</strong><br>1、特殊情况，负数不是回文，尾数为0的话只有0符合回文要求<br>2、为了避免数字反转可能导致的溢出问题，只反转一半和数字前半部分比较</p>
<ul>
<li>每次进行取余然后计算反转数字revertNumber，并计算移除数字x，循环出口为revertNumber&gt;x；<ul>
<li>奇数的话revertNumber要移除最后一位</li>
<li>偶数不用管<pre><code>class Solution &#123;
  public boolean isPalindrome(int x) &#123;
   // 特殊情况
   if(x&lt;0||x%10==0&amp;&amp;x!=0) return false;
   int revertNumber=0;
   while(x&gt;revertNumber)&#123;
       revertNumber=revertNumber*10+x%10;
       x/=10;
   &#125;
   // 考虑奇数偶数两种情况
   return revertNumber==x||revertNumber/10==x;
  &#125;
&#125;
</code></pre>
</li>
</ul>
</li>
</ul>
<p> <img src="https://raw.githubusercontent.com/viacheung/img/main/image/202306031148423.png#from=url&id=cIrjZ&originHeight=478&originWidth=1122&originalType=binary&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&title="></p>
<h2 id="特征方程解法"><a href="#特征方程解法" class="headerlink" title="特征方程解法"></a>特征方程解法</h2><p><img src="https://raw.githubusercontent.com/viacheung/img/main/image/202306031151072.png#from=url&id=u1vtd&originHeight=698&originWidth=974&originalType=binary&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&title="></p>
<h2 id="力扣48题翻转矩阵"><a href="#力扣48题翻转矩阵" class="headerlink" title="力扣48题翻转矩阵"></a><strong>力扣48题翻转矩阵</strong></h2><p><img src="https://raw.githubusercontent.com/viacheung/img/main/image/202306031149078.png#from=url&id=jndtH&originHeight=495&originWidth=561&originalType=binary&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&title="><img src="https://raw.githubusercontent.com/viacheung/img/main/image/202306031150218.png#from=url&id=ECMlW&originHeight=672&originWidth=723&originalType=binary&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&title="><br>只关注我画黑框的部分 其余三块都是每个元素旋转而成</p>
<pre><code>//        官方第二种方法
        class Solution &#123;
            public void rotate(int[][] matrix) &#123;
                int n = matrix.length;
                for (int i = 0; i &lt; n / 2; ++i) &#123;//行数 向下区取余
                    for (int j = 0; j &lt; (n + 1) / 2; ++j) &#123;//列数 加一再向下取余
                        int temp = matrix[i][j];
                        matrix[i][j] = matrix[n - j - 1][i];
                        matrix[n - j - 1][i] = matrix[n - i - 1][n - j - 1];
                        matrix[n - i - 1][n - j - 1] = matrix[j][n - i - 1];
                        matrix[j][n - i - 1] = temp;
                    &#125;
                &#125;
            &#125;
        &#125;
</code></pre>
<p>最终解法 将旋转分解为水平翻转和主对角线翻转(因为这俩翻转都是俩俩交换 直接temp换就完事儿，而旋转是4个元素在换)</p>
<pre><code>class Solution &#123;
    public void rotate(int[][] matrix) &#123;
        int n = matrix.length;
        // 水平翻转
        for (int i = 0; i &lt; n / 2; ++i) &#123;
            for (int j = 0; j &lt; n; ++j) &#123;
                int temp = matrix[i][j];
                matrix[i][j] = matrix[n - i - 1][j];
                matrix[n - i - 1][j] = temp;
            &#125;
        &#125;
        // 主对角线翻转
        for (int i = 0; i &lt; n; ++i) &#123;
            for (int j = 0; j &lt; i; ++j) &#123;
                int temp = matrix[i][j];
                matrix[i][j] = matrix[j][i];
                matrix[j][i] = temp;
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://viacheung.github.io/2023/06/04/%E4%BA%8C%E5%88%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="ViaCheung">
      <meta itemprop="description" content="el psy congroo">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="命运石之门">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/06/04/%E4%BA%8C%E5%88%86/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
	  <span class="post-time">

	  
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-06-04 01:01:36 / 修改时间：01:01:37" itemprop="dateCreated datePublished" datetime="2023-06-04T01:01:36+08:00">2023-06-04</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="二分排序"><a href="#二分排序" class="headerlink" title="二分排序"></a>二分排序</h1><p>部分有序也可以二分</p>
<h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><p>1、记录答案法（推荐这个）：<br>要保证左右断点都能取到</p>
<pre><code>while (l&lt;=r)
&#123;
    int mid=l+(r-l)/2;
    if (check(mid))
    &#123;
        r=mid-1;
    &#125;
    else l=mid+1;
&#125;
//reurn的时候要注意，现在的l是多的一个
</code></pre>
<p>2、不记录法</p>
<pre><code>bool check(int x) &#123;/* ... */&#125; // 检查x是否满足某种性质

// 寻找满足条件的左边界      
int bsearch_1(int l, int r)
&#123;
    while (l &lt; r)
    &#123;
        int mid = l + r &gt;&gt; 1;
        //对应l+(r-l)/2
        if (check(mid)) r = mid;    // check()判断mid是否满足性质
        else l = mid + 1;
    &#125;
    return l;
&#125;
// 寻找满足条件的右边界(222完全二叉树的节点个数的题解就是这个思路)   
int bsearch_2(int l, int r)
&#123;
    while (l &lt; r)
    &#123;
        //对应l+(r-l+1)/2
        int mid = l + r + 1 &gt;&gt; 1;
        if (check(mid)) l = mid;
        else r = mid - 1;
    &#125;
    return l;
&#125;
//要记住  满足条件，需要保留的就mid，不满足条件就是mid+1 mid-1
</code></pre>
<h2 id="旋转数组"><a href="#旋转数组" class="headerlink" title="旋转数组"></a>旋转数组</h2><p>将数组一分为二，其中一定有一个是有序的，另一个可能是有序，也能是部分有序。此时有序部分用二分法查找。无序部分再一分为二，其中一个一定有序，另一个可能有序，可能无序。就这样循环. </p>
<h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><p>给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。</p>
<pre><code>class Solution &#123;
    public int search(int[] nums, int target) &#123;
        int left=0,right=nums.length-1;
        while(left&lt;=right)&#123;
            //取下标中点  &gt;&gt;1表示除以2
            int mid=(left+right)&gt;&gt;1;
            if(nums[mid]==target)&#123;
                return mid;
            &#125;else if(nums[mid]&lt;target)&#123;
                left=mid+1;
            &#125;else&#123;
                right=mid-1;
            &#125;
        &#125;
        return -1;
    &#125;
&#125;
</code></pre>
<h2 id="二维数组中的查找"><a href="#二维数组中的查找" class="headerlink" title="二维数组中的查找"></a><strong>二维数组中的查找</strong></h2><ul>
<li>step 1：首先获取矩阵的两个边长，判断特殊情况。</li>
<li>step 2：首先以左下角为起点，若是它小于目标元素，则往右移动去找大的，若是他大于目标元素，则往上移动去找小的。</li>
<li>step 3：若是移动到了矩阵边界也没找到，说明矩阵中不存在目标值。<pre><code>public class Solution &#123;
  public boolean Find(int target, int [][] array) &#123;
      // 从左下角开始搜索：  列最大 行最小
      int row=array.length;
      int col=array[0].length;
      for(int i=row-1,j=0;i&gt;=0&amp;j&lt;col;)&#123;
          if(array[i][j]==target) return true;
          else if(array[i][j]&gt;target) i--;
          else j++;
      &#125;
      return false;
  &#125;
&#125;
</code></pre>
<h2 id="寻找峰值"><a href="#寻找峰值" class="headerlink" title="寻找峰值"></a><strong>寻找峰值</strong></h2>1、求最大值<pre><code>public int findPeakElement(int[] nums) &#123;
      int idx = 0;
      for (int i = 1; i &lt; nums.length; ++i) &#123;
          if (nums[i] &gt; nums[idx]) &#123;
              idx = i;
          &#125;
      &#125;
      return idx;
  &#125;
</code></pre>
2、二分<br>&#96;&#96;&#96;<br>import java.util.*;</li>
</ul>
<p>public class Solution {<br>    &#x2F;**<br>     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可<br>     *<br>     *<br>     * @param nums int整型一维数组<br>     * @return int整型<br>     *&#x2F;<br>    public int findPeakElement (int[] nums) {<br>        &#x2F;&#x2F; write code here<br>   &#x2F;&#x2F;关键思想：下坡的时候可能找到波峰，但是可能找不到，一直向下走的<br>  &#x2F;&#x2F;上坡的时候一定能找到波峰，因为题目给出的是nums[-1] &#x3D; nums[n] &#x3D; -∞<br>        int left &#x3D; 0;<br>        int right &#x3D; nums.length-1;<br>        while(left&lt;right){<br>            int mid &#x3D; left+(right-left)&#x2F;2;<br>            &#x2F;&#x2F;证明右边的路是下坡路，不一定有坡峰<br>            if(nums[mid]&gt;nums[mid+1]){<br>                right &#x3D; mid;<br>            }<br>            else{<br>                &#x2F;&#x2F;这里是右边的路是上坡路<br>                left&#x3D;mid+1;<br>            }<br>        }<br>        return right;<br>    }<br>}</p>
<pre><code>## **旋转数组的最小数字**
**思路：**
旋转数组将原本有序的数组分成了两部分有序的数组，因为在原始有序数组中，最小的元素一定是在首位，旋转后无序的点就是最小的数字。我们可以将旋转前的前半段命名为A，旋转后的前半段命名为B，旋转数组即将AB变成了BA，我们想知道最小的元素到底在哪里。
因为A部分和B部分都是各自有序的，所以我们还是想用分治来试试，每次比较中间值，确认目标值（最小元素）所在的区间。
**具体做法：**

- step 1：双指针指向旋转后数组的首尾，作为区间端点。
- step 2：若是区间中点值大于区间右界值，则最小的数字一定在中点右边。(left=mid+1)
- step 3：若是区间中点值等于区间右界值，则是不容易分辨最小数字在哪半个区间，比如[1,1,1,0,1]，应该逐个缩减右界。 (right--)
- step 4：若是区间中点值小于区间右界值，则最小的数字一定在中点左边。(right=mid)
- step 5：通过调整区间最后即可锁定最小值所在。
</code></pre>
<p>import java.util.ArrayList;<br>public class Solution {<br>    public int minNumberInRotateArray(int [] array) {<br>        int left&#x3D;0,right&#x3D;array.length-1;<br>        while(left&lt;&#x3D;right){<br>            int mid&#x3D;(left+right)&#x2F;2;<br>            if(array[mid]&gt;array[right]){<br>                left&#x3D;mid+1;<br>            }else if(array[mid]&#x3D;&#x3D;array[right]){<br>                right–;<br>            }else {<br>                &#x2F;&#x2F; 最小数字要么在左边要么是mid<br>                right&#x3D;mid;<br>            }<br>        }<br>        return array[left];<br>    }<br>}</p>
<pre><code>## **比较版本号**
比较规则：
一. 比较版本号时，请按从左到右的顺序依次比较它们的修订号。比较修订号时，只需比较忽略任何前导零后的整数值。比如&quot;0.1&quot;和&quot;0.01&quot;的版本号是相等的
二. 如果版本号没有指定某个下标处的修订号，则该修订号视为0。例如，&quot;1.1&quot;的版本号小于&quot;1.1.1&quot;。因为&quot;1.1&quot;的版本号相当于&quot;1.1.0&quot;，第3位修订号的下标为0，小于1
三. version1 &gt; version2 返回1，如果 version1 &lt; version2 返回-1，不然返回0.
思路:

1. **每次比较.前的数字大小即可**
</code></pre>
<p>import java.util.*;<br>public class Solution {<br>    public int compare (String version1, String version2) {<br>        int n1 &#x3D; version1.length();<br>        int n2 &#x3D; version2.length();<br>        int i &#x3D; 0, j &#x3D; 0;<br>        &#x2F;&#x2F;直到某个字符串结束<br>        while(i &lt; n1 || j &lt; n2){<br>            long num1 &#x3D; 0;<br>            &#x2F;&#x2F;从下一个点前截取数字<br>            while(i &lt; n1 &amp;&amp; version1.charAt(i) !&#x3D; ‘.’){<br>                num1 &#x3D; num1 * 10 + (version1.charAt(i) - ‘0’);<br>                i++;<br>            }<br>            &#x2F;&#x2F;跳过点<br>            i++;<br>            long num2 &#x3D; 0;<br>            &#x2F;&#x2F;从下一个点前截取数字<br>            while(j &lt; n2 &amp;&amp; version2.charAt(j) !&#x3D; ‘.’){<br>                num2 &#x3D; num2 * 10 + (version2.charAt(j) - ‘0’);<br>                j++;<br>            }<br>            &#x2F;&#x2F;跳过点<br>            j++;<br>            &#x2F;&#x2F;比较数字大小<br>            if(num1 &gt; num2)<br>                return 1;<br>            if(num1 &lt; num2)<br>                return -1;<br>        }<br>        &#x2F;&#x2F;版本号相同<br>        return 0;<br>    }<br>}</p>
<pre><code>
 
</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://viacheung.github.io/2023/06/04/%E5%9B%BE%E8%AE%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="ViaCheung">
      <meta itemprop="description" content="el psy congroo">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="命运石之门">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/06/04/%E5%9B%BE%E8%AE%BA/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
	  <span class="post-time">

	  
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-06-04 01:01:28 / 修改时间：01:01:29" itemprop="dateCreated datePublished" datetime="2023-06-04T01:01:28+08:00">2023-06-04</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h2><p><strong>无向图</strong><br>分析1：无向图的邻接矩阵是对称的； 分析2：顶点i的度&#x3D;第i行（列）中1的个数；<strong>特别：完全图的邻接矩阵中，对角元素为0，其余1。</strong><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/diviner_s/article/details/106978910">https://blog.csdn.net/diviner_s&#x2F;article&#x2F;details&#x2F;106978910</a><br><strong>有向图</strong><br>行列出入<br>在有向图的邻接矩阵中，第i行含义：以结点vi为尾的弧（即出度边）；第i列含义：以结点vi为头的弧（即入度边）。分析1：有向图的邻接矩阵可能是不对称的；分析2：顶点的出度 &#x3D; 第 i 行元素之和 顶点的入度 &#x3D; 第 i 列元素之和 顶点的度 &#x3D; 第 i 行元素之和 + 第 i 列元素之和</p>
<h2 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h2><h3 id="课程表问题-待看"><a href="#课程表问题-待看" class="headerlink" title="课程表问题(待看 )"></a><strong>课程表问题(待看 )</strong></h3><p><img src="https://raw.githubusercontent.com/viacheung/img/main/image/image-20220915153720951.png#from=url&id=OJmWg&originHeight=212&originWidth=753&originalType=binary&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&title="></p>
<pre><code>示例：
输入：numCourses = 4, prerequisites = [[1,0],[2,0],[3,1],[3,2]]
输出：[0,2,1,3]
解释：总共有 4 门课程。要学习课程 3，你应该先完成课程 1 和课程 2。并且课程 1 和课程 2 都应该排在课程 0 之后。
因此，一个正确的课程顺序是 [0,1,2,3] 。另一个正确的排序是 [0,2,1,3] 。
</code></pre>
<p><strong>拓扑排序定义</strong>：给定一个包含 n个节点的有向图 G，我们给出它的节点编号的一种排列，如果满足：对于图 G中的任意一条有向边 (u,v)，u在排列中都出现在 v的前面。<br><strong>推导结论：</strong>1. 不可有环 2. 拓扑排序不止一种<br><strong>解题：</strong><br><strong>BFS</strong><br>考虑拓扑排序中最前面的节点入度为0，它没有先修课程要求。将此节点加入答案中后，移除它的所有出边，如果某个相邻节点变成了「没有任何入边的节点」，那么就代表着这门课可以开始学习了。按照这样的流程，我们不断地将没有入边的节点加入答案，直到答案中包含所有的节点（得到了一种拓扑排序）或者不存在没有入边的节点（图中包含环）。<br>我们使用一个队列来进行广度优先搜索。在广度优先搜索的每一步中，我们取出队首的节点 u，我们将 u 放入答案中；移除 u 的所有出边，也就是将 u的所有相邻节点的入度减少 1。如果某个相邻节点 v 的入度变为 0，那么我们就将 v放入队列中。在广度优先搜索的过程结束后。如果答案中包含了这 n 个节点，那么我们就找到了一种拓扑排序（从队列队首取出的结点构成的排序），否则说明图中存在环，也就不存在拓扑排序了。</p>
<pre><code>class Solution &#123;
    // 存储有向图
    List&lt;List&lt;Integer&gt;&gt; edges;
    // 存储每个节点的入度
    int[] indeg;
    // 存储答案
    int[] result;
    // 答案下标
    int index;

    public int[] findOrder(int numCourses, int[][] prerequisites) &#123;
        edges = new ArrayList&lt;List&lt;Integer&gt;&gt;();
        //初始化edges，下标从0到numcourses-1
        for (int i = 0; i &lt; numCourses; ++i) &#123;
            edges.add(new ArrayList&lt;Integer&gt;());
        &#125;
        //初始化
        indeg = new int[numCourses];
        result = new int[numCourses];
        index = 0;
        //把每个Info的后面一位数当下标，前面一位数当值
        for (int[] info : prerequisites) &#123;
            edges.get(info[1]).add(info[0]);
            ++indeg[info[0]];//对应入度表修改
        &#125;

        Queue&lt;Integer&gt; queue = new LinkedList&lt;Integer&gt;();
        // 将所有入度为 0 的节点放入队列中
        for (int i = 0; i &lt; numCourses; ++i) &#123;
            if (indeg[i] == 0) &#123;
                queue.offer(i);//添加到队列
            &#125;
        &#125;

        while (!queue.isEmpty()) &#123;
            // 从队首取出一个节点
            int u = queue.poll();
            // 放入答案中
            result[index++] = u;
            for (int v: edges.get(u)) &#123;
                //这个结点指向的另一个结点的入度要减1
                --indeg[v];
                // 如果相邻节点 v 的入度为 0，就可以选 v 对应的课程了
                if (indeg[v] == 0) &#123;
                    queue.offer(v);
                &#125;
            &#125;
        &#125;
        //理论上课程数要和下标一致，不一致说明有环或是其他情况
        if (index != numCourses) &#123;
            return new int[0];
        &#125;
        return result;
    &#125;
&#125;
</code></pre>
<p>以前面示例作为例子，画个图理解一下<br><img src="https://raw.githubusercontent.com/viacheung/img/main/image/image-20220915160038236.png#from=url&id=Fj2xv&originHeight=693&originWidth=1363&originalType=binary&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&title="><br>这道题是课程二，让我们返回拓扑排序，课程一问题让我们返回是否能修完所有课程，无非就是return的不一样罢了。<br>return visited &#x3D;&#x3D; numCourses;<br><strong>DFS</strong><br>真不想看了，二刷的时候再说吧</p>
<h2 id="钥匙和房间"><a href="#钥匙和房间" class="headerlink" title="钥匙和房间"></a>钥匙和房间</h2><p>有 n 个房间，房间按从 0 到 n - 1 编号。最初，除 0 号房间外的其余所有房间都被锁住。你的目标是进入所有的房间。然而，你不能在没有获得钥匙的时候进入锁住的房间。<br>当你进入一个房间，你可能会在里面找到一套不同的钥匙，每把钥匙上都有对应的房间号，即表示钥匙可以打开的房间。你可以拿上所有钥匙去解锁其他房间。<br>给你一个数组 rooms 其中 rooms[i] 是你进入 i 号房间可以获得的钥匙集合。如果能进入 <strong>所有</strong> 房间返回 true，否则返回 false。<br><strong>题解：</strong><br>有向图：<br>深搜（DFS）或者广搜（BFS）</p>
<ol>
<li>确认递归函数，参数</li>
</ol>
<p>二维数组rooms来遍历地图 还需要一个数组，用来记录我们都走过了哪些房间</p>
<ol>
<li>确认终止条件</li>
</ol>
<p>如果我们是处理当前访问的节点，当前访问的节点如果是 true ，说明是访问过的节点，那就终止本层递归，如果不是true，我们就把它赋值为true，因为我们处理本层递归的节点。</p>
<pre><code>class Solution &#123;
    public boolean canVisitAllRooms(List&lt;List&lt;Integer&gt;&gt; rooms) &#123;
        int n=rooms.size();
        List&lt;Boolean&gt; visited=new ArrayList&lt;&gt;();
        for(int i=0;i&lt;n;i++)&#123;
            visited.add(false);
        &#125;
        dfs(0,rooms,visited);
        for(boolean flag:visited)&#123;
            if(!flag) return false;
        &#125;
        return true;
    &#125;
    // 深度优先遍历
    // List   下标索引：value
    public void dfs(int key,List&lt;List&lt;Integer&gt;&gt; rooms,List&lt;Boolean&gt; visited)&#123;
        if(visited.get(key)==true) return;
        visited.set(key,true);
        for(int k:rooms.get(key))&#123;
            dfs(k,rooms,visited);
        &#125;
</code></pre>
<h2 id="单词接龙"><a href="#单词接龙" class="headerlink" title="单词接龙"></a>单词接龙</h2><p>字典 wordList 中从单词 beginWord 和 endWord 的 <strong>转换序列</strong> 是一个按下述规格形成的序列 beginWord -&gt; s1 -&gt; s2 -&gt; … -&gt; sk：</p>
<ul>
<li>每一对相邻的单词只差一个字母。</li>
<li>对于 1 &lt;&#x3D; i &lt;&#x3D; k 时，每个 si 都在 wordList 中。注意， beginWord 不需要在 wordList 中。</li>
<li>sk &#x3D;&#x3D; endWord</li>
</ul>
<p>给你两个单词 beginWord 和 endWord 和一个字典 wordList ，返回 <em>从 beginWord 到 endWord 的 <strong>最短转换序列</strong> 中的 <strong>单词数目</strong></em> 。如果不存在这样的转换序列，返回 0 。<br><strong>题解</strong><br>本题只需要求出最短长度就可以了，不用找出路径。<br>所以这道题要解决两个问题：</p>
<ul>
<li>图中的线是如何连在一起的</li>
<li>起点和终点的最短路径长度</li>
</ul>
<p>首先题目中并没有给出点与点之间的连线，而是要我们自己去连，条件是字符只能差一个，所以判断点与点之间的关系，要自己判断是不是差一个字符，如果差一个字符，那就是有链接。<br>然后就是求起点和终点的最短路径长度，<strong>这里无向图求最短路，广搜最为合适，广搜只要搜到了终点，那么一定是最短的路径</strong>。因为广搜就是以起点中心向四周扩散的搜索。<br>本题如果用深搜，会比较麻烦，要在到达终点的不同路径中选则一条最短路。 而广搜只要达到终点，一定是最短路。<br>另外需要有一个注意点：</p>
<ul>
<li><p>本题是一个无向图，需要用标记位，标记着节点是否走过，否则就会死循环！</p>
</li>
<li><p>本题给出集合是数组型的，可以转成set结构，查找更快一些<br>&#96;&#96;&#96;<br>public int ladderLength(String beginWord, String endWord, List<String> wordList) {<br>  HashSet<String> wordSet &#x3D; new HashSet&lt;&gt;(wordList); &#x2F;&#x2F;转换为hashset 加快速度  便于查找单词在不在里面<br>  if (wordSet.size() &#x3D;&#x3D; 0 || !wordSet.contains(endWord)) {  &#x2F;&#x2F;特殊情况判断<br>  return 0;l<br>  }<br>  Queue<String> queue &#x3D; new LinkedList&lt;&gt;(); &#x2F;&#x2F;bfs 队列<br>  queue.offer(beginWord);<br>  Map&lt;String, Integer&gt; map &#x3D; new HashMap&lt;&gt;(); &#x2F;&#x2F;记录beginword到该单词的转换长度<br>  map.put(beginWord, 1);</String></String></String></p>
<p>  while (!queue.isEmpty()) {<br>  String word &#x3D; queue.poll(); &#x2F;&#x2F;取出队头单词<br>  int path  &#x3D; map.get(word); &#x2F;&#x2F;获取到该单词的路径长度<br>  for (int i &#x3D; 0; i &lt; word.length(); i++) { &#x2F;&#x2F;遍历单词的每个字符<br>      char[] chars &#x3D; word.toCharArray(); &#x2F;&#x2F;将单词转换为char array，方便替换<br>      for (char k &#x3D; ‘a’; k &lt;&#x3D; ‘z’; k++) { &#x2F;&#x2F;从’a’ 到 ‘z’ 遍历替换<br>          chars[i] &#x3D; k; &#x2F;&#x2F;替换第i个字符<br>          String newWord &#x3D; String.valueOf(chars); &#x2F;&#x2F;得到新的字符串<br>          if (newWord.equals(endWord)) {  &#x2F;&#x2F;如果新的字符串值与endWord一致，返回当前长度+1<br>              return path + 1;<br>          }<br>          if (wordSet.contains(newWord) &amp;&amp; !map.containsKey(newWord)) { &#x2F;&#x2F;如果新单词在set中，但是没有访问过<br>              map.put(newWord, path + 1); &#x2F;&#x2F;记录单词对应的路径长度<br>              queue.offer(newWord);&#x2F;&#x2F;加入队尾<br>          }<br>      }<br>  }<br>  }<br>  return 0; &#x2F;&#x2F;未找到</p>
</li>
</ul>
<p>}</p>
<pre><code>
 
</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://viacheung.github.io/2023/06/04/%E5%B9%B6%E6%9F%A5%E9%9B%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="ViaCheung">
      <meta itemprop="description" content="el psy congroo">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="命运石之门">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/06/04/%E5%B9%B6%E6%9F%A5%E9%9B%86/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
	  <span class="post-time">

	  
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-06-04 01:01:22 / 修改时间：01:01:23" itemprop="dateCreated datePublished" datetime="2023-06-04T01:01:22+08:00">2023-06-04</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><a target="_blank" rel="noopener" href="https://blog.csdn.net/the_zed/article/details/105126583">https://blog.csdn.net/the_zed&#x2F;article&#x2F;details&#x2F;105126583</a><br>查找和合并 ，一边查询一边修改结点指向是并查集的特色。</p>
<h2 id="除法求值399"><a href="#除法求值399" class="headerlink" title="除法求值399"></a>除法求值399</h2><p>&#96;&#96;&#96;<br>public class Solution {<br>            public double[] calcEquation(List&lt;List<String>&gt; equations, double[] values, List&lt;List<String>&gt; queries) {<br>                int equationsSize &#x3D; equations.size();<br>                &#x2F;&#x2F;因为子数组里面有两个元素[[“a”,”b”],[“b”,”c”]], values &#x3D; [2.0,3.0], queries &#x3D; [[“a”,”c”],[“b”,”a”],[“a”,”e”]<br>                UnionFind unionFind &#x3D; new UnionFind(2 * equationsSize);<br>                &#x2F;&#x2F; 第 1 步：预处理，将变量的值与 id 进行映射，使得并查集的底层使用数组实现，方便编码<br>                Map&lt;String, Integer&gt; hashMap &#x3D; new HashMap&lt;&gt;(2 * equationsSize);<br>                int id &#x3D; 0;<br>                for (int i &#x3D; 0; i &lt; equationsSize; i++) {<br>                    List<String> equation &#x3D; equations.get(i);<br>                    String var1 &#x3D; equation.get(0);<br>                    String var2 &#x3D; equation.get(1);</String></String></String></p>
<pre><code>                if (!hashMap.containsKey(var1)) &#123;
                    hashMap.put(var1, id);
                    id++;
                &#125;
                if (!hashMap.containsKey(var2)) &#123;
                    hashMap.put(var2, id);
                    id++;
                &#125;
                //hashmap   -&gt;   
</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://viacheung.github.io/2023/06/04/%E6%A8%A1%E6%8B%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="ViaCheung">
      <meta itemprop="description" content="el psy congroo">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="命运石之门">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/06/04/%E6%A8%A1%E6%8B%9F/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
	  <span class="post-time">

	  
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-06-04 01:01:17" itemprop="dateCreated datePublished" datetime="2023-06-04T01:01:17+08:00">2023-06-04</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="任务调度器"><a href="#任务调度器" class="headerlink" title="任务调度器"></a>任务调度器</h2><h2 id="方法一：模拟"><a href="#方法一：模拟" class="headerlink" title="方法一：模拟"></a>方法一：模拟</h2><p><img src="https://raw.githubusercontent.com/viacheung/img/main/image/image-20221012192843953.png#from=url&id=Og76s&originHeight=185&originWidth=1066&originalType=binary&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&title="><br><img src="https://raw.githubusercontent.com/viacheung/img/main/image/image-20221012192916861.png#from=url&id=ESUXi&originHeight=606&originWidth=1003&originalType=binary&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&title="><br>此处对于”我们应当选择剩余执行次数最多的那个任务“的证明忽略</p>
<pre><code>class Solution &#123;
          public int leastInterval(char[] tasks, int n) &#123;
              Map&lt;Character, Integer&gt; freq = new HashMap&lt;Character, Integer&gt;();
              for (char ch : tasks) &#123;
                  freq.put(ch, freq.getOrDefault(ch, 0) + 1);
              &#125;

              // 任务总数
              int m = freq.size();
              //最早有效时间
              List&lt;Integer&gt; nextValid = new ArrayList&lt;Integer&gt;();
              List&lt;Integer&gt; rest = new ArrayList&lt;Integer&gt;();
              Set&lt;Map.Entry&lt;Character, Integer&gt;&gt; entrySet = freq.entrySet();
              for (Map.Entry&lt;Character, Integer&gt; entry : entrySet) &#123;
                  int value = entry.getValue();
                  //初始为1
                  nextValid.add(1);
                  rest.add(value);
              &#125;

              int time = 0;
              for (int i = 0; i &lt; tasks.length; ++i) &#123;
                  ++time;
//                  将 time更新为所有nextValid中的最小值，直接「跳过」待命状态  最小值代表最早有效时间，前面肯定是冷却时间
                  int minNextValid = Integer.MAX_VALUE;
                  for (int j = 0; j &lt; m; ++j) &#123;
                      //剩余任务不为0时
                      if (rest.get(j) != 0) &#123;
                          minNextValid = Math.min(minNextValid, nextValid.get(j));
                      &#125;
                  &#125;
                  time = Math.max(time, minNextValid);
                  //寻找不在冷却中的，剩余执行次数最多的任务
                  int best = -1;
                  for (int j = 0; j &lt; m; ++j) &#123;
                      if (rest.get(j) != 0 &amp;&amp; nextValid.get(j) &lt;= time) &#123;
                          if (best == -1 || rest.get(j) &gt; rest.get(best)) &#123;
                              best = j;
                          &#125;
                      &#125;
                  &#125;
                  //赋值z
                  nextValid.set(best, time + n + 1);
                  rest.set(best, rest.get(best) - 1);
              &#125;

              return time;
          &#125;
      &#125;
</code></pre>
<p>方法一代码量太多 不想写</p>
<h2 id="方法二：构造"><a href="#方法二：构造" class="headerlink" title="方法二：构造"></a>方法二：构造</h2><p>构造n+1列矩阵，每个格子代表一个时间，行优先，也就是先第一行再第二行，记需要执行maxExec次(任务数最多的任务的数量)任务数量为maxCount,如图，maxExec就是5，maxCount为3，因此总时间为(maxExec−1)(n+1)+maxCount<br><img src="https://raw.githubusercontent.com/viacheung/img/main/image/image-20221012195808588.png#from=url&id=YKtsc&originHeight=326&originWidth=405&originalType=binary&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&title="><br>对于小于maxExec的任务如下图：<br><img src="https://raw.githubusercontent.com/viacheung/img/main/image/image-20221012200212774.png#from=url&id=a2qoG&originHeight=874&originWidth=975&originalType=binary&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&title="><br><img src="https://raw.githubusercontent.com/viacheung/img/main/image/image-20221012200347122.png#from=url&id=yljAN&originHeight=83&originWidth=946&originalType=binary&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&title="><br><img src="https://raw.githubusercontent.com/viacheung/img/main/image/image-20221012200357248.png#from=url&id=Unftu&originHeight=490&originWidth=1078&originalType=binary&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&title="></p>
<pre><code>class Solution &#123;
    public int leastInterval(char[] tasks, int n) &#123;
        Map&lt;Character, Integer&gt; freq = new HashMap&lt;Character, Integer&gt;();
        // 最多的执行次数
        int maxExec = 0;
        for (char ch : tasks) &#123;
            int exec = freq.getOrDefault(ch, 0) + 1;
            freq.put(ch, exec);
            maxExec = Math.max(maxExec, exec);
        &#125;

        // 具有最多执行次数的任务数量
        int maxCount = 0;
        //这一句可以不要
        //Set&lt;Map.Entry&lt;Character, Integer&gt;&gt; entrySet = freq.entrySet();
        for (Map.Entry&lt;Character, Integer&gt; entry : entrySet) &#123;
            int value = entry.getValue();
            if (value == maxExec) &#123;
                ++maxCount;
            &#125;
        &#125;

        return Math.max((maxExec - 1) * (n + 1) + maxCount, tasks.length);
    &#125;
&#125;
</code></pre>
<h2 id="机器人能否返回原点"><a href="#机器人能否返回原点" class="headerlink" title="机器人能否返回原点"></a>机器人能否返回原点</h2><p>在二维平面上，有一个机器人从原点 (0, 0) 开始。给出它的移动顺序，判断这个机器人在完成移动后是否在 <strong>(0, 0) 处结束</strong>。<br>移动顺序由字符串 moves 表示。字符 move[i] 表示其第 i 次移动。机器人的有效动作有 R（右），L（左），U（上）和 D（下）。<br>如果机器人在完成所有动作后返回原点，则返回 true。否则，返回 false。<br><strong>注意：</strong>机器人“面朝”的方向无关紧要。 “R” 将始终使机器人向右移动一次，“L” 将始终向左移动等。此外，假设每次移动机器人的移动幅度相同。<br>自己写的</p>
<pre><code>class Solution &#123;
    public boolean judgeCircle(String moves) &#123;
        int x=0,y=0;
        for(int i=0;i&lt;moves.length();i++)&#123;
            switch(moves.charAt(i))&#123;
                case &#39;R&#39;:
                x++;
                break;

                case &#39;L&#39;:
                x--;
                break;

                case &#39;U&#39;:
                y++;
                break;

                case &#39;D&#39;:
                y--;
                break;   

                default:             
            &#125;
        &#125;
        return (x==0&amp;&amp;y==0);
    &#125;
&#125;
</code></pre>
<h2 id="下一个排列"><a href="#下一个排列" class="headerlink" title="下一个排列"></a>下一个排列</h2><p>整数数组的一个 <strong>排列</strong> 就是将其所有成员以序列或线性顺序排列。</p>
<ul>
<li>例如，arr &#x3D; [1,2,3] ，以下这些都可以视作 arr 的排列：[1,2,3]、[1,3,2]、[3,1,2]、[2,3,1] 。</li>
</ul>
<p>整数数组的 <strong>下一个排列</strong> 是指其整数的下一个字典序更大的排列。更正式地，如果数组的所有排列根据其字典顺序从小到大排列在一个容器中，那么数组的 <strong>下一个排列</strong> 就是在这个有序容器中排在它后面的那个排列。如果不存在下一个更大的排列，那么这个数组必须重排为字典序最小的排列（即，其元素按升序排列）。</p>
<ul>
<li>例如，arr &#x3D; [1,2,3] 的下一个排列是 [1,3,2] 。</li>
<li>类似地，arr &#x3D; [2,3,1] 的下一个排列是 [3,1,2] 。</li>
<li>而 arr &#x3D; [3,2,1] 的下一个排列是 [1,2,3] ，因为 [3,2,1] 不存在一个字典序更大的排列。</li>
</ul>
<p>给你一个整数数组 nums ，找出 nums 的下一个排列。<br>必须<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95">原地</a>修改，只允许使用额外常数空间。<br>题解：下一个更大排列就是从后往前找比当前小的那个元素 交换 然后后面升序排列</p>
<pre><code>1 2 3 4
1 2 4 3
1 3 2 4
1 3 4 2
</code></pre>
<pre><code>class Solution &#123;
    public void nextPermutation(int[] nums) &#123;
        for (int i = nums.length - 1; i &gt;= 0; i--) &#123;
            for (int j = nums.length - 1; j &gt; i; j--) &#123;
                //后面要比前面大
                if (nums[j] &gt; nums[i]) &#123;
                    // 交换
                    int temp = nums[i];
                    nums[i] = nums[j];
                    nums[j] = temp;
                    // [i + 1, nums.length) 内元素升序排序
                    Arrays.sort(nums, i + 1, nums.length);
                    return;
                &#125;
            &#125;
        &#125;
        Arrays.sort(nums); // 不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。
    &#125;
&#125;
</code></pre>
<p>岛屿的周长<br>给定一个 row x col 的二维网格地图 grid ，其中：grid[i][j] &#x3D; 1 表示陆地， grid[i][j] &#x3D; 0 表示水域。<br>网格中的格子 <strong>水平和垂直</strong> 方向相连（对角线方向不相连）。整个网格被水完全包围，但其中恰好有一个岛屿（或者说，一个或多个表示陆地的格子相连组成的岛屿）。<br>岛屿中没有“湖”（“湖” 指水域在岛屿内部且不和岛屿周围的水相连）。格子是边长为 1 的正方形。网格为长方形，且宽度和高度均不超过 100 。计算这个岛屿的周长。<br>题解：<br>遍历每一个空格，遇到岛屿，计算其上下左右的情况，遇到水域或者出界的情况，周长+1</p>
<pre><code>class Solution &#123;
    // 上下左右 4 个方向
    int[] dirx = &#123;-1, 1, 0, 0&#125;;
    int[] diry = &#123;0, 0, -1, 1&#125;;

    public int islandPerimeter(int[][] grid) &#123;
        int m = grid.length;
        int n = grid[0].length;
        int res = 0; // 岛屿周长
        for (int i = 0; i &lt; m; i++) &#123;
            for (int j = 0; j &lt; n; j++) &#123;
                if (grid[i][j] == 1) &#123;
                    for (int k = 0; k &lt; 4; k++) &#123;
                        int x = i + dirx[k];
                        int y = j + diry[k];
                        // 当前位置是陆地，并且从当前位置4个方向扩展的“新位置”是“水域”或“新位置“越界，则会为周长贡献一条边
                        if (x &lt; 0 || x &gt;= m || y &lt; 0 || y &gt;= n || grid[x][y] == 0) &#123;
                            res++;
                            continue;
                        &#125;
                    &#125;
                &#125;
            &#125;
        &#125;
        return res;
    &#125;
&#125;
</code></pre>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/5/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="ViaCheung"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">ViaCheung</p>
  <div class="site-description" itemprop="description">el psy congroo</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">32</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/viacheung" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;viacheung" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:viacheung5@gmail.com" title="E-Mail → mailto:viacheung5@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/zh-CN" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ViaCheung</span>
</div>

<!--
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div> -->

<!-- 网站运行时间的设置 -->
<span id="timeDate">载入天数...</span>
<span id="times">载入时分秒...</span>
<script>
    var now = new Date();
    function createtime() {
        var grt= new Date("03/01/2023 10:00:00"); //此处修改你的建站时间或者网站上线时间
        now.setTime(now.getTime()+250);
        days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days);
        hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours);
        if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);
        mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;}
        seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
        snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;}
        document.getElementById("timeDate").innerHTML = "本站已安全运行 "+dnum+" 天 ";
        document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒.";
    }
setInterval("createtime()",250);
</script>
        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>

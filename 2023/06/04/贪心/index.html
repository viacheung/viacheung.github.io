<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.1.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"viacheung.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="贪心本来就没有套路，也没有框架，所以各种常规解法需要多接触多练习，自然而然才会想到。 局部最优可以推出全局最优，如果找不出局部最优，那可能就是一道模拟题。 在出现两个维度相互影响的情况时，两边一起考虑一定会顾此失彼，要先确定一个维度，再确定另一个一个维度。">
<meta property="og:type" content="article">
<meta property="og:title" content="贪心">
<meta property="og:url" content="http://viacheung.github.io/2023/06/04/%E8%B4%AA%E5%BF%83/index.html">
<meta property="og:site_name" content="命运石之门">
<meta property="og:description" content="贪心本来就没有套路，也没有框架，所以各种常规解法需要多接触多练习，自然而然才会想到。 局部最优可以推出全局最优，如果找不出局部最优，那可能就是一道模拟题。 在出现两个维度相互影响的情况时，两边一起考虑一定会顾此失彼，要先确定一个维度，再确定另一个一个维度。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/viacheung/img/main/image/20201124174327597.png">
<meta property="og:image" content="https://raw.githubusercontent.com/viacheung/img/main/image/image-20221120103615752.png">
<meta property="og:image" content="https://raw.githubusercontent.com/viacheung/img/main/image/53.%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C.gif">
<meta property="og:image" content="https://raw.githubusercontent.com/viacheung/img/main/image/2020112917480858.png">
<meta property="og:image" content="https://raw.githubusercontent.com/viacheung/img/main/image/20201124154758229.png">
<meta property="og:image" content="https://raw.githubusercontent.com/viacheung/img/main/image/20201201232309103.png">
<meta property="og:image" content="https://raw.githubusercontent.com/viacheung/img/main/image/20201117114916878.png">
<meta property="og:image" content="https://raw.githubusercontent.com/viacheung/img/main/image/20201117115658791.png">
<meta property="og:image" content="https://raw.githubusercontent.com/viacheung/img/main/image/20201123101929791.png">
<meta property="og:image" content="https://raw.githubusercontent.com/viacheung/img/main/image/20201221201553618.png">
<meta property="og:image" content="https://raw.githubusercontent.com/viacheung/img/main/image/20201222191924417.png">
<meta property="og:image" content="https://raw.githubusercontent.com/viacheung/img/main/image/bst_cameras_01.png">
<meta property="og:image" content="https://raw.githubusercontent.com/viacheung/img/main/image/image-20220924191640236.png">
<meta property="article:published_time" content="2023-06-04T09:44:46.000Z">
<meta property="article:modified_time" content="2023-06-04T09:59:51.929Z">
<meta property="article:author" content="ViaCheung">
<meta property="article:tag" content="Java,python">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/viacheung/img/main/image/20201124174327597.png">

<link rel="canonical" href="http://viacheung.github.io/2023/06/04/%E8%B4%AA%E5%BF%83/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>贪心 | 命运石之门</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">命运石之门</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">欢迎来到我的博客空间🙇</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://viacheung.github.io/2023/06/04/%E8%B4%AA%E5%BF%83/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="ViaCheung">
      <meta itemprop="description" content="el psy congroo">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="命运石之门">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          贪心
        </h1>

        <div class="post-meta">
	  <span class="post-time">

	  
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-06-04 17:44:46 / 修改时间：17:59:51" itemprop="dateCreated datePublished" datetime="2023-06-04T17:44:46+08:00">2023-06-04</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <ol>
<li>贪心本来就没有套路，也没有框架，所以各种常规解法需要多接触多练习，自然而然才会想到。</li>
<li>局部最优可以推出全局最优，如果找不出局部最优，那可能就是一道模拟题。</li>
<li>在出现两个维度相互影响的情况时，两边一起考虑一定会顾此失彼，要先确定一个维度，再确定另一个一个维度。<span id="more"></span></li>
<li>股票问题用dp</li>
<li>题目不要做一遍，要多练！</li>
<li>区间问题，各种覆盖各种去重。</li>
</ol>
<h2 id="分发饼干"><a href="#分发饼干" class="headerlink" title="分发饼干"></a>分发饼干</h2><p>假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。</p>
<p>对每个孩子 i，都有一个胃口值 g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 s[j] 。如果 s[j] &gt;&#x3D; g[i]，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。</p>
<p><strong>贪心策略：这里的局部最优就是小饼干喂给胃口小的，充分利用饼干尺寸喂饱一个，全局最优就是喂饱尽可能多的小孩</strong>。</p>
<pre><code class="plain">class Solution &#123;
     public int findContentChildren(int[] g, int[] s) &#123;
         //先排序
         Arrays.sort(g);
         Arrays.sort(s);
         int start=0,count=0;
         //遍历饼干尺寸
         for(int i=0;i&lt;s.length&amp;&amp;start&lt;g.length;i++)&#123;
             //找到第一个大于等于g数组的s值
             if(s[i]&gt;=g[start])&#123;
                 start++;
                 count++;
             &#125;
         &#125;
         return count;
     &#125;   
 &#125;
</code></pre>
<h2 id="摆动序列"><a href="#摆动序列" class="headerlink" title="摆动序列"></a>摆动序列</h2><p>如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为 <strong>摆动序列 。</strong>第一个差（如果存在的话）可能是正数或负数。仅有一个元素或者含两个不等元素的序列也视作摆动序列。</p>
<ul>
<li>例如， [1, 7, 4, 9, 2, 5] 是一个 <strong>摆动序列</strong> ，因为差值 (6, -3, 5, -7, 3) 是正负交替出现的。</li>
<li>相反，[1, 4, 7, 2, 5] 和 [1, 7, 4, 5, 5] 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。</li>
</ul>
<p><strong>子序列</strong> 可以通过从原始序列中删除一些（也可以不删除）元素来获得，剩下的元素保持其原始顺序。</p>
<p>给你一个整数数组 nums ，返回 nums 中作为 <strong>摆动序列</strong> 的 <strong>最长子序列的长度</strong> 。</p>
<p>贪心策略:局部最优,删除单调坡度上的节点（不包括单调坡度两端的节点），那么这个坡度就可以有两个局部峰值。</p>
<p><img src="https://raw.githubusercontent.com/viacheung/img/main/image/20201124174327597.png" alt="img"></p>
<pre><code class="plain">class Solution &#123;
     public int wiggleMaxLength(int[] nums) &#123;
         int n=nums.length;
         if(n&lt;2) return n;
         int pre=nums[1]-nums[0];
         int count=pre!=0?2:1;
         for(int i=2;i&lt;nums.length;i++)&#123;
             int cur=nums[i]-nums[i-1];
             //前面差值可以为0 但当前不可
             if((cur&gt;0&amp;&amp;pre&lt;=0)||(cur&lt;0&amp;&amp;pre&gt;=0))&#123;
                 count++;
                 pre=cur;
             &#125;
         &#125;
         return count;
     &#125;
 &#125;
</code></pre>
<h2 id="最大子数组和"><a href="#最大子数组和" class="headerlink" title="最大子数组和"></a>最大子数组和</h2><p>给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
<p><strong>子数组</strong> 是数组中的一个连续部分。</p>
<p><strong>方法一</strong></p>
<p><img src="https://raw.githubusercontent.com/viacheung/img/main/image/image-20221120103615752.png" alt="img"></p>
<pre><code class="plain">fi表示以第 i个数结尾的「连续子数组的最大和」
 class Solution &#123;
     public int maxSubArray(int[] nums) &#123;
         int maxAns=nums[0],pre=0;
         for(int x:nums)&#123;
             //求出每个位置的fi
             //加入前一段还是单独成一段
             pre=Math.max(pre+x,x);
             //维护一个最大值
             maxAns=Math.max(maxAns,pre);
         &#125;
         return maxAns;
 
     &#125;
 &#125;
 //我觉得这道题目的思想是： 走完这一生 如果我和你在一起会变得更好，那我们就在一起，否则我就丢下你。 我回顾我最光辉的时刻就是和不同人在一起，变得更好的最长连续时刻
</code></pre>
<p><strong>方法二</strong></p>
<p>当前“连续和”为负数的时候立刻放弃，从下一个元素重新计算“连续和”，因为负数加上下一个元素 “连续和”只会越来越小。<strong>局部最优的情况下，并记录最大的“连续和”，可以推出全局最优</strong>。<strong>这相当于是暴力解法中的不断调整最大子序和区间的起始位置</strong>。</p>
<p><img src="https://raw.githubusercontent.com/viacheung/img/main/image/53.%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C.gif" alt="img"></p>
<pre><code class="plain">class Solution &#123;
     public int maxSubArray(int[] nums) &#123;
         int sum=Integer.MIN_VALUE;
         int count=0;
         for(int i=0;i&lt;nums.length;i++)&#123;
             //当前连续子数组和
             count+=nums[i];
             //维护结果
             sum=Math.max(sum,count);
             //当前连续子数组和&lt;0.置为0
             if(count&lt;0) count=0;
         &#125;
         return sum;
     &#125;
 &#125;
</code></pre>
<h2 id="买卖股票的最佳时机-II"><a href="#买卖股票的最佳时机-II" class="headerlink" title="买卖股票的最佳时机 II"></a>买卖股票的最佳时机 II</h2><p>给你一个整数数组 prices ，其中 prices[i] 表示某支股票第 i 天的价格。</p>
<p>在每一天，你可以决定是否购买和&#x2F;或出售股票。你在任何时候 <strong>最多</strong> 只能持有 <strong>一股</strong> 股票。你也可以先购买，然后在 <strong>同一天</strong> 出售。</p>
<p>返回 <em>你能获得的</em> *<strong>最大*</strong> <em>利润</em> 。</p>
<p><img src="https://raw.githubusercontent.com/viacheung/img/main/image/2020112917480858.png" alt="img"></p>
<p>从图中可以发现，其实我们需要收集每天的正利润就可以，<strong>收集正利润的区间，就是股票买卖的区间，而我们只需要关注最终利润，不需要记录区间</strong>。</p>
<p><strong>局部最优：收集每天的正利润，全局最优：求得最大利润</strong>。</p>
<pre><code class="plain">class Solution &#123;
         public int maxProfit(int[] prices) &#123;
             int ans=0;
             for(int i=1;i&lt;prices.length;i++)&#123;
                 ans+=Math.max(prices[i]-prices[i-1],0);
             &#125;
             return ans;
         &#125;
     &#125;
</code></pre>
<h2 id="跳跃游戏"><a href="#跳跃游戏" class="headerlink" title="跳跃游戏"></a>跳跃游戏</h2><p>给定一个非负整数数组 nums ，你最初位于数组的 <strong>第一个下标</strong> 。</p>
<p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p>
<p><strong>判断</strong>你是否能够到达最后一个下标。</p>
<p><strong>贪心算法局部最优解：每次取最大跳跃步数（取最大覆盖范围），整体最优解：最后得到整体最大覆盖范围，看是否能到终点</strong>。</p>
<p><img src="https://raw.githubusercontent.com/viacheung/img/main/image/20201124154758229.png" alt="img"></p>
<pre><code class="plain">class Solution &#123;
     public boolean canJump(int[] nums) &#123;
         int coverRange=0;
         
        //在覆盖范围内寻找最大覆盖范围
         //覆盖范围指的是最远到达下标 只要最远到达下标大于集合长度 就返回true
         for(int i=0;i&lt;=coverRange;i++)&#123;
             coverRange=Math.max(coverRange,i+nums[i]);
             if(coverRange&gt;=nums.length-1) return true;
         &#125;
         return false;
     &#125;
 &#125;
</code></pre>
<h2 id="跳跃游戏-1"><a href="#跳跃游戏-1" class="headerlink" title="跳跃游戏"></a>跳跃游戏</h2><p>给定一个非负整数数组，你最初位于数组的第一个位置。数组中的每个元素代表你在该位置可以跳跃的最大长度。</p>
<p>你的目标是<strong>使用最少的跳跃次数</strong>到达数组的最后一个位置。</p>
<p><strong>贪心策略</strong>：当前可移动距离尽可能多走，如果还没到终点，步数再加一。整体最优：一步尽可能多走，从而达到最小步数。</p>
<p>我的理解：</p>
<p>当前覆盖的最大区域：下一步可达的最大区域 </p>
<p><img src="https://raw.githubusercontent.com/viacheung/img/main/image/20201201232309103.png" alt="img"></p>
<pre><code class="plain">class Solution &#123;
     public int jump(int[] nums) &#123;
         if (nums == null || nums.length == 0 || nums.length == 1) &#123;
             return 0;
         &#125;
         //记录跳跃的次数
         int count=0;
         //当前的覆盖最大区域
         int curDistance = 0;
         //最大的覆盖区域
         int maxDistance = 0;
         for (int i = 0; i &lt; nums.length; i++) &#123;
             //在可覆盖区域内更新最大的覆盖区域
             maxDistance = Math.max(maxDistance,i+nums[i]);
             //说明当前一步，再跳一步就到达了末尾
             if (maxDistance&gt;=nums.length-1)&#123;
                 count++;
                 break;
             &#125;
             //走到当前覆盖的最大区域时，更新下一步可达的最大区域  说明此时还没有跳到最后一个位置，那么步数需要+1
             if (i==curDistance)&#123;
                 curDistance = maxDistance;
                 count++;
             &#125;
         &#125;
         return count;
     &#125;
 &#125;
</code></pre>
<h2 id="K-次取反后最大化的数组和"><a href="#K-次取反后最大化的数组和" class="headerlink" title="K 次取反后最大化的数组和"></a>K 次取反后最大化的数组和</h2><p>给你一个整数数组 nums 和一个整数 k ，按以下方法修改该数组：</p>
<p>选择某个下标 i 并将 nums[i] 替换为 -nums[i] 。重复这个过程恰好 k 次。可以多次选择同一个下标 i 。以这种方式修改数组后，返回数组 <strong>可能的最大和</strong> 。</p>
<p><strong>题解：</strong></p>
<ul>
<li>第一步：将数组按照绝对值大小从大到小排序，<strong>注意要按照绝对值的大小</strong></li>
<li>第二步：从前向后遍历，遇到负数将其变为正数，同时K–</li>
<li>第三步：如果K还大于0，那么反复转变数值最小的元素，将K用完</li>
<li>第四步：求和</li>
</ul>
<pre><code class="plain">class Solution &#123;
     public int largestSumAfterKNegations(int[] nums, int k) &#123;
         //将数组按照绝对值大小从大到小排序，注意要按照绝对值的大小
         nums = IntStream.of(nums)
              .boxed()
              .sorted((o1, o2) -&gt; Math.abs(o2) - Math.abs(o1))
              .mapToInt(Integer::intValue).toArray();
         //从前向后遍历，遇到负数将其变为正数，同时K--
         for(int i=0;i&lt;nums.length;i++)&#123;
             if(nums[i]&lt;0&amp;&amp;k&gt;0) &#123;
                 nums[i]*=-1;
                 k--;
             &#125;
         &#125;
         // 如果K还大于0，那么反复转变数值最小的元素，将K用完
         if(k%2==1) nums[nums.length-1]*=-1;
         int ans=0;
         for(int num:nums)&#123;
             ans+=num;
         &#125;
         return ans;
     &#125;
 &#125;
</code></pre>
<h2 id="加油站"><a href="#加油站" class="headerlink" title="加油站"></a>加油站</h2><p>在一条环路上有 n 个加油站，其中第 i 个加油站有汽油 gas[i] 升。</p>
<p>你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。</p>
<p>给定两个整数数组 gas 和 cost ，如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1 。如果存在解，则 <strong>保证</strong> 它是 <strong>唯一</strong> 的。</p>
<p><strong>思路：</strong></p>
<p>如果总油量减去总消耗大于等于零那么一定可以跑完一圈，说明 各个站点的加油站 剩油量rest[i]相加一定是大于等于零的。</p>
<p>每个加油站的剩余量rest[i]为gas[i] - cost[i]。</p>
<p>i从0开始累加rest[i]，和记为curSum，一旦curSum小于零，说明[0, i]区间都不能作为起始位置，起始位置从i+1算起，再从0计算curSum。</p>
<p>为什么[0, i]区间都不能作为起始位置？我的理解：首先0肯定是不能作为起始位置的，假设存在0&lt;j&lt;i，使得j可以作为起始位置，那么[j,i]的curSum肯定大于0，又[0,i]curSum小于0，则[0,j]的curSum必小于0，与第一次出现小于01矛盾，所以不存在0&lt;j&lt;i，使得j可以作为起始位置</p>
<pre><code class="plain">class Solution &#123;
     public int canCompleteCircuit(int[] gas, int[] cost) &#123;
         //当rest累加为负数，就从i+1重新开始，cur归0 最后判断总油是不是小于0
         int curgas=0,sumgas=0,index=0;
         for(int i=0;i&lt;gas.length;i++)&#123;
             curgas+=gas[i]-cost[i];
             sumgas+=gas[i]-cost[i];
             if(curgas&lt;0)&#123;
                 index=(i+1)%gas.length;
                 curgas=0;
             &#125;
         &#125;
         if(sumgas&lt;0)&#123;
             return -1;
         &#125;else&#123;
             return index;
         &#125;
     &#125;
 &#125;
</code></pre>
<h2 id="分发糖果"><a href="#分发糖果" class="headerlink" title="分发糖果"></a>分发糖果</h2><p>n 个孩子站成一排。给你一个整数数组 ratings 表示每个孩子的评分。</p>
<p>你需要按照以下要求，给这些孩子分发糖果：</p>
<ul>
<li>每个孩子至少分配到 1 个糖果。</li>
<li>相邻两个孩子评分更高的孩子会获得更多的糖果。</li>
</ul>
<p>请你给每个孩子分发糖果，计算并返回需要准备的 <strong>最少糖果数目</strong> 。</p>
<p><strong>题解：</strong></p>
<p><strong>遇到两个维度权衡的时候，一定要先确定一个维度，再确定另一个维度。</strong></p>
<p><strong>右边评分大于左边的情况（从前向后遍历）</strong></p>
<p>局部最优：只要右边评分比左边大，右边的孩子就多一个糖果，全局最优：相邻的孩子中，评分高的右孩子获得比左边孩子更多的糖果</p>
<p>局部最优可以推出全局最优。</p>
<p>如果ratings[i] &gt; ratings[i - 1] 那么[i]的糖 一定要比[i - 1]的糖多一个，所以贪心：candyVec[i] &#x3D; candyVec[i - 1] + 1</p>
<p><img src="https://raw.githubusercontent.com/viacheung/img/main/image/20201117114916878.png" alt="img"></p>
<p><strong>左孩子大于右孩子的情况（从后向前遍历）</strong></p>
<p>局部最优：如果 ratings[i] &gt; ratings[i + 1]，取candyVec[i + 1] + 1 （从右边这个加1得到的糖果数量）和 candyVec[i] （之前比较右孩子大于左孩子得到的糖果数量）。最大的糖果数量，保证第i个小孩的糖果数量即大于左边的也大于右边的。全局最优：相邻的孩子中，评分高的孩子获得更多的糖果。</p>
<p>局部最优可以推出全局最优。</p>
<p>所以就取candyVec[i + 1] + 1 和 candyVec[i] 最大的糖果数量，<strong>candyVec[i]只有取最大的才能既保持对左边candyVec[i - 1]的糖果多，也比右边candyVec[i + 1]的糖果多</strong>。</p>
<p><img src="https://raw.githubusercontent.com/viacheung/img/main/image/20201117115658791.png" alt="img"></p>
<pre><code class="plain">class Solution &#123;
     public int candy(int[] ratings) &#123;
         int n=ratings.length;
         int[] candyVec=new int[n];
         candyVec[0]=1;
         for(int i=1;i&lt;n;i++)&#123;
             candyVec[i]=(ratings[i]&gt;ratings[i-1])?candyVec[i-1]+1:1;
         &#125;
         // for(int i=0;i&lt;n;i++)&#123;
         //     if(ratings[i]&gt;ratings[i+1])&#123;
         //         //这就是为什么比较左大于右情况时不能从前往后的原因，因为用到的candyVec[i+1]不是最新的
         //         candyVec[i]=Math.max(candyVec[i],candyVec[i+1]+1);
         //     &#125;
         // &#125;
         for(int i=n-2;i&gt;=0;i--)&#123;
             if(ratings[i]&gt;ratings[i+1])&#123;
                 candyVec[i]=Math.max(candyVec[i],candyVec[i+1]+1);
             &#125;
         &#125;
         int ans=0;
         for(int candy:candyVec)&#123;
             ans+=candy;
         &#125;
         return ans;
     &#125;
 &#125;
</code></pre>
<h2 id="柠檬水找零"><a href="#柠檬水找零" class="headerlink" title="柠檬水找零"></a>柠檬水找零</h2><p>在柠檬水摊上，每一杯柠檬水的售价为 5 美元。顾客排队购买你的产品，（按账单 bills 支付的顺序）一次购买一杯。</p>
<p>每位顾客只买一杯柠檬水，然后向你付 5 美元、10 美元或 20 美元。你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付 5 美元。</p>
<p>注意，一开始你手头没有任何零钱。</p>
<p>给你一个整数数组 bills ，其中 bills[i] 是第 i 位顾客付的账。如果你能给每位顾客正确找零，返回 true ，否则返回 false 。</p>
<pre><code class="plain">/**
 题解：
 贪心策略：20美元情况优先找一个10元和5元 switch和if else都可 
 我最开始还定义一个num_20 后来发现这个变量只有增加，所以可以去掉
 **/
 class Solution &#123;
     public boolean lemonadeChange(int[] bills) &#123;
         int num_5=0,num_10=0;
         for(int i=0;i&lt;bills.length;i++)&#123;
             switch(bills[i])&#123;
                 case 5:
                 num_5++;
                 break;
 
                 case 10:
                 num_5--;
                 num_10++;
                 break;
 
                 case 20:
                 if(num_10&gt;=1)&#123;
                     num_10--;
                     num_5--;
                 &#125;else&#123;
                     num_5-=3;
                 &#125;;
                 break;
                 default:
             &#125;
             if(num_10&lt;0||num_5&lt;0) return false;
         &#125;
         return true;
     &#125;
 &#125;
</code></pre>
<h2 id="根据身高重建队列"><a href="#根据身高重建队列" class="headerlink" title="根据身高重建队列"></a>根据身高重建队列</h2><p>排序里面做过</p>
<h2 id="用最少数量的箭引爆气球"><a href="#用最少数量的箭引爆气球" class="headerlink" title="用最少数量的箭引爆气球"></a>用最少数量的箭引爆气球</h2><p>有一些球形气球贴在一堵用 XY 平面表示的墙面上。墙面上的气球记录在整数数组 points ，其中points[i] &#x3D; [xstart, xend] 表示水平直径在 xstart 和 xend之间的气球。你不知道气球的确切 y 坐标。</p>
<p>一支弓箭可以沿着 x 轴从不同点 <strong>完全垂直</strong> 地射出。在坐标 x 处射出一支箭，若有一个气球的直径的开始和结束坐标为 x<code>start，x</code>end， 且满足 xstart ≤ x ≤ x&#96;&#96;end，则该气球会被 <strong>引爆</strong> 。可以射出的弓箭的数量 <strong>没有限制</strong> 。 弓箭一旦被射出之后，可以无限地前进。</p>
<p>给你一个数组 points ，<em>返回引爆所有气球所必须射出的</em> *<strong>最小*</strong> <em>弓箭数</em> 。</p>
<p><img src="https://raw.githubusercontent.com/viacheung/img/main/image/20201123101929791.png" alt="img"></p>
<pre><code class="plain">class Solution &#123;
     public int findMinArrowShots(int[][] points) &#123;
         Arrays.sort(points,new Comparator&lt;int[]&gt;()&#123;
             public int compare(int[] point1,int[] point2)&#123;
                 //按照左边界排序就行
                 //这里这么写 是为了防止溢出，做减法可能导致数值溢出 要直接比较
                 return point1[0]&gt;point2[0]?1:-1;
             &#125;
         &#125;);
         //需要箭个数
         int count=0;
         int i=0;
         while(i&lt;points.length)&#123;
             int index=1;
             int minright=points[i][1];
             //因为已经保证了左边界有序，因此只需要下一个int[]0位置要小于等于最小右边界就可以放在一起被引爆
             while(i+index&lt;points.length&amp;&amp;minright&gt;=points[i+index][0])&#123;
                 minright=Math.min(minright, points[i+index][1]);//维护有边界最小值               
                 index++;
             &#125;
             i=i+index;
             count++;
         &#125;
         return count;
     &#125;
 &#125;
 //代码随想录
 class Solution &#123;
     public int findMinArrowShots(int[][] points) &#123;
         // 根据气球直径的开始坐标从小到大排序
         // 使用Integer内置比较方法，不会溢出
         Arrays.sort(points, (a, b) -&gt; Integer.compare(a[0], b[0]));
         int count = 1;  // points 不为空至少需要一支箭
         for (int i = 1; i &lt; points.length; i++) &#123;
             if (points[i][0] &gt; points[i - 1][1]) &#123;  // 气球i和气球i-1不挨着，注意这里不是&gt;=
                 count++; // 需要一支箭
             &#125; else &#123;  // 气球i和气球i-1挨着、
                 //points[i][1] 存的是i及之前的最小右边界
                 points[i][1] = Math.min(points[i][1], points[i - 1][1]); // 更新重叠气球最小右边界
             &#125;
         &#125;
         return count;
     &#125;
 &#125;
</code></pre>
<h2 id="无重叠区间"><a href="#无重叠区间" class="headerlink" title="无重叠区间"></a>无重叠区间</h2><p>给定一个区间的集合 intervals ，其中 intervals[i] &#x3D; [starti, endi] 。返回 <em>需要移除区间的最小数量，使剩余区间互不重叠</em> 。</p>
<p>题解：和上一题很像</p>
<p>右边界排序之后，局部最优：优先选右边界小的区间，所以从左向右遍历，留给下一个区间的空间大一些，从而尽量避免交叉。全局最优：选取最多的非交叉区间。</p>
<p><img src="https://raw.githubusercontent.com/viacheung/img/main/image/20201221201553618.png" alt="img"></p>
<pre><code class="plain">class Solution &#123;
     public int eraseOverlapIntervals(int[][] intervals) &#123;
         //按照右边界排序  升序排
         Arrays.sort(intervals,(a,b)-&gt;Integer.compare(a[1],b[1]));
         //需要移除区间的最小数量
         int count=0;
         int minRight=Integer.MIN_VALUE;
         for(int i=0;i&lt;intervals.length;i++)&#123;
             //后一个的左边界如果大于前一个右边界  更新minright   
             if(minRight&lt;=intervals[i][0])&#123;
                 minRight=intervals[i][1];
             &#125;else&#123;
                 //需要移除重叠的区域,为了保证更多不相交区间,右边界尽量小
                 count++;
             &#125;
         &#125;
         return count;
     &#125;
 &#125;
</code></pre>
<h2 id="划分字母区间"><a href="#划分字母区间" class="headerlink" title="划分字母区间"></a>划分字母区间</h2><p>字符串 S 由小写字母组成。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。返回一个表示每个字符串片段的长度的列表。</p>
<p><img src="https://raw.githubusercontent.com/viacheung/img/main/image/20201222191924417.png" alt="img"></p>
<pre><code class="plain">class Solution &#123;
     public List&lt;Integer&gt; partitionLabels(String s) &#123;
         // 统计每一个字符最后出现的位置  因为是26个字母 所以长度26 位置0对应就是a字符出现最远位置
         int[] hash=new int[26];
         for(int i=0;i&lt;s.length();i++)&#123;
             //更新最远距离 可以覆盖的
             hash[s.charAt(i)-&#39;a&#39;]=i;
         &#125;
         int start=0,end=0;//左右边界
         List&lt;Integer&gt; ans=new ArrayList&lt;&gt;();
         for(int i=0;i&lt;s.length();i++)&#123;
             // 更新当前出现的最远出现下标
             end=Math.max(end,hash[s.charAt(i)-&#39;a&#39;]);
             // 如果找到字符最远出现位置下标和当前下标相等了，则找到了分割点
             if(end==i)&#123;
                 ans.add(end-start+1);
                 // 调整start
                 start=i+1;
             &#125;
         &#125;
         return ans;
 
     &#125;
 &#125;
</code></pre>
<h2 id="合并区间"><a href="#合并区间" class="headerlink" title="合并区间"></a>合并区间</h2><p>以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] &#x3D; [starti, endi] 。请你合并所有重叠的区间，并返回 <em>一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间</em> 。</p>
<p>题解：</p>
<pre><code class="plain">class Solution &#123;
     public int[][] merge(int[][] intervals) &#123;
         List&lt;int[]&gt; res = new LinkedList&lt;&gt;();
         //按照左边界排序
         Arrays.sort(intervals, (x, y) -&gt; Integer.compare(x[0], y[0]));
         //initial start 是最小左边界
         int start = intervals[0][0];
         int rightmostRightBound = intervals[0][1];
         for (int i = 1; i &lt; intervals.length; i++) &#123;
             //如果左边界大于最大右边界
             if (intervals[i][0] &gt; rightmostRightBound) &#123;
                 //加入区间 并且更新start
                 res.add(new int[]&#123;start, rightmostRightBound&#125;);
                 start = intervals[i][0];
                 rightmostRightBound = intervals[i][1];
             &#125; else &#123;
                 //更新最大右边界
                 rightmostRightBound = Math.max(rightmostRightBound, intervals[i][1]);
             &#125;
         &#125;
         res.add(new int[]&#123;start, rightmostRightBound&#125;);
         return res.toArray(new int[res.size()][]);
     &#125;
 &#125;
 &#125;
//相当简洁
 class Solution &#123;
     public int[][] merge(int[][] intervals) &#123;
         Arrays.sort(intervals, (x, y) -&gt; Integer.compare(x[0], y[0]));
         List&lt;int[]&gt; ans=new ArrayList&lt;&gt;();
         int n=intervals.length;
         for(int i=0;i&lt;n;i++)&#123;
             // 第一次加入或者区间不相交，直接加入集合
             if(ans.size()==0||intervals[i][0]&gt;ans.get(ans.size()-1)[1])&#123;
                 ans.add(intervals[i]);
             &#125;else&#123;
                 // 否则更改前一个元素的右边界，注意这里直接修改，也就避免再添加了
                 ans.get(ans.size()-1)[1]=Math.max(intervals[i][1],ans.get(ans.size()-1)[1]);
             &#125;
         &#125;
         return ans.toArray(new int[ans.size()][]);//转成数组要指定大小
 
     &#125;
 &#125;
</code></pre>
<h2 id="单调递增的数字"><a href="#单调递增的数字" class="headerlink" title="单调递增的数字"></a>单调递增的数字</h2><p>当且仅当每个相邻位数上的数字 x 和 y 满足 x &lt;&#x3D; y 时，我们称这个整数是<strong>单调递增</strong>的。</p>
<p>给定一个整数 n ，返回 <em>小于或等于</em> <em>n</em> <em>的最大数字，且数字呈</em> *<strong>单调递增*</strong> 。</p>
<p>题解：</p>
<p><strong>局部最优：遇到strNum[i - 1] &gt; strNum[i]的情况，让strNum[i - 1]–，然后strNum[i]给为9，可以保证这两位变成最大单调递增整数</strong>。</p>
<p><strong>但这里局部最优推出全局最优，还需要其他条件，即遍历顺序，和标记从哪一位开始统一改成9</strong>。</p>
<p><strong>又因为从前后向遍历会改变已经遍历过的结果，所以从后往前遍历</strong></p>
<pre><code class="plain">class Solution &#123;
     public int monotoneIncreasingDigits(int n) &#123;
         char[] chars = Integer.toString(n).toCharArray();
         // start用来标记赋值9从哪里开始
         // 设置为这个默认值，为了防止第二个for循环在start没有被赋值的情况下执行
         //初始化 ，start 表示要开始填充&#39;9&#39;的位置
         int start=chars.length;
         for(int i=chars.length-1;i&gt;0;i--)&#123;
             if(chars[i-1]&gt;chars[i])&#123;
                 chars[i-1]--;
                 start=i;
             &#125;
         &#125;
         // 从start开始一直往后填充&#39;9&#39;
         for(int i=start;i&lt;chars.length;i++)&#123;
             chars[i]=&#39;9&#39;;
         &#125;
         // 类型转换
         return Integer.parseInt(String.valueOf(chars));
     &#125;
 &#125;
</code></pre>
<h2 id="监控二叉树"><a href="#监控二叉树" class="headerlink" title="监控二叉树"></a>监控二叉树</h2><p>给定一个二叉树，我们在树的节点上安装摄像头。</p>
<p>节点上的每个摄影头都可以监视<strong>其父对象、自身及其直接子对象。</strong></p>
<p>计算监控树的所有节点所需的最小摄像头数量。</p>
<p><img src="https://raw.githubusercontent.com/viacheung/img/main/image/bst_cameras_01.png" alt="img"></p>
<p><strong>后序遍历</strong>：叶子节点放不放摄像头省下了的摄像头数量是指数阶别的,所以让叶子节点的父节点安摄像头，所用摄像头最少，选择后序遍历</p>
<p><strong>如何隔两个节点放一个摄像头</strong> ：状态转移</p>
<ul>
<li>0：该节点无覆盖</li>
<li>1：本节点有摄像头</li>
<li>2：本节点有覆盖</li>
</ul>
<ol>
<li>情况一：左孩子有覆盖，右孩子有覆盖，那么此时中间节点应该就是无覆盖的状态了。</li>
<li>情况2：左右节点至少有一个无覆盖的情况，如果是以下情况，此时摄像头的数量要加一，并且return 1，代表中间节点放摄像头。</li>
<li>情况3：左右节点至少有一个有摄像头，其父节点就应该是2</li>
</ol>
<pre><code class="plain">class Solution &#123;
     int count=0;
     public int minCameraCover(TreeNode root) &#123;
     //     0 表示无覆盖 
     //    1 表示 有摄像头
     //    2 表示有覆盖       
         if(mincame(root)==0) count++;
         return count;
     &#125;
     public int mincame(TreeNode root)&#123;
         //空节点默认为 有覆盖状态，避免在叶子节点上放摄像头 
         if(root==null) return 2;
         // 优先遍历叶子结点  因为让叶子节点的父节点安摄像头，所用摄像头最少  用后序遍历
         int left=mincame(root.left);
         int right=mincame(root.right);
         if(left==2&amp;&amp;right==2)&#123;
             return 0;
         &#125;else if(left==0||right==0)&#123;
             count++;
             return 1;
         &#125;else&#123;
             return 2;
         &#125;
     &#125;
 &#125;
</code></pre>
<h2 id="最长递增子序列（也可dp）"><a href="#最长递增子序列（也可dp）" class="headerlink" title="最长递增子序列（也可dp）"></a>最长递增子序列（也可dp）</h2><p>考虑一个简单的贪心，如果我们要使上升子序列尽可能的长，则我们需要让序列上升得尽可能慢，因此我们希望每次在上升子序列最后加上的那个数尽可能的小。</p>
<p>基于上面的贪心思路，我们维护一个数组 d[i]，表示长度为 i的最长上升子序列的末尾元素的最小值，用 len记录目前最长上升子序列的长度，起始时 len 为 1，d[1]&#x3D;nums[0]</p>
<p>同时我们可以注意到 d[i] 是关于 i 单调递增的。（显而易见）根据 ddd 数组的单调性，我们可以使用二分查找寻找下标 i，优化时间复杂度。</p>
<p><img src="https://raw.githubusercontent.com/viacheung/img/main/image/image-20220924191640236.png" alt="img"></p>
<pre><code class="plain">class Solution &#123;
     public int lengthOfLIS(int[] nums) &#123;
         int len = 1, n = nums.length;
         if (n == 0) &#123;
             return 0;
         &#125;
         //细节 d代表长度为i的最长上升子序列的末尾元素的最小值，d[0……n]因此共n+1个数 所以是new int[n + 1]
         int[] d = new int[n + 1];
         d[len] = nums[0];
         for (int i = 1; i &lt; n; ++i) &#123;
             if (nums[i] &gt; d[len]) &#123;
                 d[++len] = nums[i];//先++
             &#125; else &#123;
                 int l = 1, r = len, pos = 0; // 如果找不到说明所有的数都比 nums[i] 大，此时要更新 d[1]，所以这里将 pos 设为 0  
                 while (l &lt;= r) &#123;
                     int mid = (l + r) &gt;&gt; 1;
                     //目的是找到第一个比num[i]小的数字，也就是小于nums[i]的数字里面最接近nums[i]的数字
                     if (d[mid] &lt; nums[i]) &#123;
                         pos = mid;//更新pos
                         l = mid + 1;
                     &#125; else &#123;
                         r = mid - 1;
                     &#125;
                 &#125;
                 d[pos + 1] = nums[i];//更新 
             &#125;
         &#125;
         return len;
     &#125;
 &#125;
</code></pre>
<h2 id="Dota2-参议院"><a href="#Dota2-参议院" class="headerlink" title="Dota2 参议院"></a>Dota2 参议院</h2><p>Dota2 的世界里有两个阵营：Radiant（天辉）和 Dire（夜魇）</p>
<p>Dota2 参议院由来自两派的参议员组成。现在参议院希望对一个 Dota2 游戏里的改变作出决定。他们以一个基于轮为过程的投票进行。在每一轮中，每一位参议员都可以行使两项权利中的 <strong>一</strong> 项：</p>
<ul>
<li><strong>禁止一名参议员的权利</strong>：参议员可以让另一位参议员在这一轮和随后的几轮中丧失 <strong>所有的权利</strong> 。</li>
<li><strong>宣布胜利</strong>：如果参议员发现有权利投票的参议员都是 <strong>同一个阵营的</strong> ，他可以宣布胜利并决定在游戏中的有关变化。</li>
</ul>
<p>给你一个字符串 senate 代表每个参议员的阵营。字母 ‘R’ 和 ‘D’分别代表了 Radiant（天辉）和 Dire（夜魇）。然后，如果有 n 个参议员，给定字符串的大小将是 n。</p>
<p>以轮为基础的过程从给定顺序的第一个参议员开始到最后一个参议员结束。这一过程将持续到投票结束。所有失去权利的参议员将在过程中被跳过。</p>
<p>假设每一位参议员都足够聪明，会为自己的政党做出最好的策略，你需要预测哪一方最终会宣布胜利并在 Dota2 游戏中决定改变。输出应该是 “Radiant” 或 “Dire” 。</p>
<p>题解：</p>
<p>例如：RDDRD</p>
<p>第一轮：senate[0]的R消灭senate[1]的D，那么senate[2]的D，是消灭senate[0]的R还是消灭senate[3]的R呢？</p>
<p>当然是消灭senate[3]的R，因为当轮到这个R的时候，它可以消灭senate[4]的D。</p>
<p><strong>所以消灭的策略是，尽量消灭自己后面的对手，因为前面的对手已经使用过权利了，而后序的对手依然可以使用权利消灭自己的同伴！</strong></p>
<pre><code class="plain">class Solution &#123;
     public String predictPartyVictory(String senateStr) &#123;
         // R = true表示本轮循环结束后，字符串里依然有R。D同理
         Boolean R = true, D = true;
         // 当flag大于0时，R在D前出现，R可以消灭D。当flag小于0时，D在R前出现，D可以消灭R
         int flag = 0;
         byte[] senate =  senateStr.getBytes();
         while (R &amp;&amp; D) &#123; // 一旦R或者D为false，就结束循环，说明本轮结束后只剩下R或者D了
             R = false;
             D = false;
             for (int i = 0; i &lt; senate.length; i++) &#123;
                 if (senate[i] == &#39;R&#39;) &#123;
                     if (flag &lt; 0) senate[i] = 0; // 消灭R，R此时为false
                     else R = true; // 如果没被消灭，本轮循环结束有R
                     flag++;
                 &#125;
                 if (senate[i] == &#39;D&#39;) &#123;
                     if (flag &gt; 0) senate[i] = 0;
                     else D = true;
                     flag--;
                 &#125;
             &#125;
         &#125;
         // 循环结束之后，R和D只能有一个为true
         return R == true ? &quot;Radiant&quot; : &quot;Dire&quot;;
     &#125;
 &#125;
</code></pre>
<h2 id="分割平衡字符串"><a href="#分割平衡字符串" class="headerlink" title="分割平衡字符串"></a>分割平衡字符串</h2><p><strong>平衡字符串</strong> 中，’L’ 和 ‘R’ 字符的数量是相同的。</p>
<p>给你一个平衡字符串 s，请你将它分割成尽可能多的子字符串，并满足：</p>
<ul>
<li>每个子字符串都是平衡字符串。</li>
</ul>
<p>返回可以通过分割得到的平衡字符串的 <strong>最大数量****。</strong></p>
<p>简单 直接做出来</p>
<pre><code class="plain">class Solution &#123;
     int count=0;
     public int balancedStringSplit(String s) &#123;
         int Lcount=0,Rcount=0;
         for(int i=0;i&lt;s.length();i++)&#123;
             if(s.charAt(i)==&#39;L&#39;)&#123;
                 Lcount++;
             &#125;
             if(s.charAt(i)==&#39;R&#39;)&#123;
                 Rcount++;
             &#125;
             if(Lcount==Rcount)&#123;
                 count++;
             &#125;
         &#125; 
         return count;
     &#125;
 &#125;
</code></pre>

    </div>

    
    
    
        <div class="reward-container">
  <div>“坚持原创技术分享，您的支持将鼓励我继续创作!“</div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/images/wechatpay.jpg" alt="ViaCheung 微信支付">
        <p>微信支付</p>
      </div>

  </div>
</div>

        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>ViaCheung
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://viacheung.github.io/2023/06/04/%E8%B4%AA%E5%BF%83/" title="贪心">http://viacheung.github.io/2023/06/04/贪心/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/zh-CN" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2023/06/04/%E5%8F%8C%E6%8C%87%E9%92%88/" rel="prev" title="双指针">
      <i class="fa fa-chevron-left"></i> 双指针
    </a></div>
      <div class="post-nav-item">
    <a href="/2023/06/04/%E5%9B%BE%E8%AE%BA/" rel="next" title="图论">
      图论 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E5%8F%91%E9%A5%BC%E5%B9%B2"><span class="nav-number">1.</span> <span class="nav-text">分发饼干</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%91%86%E5%8A%A8%E5%BA%8F%E5%88%97"><span class="nav-number">2.</span> <span class="nav-text">摆动序列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C"><span class="nav-number">3.</span> <span class="nav-text">最大子数组和</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA-II"><span class="nav-number">4.</span> <span class="nav-text">买卖股票的最佳时机 II</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F"><span class="nav-number">5.</span> <span class="nav-text">跳跃游戏</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F-1"><span class="nav-number">6.</span> <span class="nav-text">跳跃游戏</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#K-%E6%AC%A1%E5%8F%96%E5%8F%8D%E5%90%8E%E6%9C%80%E5%A4%A7%E5%8C%96%E7%9A%84%E6%95%B0%E7%BB%84%E5%92%8C"><span class="nav-number">7.</span> <span class="nav-text">K 次取反后最大化的数组和</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8A%A0%E6%B2%B9%E7%AB%99"><span class="nav-number">8.</span> <span class="nav-text">加油站</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E5%8F%91%E7%B3%96%E6%9E%9C"><span class="nav-number">9.</span> <span class="nav-text">分发糖果</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9F%A0%E6%AA%AC%E6%B0%B4%E6%89%BE%E9%9B%B6"><span class="nav-number">10.</span> <span class="nav-text">柠檬水找零</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%B9%E6%8D%AE%E8%BA%AB%E9%AB%98%E9%87%8D%E5%BB%BA%E9%98%9F%E5%88%97"><span class="nav-number">11.</span> <span class="nav-text">根据身高重建队列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%94%A8%E6%9C%80%E5%B0%91%E6%95%B0%E9%87%8F%E7%9A%84%E7%AE%AD%E5%BC%95%E7%88%86%E6%B0%94%E7%90%83"><span class="nav-number">12.</span> <span class="nav-text">用最少数量的箭引爆气球</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%97%A0%E9%87%8D%E5%8F%A0%E5%8C%BA%E9%97%B4"><span class="nav-number">13.</span> <span class="nav-text">无重叠区间</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%92%E5%88%86%E5%AD%97%E6%AF%8D%E5%8C%BA%E9%97%B4"><span class="nav-number">14.</span> <span class="nav-text">划分字母区间</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4"><span class="nav-number">15.</span> <span class="nav-text">合并区间</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%95%E8%B0%83%E9%80%92%E5%A2%9E%E7%9A%84%E6%95%B0%E5%AD%97"><span class="nav-number">16.</span> <span class="nav-text">单调递增的数字</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9B%91%E6%8E%A7%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">17.</span> <span class="nav-text">监控二叉树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97%EF%BC%88%E4%B9%9F%E5%8F%AFdp%EF%BC%89"><span class="nav-number">18.</span> <span class="nav-text">最长递增子序列（也可dp）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Dota2-%E5%8F%82%E8%AE%AE%E9%99%A2"><span class="nav-number">19.</span> <span class="nav-text">Dota2 参议院</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E5%89%B2%E5%B9%B3%E8%A1%A1%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">20.</span> <span class="nav-text">分割平衡字符串</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="ViaCheung"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">ViaCheung</p>
  <div class="site-description" itemprop="description">el psy congroo</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">40</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/viacheung" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;viacheung" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:viacheung5@gmail.com" title="E-Mail → mailto:viacheung5@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/zh-CN" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ViaCheung</span>
</div>

<!--
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div> -->

<!-- 网站运行时间的设置 -->
<span id="timeDate">载入天数...</span>
<span id="times">载入时分秒...</span>
<script>
    var now = new Date();
    function createtime() {
        var grt= new Date("03/01/2023 10:00:00"); //此处修改你的建站时间或者网站上线时间
        now.setTime(now.getTime()+250);
        days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days);
        hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours);
        if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);
        mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;}
        seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
        snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;}
        document.getElementById("timeDate").innerHTML = "本站已安全运行 "+dnum+" 天 ";
        document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒.";
    }
setInterval("createtime()",250);
</script>
        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>

<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.1.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"viacheung.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="Redis是什么以及优缺点整个数据库加载在内存当中操作，定期通过异步操作把数据库中的数据flush到硬盘上进行保存，每秒10w次读写操作">
<meta property="og:type" content="article">
<meta property="og:title" content="Redis">
<meta property="og:url" content="http://viacheung.github.io/2023/06/04/Redis/index.html">
<meta property="og:site_name" content="命运石之门">
<meta property="og:description" content="Redis是什么以及优缺点整个数据库加载在内存当中操作，定期通过异步操作把数据库中的数据flush到硬盘上进行保存，每秒10w次读写操作">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/viacheung/img/main/image/98987d9417b2bab43087f45fc959d32a-20230309232253633.png">
<meta property="og:image" content="https://raw.githubusercontent.com/viacheung/img/main/image/1545973609449.png">
<meta property="og:image" content="https://raw.githubusercontent.com/viacheung/img/main/image/1545977832954.png">
<meta property="og:image" content="https://raw.githubusercontent.com/viacheung/img/main/image/1545978062568.png">
<meta property="og:image" content="https://raw.githubusercontent.com/viacheung/img/main/image/1735bb5881bbb1d4~tplv-t2oaga2asx-watermark.awebp">
<meta property="og:image" content="https://raw.githubusercontent.com/viacheung/img/main/image/1735bb5881a19fec~tplv-t2oaga2asx-watermark.awebp">
<meta property="og:image" content="https://raw.githubusercontent.com/viacheung/img/main/image/1735bb5881fb4a1b~tplv-t2oaga2asx-watermark.awebp">
<meta property="og:image" content="https://raw.githubusercontent.com/viacheung/img/main/image/1735bb588215b298~tplv-t2oaga2asx-watermark.awebp">
<meta property="og:image" content="https://raw.githubusercontent.com/viacheung/img/main/image/2021013117512340.png">
<meta property="og:image" content="https://raw.githubusercontent.com/viacheung/img/main/image/202105092153018231.png">
<meta property="og:image" content="https://raw.githubusercontent.com/viacheung/img/main/image/202105092153019692.png">
<meta property="og:image" content="https://raw.githubusercontent.com/viacheung/img/main/image/image-20210828175543973.png">
<meta property="og:image" content="https://raw.githubusercontent.com/viacheung/img/main/image/image-20210829103307048.png">
<meta property="article:published_time" content="2023-06-04T06:10:34.000Z">
<meta property="article:modified_time" content="2023-06-04T06:24:25.557Z">
<meta property="article:author" content="ViaCheung">
<meta property="article:tag" content="Java,python">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/viacheung/img/main/image/98987d9417b2bab43087f45fc959d32a-20230309232253633.png">

<link rel="canonical" href="http://viacheung.github.io/2023/06/04/Redis/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Redis | 命运石之门</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">命运石之门</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">欢迎来到我的博客空间🙇</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://viacheung.github.io/2023/06/04/Redis/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="ViaCheung">
      <meta itemprop="description" content="el psy congroo">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="命运石之门">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Redis
        </h1>

        <div class="post-meta">
	  <span class="post-time">

	  
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-06-04 14:10:34 / 修改时间：14:24:25" itemprop="dateCreated datePublished" datetime="2023-06-04T14:10:34+08:00">2023-06-04</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%85%AB%E8%82%A1/" itemprop="url" rel="index"><span itemprop="name">八股</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="Redis是什么以及优缺点"><a href="#Redis是什么以及优缺点" class="headerlink" title="Redis是什么以及优缺点"></a>Redis是什么以及优缺点</h2><p>整个数据库加载在内存当中操作，定期通过异步操作把数据库中的数据flush到硬盘上进行保存，每秒10w次读写操作<span id="more"></span></p>
<p><strong>优点：</strong></p>
<p>读写性能高 Redis能读的速度是110000次&#x2F;s，写的速度是81000次&#x2F;s。</p>
<p>支持数据持久化 AOF RDB</p>
<p>支持事务</p>
<p>数据结构丰富：hash set zset list string</p>
<p>支持主从复制和读写分离 主机会自动将数据同步到从机，可以进行读写分离。</p>
<p>支持发布订阅 pub-sub，通知，key过期等特性</p>
<p><strong>缺点：</strong></p>
<ul>
<li>数据库容量受到物理内存的限制，不能用作海量数据的高性能读写，因此Redis适合的场景主要局限在较小数据量的高性能操作和运算上。</li>
<li>主机宕机，宕机前有部分数据未能及时同步到从机，切换IP后还会引入数据不一致的问题，降低了系统的可用性。</li>
</ul>
<h2 id="Redis为什么快"><a href="#Redis为什么快" class="headerlink" title="Redis为什么快"></a>Redis为什么快</h2><p>1、内存存储：没有磁盘IO的开销 。数据存在内存中，类似于 HashMap，HashMap 的优势就是查找和操作的时间复杂度都是O(1)。</p>
<p>2、单线程：避免了多个线程之间线程切换和锁资源争用的开销。注意：单线程是指的是在核心网络模型中，网络请求模块使用一个线程来处理，即一个线程处理所有网络请求。</p>
<p>3、非阻塞IO：Redis使用多路复用IO技术，将epoll作为I&#x2F;O多路复用技术的实现，再加上Redis自身的事件处理模型将epoll中的连接、读写、关闭都转换为事件，不在网络I&#x2F;O上浪费过多的时间。</p>
<p>4、优化的数据结构，提升性能：Redis有诸多可以直接应用的优化数据结构的实现，应用层可以直接使用原生的数据结构提升性能。</p>
<p>5、使用底层模型不同：Redis直接自己构建了 VM (虚拟内存)机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求。</p>
<p>内存数据库，读写速度快 分布式锁，甚⾄是消息队列。 </p>
<hr>
<p>Redis的VM(虚拟内存)机制就是暂时把不经常访问的数据(冷数据)从内存交换到磁盘中，从而腾出宝贵的内存空间用于其它需要访问的数据(热数据)。通过VM功能可以实现冷热数据分离，使热数据仍在内存中、冷数据保存到磁盘。这样就可以避免因为内存不足而造成访问速度下降的问题。</p>
<p>Redis提高数据库容量的办法有两种：一种是可以将数据分割到多个RedisServer上；另一种是使用虚拟内存把那些不经常访问的数据交换到磁盘上。<strong>需要特别注意的是Redis并没有使用OS提供的Swap，而是自己实现。</strong></p>
<hr>
<h2 id="分布式缓存常⻅的技术选型⽅案有哪些？"><a href="#分布式缓存常⻅的技术选型⽅案有哪些？" class="headerlink" title="分布式缓存常⻅的技术选型⽅案有哪些？"></a>分布式缓存常⻅的技术选型⽅案有哪些？</h2><h2 id="说⼀下-Redis-和-Memcached-的区别和共同点"><a href="#说⼀下-Redis-和-Memcached-的区别和共同点" class="headerlink" title="说⼀下 Redis 和 Memcached 的区别和共同点"></a>说⼀下 Redis 和 Memcached 的区别和共同点</h2><p>共同点 ：基于内存 过期策略 性能</p>
<p>区别 ：</p>
<ol>
<li>数据类型丰富 list set hash zset</li>
<li>数据的持久化 </li>
<li>灾难恢复机制。 把缓存中的数据持久化到磁盘上。</li>
<li>Redis ⽬前是⽀持 cluster 模式</li>
<li>Memcached 多线程，⾮阻塞 IO 复⽤的⽹络模型； Redis 使⽤单线程的多路 IO 复⽤模型。 </li>
<li>Memcached过期数据的删除策略只⽤了惰性删除，⽽ Redis 同时使⽤了惰性删除与定期删除。</li>
</ol>
<h2 id="Redis相比Memcached有哪些优势？"><a href="#Redis相比Memcached有哪些优势？" class="headerlink" title="Redis相比Memcached有哪些优势？"></a><a target="_blank" rel="noopener" href="https://www.javalearn.cn/#/doc/Redis/%E9%9D%A2%E8%AF%95%E9%A2%98?id=_3-redis%E7%9B%B8%E6%AF%94memcached%E6%9C%89%E5%93%AA%E4%BA%9B%E4%BC%98%E5%8A%BF%EF%BC%9F">Redis相比Memcached有哪些优势？</a></h2><ul>
<li>数据类型：Memcached所有的值均是简单的字符串，Redis支持更为丰富的数据类型，支持string(字符串)，list(列表)，Set(集合)、Sorted Set(有序集合)、Hash(哈希)等。</li>
<li>持久化：Redis支持数据落地持久化存储，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用。 memcache不支持数据持久存储 。</li>
<li>集群模式：Redis提供主从同步机制，以及 Cluster集群部署能力，能够提供高可用服务。Memcached没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据</li>
<li>性能对比：Redis的速度比Memcached快很多。</li>
<li>网络IO模型：Redis使用单线程的多路 IO 复用模型，Memcached使用多线程的非阻塞IO模式。</li>
<li>Redis支持服务器端的数据操作：Redis相比Memcached来说，拥有更多的数据结构和并支持更丰富的数据操作，通常在Memcached里，你需要将数据拿到客户端来进行类似的修改再set回去。这大大增加了网络IO的次数和数据体积。在Redis中，这些复杂的操作通常和一般的GET&#x2F;SET一样高效。所以，如果需要缓存能够支持更复杂的结构和操作，那么Redis会是不错的选择。</li>
</ul>
<h2 id="缓存数据的处理流程是怎样的？"><a href="#缓存数据的处理流程是怎样的？" class="headerlink" title="缓存数据的处理流程是怎样的？"></a>缓存数据的处理流程是怎样的？</h2><p>用户请求数据在缓存直接范围，不在，查数据库，数据库在，更新缓存，不在，返回空</p>
<h2 id="为什么要⽤-Redis-x2F-为什么要⽤缓存？"><a href="#为什么要⽤-Redis-x2F-为什么要⽤缓存？" class="headerlink" title="为什么要⽤ Redis&#x2F;为什么要⽤缓存？"></a>为什么要⽤ Redis&#x2F;为什么要⽤缓存？</h2><p><strong>从高并发上来说：</strong></p>
<ul>
<li>直接操作缓存能够承受的请求是远远大于直接访问数据库的，所以我们可以考虑把数据库中的部分数据转移到缓存中去，这样用户的一部分请求会直接到缓存这里而不用经过数据库。缓存能够承受的数据库请求数量是远远⼤于直接访问数据库的，也就提⾼的系统整体的并发。</li>
</ul>
<p><strong>从高性能上来说：</strong></p>
<ul>
<li>用户第一次访问数据库中的某些数据。 因为是从硬盘上读取的所以这个过程会比较慢。将该用户访问的数据存在缓存中，下一次再访问这些数据的时候就可以直接从缓存中获取了。操作缓存就是直接操作内存，所以速度相当快。如果数据库中的对应数据改变的之后，同步改变缓存中相应的数据。</li>
</ul>
<p>总结：</p>
<p>提升⽤户体验以及应对更多的⽤户。——》 ⾼性能”和“⾼并发 </p>
<p>高性能：从硬盘取太慢 从缓存快</p>
<p>⾼并发： MySQL QPS （服务器每秒可以执⾏的查询次数 ）⼤概都在 1w 左右（4 核 8g） ，但是使⽤ Redis 缓存之后单机 10w- 30w， redis 集群的话会更⾼。 </p>
<h2 id="为什么用redis而不是map-x2F-guava做缓存"><a href="#为什么用redis而不是map-x2F-guava做缓存" class="headerlink" title="为什么用redis而不是map&#x2F;guava做缓存"></a>为什么用redis而不是map&#x2F;guava做缓存</h2><p>缓存分为本地缓存和分布式缓存。以java为例，使用自带的map或者guava实现的是<strong>本地缓存</strong>，最主要的特点是轻量以及快速，生命周期随着jvm的销毁而结束，并且在多实例的情况下，每个实例都需要各自保存一份缓存，缓存不具有一致性。</p>
<p>使用Redis或memcached之类的称为<strong>分布式缓存</strong>，在多实例的情况下，<strong>各实例共用一份缓存数据，缓存具有一致性</strong>。缺点是需要保持Redis或memcached服务的高可用，整个程序架构上较为复杂。</p>
<ul>
<li>（缓存容量大）Redis 可以用几十 G 内存来做缓存，Map 不行，一般 JVM 也就分几个 G 数据就够大了；</li>
<li>（持久化）Redis 的缓存可以持久化，Map 是内存对象，程序一重启数据就没了；</li>
<li>（分布式缓存）Redis 可以实现分布式的缓存，Map 只能存在创建它的程序里；</li>
<li>（高并发）Redis 可以处理每秒百万级的并发，是专业的缓存服务，Map 只是一个普通的对象；</li>
<li>（缓存过期+丰富API）Redis 缓存有过期机制，Map 本身无此功能；Redis 有丰富的 API，Map 就简单太多了；</li>
<li>（分布式共享数据）Redis可单独部署，多个项目之间可以共享，本地内存无法共享；</li>
<li>（单独管理工具）Redis有专门的管理工具可以查看缓存数据。</li>
</ul>
<h2 id="Redis-常⻅数据结构以及使⽤场景分析"><a href="#Redis-常⻅数据结构以及使⽤场景分析" class="headerlink" title="Redis 常⻅数据结构以及使⽤场景分析"></a>Redis 常⻅数据结构以及使⽤场景分析</h2><p><strong>1、缓存</strong></p>
<p>缓存现在几乎是所有中大型网站都在用的必杀技，合理的利用缓存不仅能够提升网站访问速度，还能大大降低数据库的压力。Redis提供了键过期功能，也提供了灵活的键淘汰策略，所以，现在Redis用在缓存的场合非常多。</p>
<p><strong>2、排行榜</strong></p>
<p>很多网站都有排行榜应用的，如京东的月度销量榜单、商品按时间的上新排行榜等。Redis提供的有序集合数据类构能实现各种复杂的排行榜应用。</p>
<p><strong>3、计数器</strong></p>
<p>什么是计数器，如电商网站商品的浏览量、视频网站视频的播放数等。为了保证数据实时效，每次浏览都得给+1，并发量高时如果每次都请求数据库操作无疑是种挑战和压力。Redis提供的incr命令来实现计数器功能，内存操作，性能非常好，非常适用于这些计数场景。</p>
<p><strong>4、分布式会话</strong></p>
<p>集群模式下，在应用不多的情况下一般使用容器自带的session复制功能就能满足，当应用增多相对复杂的系统中，一般都会搭建以Redis等内存数据库为中心的session服务，session不再由容器管理，而是由session服务及内存数据库管理。</p>
<p><strong>5、分布式锁</strong></p>
<p>在很多互联网公司中都使用了分布式技术，分布式技术带来的技术挑战是对同一个资源的并发访问，如全局ID、减库存、秒杀等场景，并发量不大的场景可以使用数据库的悲观锁、乐观锁来实现，但在并发量高的场合中，利用数据库锁来控制资源的并发访问是不太理想的，大大影响了数据库的性能。可以利用Redis的setnx功能来编写分布式的锁，如果设置返回1说明获取锁成功，否则获取锁失败，实际应用中要考虑的细节要更多。</p>
<p><strong>6、 社交网络</strong></p>
<p>点赞、踩、关注&#x2F;被关注、共同好友等是社交网站的基本功能，社交网站的访问量通常来说比较大，而且传统的关系数据库类型不适合存储这种类型的数据，Redis提供的哈希、集合等数据结构能很方便的的实现这些功能。如在微博中的共同好友，通过Redis的set能够很方便得出。</p>
<p><strong>7、最新列表</strong></p>
<p>Redis列表结构，LPUSH可以在列表头部插入一个内容ID作为关键字，LTRIM可用来限制列表的数量，这样列表永远为N个ID，无需查询最新的列表，直接根据ID去到对应的内容页即可。</p>
<p><strong>8、消息系统</strong></p>
<p>消息队列是大型网站必用中间件，如ActiveMQ、RabbitMQ、Kafka等流行的消息队列中间件，主要用于业务解耦、流量削峰及异步处理实时性低的业务。Redis提供了发布&#x2F;订阅及阻塞队列功能，能实现一个简单的消息队列系统。另外，这个不能和专业的消息中间件相比。</p>
<p>string:计数器 过期</p>
<p>List:消息队列</p>
<p>incr命令：计数器</p>
<p>hash:存储对象数据 ⽤户信息，商品信息 </p>
<p>set ：获取多个数据源交集和并集 ，共同关注、共同粉丝、共同喜好 </p>
<p>sorted set （zset） ：礼物排⾏榜，弹幕消息 </p>
<h2 id="Redis的数据类型有哪些？"><a href="#Redis的数据类型有哪些？" class="headerlink" title="Redis的数据类型有哪些？"></a>Redis的数据类型有哪些？</h2><p>有五种常用数据类型：String、Hash、Set、List、SortedSet。以及三种特殊的数据类型：Bitmap、HyperLogLog、Geospatial ，其中HyperLogLog、Bitmap的底层都是 String 数据类型，Geospatial 的底层是 Sorted Set 数据类型。</p>
<p><strong>五种常用的数据类型</strong>：</p>
<p>1、String：String是最常用的一种数据类型，普通的<strong>key- value</strong> 存储都可以归为此类。<strong>其中Value既可以是数字也可以是字符串</strong>。使用场景：常规key-value缓存应用。常规计数: 微<strong>博数， 粉丝数。</strong></p>
<p>2、Hash：Hash 是一个键值(key &#x3D;&gt; value)对集合。Redishash 是一个 string 类型的 field 和 value 的映射表，hash 特别适合用于<strong>存储对象</strong>，并且可以像数据库中update一个属性一样只修改某一项属性值。</p>
<p>3、Set：Set是一个无序的天然去重的集合，即Key-Set。此外还提供了<strong>交集、并集</strong>等一系列直接操作集合的方法，对于<strong>求共同好友、共同关注</strong>什么的功能实现特别方便。</p>
<p>4、List：List是一个有序可重复的集合，其遵循<strong>FIFO</strong>的原则，底层是依赖双向链表实现的，因此支持正向、反向双重查找。通过List，我们可以很方面的获得类似于<strong>最新回复</strong>这类的功能实现。</p>
<p>5、SortedSet：类似于java中的TreeSet，是Set的可排序版。此外还支持优先级排序，维护了一个score的参数来实现。适用于<strong>排行榜和带权重的消息队列</strong>等场景。</p>
<p><strong>三种特殊的数据类型</strong>：</p>
<p>1、Bitmap：位图，Bitmap想象成一个以位为单位数组，数组中的每个单元只能存0或者1，数组的下标在Bitmap中叫做偏移量。使用Bitmap实现统计功能，更省空间。<strong>如果只需要统计数据的二值状态，例如商品有没有、用户在不在等</strong>，就可以使用 Bitmap，因为它只用一个 bit 位就能表示 0 或 1。</p>
<p>2、Hyperloglog。HyperLogLog 是一种<strong>用于统计基数的数据集合类型</strong>，HyperLogLog 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定 的、并且是很小的。每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基 数。场景：<strong>统计网页的UV（即Unique Visitor，不重复访客，一个人访问某个网站多次，但是还是只计算为一次）。</strong></p>
<p>要注意，HyperLogLog 的统计规则是基于<strong>概率</strong>完成的，所以它给出的统计结果是有一定误差的，标准误算率是 0.81%。</p>
<p>3、Geospatial ：主要用于存储地理位置信息，并对存储的信息进行操作，适用场景如<strong>朋友的定位、附近的人、打车距离计算等。</strong></p>
<h2 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h2><h3 id="Redis-持久化机制-怎么保证-Redis-挂掉之后再重启数据可以进⾏恢复"><a href="#Redis-持久化机制-怎么保证-Redis-挂掉之后再重启数据可以进⾏恢复" class="headerlink" title="Redis 持久化机制(怎么保证 Redis 挂掉之后再重启数据可以进⾏恢复)"></a>Redis 持久化机制(怎么保证 Redis 挂掉之后再重启数据可以进⾏恢复)</h3><p>为了能够重用Redis数据，或者防止系统故障，我们需要将Redis中的数据写入到磁盘空间中，即持久化。</p>
<h4 id="快照（snapshotting）持久化（RDB）-（默认）"><a href="#快照（snapshotting）持久化（RDB）-（默认）" class="headerlink" title="快照（snapshotting）持久化（RDB） （默认）"></a><strong>快照（snapshotting）持久化（RDB</strong>） <strong>（默认）</strong></h4><p>在<strong>指定的时间间隔内</strong>将内存中的数据集快照写入磁盘(Snapshot)，它恢复时是将快照文件直接读到内存里。</p>
<p><strong>优势</strong>：适合大规模的数据恢复；对数据完整性和一致性要求不高</p>
<p><strong>劣势</strong>：在一定间隔时间做一次备份，所以如果Redis意外down掉的话，就会<strong>丢失最后一次快照后的所有修改</strong>。（Redis 主从结构，主要⽤来提⾼ Redis 性能），还可以将快照留在原地以便重启服务器的时候使⽤ </p>
<h4 id="AOF（append-only-file）持久化"><a href="#AOF（append-only-file）持久化" class="headerlink" title="AOF（append-only file）持久化"></a><strong>AOF（append-only file）持久化</strong></h4><p>每执⾏⼀条会更改 Redis 中的数据的命令， Redis 就会将该命令写⼊硬盘中的 AOF ⽂件。 Redis启动之初会读取该文件重新构建数据</p>
<p>AOF采用文件追加方式，文件会越来越大，为避免出现此种情况，新增了重写机制，当AOF文件的大小超过所设定的阈值时， Redis就会启动AOF文件的内容压缩，只保留可以恢复数据的最小指令集(比如两条数据取最新的那条就行了).。</p>
<p><strong>优势</strong></p>
<ul>
<li>每修改同步：appendfsync always 同步持久化，每次发生数据变更会被立即记录到磁盘，性能较差但数据完整性比较好</li>
<li>每秒同步：appendfsync everysec异步操作，每秒记录，如果一秒内宕机，有数据丢失</li>
<li>不同步：appendfsync no 从不同步</li>
</ul>
<p><strong>具体地:</strong></p>
<ul>
<li><strong>Always</strong>，这个单词的意思是「总是」，所以它的意思是每次写操作命令执行完后，同步将 AOF 日志数据写回硬盘；</li>
<li><strong>Everysec</strong>，这个单词的意思是「每秒」，所以它的意思是每次写操作命令执行完后，先将命令写入到 AOF 文件的内核缓冲区，然后每隔一秒将缓冲区里的内容写回到硬盘；</li>
<li><strong>No</strong>，意味着不由 Redis 控制写回硬盘的时机，转交给操作系统控制写回的时机，也就是每次写操作命令执行完后，先将命令写入到 AOF 文件的内核缓冲区，再由操作系统决定何时将缓冲区内容写回硬盘。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/viacheung/img/main/image/98987d9417b2bab43087f45fc959d32a-20230309232253633.png" alt="img"></p>
<p><strong>劣势</strong></p>
<ul>
<li>相同数据集的数据而言aof文件要远大于rdb文件，恢复速度慢于rdb</li>
<li>aof运行效率要慢于rdb，每秒同步策略效率较好，不同步效率和rdb相同</li>
</ul>
<h3 id="如何选择合适的持久化方式"><a href="#如何选择合适的持久化方式" class="headerlink" title="如何选择合适的持久化方式"></a><a target="_blank" rel="noopener" href="https://www.javalearn.cn/#/doc/Redis/%E9%9D%A2%E8%AF%95%E9%A2%98?id=_9-%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%E5%90%88%E9%80%82%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96%E6%96%B9%E5%BC%8F">如何选择合适的持久化方式</a></h3><ul>
<li>如果是数据不那么敏感，且可以从其他地方重新生成补回的，那么可以关闭持久化。</li>
<li>如果是数据比较重要，不想再从其他地方获取，且可以承受数分钟的数据丢失，比如缓存等，那么可以只使用RDB。</li>
<li>如果是用做内存数据库，要使用Redis的持久化，建议是RDB和AOF都开启，或者定期执行bgsave做快照备份，RDB方式更适合做数据的备份，AOF可以保证数据的不丢失。</li>
</ul>
<h2 id="Redis持久化数据和缓存怎么做扩容？"><a href="#Redis持久化数据和缓存怎么做扩容？" class="headerlink" title="Redis持久化数据和缓存怎么做扩容？"></a>Redis持久化数据和缓存怎么做扩容？</h2><ul>
<li>如果Redis被当做缓存使用，使用一致性哈希实现动态扩容缩容。</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903750860013576">https://juejin.cn/post/6844903750860013576</a></p>
<p>一致性hash算法可以保证当机器增加或者减少时，节点之间的数据迁移只限于两个节点之间，不会造成全局的网络问题。</p>
<ol>
<li>传统hash算法增减服务器会导致大量key重定向到其他服务器</li>
<li>一致性hash算法有一个0-2^31的圆环(哈希值是32位无符号整形）值为Key的数据隶属于顺时针方向第一个服务器</li>
</ol>
<p><img src="https://raw.githubusercontent.com/viacheung/img/main/image/1545973609449.png" alt="img"></p>
<ol>
<li>当宕机和扩展服务器只会影响一部分数据</li>
</ol>
<p><img src="https://raw.githubusercontent.com/viacheung/img/main/image/1545977832954.png" alt="img"></p>
<p><img src="https://raw.githubusercontent.com/viacheung/img/main/image/1545978062568.png" alt="img"></p>
<ol>
<li>如果节点太少,会导致数据倾斜,也就是hash范围差距大 那么可以引入了<strong>虚拟节点机制</strong>，即对每个节点计算多个哈希值，每个计算结果位置都放置在对应节点中，这些节点<strong>称为虚拟节点</strong>。</li>
</ol>
<ul>
<li>如果Redis被当做一个持久化存储使用，必须使用固定的keys-to-nodes映射关系，节点的数量一旦确定不能变化。否则的话(即Redis节点需要动态变化的情况），必须使用可以在运行时进行数据再平衡的一套系统，而当前只有Redis集群可以做到这样。</li>
</ul>
<h2 id="过期键的删除策略、淘汰策略"><a href="#过期键的删除策略、淘汰策略" class="headerlink" title="过期键的删除策略、淘汰策略"></a>过期键的删除策略、淘汰策略</h2><ol>
<li>惰性删除 ：只会在取出key的时候才对数据进⾏过期检查。这样对CPU最友好，但是可能会造成太多过期 key 没有被删除。</li>
<li>定期删除 ： 每隔⼀段时间抽取⼀批 key 执⾏删除过期key操作。并且， Redis 底层会通过限制删除操作执⾏的时⻓和频率来减少删除操作对CPU时间的影响。</li>
</ol>
<p>删除key常见的三种处理方式:</p>
<p><strong>1、定时删除</strong></p>
<p>在设置某个key 的过期时间同时，我们创建一个定时器，让定时器在该过期时间到来时，立即执行对其进行删除的操作。</p>
<p>优点：定时删除对内存是最友好的，能够保存内存的key一旦过期就能立即从内存中删除。</p>
<p>缺点：对CPU最不友好，在过期键比较多的时候，删除过期键会占用一部分 CPU 时间，对服务器的响应时间和吞吐量造成影响。</p>
<p><strong>2、惰性删除</strong></p>
<p>设置该key 过期时间后，我们不去管它，当需要该key时，我们在检查其是否过期，如果过期，我们就删掉它，反之返回该key。(代码层面)</p>
<p>优点：对 CPU友好，我们只会在使用该键时才会进行过期检查，对于很多用不到的key不用浪费时间进行过期检查。</p>
<p>缺点：对内存不友好，如果一个键已经过期，但是一直没有使用，那么该键就会一直存在内存中，如果数据库中有很多这种使用不到的过期键，这些键便永远不会被删除，内存永远不会释放。从而造成内存泄漏。(不用但存在)</p>
<p><strong>3、定期删除</strong></p>
<p>每隔一段时间，我们就对一些key进行检查，删除里面过期的key。</p>
<p>优点：可以通过限制删除操作执行的时长和频率来减少删除操作对 CPU 的影响。另外定期删除，也能有效释放过期键占用的内存。</p>
<p>缺点：难以确定删除操作执行的时长和频率。如果执行的太频繁，定期删除策略变得和定时删除策略一样，对CPU不友好。如果执行的太少，那又和惰性删除一样了，过期键占用的内存不会及时得到释放。</p>
<p>另外最重要的是，在获取某个键时，如果某个键的过期时间已经到了，但是还没执行定期删除，那么就会返回这个键的值，这是业务不能忍受的错误。</p>
<h2 id="Redis-key的过期时间和永久有效分别怎么设置？"><a href="#Redis-key的过期时间和永久有效分别怎么设置？" class="headerlink" title="Redis key的过期时间和永久有效分别怎么设置？"></a><a target="_blank" rel="noopener" href="https://www.javalearn.cn/#/doc/Redis/%E9%9D%A2%E8%AF%95%E9%A2%98?id=_12-redis-key%E7%9A%84%E8%BF%87%E6%9C%9F%E6%97%B6%E9%97%B4%E5%92%8C%E6%B0%B8%E4%B9%85%E6%9C%89%E6%95%88%E5%88%86%E5%88%AB%E6%80%8E%E4%B9%88%E8%AE%BE%E7%BD%AE%EF%BC%9F">Redis key的过期时间和永久有效分别怎么设置？</a></h2><p>通过expire或pexpire命令，客户端可以以秒或毫秒的精度为数据库中的某个键设置生存时间。</p>
<p>与expire和pexpire命令类似，客户端可以通过expireat和pexpireat命令，以秒或毫秒精度给数据库中的某个键设置过期时间，可以理解为：让某个键在某个时间点过期。</p>
<h3 id="Redis-给缓存数据设置过期时间有啥⽤？"><a href="#Redis-给缓存数据设置过期时间有啥⽤？" class="headerlink" title="Redis 给缓存数据设置过期时间有啥⽤？"></a>Redis 给缓存数据设置过期时间有啥⽤？</h3><p>命令：字符串：setex 其他 expire </p>
<p>有助于缓解内存的消耗 </p>
<p>业务场景就是需要某个数据只在某⼀时间段内存在 ⽐如我们的短信验证码可能只在1分钟内有效，⽤户登录的 token 可能只在 1 天内有效。 </p>
<p>如果使⽤传统的数据库来处理的话，⼀般都是⾃⼰判断过期，这样更麻烦并且性能要差很多。 </p>
<h3 id="Redis是如何判断数据是否过期的呢？"><a href="#Redis是如何判断数据是否过期的呢？" class="headerlink" title="Redis是如何判断数据是否过期的呢？"></a>Redis是如何判断数据是否过期的呢？</h3><p>过期字典 (hash表）键指向Redis数据库中的某个key(键)，值是⼀个long long类型的整数(数据库键的过期时间)</p>
<h3 id="Redis-内存淘汰机制了解么？"><a href="#Redis-内存淘汰机制了解么？" class="headerlink" title="Redis 内存淘汰机制了解么？"></a>Redis 内存淘汰机制了解么？</h3><p>仅仅通过给 key 设置过期时间不太够，还是有很多key没删掉，报oom，因此要用内存淘汰机制</p>
<ol>
<li>volatile-lru（least recently used） ：从已设置过期时间的数据 中移除最近最少使⽤数据</li>
<li>allkeys-lru（least recently used） ：在键空间中，移除最近最少使⽤的 key（最常⽤）</li>
<li>volatile-lfu 从已设置过期时间的数据 中移除最不经常使⽤数据</li>
<li>allkeys-lfu（least recently used） ：在键空间中，移除最近最不经常用的 key（最常⽤）</li>
<li>volatile-random：从已设置过期时间的数据任意选择数据淘汰</li>
<li>allkeys-random：从数据集中任意选择数据淘汰</li>
<li>volatile-ttl：从已设置过期时间的数据挑选要过期的数据淘汰</li>
<li>no-eviction：禁止驱逐数据，也就是说当内存不足以容纳新写入数据时，新写入操作会报错。这个应该没人使用吧！</li>
</ol>
<p>内存淘汰策略可以通过配置文件来修改，Redis.conf对应的配置项是maxmemory-policy 修改对应的值就行，默认是noeviction。</p>
<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>Redis事务提供了⼀种将多个命令请求打包的功能。然后，再按顺序执⾏打包的所有命令，并且不会被中途打断。 </p>
<p>Redis 是不⽀持 roll back 的，因⽽不满⾜原⼦性的（⽽且不满⾜持久性）。 </p>
<p><strong>为啥不支持回滚？</strong></p>
<p>更简单便捷并且性能更好。 即使命令执⾏错误也应该在开发过程中就被发现⽽不是⽣产过程中。 </p>
<h2 id="缓存异常"><a href="#缓存异常" class="headerlink" title="缓存异常"></a>缓存异常</h2><p>缓存异常有四种类型，分别是缓存和数据库的数据不一致、缓存雪崩、缓存击穿和缓存穿透。</p>
<hr>
<h3 id="如何保证缓存与数据库双写时的数据一致性？"><a href="#如何保证缓存与数据库双写时的数据一致性？" class="headerlink" title="如何保证缓存与数据库双写时的数据一致性？"></a>如何保证缓存与数据库双写时的数据一致性？</h3><p>背景：使用到缓存，无论是本地内存做缓存还是使用 Redis 做缓存，那么就会存在数据同步的问题，因为配置信息缓存在内存中，而内存时无法感知到数据在数据库的修改。这样就会造成数据库中的数据与缓存中数据不一致的问题。</p>
<p>共有四种方案：</p>
<ol>
<li>先更新数据库，后更新缓存</li>
<li>先更新缓存，后更新数据库</li>
<li>先删除缓存，后更新数据库</li>
<li>先更新数据库，后删除缓存</li>
</ol>
<p>第一种和第二种方案，没有人使用的，因为第一种方案存在问题是：并发更新数据库场景下，会将脏数据刷到缓存。</p>
<p>第二种方案存在的问题是：如果先更新缓存成功，但是数据库更新失败，则肯定会造成数据不一致。</p>
<p>目前主要用第三和第四种方案。</p>
<h3 id="先删除缓存，后更新数据库"><a href="#先删除缓存，后更新数据库" class="headerlink" title="先删除缓存，后更新数据库"></a>先删除缓存，后更新数据库</h3><p>该方案也会出问题，此时来了两个请求，请求 A（更新操作） 和请求 B（查询操作）</p>
<ol>
<li>请求A进行写操作，删除缓存</li>
<li>请求B查询发现缓存不存在</li>
<li>请求B去数据库查询得到旧值(此时)</li>
<li>请求B将旧值写入缓存</li>
<li>请求A将新值写入数据库</li>
</ol>
<p>上述情况就会导致不一致的情形出现。而且，如果不采用给缓存设置过期时间策略，该数据永远都是脏数据。</p>
<h5 id="答案一：延时双删"><a href="#答案一：延时双删" class="headerlink" title="答案一：延时双删"></a>答案一：延时双删</h5><p>（1）先淘汰缓存 </p>
<p>（2）再写数据库（这两步和原来一样） </p>
<p>（3）休眠1秒，再次淘汰缓存，这么做，可以将1秒内所造成的缓存脏数据，再次删除。<strong>确保读请求结束，写请求可以删除读请求造成的缓存脏数据</strong>。自行评估自己的项目的读数据业务逻辑的耗时，<strong>写数据的休眠时间则在读数据业务逻辑的耗时基础上，加几百ms即可。</strong></p>
<p>（我的理解：请求A先删缓存再往DB写数据，就算这时B来查数据库，缓存没数据，然后查DB，此时查到的是旧数据，写到缓存，A等待B写完之和再删缓存，这样就缓存一致）</p>
<p>如果使用的是 Mysql 的<strong>读写分离的架构的话</strong>，那么其实主从同步之间也会有时间差。</p>
<p><img src="https://raw.githubusercontent.com/viacheung/img/main/image/1735bb5881bbb1d4~tplv-t2oaga2asx-watermark.awebp" alt="img"></p>
<p>此时来了两个请求，请求 A（更新操作） 和请求 B（查询操作）</p>
<ol>
<li>请求 A 更新操作，删除了 Redis</li>
<li>请求主库进行更新操作，主库与从库进行同步数据的操作</li>
<li>请 B 查询操作，发现 Redis 中没有数据</li>
<li>去从库中拿去数据</li>
<li>此时同步数据(binlog没写完)还未完成，拿到的数据是旧数据</li>
</ol>
<p>此时的解决办法就是如果是对 Redis 进行填充数据的查询数据库操作，那么就强制将其指向主库进行查询。</p>
<p><img src="https://raw.githubusercontent.com/viacheung/img/main/image/1735bb5881a19fec~tplv-t2oaga2asx-watermark.awebp" alt="img"></p>
<h5 id="答案二：-更新与读取操作进行异步串行化"><a href="#答案二：-更新与读取操作进行异步串行化" class="headerlink" title="答案二： 更新与读取操作进行异步串行化"></a>答案二： 更新与读取操作进行异步串行化</h5><p>采用<strong>更新与读取操作进行异步串行化</strong></p>
<p><strong>异步串行化</strong></p>
<p>我在系统内部维护n个内存队列，更新数据的时候，根据数据的唯一标识，将该操作路由之后，发送到其中一个jvm内部的内存队列中（对同一数据的请求发送到同一个队列）。读取数据的时候，如果发现数据不在缓存中，并且此时队列里有更新库存的操作，那么将重新读取数据+更新缓存的操作，根据唯一标识路由之后，也将发送到同一个jvm内部的内存队列中。然后每个队列对应一个工作线程，每个工作线程串行地拿到对应的操作，然后一条一条的执行。</p>
<p>这样的话，<strong>一个数据变更的操作，先执行删除缓存，然后再去更新数据库，但是还没完成更新的时候，如果此时一个读请求过来，读到了空的缓存，那么可以先将缓存更新的请求发送到队列中，此时会在队列中积压，排在刚才更新库的操作之后，然后同步等待缓存更新完成，再读库。</strong></p>
<p><strong>读操作去重</strong></p>
<p>多个读库更新缓存的请求串在同一个队列中是没意义的，因此可以做过滤，如果发现队列中已经有了该数据的更新缓存的请求了，那么就不用再放进去了，直接等待前面的更新操作请求完成即可，待那个队列对应的工作线程完成了上一个操作（数据库的修改）之后，才会去执行下一个操作（读库更新缓存），此时会从数据库中读取最新的值，然后写入缓存中。</p>
<p>如果请求还在等待时间范围内，不断轮询发现可以取到值了，那么就直接返回；如果请求等待的时间超过一定时长，那么这一次直接从数据库中读取当前的旧值。（返回旧值不是又导致缓存和数据库不一致了么？那至少可以减少这个情况发生，因为等待超时也不是每次都是，几率很小吧。这里我想的是，如果超时了就直接读旧值，这时候仅仅是读库后返回而不放缓存）</p>
<h3 id="先更新数据库，后删除缓存"><a href="#先更新数据库，后删除缓存" class="headerlink" title="先更新数据库，后删除缓存"></a>先更新数据库，后删除缓存</h3><p>这一种情况也会出现问题，比如更新数据库成功了，但是在删除缓存的阶段出错了没有删除成功，那么此时再读取缓存的时候每次都是错误的数据了。</p>
<p><img src="https://raw.githubusercontent.com/viacheung/img/main/image/1735bb5881fb4a1b~tplv-t2oaga2asx-watermark.awebp" alt="img"></p>
<p>此时解决方案就是利用消息队列进行<strong>删除的补偿</strong>。具体的业务逻辑用语言描述如下：</p>
<ol>
<li>请求 A 先对数据库进行更新操作</li>
<li>在对 Redis 进行删除操作的时候发现报错，删除失败</li>
<li>此时将Redis 的 key 作为消息体发送到消息队列中</li>
<li>系统接收到消息队列发送的消息后再次对 Redis 进行删除操作</li>
</ol>
<p>但是这个方案会有一个缺点就是会对业务代码造成大量的侵入，深深的耦合在一起，所以这时会有一个优化的方案，我们知道对 Mysql 数据库更新操作后在binlog 日志中我们都能够找到相应的操作，那么我们可以订阅 Mysql 数据库的 binlog 日志对缓存进行操作。</p>
<p><img src="https://raw.githubusercontent.com/viacheung/img/main/image/1735bb588215b298~tplv-t2oaga2asx-watermark.awebp" alt="img"></p>
<h3 id="什么是缓存击穿"><a href="#什么是缓存击穿" class="headerlink" title="什么是缓存击穿?"></a>什么是缓存击穿?</h3><p>(热点key失效)</p>
<p>缓存击穿跟缓存雪崩有点类似，缓存雪崩是大规模的key失效，而缓存击穿是某个热点的key失效(及你太美)，大并发集中对其进行请求，就会造成大量请求读缓存没读到数据，从而导致高并发访问数据库，引起数据库压力剧增。这种现象就叫做缓存击穿。</p>
<p>从两个方面解决，第一是否可以考虑热点key不设置过期时间，第二是否可以考虑降低打在数据库上的请求数量。</p>
<p>解决方案：</p>
<ul>
<li><p>在缓存失效后，通过互斥锁或者队列来控制读数据写缓存的线程数量&#x3D;&#x3D;，比如某个key只允许一个线程查询数据和写缓存，其他线程等待。这种方式会阻塞其他的线程，此时系统的吞吐量会下降</p>
</li>
<li><p>热点数据缓存永远不过期。永不过期实际包含两层意思：</p>
</li>
<li><ul>
<li>物理不过期，针对热点key不设置过期时间</li>
<li>逻辑过期，把过期时间存在key对应的value里，如果发现要过期了，通过一个后台的异步线程进行缓存的构建</li>
</ul>
</li>
</ul>
<h3 id="什么是缓存穿透"><a href="#什么是缓存穿透" class="headerlink" title="什么是缓存穿透?"></a>什么是缓存穿透?</h3><p>(缓存数据库都无)</p>
<p>缓存穿透是指用户请求的数据在缓存中不存在即没有命中，同时在数据库中也不存在，导致用户每次请求该数据都要去数据库中查询一遍。如果有恶意攻击者不断请求系统中不存在的数据，会导致短时间大量请求落在数据库上，造成数据库压力过大，甚至导致数据库承受不住而宕机崩溃。</p>
<p>缓存穿透的关键在于在Redis中查不到key值，它和缓存击穿的根本区别在于传进来的key在Redis中是不存在的。假如有黑客传进大量的不存在的key，那么大量的请求打在数据库上是很致命的问题，所以在日常开发中要对参数做好校验，一些非法的参数，不可能存在的key就直接返回错误提示。</p>
<p><img src="https://raw.githubusercontent.com/viacheung/img/main/image/2021013117512340.png" alt="img"></p>
<p>解决方法：</p>
<ul>
<li>将无效的key存放进Redis中：</li>
</ul>
<p>当出现Redis查不到数据，数据库也查不到数据的情况，我们就把这个key保存到Redis中，设置value&#x3D;”null”，并设置其过期时间极短，后面再出现查询这个key的请求的时候，直接返回null，就不需要再查询数据库了。但这种处理方式是有问题的，假如传进来的这个不存在的Key值每次都是随机的，那存进Redis也没有意义。</p>
<ul>
<li>使用布隆过滤器：</li>
</ul>
<p>(准确度换空间?)</p>
<p>如果布隆过滤器判定某个 key 不存在布隆过滤器中，那么就一定不存在，如果判定某个 key 存在，那么很大可能是存在(存在一定的误判率)。于是我们可以在缓存之前再加一个布隆过滤器，将数据库中的所有key都存储在布隆过滤器中，在查询Redis前先去布隆过滤器查询 key 是否存在，如果不存在就直接返回请求参数错误信息给客户端，不让其访问数据库，从而避免了对底层存储系统的查询压力。</p>
<p>如何选择：针对一些恶意攻击，攻击带过来的大量key是随机，那么我们采用第一种方案就会缓存大量不存在key的数据。那么这种方案就不合适了，我们可以先对使用布隆过滤器方案进行过滤掉这些key。所以，针对这种key异常多、请求重复率比较低的数据，优先使用第二种方案直接过滤掉。而对于空数据的key有限的，重复率比较高的，则可优先采用第一种方式进行缓存。</p>
<h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a><strong>缓存雪崩</strong></h3><p>(大规模的key失效)</p>
<p>如果缓在某一个时刻出现<strong>大规模的key失效，</strong>那么就会导致大量的请求打在了数据库上面，导致数据库压力巨大，如果在高并发的情况下，可能瞬间就会导致数据库宕机。这时候<strong>如果运维马上又重启数据库，马上又会有新的流量把数据库打死</strong>。这就是缓存雪崩。</p>
<p>造成缓存雪崩的关键在于同一时间的大规模的key失效，主要有两种可能：</p>
<ul>
<li>第一种是Redis宕机</li>
<li>第二种可能就是采用了相同的过期时间。</li>
</ul>
<p>例子：秒杀开始 12 个⼩时之前，我们统⼀存放了⼀批商品到 Redis 中，设置的缓存过期时间也是 12 个⼩时，那么秒杀开始的时候，这些秒杀的商品的访问直接就失效了。导致的情况就是，相应的请求直接就落到了数据库上，就像雪崩⼀样可怕。 </p>
<h3 id="有哪些解决办法？"><a href="#有哪些解决办法？" class="headerlink" title="有哪些解决办法？"></a>有哪些解决办法？</h3><p>解决方案：</p>
<p>1、事前：</p>
<ul>
<li><p>均匀过期：设置不同的过期时间，让缓存失效的时间尽量均匀，避免相同的过期时间导致缓存雪崩，造成大量数据库的访问。如把每个Key的失效时间都加个随机值，setRedis（Key，value，time + Math.random() * 10000）；，保证数据不会在同一时间大面积失效。</p>
</li>
<li><p>分级缓存：第一级缓存失效的基础上，访问二级缓存，每一级缓存的失效时间都不同。</p>
</li>
<li><p>热点数据缓存永远不过期。永不过期实际包含两层意思：</p>
</li>
<li><ul>
<li>物理不过期，针对热点key不设置过期时间</li>
<li>逻辑过期，把过期时间存在key对应的value里，如果发现要过期了，通过一个后台的异步线程进行缓存的构建(定时任务)</li>
</ul>
</li>
<li><p>保证Redis缓存的高可用，防止Redis宕机导致缓存雪崩的问题。可以使用 主从+ 哨兵，Redis集群来避免 Redis 全盘崩溃的情况。</p>
</li>
</ul>
<p>2、事中：</p>
<ul>
<li>互斥锁：在缓存失效后，通过互斥锁或者队列来控制读数据写缓存的线程数量，比如某个key只允许一个线程查询数据和写缓存，其他线程等待。这种方式会阻塞其他的线程，此时系统的吞吐量会下降</li>
<li>使用熔断机制，限流降级。当流量达到一定的阈值，直接返回“系统拥挤”之类的提示，<strong>防止过多的请求打在数据库上将数据库击垮，至少能保证一部分用户是可以正常使用，其他用户多刷新几次也能得到结果。</strong></li>
</ul>
<p>3、事后：</p>
<p>开启Redis持久化机制，尽快恢复缓存数据，一旦重启，就能从磁盘上自动加载数据恢复内存中的数据。 </p>
<h3 id="什么是缓存预热"><a href="#什么是缓存预热" class="headerlink" title="什么是缓存预热?"></a>什么是缓存预热?</h3><p>缓存预热是指系统上线后，提前将相关的缓存数据加载到缓存系统。避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题，用户直接查询事先被预热的缓存数据。</p>
<p>如果不进行预热，那么Redis初始状态数据为空，系统上线初期，对于高并发的流量，都会访问到数据库中， 对数据库造成流量的压力。</p>
<p>缓存预热解决方案：</p>
<ul>
<li>数据量不大的时候，工程启动的时候进行加载缓存动作；</li>
<li>数据量大的时候，设置一个定时任务脚本，进行缓存的刷新；(防止启动太慢)</li>
<li>数据量太大的时候，优先保证热点数据进行提前加载到缓存。</li>
</ul>
<h3 id="什么是缓存降级？"><a href="#什么是缓存降级？" class="headerlink" title="什么是缓存降级？"></a>什么是缓存降级？</h3><p>缓存降级是指缓存失效或缓存服务器挂掉的情况下，不去访问数据库，直接返回默认数据或访问服务的内存数据。降级一般是有损的操作，所以尽量减少降级对于业务的影响程度。</p>
<p>在进行降级之前要对系统进行梳理，看看系统是不是可以丢卒保帅；从而梳理出哪些必须誓死保护，哪些可降级；比如可以参考日志级别设置预案：</p>
<ul>
<li>一般：比如有些服务偶尔因为网络抖动或者服务正在上线而超时，可以自动降级；</li>
<li>警告：有些服务在一段时间内成功率有波动（如在95~100%之间），可以自动降级或人工降级，并发送告警；</li>
<li>错误：比如可用率低于90%，或者数据库连接池被打爆了，或者访问量突然猛增到系统能承受的最大阀值，此时可以根据情况自动降级或者人工降级；</li>
<li>严重错误：比如因为特殊原因数据错误了，此时需要紧急人工降级。</li>
</ul>
<h2 id="如何保证缓存和数据库数据的⼀致性？"><a href="#如何保证缓存和数据库数据的⼀致性？" class="headerlink" title="如何保证缓存和数据库数据的⼀致性？"></a>如何保证缓存和数据库数据的⼀致性？</h2><p>缓存失效时间变短（不推荐，治标不治本）：我们让缓存数据的过期时间变短，这样的话缓存就会从数据库中加载数据。另外，这种解决办法对于先操作缓存后操作数据库的场景不适⽤ </p>
<p>增加cache更新重试机制（常⽤） ： 如果 cache 服务当前不可⽤导致缓存删除失败的话，我们就隔⼀段时间进⾏重试，重试次数可以⾃⼰定。如果多次重试还是失败的话，我们可以把当前更新失败的 key 存⼊队列中，等缓存服务可⽤之后，再将 缓存中对应的 key 删除即可 </p>
<h2 id="线程模型"><a href="#线程模型" class="headerlink" title="线程模型"></a>线程模型</h2><h3 id="Redis为何选择单线程？"><a href="#Redis为何选择单线程？" class="headerlink" title="Redis为何选择单线程？"></a>Redis为何选择单线程？</h3><p>在<strong>Redis 6.0以前，Redis的核心网络模型选择用单线程</strong>来实现。先来看下官方的回答：</p>
<p>核心意思就是，对于一个 DB 来说，CPU 通常不会是瓶颈，因为大多数请求不会是 CPU 密集型的，而是 I&#x2F;O 密集型。具体到 Redis的话，如果不考虑 RDB&#x2F;AOF 等持久化方案，Redis是完全的纯内存操作，执行速度是非常快的，因此这部分操作通常不会是性能瓶颈，Redis真正的性能瓶颈在于网络 I&#x2F;O，也就是客户端和服务端之间的网络传输延迟，因此 Redis选择了单线程的 I&#x2F;O 多路复用来实现它的核心网络模型。</p>
<p>实际上更加具体的选择单线程的原因如下：</p>
<ul>
<li>避免过多的<strong>上下文切换开销</strong>：如果是单线程则可以规避进程内频繁的线程切换开销，因为程序始终运行在进程中单个线程内，没有多线程切换的场景。</li>
<li><strong>避免同步机制的开销</strong>：如果 Redis选择多线程模型，又因为 Redis是一个数据库，那么势必涉及到底层数据同步的问题，则必然会引入某些同步机制，比如锁，而我们知道 Redis不仅仅提供了简单的 key-value 数据结构，还有 list、set 和 hash 等等其他丰富的数据结构，而<strong>不同的数据结构对同步访问的加锁粒度又不尽相同</strong>，可能会导致在操作数据过程中带来很多<strong>加锁解锁的开销</strong>，增加程序复杂度的同时还会降低性能。</li>
<li>简单可维护：如果 Redis使用多线程模式，<strong>那么所有的底层数据结构都必须实现成线程安全的</strong>，这无疑又使得 Redis的实现变得更加复杂。</li>
</ul>
<p>总而言之，Redis选择单线程可以说是<strong>多方博弈</strong>之后的一种权衡：在保证足够的性能表现之下，使用单线程保持代码的简单和可维护性。</p>
<h3 id="Redis真的是单线程？"><a href="#Redis真的是单线程？" class="headerlink" title="Redis真的是单线程？"></a>Redis真的是单线程？</h3><p>讨论 这个问题前，先看下 Redis的版本中两个重要的节点：</p>
<ol>
<li>Redisv4.0（引入多线程处理异步任务）</li>
<li>Redis 6.0（在网络模型中实现多线程 I&#x2F;O ）</li>
</ol>
<p>所以，网络上说的Redis是单线程，通常是指在Redis 6.0之前，其核心网络模型使用的是单线程。</p>
<p>且Redis6.0引入<strong>多线程I&#x2F;O</strong>，只是用来<strong>处理网络数据的读写和协议的解析</strong>，而<strong>执行命令依旧是单线程</strong>。</p>
<p>Redis在 v4.0 版本的时候就已经引入了的多线程来做一些异步操作，此举主要针对的是那些非常耗时的命令，通过将这些命令的执行进行异步化，避免阻塞单线程的事件循环。</p>
<p>在 Redisv4.0 之后增加了一些的非阻塞命令如 UNLINK、FLUSHALL ASYNC、FLUSHDB ASYNC。</p>
<h3 id="Redis-6-0为何引入多线程？"><a href="#Redis-6-0为何引入多线程？" class="headerlink" title="Redis 6.0为何引入多线程？"></a>Redis 6.0为何引入多线程？</h3><p>很简单，就是 Redis的网络 I&#x2F;O 瓶颈已经越来越明显了。</p>
<p>随着互联网的飞速发展，互联网业务系统所要处理的线上流量越来越大，Redis的单线程模式会导致系统消耗很多 CPU 时间在网络 I&#x2F;O 上从而降低吞吐量，要提升 Redis的性能有两个方向：</p>
<ul>
<li>优化网络 I&#x2F;O 模块</li>
<li>提高机器内存读写的速度</li>
</ul>
<p>后者依赖于硬件的发展，暂时无解。所以只能从前者下手，网络 I&#x2F;O 的优化又可以分为两个方向：</p>
<ul>
<li>零拷贝技术或者 DPDK 技术</li>
<li>利用多核优势</li>
</ul>
<p>零拷贝技术有其局限性，无法完全适配 Redis这一类复杂的网络 I&#x2F;O 场景，更多网络 I&#x2F;O 对 CPU 时间的消耗和 Linux 零拷贝技术。而 DPDK 技术通过旁路网卡 I&#x2F;O 绕过内核协议栈的方式又太过于复杂以及需要内核甚至是硬件的支持。</p>
<p>总结起来，Redis支持多线程主要就是两个原因：</p>
<ul>
<li><strong>可以充分利用服务器 CPU 资源，目前主线程只能利用一个核</strong></li>
<li><strong>多线程任务可以****分摊 Redis 同步 IO 读写负荷</strong></li>
</ul>
<h3 id="Redis-6-0-采用多线程后，性能的提升效果如何？"><a href="#Redis-6-0-采用多线程后，性能的提升效果如何？" class="headerlink" title="Redis 6.0 采用多线程后，性能的提升效果如何？"></a>Redis 6.0 采用多线程后，性能的提升效果如何？</h3><p>Redis 作者 antirez 在 RedisConf 2019 分享时曾提到：Redis 6 引入的多线程 IO 特性对性能提升至少是<strong>一倍以上</strong>。</p>
<p>国内也有大牛曾使用 unstable 版本在阿里云 esc 进行过测试，GET&#x2F;SET 命令在 4 线程 IO 时性能相比单线程是几乎是翻倍了。</p>
<h3 id="介绍下Redis的线程模型"><a href="#介绍下Redis的线程模型" class="headerlink" title="介绍下Redis的线程模型"></a>介绍下Redis的线程模型</h3><p>Redis的线程模型包括Redis 6.0之前和Redis 6.0。</p>
<p>下面介绍的是Redis 6.0之前。</p>
<p>Redis 是基于 <strong>reactor</strong> 模式开发了网络事件处理器，这个处理器叫做文件事件处理器（file event handler）。由于这个文件事件处理器是单线程的，所以 Redis 才叫做单线程的模型。采用 IO 多路复用机制同时监听多个 Socket，根据 socket 上的事件来选择对应的事件处理器来处理这个事件。</p>
<p>IO多路复用是 IO 模型的一种，有时也称为异步阻塞 IO，是基于经典的 Reactor 设计模式设计的。多路指的是多个 Socket 连接，复用指的是复用一个线程。多路复用主要有三种技术：Select，Poll，Epoll。</p>
<p>Epoll 是最新的也是目前最好的多路复用技术。</p>
<p>模型如下图：</p>
<p><img src="https://raw.githubusercontent.com/viacheung/img/main/image/202105092153018231.png" alt="img"></p>
<p>文件事件处理器的结构包含了四个部分：</p>
<ul>
<li><p>多个 Socket。Socket 会产生 AE_READABLE(读) 和 AE_WRITABLE (写)事件：</p>
</li>
<li><ul>
<li>当 socket 变得可读时或者有新的可以应答的 socket 出现时，socket 就会产生一个 AE_READABLE 事件</li>
<li>当 socket 变得可写时，socket 就会产生一个 AE_WRITABLE(可写) 事件。</li>
</ul>
</li>
<li><p>IO 多路复用程序</p>
</li>
<li><p>文件事件分派器</p>
</li>
<li><p>事件处理器。事件处理器包括：连接应答处理器、命令请求处理器、命令回复处理器，每个处理器对应不同的 socket 事件：</p>
</li>
<li><ul>
<li>如果是客户端要连接 Redis，那么会为 socket 关联连接<strong>应答处理器</strong></li>
<li>如果是客户端要写数据到 Redis（读、写请求命令），那么会为 socket 关联<strong>命令请求处理器</strong></li>
<li>如果是客户端要从 Redis 读数据，那么会为 socket 关联<strong>命令回复处理器</strong></li>
</ul>
</li>
</ul>
<p>多个 socket 会产生不同的事件，不同的事件对应着不同的操作，IO 多路复用程序监听着这些 Socket，当这些 Socket 产生了事件，IO 多路复用程序会将这些事件放到一个<strong>队列</strong>中，通过这个队列，以有序、同步、每次一个事件的方式向文件时间分派器中传送。当事件处理器处理完一个事件后，IO 多路复用程序才会继续向文件分派器传送下一个事件。</p>
<p>下图是客户端与 Redis 通信的一次完整的流程：</p>
<p><img src="https://raw.githubusercontent.com/viacheung/img/main/image/202105092153019692.png" alt="img"></p>
<ol>
<li>Redis 启动初始化的时候，Redis 会将连接应答处理器与 AE_READABLE 事件关联起来。</li>
<li>如果一个客户端跟 Redis 发起连接，此时 Redis 会产生一个 AE_READABLE 事件，由于开始之初 AE_READABLE 是与连接应答处理器关联，所以由连接应答处理器来处理该事件，这时连接应答处理器会与客户端建立连接，<strong>创建客户端响应的 socket</strong>，<strong>同时将这个 socket 的 AE_READABLE 事件与命令请求处理器关联起来。</strong></li>
<li>如果这个时间客户端向 Redis 发送一个命令（set k1 v1），这时 socket 会产生一个 AE_READABLE 事件，IO 多路复用程序会将该事件压入队列中，此时事件分派器从队列中取得该事件，由于该 socket 的 AE_READABLE 事件已经和命令请求处理器关联了，因此事件分派器会将该事件交给命令请求处理器处理，命令请求处理器读取事件中的命令并完成。<strong>操作完成后，Redis 会将该 socket 的 AE_WRITABLE 事件与命令回复处理器关联。</strong></li>
<li>如果客户端已经准备好接受数据后，Redis 中的该 socket 会产生一个 AE_WRITABLE 事件，同样会压入队列然后被事件派发器取出交给相对应的命令回复处理器，由该命令回复处理器将准备好的响应数据写入 socket 中，供客户端读取。</li>
<li>命令回复处理器写完后，就会删除该 socket 的 AE_WRITABLE 事件与命令回复处理器的关联关系。</li>
</ol>
<h3 id="Redis-6-0-多线程的实现机制？"><a href="#Redis-6-0-多线程的实现机制？" class="headerlink" title="Redis 6.0 多线程的实现机制？"></a>Redis 6.0 多线程的实现机制？</h3><p><strong>流程简述如下</strong>：</p>
<ul>
<li>主线程负责接收建立连接请求，获取 Socket 放入全局等待读处理队列。</li>
<li>主线程处理完读事件之后，通过 RR（Round Robin）将这些连接分配给这些 IO 线程。</li>
<li>主线程阻塞等待 IO 线程读取 Socket 完毕。</li>
<li>主线程通过单线程的方式执行请求命令，请求数据读取并解析完成，但并不执行。</li>
<li>主线程阻塞等待 IO 线程将数据回写 Socket 完毕。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/viacheung/img/main/image/image-20210828175543973.png" alt="img"></p>
<h3 id="Redis-6-0开启多线程后，是否会存在线程并发安全问题？"><a href="#Redis-6-0开启多线程后，是否会存在线程并发安全问题？" class="headerlink" title="Redis 6.0开启多线程后，是否会存在线程并发安全问题？"></a>Redis 6.0开启多线程后，是否会存在线程并发安全问题？</h3><p>从实现机制可以看出，Redis 的多线程部分只是用来处理网络数据的读写和协议解析，执行命令仍然是单线程顺序执行。</p>
<p>所以我们不需要去考虑控制 Key、Lua、事务，LPUSH&#x2F;LPOP 等等的并发及线程安全问题。</p>
<h3 id="Redis-6-0-与-Memcached-多线程模型的对比"><a href="#Redis-6-0-与-Memcached-多线程模型的对比" class="headerlink" title="Redis 6.0 与 Memcached 多线程模型的对比"></a>Redis 6.0 与 Memcached 多线程模型的对比</h3><ul>
<li><strong>相同点：</strong>都采用了 Master 线程 -Worker 线程的模型。</li>
<li><strong>不同点</strong>：Memcached 执行主逻辑也是在 Worker 线程里，模型更加简单，实现了真正的线程隔离，符合我们对线程隔离的常规理解。而 Redis 把处理逻辑交还给 Master 线程，虽然一定程度上增加了模型复杂度，但也解决了线程并发安全等问题。</li>
</ul>
<h3 id="Redis-单线程模型详解"><a href="#Redis-单线程模型详解" class="headerlink" title="Redis 单线程模型详解"></a>Redis 单线程模型详解</h3><p>单线程如何监听来⾃客户端的⼤量连接？</p>
<p>答：Redis 通过IO 多路复⽤程序 来监听来⾃客户端的⼤量连接 </p>
<p>好处：I&#x2F;O 多路复⽤技术的使⽤让 Redis 不需要额外创建多余的线程来监听客户端的⼤量连接，降低了资源的消耗</p>
<h3 id="Redis-没有使⽤多线程？为什么不使⽤多线程？"><a href="#Redis-没有使⽤多线程？为什么不使⽤多线程？" class="headerlink" title="Redis 没有使⽤多线程？为什么不使⽤多线程？"></a>Redis 没有使⽤多线程？为什么不使⽤多线程？</h3><ol>
<li>编程容易 容易维护；</li>
<li>Redis 的性能瓶颈不在 CPU ，主要在内存和⽹络，没必要多线程；</li>
<li>多线程就会存在死锁、线程上下⽂切换等问题，甚⾄会影响性能。</li>
</ol>
<h3 id="Redis6-0-之后为何引⼊了多线程"><a href="#Redis6-0-之后为何引⼊了多线程" class="headerlink" title="Redis6.0 之后为何引⼊了多线程"></a>Redis6.0 之后为何引⼊了多线程</h3><p>为了提⾼⽹络 IO 读写性能 但也只是在⽹络数据的读写这类耗时操作上使⽤了， 执⾏命令仍然是单线程顺序执⾏ </p>
<p>默认禁用，修改 redis 配置⽂件 redis.conf 开启</p>
<h2 id="事务-1"><a href="#事务-1" class="headerlink" title="事务"></a>事务</h2><h3 id="Redis事务的概念"><a href="#Redis事务的概念" class="headerlink" title="Redis事务的概念"></a>Redis事务的概念</h3><p>Redis的事务并不是我们传统意义上理解的事务，我们都知道 单个 Redis 命令的执行是原子性的，但 Redis 没有在事务上增加任何维持原子性的机制，所以 Redis <strong>事务的执行并不是原子性的</strong>。</p>
<p>事务可以理解为一个<strong>打包的批量执行脚本</strong>，但<strong>批量指令并非原子化</strong>的操作，<strong>中间某条指令的失败不会导致前面已做指令的回滚，也不会造成后续的指令不做。</strong>(没回滚)</p>
<p><strong>总结：</strong></p>
<ol>
<li>Redis事务中如果有某一条命令执行失败，之前的命令不会回滚，其后的命令仍然会被继续执行。<strong>鉴于这个原因，所以说Redis的事务严格意义上来说是不具备原子性的</strong>。</li>
<li>Redis事务中所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。</li>
<li>在事务开启之前，如果客户端与服务器之间出现通讯故障并导致网络断开，其后所有待执行的语句都将不会被服务器执行。<strong>然而如果网络中断事件是发生在客户端执行EXEC命令之后，那么该事务中的所有命令都会被服务器执行。</strong></li>
</ol>
<p>当使用Append-Only模式时，Redis会通过调用系统函数write将该事务内的所有写操作在本次调用中全部写入磁盘。然而如果在写入的过程中出现系统崩溃，如电源故障导致的宕机，那么此时也许只有部分数据被写入到磁盘，而另外一部分数据却已经丢失。Redis服务器会在重新启动时执行一系列必要的一致性检测，一旦发现类似问题，就会立即退出并给出相应的错误提示。此时，我们就要充分利用Redis工具包中提供的Redis-check-aof工具，<strong>该工具可以帮助我们定位到数据不一致的错误，并将已经写入的部分数据进行回滚。</strong>修复之后我们就可以再次重新启动Redis服务器了。</p>
<h3 id="Redis事务的三个阶段"><a href="#Redis事务的三个阶段" class="headerlink" title="Redis事务的三个阶段"></a>Redis事务的三个阶段</h3><ol>
<li>multi 开启事务</li>
<li>大量指令入队</li>
<li>exec执行事务块内命令，<strong>截止此处一个事务已经结束。</strong></li>
<li>discard 取消事务</li>
<li>watch 监视一个或多个key，如果事务执行前key被改动，事务将打断。unwatch 取消监视。</li>
</ol>
<p>事务执行过程中，如果服务端收到有EXEC、DISCARD、WATCH、MULTI之外的请求，将会把请求放入队列中排队.</p>
<h3 id="Redis事务相关命令"><a href="#Redis事务相关命令" class="headerlink" title="Redis事务相关命令"></a>Redis事务相关命令</h3><p>Redis事务功能是通过MULTI、EXEC、DISCARD和WATCH 四个原语实现的</p>
<ul>
<li>WATCH 命令是一个乐观锁，可以为 Redis 事务提供 check-and-set （CAS）行为。 可以监控一个或多个键，一旦其中有一个键被修改（或删除），之后的事务就不会执行，监控一直持续到EXEC命令。</li>
<li>MULTI命令用于开启一个事务，它总是返回OK。 MULTI执行之后，客户端可以继续向服务器发送任意多条命令，这些命令不会立即被执行，而是被放到一个队列中，当EXEC命令被调用时，所有队列中的命令才会被执行。</li>
<li>EXEC：执行所有事务块内的命令。返回事务块内所有命令的返回值，按命令执行的先后顺序排列。 当操作被打断时，返回空值 nil 。 通过调用DISCARD，客户端可以清空事务队列，并放弃执行事务， 并且客户端会从事务状态中退出。</li>
<li>UNWATCH命令可以取消watch对所有key的监控。</li>
</ul>
<h3 id="Redis事务支持隔离性吗"><a href="#Redis事务支持隔离性吗" class="headerlink" title="Redis事务支持隔离性吗?"></a>Redis事务支持隔离性吗?</h3><p>Redis 是单进程程序，并且它保证在执行事-务时，不会对事务进行中断，事务可以运行直到执行完所有事务队列中的命令为止。因此，<strong>Redis 的事务是总是带有隔离性的</strong>。</p>
<h3 id="Redis为什么不支持事务回滚？"><a href="#Redis为什么不支持事务回滚？" class="headerlink" title="Redis为什么不支持事务回滚？"></a><a target="_blank" rel="noopener" href="https://www.javalearn.cn/#/doc/Redis/%E9%9D%A2%E8%AF%95%E9%A2%98?id=_34-redis%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E6%94%AF%E6%8C%81%E4%BA%8B%E5%8A%A1%E5%9B%9E%E6%BB%9A%EF%BC%9F">Redis为什么不支持事务回滚？</a></h3><ul>
<li>Redis 命令只会因为错误的语法而失败，或是命令用在了错误类型的键上面，这些问题不能在入队时发现，这也就是说，从实用性的角度来说，失败的命令是由编程错误造成的，而这些错误应该在开发的过程中被发现，而不应该出现在生产环境中.</li>
<li>因为不需要对回滚进行支持，所以 Redis 的内部可以保持简单且快速。</li>
</ul>
<h3 id="Redis事务其他实现"><a href="#Redis事务其他实现" class="headerlink" title="Redis事务其他实现(?)"></a><a target="_blank" rel="noopener" href="https://www.javalearn.cn/#/doc/Redis/%E9%9D%A2%E8%AF%95%E9%A2%98?id=_35-redis%E4%BA%8B%E5%8A%A1%E5%85%B6%E4%BB%96%E5%AE%9E%E7%8E%B0">Redis事务其他实现</a>(?)</h3><ul>
<li>基于Lua脚本，Redis可以保证脚本内的命令一次性、按顺序地执行， 其同时也不提供事务运行错误的回滚，执行过程中如果部分命令运行错误，剩下的命令还是会继续运行完。</li>
<li>基于中间标记变量，通过另外的标记变量来标识事务是否执行完成，读取数据时先读取该标记变量判断是否事务执行完成。但这样会需要额外写代码实现，比较繁琐。</li>
</ul>
<h2 id="主从、哨兵、集群"><a href="#主从、哨兵、集群" class="headerlink" title="主从、哨兵、集群"></a>主从、哨兵、集群</h2><h3 id="36-Redis常见使用方式有哪些？"><a href="#36-Redis常见使用方式有哪些？" class="headerlink" title="36. Redis常见使用方式有哪些？"></a><a target="_blank" rel="noopener" href="https://www.javalearn.cn/#/doc/Redis/%E9%9D%A2%E8%AF%95%E9%A2%98?id=_36-redis%E5%B8%B8%E8%A7%81%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F">36. Redis常见使用方式有哪些？</a></h3><p>Redis的几种常见使用方式包括：</p>
<ul>
<li>Redis单副本；</li>
<li>Redis多副本（主从）；</li>
<li>Redis Sentinel（哨兵）；</li>
<li>Redis Cluster；</li>
<li>Redis自研。</li>
</ul>
<p>使用场景：</p>
<p>如果数据量很少，主要是承载高并发高性能的场景，比如缓存一般就几个G的话，单机足够了。</p>
<p>主从模式：master 节点挂掉后，需要<strong>手动</strong>指定新的 master，可用性不高，基本不用。</p>
<p>哨兵模式：master 节点挂掉后，哨兵进程会主动选举新的 master，可用性高，但是每个节点存储的数据是一样的，浪费内存空间。数据量不是很多，集群规模不是很大，需要自动容错容灾的时候使用。</p>
<p>Redis cluster 主要是针对海量数据+高并发+高可用的场景，如果是海量数据，如果你的数据量很大，那么建议就用Redis cluster，所有master的容量总和就是Redis cluster可缓存的数据容量。</p>
<h3 id="介绍下Redis单副本"><a href="#介绍下Redis单副本" class="headerlink" title="介绍下Redis单副本"></a>介绍下Redis单副本</h3><p>Redis单副本，采用单个Redis节点部署架构，没有备用节点实时同步数据，不提供数据持久化和备份策略，适用于数据可靠性要求不高的纯缓存业务场景。</p>
<p><img src="https://raw.githubusercontent.com/viacheung/img/main/image/image-20210829103307048.png" alt="img"></p>
<p><strong>优点：</strong></p>
<ul>
<li>架构简单，部署方便；</li>
<li>高性价比：缓存使用时无需备用节点（单实例可用性可以用supervisor或crontab保证），当然为了满足业务的高可用性，也可以牺牲一个备用节点，但同时刻只有一个实例对外提供服务；</li>
<li>高性能。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>不保证数据的可靠性；</li>
<li>在缓存使用，进程重启后，数据丢失，即使有备用的节点解决高可用性，但是仍然不能解决缓存预热问题，因此不适用于数据可靠性要求高的业务；</li>
<li>高性能受限于单核CPU的处理能力（Redis是单线程机制），CPU为主要瓶颈，所以适合操作命令简单，排序、计算较少的场景。也可以考虑用Memcached替代。</li>
</ul>

    </div>

    
    
    
        <div class="reward-container">
  <div>“如果觉得有用的话，支持一下吧!“</div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/images/wechat.jpg" alt="ViaCheung 微信支付">
        <p>微信支付</p>
      </div>

  </div>
</div>

        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>ViaCheung
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://viacheung.github.io/2023/06/04/Redis/" title="Redis">http://viacheung.github.io/2023/06/04/Redis/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/zh-CN" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2023/06/04/Spring/" rel="prev" title="Spring">
      <i class="fa fa-chevron-left"></i> Spring
    </a></div>
      <div class="post-nav-item">
    <a href="/2023/06/04/SQL/" rel="next" title="SQL">
      SQL <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis%E6%98%AF%E4%BB%80%E4%B9%88%E4%BB%A5%E5%8F%8A%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-number">1.</span> <span class="nav-text">Redis是什么以及优缺点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BF%AB"><span class="nav-number">2.</span> <span class="nav-text">Redis为什么快</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98%E5%B8%B8%E2%BB%85%E7%9A%84%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B%E2%BD%85%E6%A1%88%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="nav-number">3.</span> <span class="nav-text">分布式缓存常⻅的技术选型⽅案有哪些？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%B4%E2%BC%80%E4%B8%8B-Redis-%E5%92%8C-Memcached-%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E5%85%B1%E5%90%8C%E7%82%B9"><span class="nav-number">4.</span> <span class="nav-text">说⼀下 Redis 和 Memcached 的区别和共同点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis%E7%9B%B8%E6%AF%94Memcached%E6%9C%89%E5%93%AA%E4%BA%9B%E4%BC%98%E5%8A%BF%EF%BC%9F"><span class="nav-number">5.</span> <span class="nav-text">Redis相比Memcached有哪些优势？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E6%95%B0%E6%8D%AE%E7%9A%84%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84%EF%BC%9F"><span class="nav-number">6.</span> <span class="nav-text">缓存数据的处理流程是怎样的？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E2%BD%A4-Redis-x2F-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E2%BD%A4%E7%BC%93%E5%AD%98%EF%BC%9F"><span class="nav-number">7.</span> <span class="nav-text">为什么要⽤ Redis&#x2F;为什么要⽤缓存？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8redis%E8%80%8C%E4%B8%8D%E6%98%AFmap-x2F-guava%E5%81%9A%E7%BC%93%E5%AD%98"><span class="nav-number">8.</span> <span class="nav-text">为什么用redis而不是map&#x2F;guava做缓存</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis-%E5%B8%B8%E2%BB%85%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BB%A5%E5%8F%8A%E4%BD%BF%E2%BD%A4%E5%9C%BA%E6%99%AF%E5%88%86%E6%9E%90"><span class="nav-number">9.</span> <span class="nav-text">Redis 常⻅数据结构以及使⽤场景分析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="nav-number">10.</span> <span class="nav-text">Redis的数据类型有哪些？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8C%81%E4%B9%85%E5%8C%96"><span class="nav-number">11.</span> <span class="nav-text">持久化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis-%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6-%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81-Redis-%E6%8C%82%E6%8E%89%E4%B9%8B%E5%90%8E%E5%86%8D%E9%87%8D%E5%90%AF%E6%95%B0%E6%8D%AE%E5%8F%AF%E4%BB%A5%E8%BF%9B%E2%BE%8F%E6%81%A2%E5%A4%8D"><span class="nav-number">11.1.</span> <span class="nav-text">Redis 持久化机制(怎么保证 Redis 挂掉之后再重启数据可以进⾏恢复)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BF%AB%E7%85%A7%EF%BC%88snapshotting%EF%BC%89%E6%8C%81%E4%B9%85%E5%8C%96%EF%BC%88RDB%EF%BC%89-%EF%BC%88%E9%BB%98%E8%AE%A4%EF%BC%89"><span class="nav-number">11.1.1.</span> <span class="nav-text">快照（snapshotting）持久化（RDB） （默认）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#AOF%EF%BC%88append-only-file%EF%BC%89%E6%8C%81%E4%B9%85%E5%8C%96"><span class="nav-number">11.1.2.</span> <span class="nav-text">AOF（append-only file）持久化</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%E5%90%88%E9%80%82%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96%E6%96%B9%E5%BC%8F"><span class="nav-number">11.2.</span> <span class="nav-text">如何选择合适的持久化方式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis%E6%8C%81%E4%B9%85%E5%8C%96%E6%95%B0%E6%8D%AE%E5%92%8C%E7%BC%93%E5%AD%98%E6%80%8E%E4%B9%88%E5%81%9A%E6%89%A9%E5%AE%B9%EF%BC%9F"><span class="nav-number">12.</span> <span class="nav-text">Redis持久化数据和缓存怎么做扩容？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%87%E6%9C%9F%E9%94%AE%E7%9A%84%E5%88%A0%E9%99%A4%E7%AD%96%E7%95%A5%E3%80%81%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5"><span class="nav-number">13.</span> <span class="nav-text">过期键的删除策略、淘汰策略</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis-key%E7%9A%84%E8%BF%87%E6%9C%9F%E6%97%B6%E9%97%B4%E5%92%8C%E6%B0%B8%E4%B9%85%E6%9C%89%E6%95%88%E5%88%86%E5%88%AB%E6%80%8E%E4%B9%88%E8%AE%BE%E7%BD%AE%EF%BC%9F"><span class="nav-number">14.</span> <span class="nav-text">Redis key的过期时间和永久有效分别怎么设置？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis-%E7%BB%99%E7%BC%93%E5%AD%98%E6%95%B0%E6%8D%AE%E8%AE%BE%E7%BD%AE%E8%BF%87%E6%9C%9F%E6%97%B6%E9%97%B4%E6%9C%89%E5%95%A5%E2%BD%A4%EF%BC%9F"><span class="nav-number">14.1.</span> <span class="nav-text">Redis 给缓存数据设置过期时间有啥⽤？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis%E6%98%AF%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E6%95%B0%E6%8D%AE%E6%98%AF%E5%90%A6%E8%BF%87%E6%9C%9F%E7%9A%84%E5%91%A2%EF%BC%9F"><span class="nav-number">14.2.</span> <span class="nav-text">Redis是如何判断数据是否过期的呢？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis-%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E6%9C%BA%E5%88%B6%E4%BA%86%E8%A7%A3%E4%B9%88%EF%BC%9F"><span class="nav-number">14.3.</span> <span class="nav-text">Redis 内存淘汰机制了解么？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1"><span class="nav-number">15.</span> <span class="nav-text">事务</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E5%BC%82%E5%B8%B8"><span class="nav-number">16.</span> <span class="nav-text">缓存异常</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E7%BC%93%E5%AD%98%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8F%8C%E5%86%99%E6%97%B6%E7%9A%84%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7%EF%BC%9F"><span class="nav-number">16.1.</span> <span class="nav-text">如何保证缓存与数据库双写时的数据一致性？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%88%E5%88%A0%E9%99%A4%E7%BC%93%E5%AD%98%EF%BC%8C%E5%90%8E%E6%9B%B4%E6%96%B0%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="nav-number">16.2.</span> <span class="nav-text">先删除缓存，后更新数据库</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%AD%94%E6%A1%88%E4%B8%80%EF%BC%9A%E5%BB%B6%E6%97%B6%E5%8F%8C%E5%88%A0"><span class="nav-number">16.2.0.1.</span> <span class="nav-text">答案一：延时双删</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%AD%94%E6%A1%88%E4%BA%8C%EF%BC%9A-%E6%9B%B4%E6%96%B0%E4%B8%8E%E8%AF%BB%E5%8F%96%E6%93%8D%E4%BD%9C%E8%BF%9B%E8%A1%8C%E5%BC%82%E6%AD%A5%E4%B8%B2%E8%A1%8C%E5%8C%96"><span class="nav-number">16.2.0.2.</span> <span class="nav-text">答案二： 更新与读取操作进行异步串行化</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%88%E6%9B%B4%E6%96%B0%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%8C%E5%90%8E%E5%88%A0%E9%99%A4%E7%BC%93%E5%AD%98"><span class="nav-number">16.3.</span> <span class="nav-text">先更新数据库，后删除缓存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF"><span class="nav-number">16.4.</span> <span class="nav-text">什么是缓存击穿?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F"><span class="nav-number">16.5.</span> <span class="nav-text">什么是缓存穿透?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9"><span class="nav-number">16.6.</span> <span class="nav-text">缓存雪崩</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%89%E5%93%AA%E4%BA%9B%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95%EF%BC%9F"><span class="nav-number">16.7.</span> <span class="nav-text">有哪些解决办法？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BC%93%E5%AD%98%E9%A2%84%E7%83%AD"><span class="nav-number">16.8.</span> <span class="nav-text">什么是缓存预热?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BC%93%E5%AD%98%E9%99%8D%E7%BA%A7%EF%BC%9F"><span class="nav-number">16.9.</span> <span class="nav-text">什么是缓存降级？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E7%BC%93%E5%AD%98%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E6%95%B0%E6%8D%AE%E7%9A%84%E2%BC%80%E8%87%B4%E6%80%A7%EF%BC%9F"><span class="nav-number">17.</span> <span class="nav-text">如何保证缓存和数据库数据的⼀致性？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="nav-number">18.</span> <span class="nav-text">线程模型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis%E4%B8%BA%E4%BD%95%E9%80%89%E6%8B%A9%E5%8D%95%E7%BA%BF%E7%A8%8B%EF%BC%9F"><span class="nav-number">18.1.</span> <span class="nav-text">Redis为何选择单线程？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis%E7%9C%9F%E7%9A%84%E6%98%AF%E5%8D%95%E7%BA%BF%E7%A8%8B%EF%BC%9F"><span class="nav-number">18.2.</span> <span class="nav-text">Redis真的是单线程？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis-6-0%E4%B8%BA%E4%BD%95%E5%BC%95%E5%85%A5%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%9F"><span class="nav-number">18.3.</span> <span class="nav-text">Redis 6.0为何引入多线程？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis-6-0-%E9%87%87%E7%94%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%90%8E%EF%BC%8C%E6%80%A7%E8%83%BD%E7%9A%84%E6%8F%90%E5%8D%87%E6%95%88%E6%9E%9C%E5%A6%82%E4%BD%95%EF%BC%9F"><span class="nav-number">18.4.</span> <span class="nav-text">Redis 6.0 采用多线程后，性能的提升效果如何？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%8B%E7%BB%8D%E4%B8%8BRedis%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="nav-number">18.5.</span> <span class="nav-text">介绍下Redis的线程模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis-6-0-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6%EF%BC%9F"><span class="nav-number">18.6.</span> <span class="nav-text">Redis 6.0 多线程的实现机制？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis-6-0%E5%BC%80%E5%90%AF%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%90%8E%EF%BC%8C%E6%98%AF%E5%90%A6%E4%BC%9A%E5%AD%98%E5%9C%A8%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="nav-number">18.7.</span> <span class="nav-text">Redis 6.0开启多线程后，是否会存在线程并发安全问题？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis-6-0-%E4%B8%8E-Memcached-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="nav-number">18.8.</span> <span class="nav-text">Redis 6.0 与 Memcached 多线程模型的对比</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis-%E5%8D%95%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B%E8%AF%A6%E8%A7%A3"><span class="nav-number">18.9.</span> <span class="nav-text">Redis 单线程模型详解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis-%E6%B2%A1%E6%9C%89%E4%BD%BF%E2%BD%A4%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E4%BD%BF%E2%BD%A4%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%9F"><span class="nav-number">18.10.</span> <span class="nav-text">Redis 没有使⽤多线程？为什么不使⽤多线程？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis6-0-%E4%B9%8B%E5%90%8E%E4%B8%BA%E4%BD%95%E5%BC%95%E2%BC%8A%E4%BA%86%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="nav-number">18.11.</span> <span class="nav-text">Redis6.0 之后为何引⼊了多线程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1-1"><span class="nav-number">19.</span> <span class="nav-text">事务</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis%E4%BA%8B%E5%8A%A1%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="nav-number">19.1.</span> <span class="nav-text">Redis事务的概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis%E4%BA%8B%E5%8A%A1%E7%9A%84%E4%B8%89%E4%B8%AA%E9%98%B6%E6%AE%B5"><span class="nav-number">19.2.</span> <span class="nav-text">Redis事务的三个阶段</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis%E4%BA%8B%E5%8A%A1%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4"><span class="nav-number">19.3.</span> <span class="nav-text">Redis事务相关命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis%E4%BA%8B%E5%8A%A1%E6%94%AF%E6%8C%81%E9%9A%94%E7%A6%BB%E6%80%A7%E5%90%97"><span class="nav-number">19.4.</span> <span class="nav-text">Redis事务支持隔离性吗?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E6%94%AF%E6%8C%81%E4%BA%8B%E5%8A%A1%E5%9B%9E%E6%BB%9A%EF%BC%9F"><span class="nav-number">19.5.</span> <span class="nav-text">Redis为什么不支持事务回滚？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis%E4%BA%8B%E5%8A%A1%E5%85%B6%E4%BB%96%E5%AE%9E%E7%8E%B0"><span class="nav-number">19.6.</span> <span class="nav-text">Redis事务其他实现(?)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BB%E4%BB%8E%E3%80%81%E5%93%A8%E5%85%B5%E3%80%81%E9%9B%86%E7%BE%A4"><span class="nav-number">20.</span> <span class="nav-text">主从、哨兵、集群</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#36-Redis%E5%B8%B8%E8%A7%81%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="nav-number">20.1.</span> <span class="nav-text">36. Redis常见使用方式有哪些？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%8B%E7%BB%8D%E4%B8%8BRedis%E5%8D%95%E5%89%AF%E6%9C%AC"><span class="nav-number">20.2.</span> <span class="nav-text">介绍下Redis单副本</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="ViaCheung"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">ViaCheung</p>
  <div class="site-description" itemprop="description">el psy congroo</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">42</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/viacheung" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;viacheung" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:viacheung5@gmail.com" title="E-Mail → mailto:viacheung5@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/zh-CN" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ViaCheung</span>
</div>

<!--
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div> -->

<!-- 网站运行时间的设置 -->
<span id="timeDate">载入天数...</span>
<span id="times">载入时分秒...</span>
<script>
    var now = new Date();
    function createtime() {
        var grt= new Date("03/01/2023 10:00:00"); //此处修改你的建站时间或者网站上线时间
        now.setTime(now.getTime()+250);
        days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days);
        hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours);
        if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);
        mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;}
        seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
        snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;}
        document.getElementById("timeDate").innerHTML = "本站已安全运行 "+dnum+" 天 ";
        document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒.";
    }
setInterval("createtime()",250);
</script>
        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>

<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.1.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"viacheung.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="计算机网络的各层协议及作用？">
<meta property="og:type" content="article">
<meta property="og:title" content="计算机网络">
<meta property="og:url" content="http://viacheung.github.io/2023/06/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/index.html">
<meta property="og:site_name" content="命运石之门">
<meta property="og:description" content="计算机网络的各层协议及作用？">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/viacheung/img/main/image/image-20230318181257136.png">
<meta property="og:image" content="https://raw.githubusercontent.com/viacheung/img/main/image/image-20210520161056918.png">
<meta property="og:image" content="https://raw.githubusercontent.com/viacheung/img/main/image/image-20210520180127547.png">
<meta property="og:image" content="https://raw.githubusercontent.com/viacheung/img/main/image/image-20210520214432214.png">
<meta property="og:image" content="https://raw.githubusercontent.com/viacheung/img/main/image/image-20230318181625164.png">
<meta property="og:image" content="https://raw.githubusercontent.com/viacheung/img/main/image/image-20210519180008296.png">
<meta property="og:image" content="https://raw.githubusercontent.com/viacheung/img/main/image/image-20210520214123058.png">
<meta property="og:image" content="https://raw.githubusercontent.com/viacheung/img/main/image/image-20210520214146324.png">
<meta property="og:image" content="https://raw.githubusercontent.com/viacheung/img/main/image/image-20210525114439748.png">
<meta property="og:image" content="https://raw.githubusercontent.com/viacheung/img/main/image/image-20230313160513726.png">
<meta property="og:image" content="https://raw.githubusercontent.com/viacheung/img/main/image/image-20230313160546396.png">
<meta property="og:image" content="https://raw.githubusercontent.com/viacheung/img/main/image/image-20230404211801661.png">
<meta property="og:image" content="https://raw.githubusercontent.com/viacheung/img/main/image/image-20210525160006424.png">
<meta property="article:published_time" content="2023-06-04T09:40:54.000Z">
<meta property="article:modified_time" content="2023-06-04T09:41:41.707Z">
<meta property="article:author" content="ViaCheung">
<meta property="article:tag" content="Java,python">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/viacheung/img/main/image/image-20230318181257136.png">

<link rel="canonical" href="http://viacheung.github.io/2023/06/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>计算机网络 | 命运石之门</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">命运石之门</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">欢迎来到我的博客空间🙇</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/viacheung" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://viacheung.github.io/2023/06/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="ViaCheung">
      <meta itemprop="description" content="el psy congroo">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="命运石之门">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          计算机网络
        </h1>

        <div class="post-meta">
	  <span class="post-time">

	  
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-06-04 17:40:54 / 修改时间：17:41:41" itemprop="dateCreated datePublished" datetime="2023-06-04T17:40:54+08:00">2023-06-04</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%85%AB%E8%82%A1/" itemprop="url" rel="index"><span itemprop="name">八股</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="计算机网络的各层协议及作用？"><a href="#计算机网络的各层协议及作用？" class="headerlink" title="计算机网络的各层协议及作用？"></a>计算机网络的各层协议及作用？</h2><img src="https://raw.githubusercontent.com/viacheung/img/main/image/image-20230318181257136.png" alt="img" style="zoom:50%;">



<span id="more"></span>应用层：**应用进程之间交互**   DNS（域名系统）  HTTP（超文本传输协议）  SMTP（电子邮件）



<p>表示层：<strong>数据格式的转换</strong>，如加密解密、转换翻译、压缩解压缩等。</p>
<p>会话层：网络中的两节点之间建立、维持和终止通信，如<strong>服务器验证用户登录</strong></p>
<p>运输层：为应用层提供通用数据传输服务 TCP（面向连接 可靠） UDP（⽆连接  不保证数据传输的可靠性  ）</p>
<p>网络层：选择合适路由节点  确保数据及时发送  IP协议</p>
<p>数据链路层：把网络层交付下来的ip数据报组装为帧 在两个相邻节点间链路传送帧（发数据）  帧包括数据＋控制信息（同步信息、地址信息、差错控制–丢失帧）</p>
<p>物理层：数据单位bt  实现相邻节点<strong>比特流</strong>的透明传输 尽量屏蔽传输介质和物理设备差异</p>
<h2 id="为什么分层？"><a href="#为什么分层？" class="headerlink" title="为什么分层？"></a>为什么分层？</h2><p>1、易于实现和标准化各层独立，就可以把大问题分割成多个小问题，利于实现；</p>
<p>2、灵活性好：如果某一层发生变化，只要接口不变，不会影响其他层；</p>
<p>3、分层后，用户只关心用到的应用层，其他层用户可以复用；<br>4、各层之间相互独立：高层不需要知道底层的功能是采取硬件来实现的，只需要知道通过底层的接口来获得所需要的服务。</p>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>三层架构和MVC</p>
<h2 id="三次握手-（建立连接）"><a href="#三次握手-（建立连接）" class="headerlink" title="三次握手 （建立连接）"></a>三次握手 （建立连接）</h2><p><img src="https://raw.githubusercontent.com/viacheung/img/main/image/image-20210520161056918.png" alt="img"></p>
<p>三次握手机制：</p>
<ul>
<li>第一次握手：客户端请求建立连接，向服务端发送一个<strong>同步报文</strong>（SYN&#x3D;1），同时选择一个随机数 seq &#x3D; x 作为<strong>初始序列号</strong>，并进入SYN_SENT状态，等待服务器确认。</li>
<li>第二次握手：：服务端收到连接请求报文后，如果同意建立连接，则向客户端发送<strong>同步确认报文</strong>（SYN&#x3D;1，ACK&#x3D;1），确认号为 ack &#x3D; x + 1，同时选择一个随机数 seq &#x3D; y 作为初始序列号，此时服务器进入SYN_RECV状态。</li>
<li>第三次握手：客户端收到服务端的确认后，向服务端发送一个<strong>确认报文</strong>（ACK&#x3D;1），确认号为 ack &#x3D; y + 1，序列号为 seq &#x3D; x + 1，客户端和服务器进入ESTABLISHED状态，完成三次握手。</li>
</ul>
<p>理想状态下，TCP连接一旦建立，在通信双方中的任何一方主动关闭连接之前，TCP 连接都将被一直保持下去。</p>
<p>确认号&#x3D;序列号+1;</p>
<p>总结：</p>
<p>1、客户端发送带有syn(请求同步)的数据包到服务端  选择一个随机数seq&#x3D;x</p>
<p>服务端发送带有syn+ack的数据包</p>
<p>客户端发送带有ack标志数据包</p>
<p>目的：建立可靠传输，双方确认自己与对方的发送接受都正常</p>
<p>确保双方都是能发能接</p>
<h2 id="为什么需要三次握手，而不是两次？"><a href="#为什么需要三次握手，而不是两次？" class="headerlink" title="为什么需要三次握手，而不是两次？"></a><a target="_blank" rel="noopener" href="https://www.javalearn.cn/#/doc/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%9D%A2%E8%AF%95%E9%A2%98?id=_5-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%EF%BC%8C%E8%80%8C%E4%B8%8D%E6%98%AF%E4%B8%A4%E6%AC%A1%EF%BC%9F">为什么需要三次握手，而不是两次？</a></h2><p>主要有三个原因：</p>
<ol>
<li>防止已过期的连接请求报文突然又传送到服务器，因而产生错误和资源浪费。<br>   在双方两次握手即可建立连接的情况下，假设客户端发送 A 报文段请求建立连接，由于网络原因造成 A 暂时无法到达服务器，服务器接收不到请求报文段就不会返回确认报文段。<br>   客户端在长时间得不到应答的情况下重新发送请求报文段 B，这次 B 顺利到达服务器，服务器随即返回确认报文并进入 ESTABLISHED 状态，客户端在收到 确认报文后也进入 ESTABLISHED 状态，双方建立连接并传输数据，之后正常断开连接。<br>   此时姗姗来迟的 A 报文段才到达服务器，服务器随即返回确认报文并进入 ESTABLISHED 状态，但是已经进入 CLOSED 状态的客户端无法再接受确认报文段，更无法进入 ESTABLISHED 状态，这将导致服务器长时间单方面等待，造成资源浪费。 </li>
<li>三次握手才能让双方均确认自己和对方的发送和接收能力都正常。<br>   第一次握手：客户端只是发送处请求报文段，<strong>什么都无法确认</strong>，而服务器可以确认自己的接收能力和对方的发送能力正常；<br>   第二次握手：客户端可以确认自己发送能力和接收能力正常，对方发送能力和接收能力正常；<br>   第三次握手：服务器可以确认自己发送能力和接收能力正常，对方发送能力和接收能力正常；<br>   可见三次握手才能让双方都确认自己和对方的发送和接收能力全部正常，这样就可以愉快地进行通信了。 </li>
<li>告知对方自己的初始序号值，并确认收到对方的初始序号值。<br>   TCP 实现了可靠的数据传输，原因之一就是 TCP 报文段中维护了序号字段和确认序号字段，通过这两个字段双方都可以知道在自己发出的数据中，哪些是已经被对方确认接收的。这两个字段的值会在初始序号值得基础递增，<strong>如果是两次握手，只有发起方的初始序号可以得到确认，而另一方的初始序号则得不到确认。</strong></li>
</ol>
<h2 id="为什么要三次握手，而不是四次？"><a href="#为什么要三次握手，而不是四次？" class="headerlink" title="为什么要三次握手，而不是四次？"></a><a target="_blank" rel="noopener" href="https://www.javalearn.cn/#/doc/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%9D%A2%E8%AF%95%E9%A2%98?id=_6-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%EF%BC%8C%E8%80%8C%E4%B8%8D%E6%98%AF%E5%9B%9B%E6%AC%A1%EF%BC%9F">为什么要三次握手，而不是四次？</a></h2><p>因为<strong>三次握手已经可以确认双方的发送接收能力正常</strong>，双方都知道彼此已经准备好，而且也可以完成对双方初始序号值得确认，也就无需再第四次握手了。</p>
<ul>
<li>第一次握手：服务端确认“自己收、客户端发”报文功能正常。</li>
<li>第二次握手：客户端确认“自己发、自己收、服务端收、客户端发”报文功能正常，客户端认为连接已建立。</li>
<li>第三次握手：服务端确认“自己发、客户端收”报文功能正常，此时双方均建立连接，可以正常通信。</li>
</ul>
<h2 id="什么是-SYN洪泛攻击？如何防范？"><a href="#什么是-SYN洪泛攻击？如何防范？" class="headerlink" title="什么是 SYN洪泛攻击？如何防范？"></a><a target="_blank" rel="noopener" href="https://www.javalearn.cn/#/doc/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%9D%A2%E8%AF%95%E9%A2%98?id=_7-%E4%BB%80%E4%B9%88%E6%98%AF-syn%E6%B4%AA%E6%B3%9B%E6%94%BB%E5%87%BB%EF%BC%9F%E5%A6%82%E4%BD%95%E9%98%B2%E8%8C%83%EF%BC%9F">什么是 SYN洪泛攻击？如何防范？</a></h2><p>SYN洪泛攻击属于 DOS 攻击的一种，它利用 TCP 协议缺陷，通过发送大量的半连接请求，耗费 CPU 和内存资源。</p>
<p>原理：</p>
<ul>
<li>在三次握手过程中，服务器发送 <code>[SYN/ACK]</code> 包（第二个包）之后、收到客户端的 <code>[ACK]</code> 包（第三个包）之前的 TCP 连接称为半连接（half-open connect），此时服务器处于 <code>SYN_RECV</code>（等待客户端响应）状态。如果接收到客户端的 <code>[ACK]</code>，则 TCP 连接成功，如果未接受到，则会<strong>不断重发请求</strong>直至成功。</li>
<li>SYN 攻击的攻击者在短时间内<strong>伪造大量不存在的 IP 地址</strong>，向服务器不断地发送 <code>[SYN]</code> 包，服务器回复 <code>[SYN/ACK]</code> 包，并等待客户的确认。由于源地址是不存在的，服务器需要不断的重发直至超时。</li>
<li>这些伪造的 <code>[SYN]</code> 包将长时间占用未连接队列，影响了正常的 SYN，导致目标系统运行缓慢、网络堵塞甚至系统瘫痪。</li>
</ul>
<p>总结，不存在Ip发syn包，让服务器一直等待</p>
<p>检测：当在服务器上看到大量的半连接状态时，特别是源 IP 地址是随机的，基本上可以断定这是一次 SYN 攻击。</p>
<p>防范：</p>
<ul>
<li>通过防火墙、路由器等过滤网关防护。</li>
<li>通过加固 TCP&#x2F;IP 协议栈防范，如增加最大半连接数，缩短超时时间。</li>
<li>SYN cookies技术。SYN Cookies 是对 TCP 服务器端的三次握手做一些修改，专门用来防范 SYN 洪泛攻击的一种手段。</li>
</ul>
<h2 id="三次握手连接阶段，最后一次ACK包丢失，会发生什么？"><a href="#三次握手连接阶段，最后一次ACK包丢失，会发生什么？" class="headerlink" title="三次握手连接阶段，最后一次ACK包丢失，会发生什么？"></a><a target="_blank" rel="noopener" href="https://www.javalearn.cn/#/doc/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%9D%A2%E8%AF%95%E9%A2%98?id=_8-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E8%BF%9E%E6%8E%A5%E9%98%B6%E6%AE%B5%EF%BC%8C%E6%9C%80%E5%90%8E%E4%B8%80%E6%AC%A1ack%E5%8C%85%E4%B8%A2%E5%A4%B1%EF%BC%8C%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%EF%BC%9F">三次握手连接阶段，最后一次ACK包丢失，会发生什么？</a></h2><p><strong>服务端：</strong></p>
<p>（服务端超时重传 重传指定次数后 服务器自动关连接）</p>
<ul>
<li>第三次的ACK在网络中丢失，那么服务端该TCP连接的状态为SYN_RECV,并且会根据 TCP的超时重传机制，会等待3秒、6秒、12秒后重新发送SYN+ACK包，以便客户端重新发送ACK包。</li>
<li>如果重发指定次数之后，仍然未收到 客户端的ACK应答，那么一段时间后，服务端自动关闭这个连接。</li>
</ul>
<p><strong>客户端：</strong></p>
<p>(后面发数据 会发现三次握手失败)</p>
<p>客户端认为这个连接已经建立，如果客户端向服务端发送数据，服务端将以RST包（Reset，标示复位，用于异常的关闭连接）响应。此时，客户端知道第三次握手失败。</p>
<h2 id="四次挥手（断开连接）"><a href="#四次挥手（断开连接）" class="headerlink" title="四次挥手（断开连接）"></a>四次挥手（断开连接）</h2><p><img src="https://raw.githubusercontent.com/viacheung/img/main/image/image-20210520180127547.png" alt="img"></p>
<ul>
<li><p>第一次挥手：客户端向服务端发送连接释放报文（FIN&#x3D;1，ACK&#x3D;1），主动关闭连接，同时等待服务端的确认。 </p>
</li>
<li><ul>
<li>序列号 seq &#x3D; u，即客户端上次发送的报文的最后一个字节的序号 + 1</li>
<li>确认号 ack &#x3D; k, 即服务端上次发送的报文的最后一个字节的序号 + 1</li>
</ul>
</li>
<li><p>第二次挥手：服务端收到连接释放报文后，立即发出<strong>确认报文</strong>（ACK&#x3D;1）（序列号 seq &#x3D; k，确认号 ack &#x3D; u + 1）。<br>  这时 TCP 连接处于半关闭状态，即客户端到服务端的连接已经释放了，但是服务端到客户端的连接还未释放。这表示客户端已经没有数据发送了，但是服务端可能还要给客户端发送数据。 </p>
</li>
<li><p>第三次挥手：服务端向客户端发送连接释放报文（FIN&#x3D;1，ACK&#x3D;1），主动关闭连接，同时等待 A 的确认。 </p>
</li>
<li><ul>
<li>序列号 seq &#x3D; w，即服务端上次发送的报文的最后一个字节的序号 + 1。</li>
<li>确认号 ack &#x3D; u + 1，与第二次挥手相同，因为这段时间客户端没有发送数据</li>
</ul>
</li>
<li><p>第四次挥手：客户端收到服务端的连接释放报文后，立即发出<strong>确认报文</strong>（ACK&#x3D;1）（序列号 seq &#x3D; u + 1，确认号为 ack &#x3D; w + 1）。<br>  此时，客户端就进入了 <code>TIME-WAIT</code> 状态。注意此时客户端到 TCP 连接还没有释放，必须经过 2*MSL（最长报文段寿命）的时间后，才进入 <code>CLOSED</code> 状态。而服务端只要收到客户端发出的确认，就立即进入 <code>CLOSED</code> 状态。可以看到，服务端结束 TCP 连接的时间要比客户端早一些。</p>
</li>
</ul>
<p>总结：</p>
<p>客户端发送一个fin，服务端回一个ack，然后客户端到服务端的数据传送关闭</p>
<p>服务端发送一个fin，客户端回一个ack，然后服务端到客户端的数据传送关闭</p>
<p>目的  ：两边确认对方没有要发送的数据</p>
<h2 id="为什么连接的时候是三次握手，关闭的时候却是四次握手？"><a href="#为什么连接的时候是三次握手，关闭的时候却是四次握手？" class="headerlink" title="为什么连接的时候是三次握手，关闭的时候却是四次握手？"></a><a target="_blank" rel="noopener" href="https://www.javalearn.cn/#/doc/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%9D%A2%E8%AF%95%E9%A2%98?id=_10-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%9E%E6%8E%A5%E7%9A%84%E6%97%B6%E5%80%99%E6%98%AF%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%EF%BC%8C%E5%85%B3%E9%97%AD%E7%9A%84%E6%97%B6%E5%80%99%E5%8D%B4%E6%98%AF%E5%9B%9B%E6%AC%A1%E6%8F%A1%E6%89%8B%EF%BC%9F">为什么连接的时候是三次握手，关闭的时候却是四次握手？</a></h2><p>服务器在收到客户端的 FIN 报文段后，可能还有一些数据要传输，所以不能马上关闭连接，但是会做出应答，返回 ACK 报文段.</p>
<p>接下来可能会继续发送数据，在数据发送完后，服务器会向客户单发送 FIN 报文，表示数据已经发送完毕，请求关闭连接。服务器的<strong>ACK和FIN一般都会分开发送</strong>，从而导致多了一次，因此一共需要四次挥手。</p>
<h2 id="为什么客户端的-TIME-WAIT-状态必须等待-2MSL-？"><a href="#为什么客户端的-TIME-WAIT-状态必须等待-2MSL-？" class="headerlink" title="为什么客户端的 TIME-WAIT 状态必须等待 2MSL ？"></a><a target="_blank" rel="noopener" href="https://www.javalearn.cn/#/doc/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%9D%A2%E8%AF%95%E9%A2%98?id=_11-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84-time-wait-%E7%8A%B6%E6%80%81%E5%BF%85%E9%A1%BB%E7%AD%89%E5%BE%85-2msl-%EF%BC%9F">为什么客户端的 TIME-WAIT 状态必须等待 2MSL ？</a></h2><p>主要有两个原因：</p>
<ol>
<li>确保 ACK 报文能够到达服务端，从而使服务端正常关闭连接。<br>   第四次挥手时，客户端第四次挥手的 ACK 报文不一定会到达服务端。服务端会超时重传 FIN&#x2F;ACK 报文，此时如果客户端已经断开了连接，那么就无法响应服务端的二次请求，这样服务端迟迟收不到 FIN&#x2F;ACK 报文的确认，就无法正常断开连接。<br>   MSL 是报文段在网络上存活的最长时间。客户端等待 2MSL 时间，即「客户端 ACK 报文 1MSL 超时 + 服务端 FIN 报文 1MSL 传输」，就能够收到服务端重传的 FIN&#x2F;ACK 报文，然后客户端重传一次 ACK 报文，并重新启动 2MSL 计时器。如此保证服务端能够正常关闭。<br>   如果服务端重发的 FIN 没有成功地在 2MSL 时间里传给客户端，服务端则会继续超时重试直到断开连接。 </li>
<li>防止已失效的连接请求报文段出现在之后的连接中。<br>   TCP 要求在 2MSL 内不使用相同的序列号。客户端在发送完最后一个 ACK 报文段后，再经过时间 2MSL，就可以保证本连接持续的时间内产生的所有报文段都从网络中消失。这样就可以使下一个连接中不会出现这种旧的连接请求报文段。或者即使收到这些过时的报文，也可以不处理它。</li>
</ol>
<h2 id="如果已经建立了连接，但是客户端出现故障了怎么办？"><a href="#如果已经建立了连接，但是客户端出现故障了怎么办？" class="headerlink" title="如果已经建立了连接，但是客户端出现故障了怎么办？"></a><a target="_blank" rel="noopener" href="https://www.javalearn.cn/#/doc/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%9D%A2%E8%AF%95%E9%A2%98?id=_12-%E5%A6%82%E6%9E%9C%E5%B7%B2%E7%BB%8F%E5%BB%BA%E7%AB%8B%E4%BA%86%E8%BF%9E%E6%8E%A5%EF%BC%8C%E4%BD%86%E6%98%AF%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%87%BA%E7%8E%B0%E6%95%85%E9%9A%9C%E4%BA%86%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F">如果已经建立了连接，但是客户端出现故障了怎么办？</a></h2><p>或者说，如果三次握手阶段、四次挥手阶段的包丢失了怎么办？如“服务端重发 FIN丢失”的问题。</p>
<p>简而言之，通过<strong>定时器 + 超时重试机制</strong>，尝试获取确认，直到最后会自动断开连接。</p>
<p>具体而言，TCP 设有一个保活计时器。服务器每收到一次客户端的数据，都会重新复位这个计时器，以Linux服务器为例，时间通常是设置为 2 小时。若 2 小时还没有收到客户端的任何数据，服务器就开始重试：每隔 75 秒（默认）发送一个探测报文段，若一共发送 10 个探测报文后客户端依然没有回应，那么服务器就认为连接已经断开了。</p>
<p>附：Linux服务器系统内核参数配置</p>
<ol>
<li>tcp_keepalive_time，在TCP保活打开的情况下，最后一次数据交换到TCP发送第一个保活探测包的间隔，即允许的持续空闲时长，或者说每次正常发送心跳的周期，默认值为7200s（2h）。</li>
<li>tcp_keepalive_probes 在tcp_keepalive_time之后，没有接收到对方确认，<strong>继续发送保活探测包次数，默认值为9（次）</strong>。</li>
<li>tcp_keepalive_intvl，在tcp_keepalive_time之后，没有接收到对方确认，继续发送保活探测包的发送频率，默认值为75s。 发送频率tcp_keepalive_intvl乘以发送次数tcp_keepalive_probes，就得到了从开始探测到放弃探测确定连接断开的时间； 举例：若设置，服务器在客户端连接空闲的时候，每90秒发送一次保活探测包到客户端，若没有及时收到客户端的TCP Keepalive ACK确认，将继续等待15秒*2&#x3D;30秒。总之可以在90s+30s&#x3D;120秒（两分钟）时间内可检测到连接失效与否。</li>
</ol>
<h2 id="TIME-WAIT-状态过多会产生什么后果？怎样处理？"><a href="#TIME-WAIT-状态过多会产生什么后果？怎样处理？" class="headerlink" title="TIME-WAIT 状态过多会产生什么后果？怎样处理？"></a><a target="_blank" rel="noopener" href="https://www.javalearn.cn/#/doc/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%9D%A2%E8%AF%95%E9%A2%98?id=_13-time-wait-%E7%8A%B6%E6%80%81%E8%BF%87%E5%A4%9A%E4%BC%9A%E4%BA%A7%E7%94%9F%E4%BB%80%E4%B9%88%E5%90%8E%E6%9E%9C%EF%BC%9F%E6%80%8E%E6%A0%B7%E5%A4%84%E7%90%86%EF%BC%9F">TIME-WAIT 状态过多会产生什么后果？怎样处理？</a></h2><p>从服务器来讲，短时间内关闭了大量的Client连接，就会造成服务器上出现大量的TIME_WAIT连接，严重消耗着服务器的资源，此时部分客户端就会显示连接不上。</p>
<p>从客户端来讲，客户端TIME_WAIT过多，就会导致端口资源被占用，因为端口就65536个，被占满就会导致无法创建新的连接。</p>
<p><strong>解决办法：</strong></p>
<ul>
<li>服务器可以设置 SO_REUSEADDR 套接字选项来避免 TIME_WAIT状态，此套接字选项告诉内核，即使此端口正忙（处于 TIME_WAIT状态），也请继续并重用它。</li>
<li>调整系统内核参数，修改&#x2F;etc&#x2F;sysctl.conf文件，即修改<code>net.ipv4.tcp_tw_reuse 和 tcp_timestamps</code></li>
<li>强制关闭，发送 RST 包越过TIME_WAIT状态，直接进入CLOSED状态。</li>
</ul>
<h2 id="TIME-WAIT-是服务器端的状态-还是客户端的状态"><a href="#TIME-WAIT-是服务器端的状态-还是客户端的状态" class="headerlink" title="TIME_WAIT 是服务器端的状态?还是客户端的状态?"></a><a target="_blank" rel="noopener" href="https://www.javalearn.cn/#/doc/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%9D%A2%E8%AF%95%E9%A2%98?id=_14-time_wait-%E6%98%AF%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E7%9A%84%E7%8A%B6%E6%80%81%E8%BF%98%E6%98%AF%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84%E7%8A%B6%E6%80%81">TIME_WAIT 是服务器端的状态?还是客户端的状态?</a></h2><p>TIME_WAIT 是主动断开连接的一方会进入的状态，一般情况下，都是客户端所处的状态;服务器端一般设置不主动关闭连接。</p>
<p>TIME_WAIT 需要等待 2MSL，在大量短连接的情况下，TIME_WAIT会太多，这也会消耗很多系统资源。对于服务器来说，在 HTTP 协议里指定 KeepAlive（浏览器重用一个 TCP 连接来处理多个 HTTP 请求），由浏览器来主动断开连接，可以一定程度上减少服务器的这个问题</p>
<h2 id="详细讲一下TCP的滑动窗口？"><a href="#详细讲一下TCP的滑动窗口？" class="headerlink" title="详细讲一下TCP的滑动窗口？"></a><a target="_blank" rel="noopener" href="https://www.javalearn.cn/#/doc/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%9D%A2%E8%AF%95%E9%A2%98?id=_16-%E8%AF%A6%E7%BB%86%E8%AE%B2%E4%B8%80%E4%B8%8Btcp%E7%9A%84%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%EF%BC%9F">详细讲一下TCP的滑动窗口？</a></h2><p>在进行数据传输时，如果传输的数据比较大，就需要拆分为多个数据包进行发送。TCP 协议需要对数据进行确认后，才可以发送下一个数据包。这样一来，就会在等待确认应答包环节浪费时间。</p>
<p>为了避免这种情况，TCP引入了窗口概念。窗口大小指的是不需要等待确认应答包而可以继续发送数据包的最大值。</p>
<p><img src="https://raw.githubusercontent.com/viacheung/img/main/image/image-20210520214432214.png" alt="img"></p>
<p>从上面的图可以看到滑动窗口左边的是已发送并且被确认的分组，滑动窗口右边是还没有轮到的分组。</p>
<p>滑动窗口里面也分为两块，一块是已经发送但是未被确认的分组，另一块是窗口内等待发送的分组。随着已发送的分组不断被确认，窗口内等待发送的分组也会不断被发送。整个窗口就会往右移动，让还没轮到的分组进入窗口内。</p>
<p>可以看到滑动窗口起到了一个限流的作用，也就是说当前滑动窗口的大小决定了当前 TCP 发送包的速率，而滑动窗口的大小取决于拥塞控制窗口和流量控制窗口的两者间的最小值。</p>
<h2 id="TCP-VS-UD"><a href="#TCP-VS-UD" class="headerlink" title="TCP VS UD"></a>TCP VS UD</h2><p><img src="https://raw.githubusercontent.com/viacheung/img/main/image/image-20230318181625164.png" alt="img"></p>
<p>TCP 用于在传输层有必要实现可靠传输的情况，UDP 用于对高速传输和实时性有较高要求的通信。TCP 和 UDP 应该根据应用目的按需使用。</p>
<h2 id="UDP-和-TCP-对应的应用场景是什么？"><a href="#UDP-和-TCP-对应的应用场景是什么？" class="headerlink" title="UDP 和 TCP 对应的应用场景是什么？"></a><a target="_blank" rel="noopener" href="https://www.javalearn.cn/#/doc/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%9D%A2%E8%AF%95%E9%A2%98?id=_3-udp-%E5%92%8C-tcp-%E5%AF%B9%E5%BA%94%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F">UDP 和 TCP 对应的应用场景是什么？</a></h2><p>TCP 是面向连接，能保证数据的可靠性交付，因此经常用于：</p>
<ul>
<li>FTP文件传输</li>
<li>HTTP &#x2F; HTTPS</li>
</ul>
<p>UDP 面向无连接，它可以随时发送数据，再加上UDP本身的处理既简单又高效，因此经常用于：</p>
<ul>
<li>包总量较少的通信，如 DNS 、SNMP等</li>
<li>视频、音频等多媒体通信</li>
<li>广播通信</li>
</ul>
<p><img src="https://raw.githubusercontent.com/viacheung/img/main/image/image-20210519180008296.png" alt="img"></p>
<h2 id="TCP-协议如何保证可靠传输"><a href="#TCP-协议如何保证可靠传输" class="headerlink" title="TCP 协议如何保证可靠传输"></a>TCP 协议如何保证可靠传输</h2><p>重传、流量控制、拥塞控制、序列号与确认应达号、校验和</p>
<p>1、合适地分割数据变成数据块</p>
<p>2、给包编号</p>
<p>3、校验和： 通过检验和的方式，接收端可以检测出来数据是否有差错和异常，假如有差错就会直接丢弃TCP段，重新发送。</p>
<p>4、丢失重复</p>
<p>5、流量控制 （缓冲空间 利用滑动窗口实现）：</p>
<p>如果主机A 一直向主机B发送数据，不考虑主机B的接受能力，则可能导致主机B的接受缓冲区满了而无法再接受数据，从而会导致大量的数据丢包，引发重传机制。而在重传的过程中，若主机B的接收缓冲区情况仍未好转，则会将大量的时间浪费在重传数据上，降低传送数据的效率。所以引入流量控制机制，主机B通过告诉主机A自己接收缓冲区的大小，来使主机A控制发送的数据量。流量控制与TCP协议报头中的窗口大小有关。</p>
<p>6、拥塞控制（拥塞时减少发送）：</p>
<p>在数据传输过程中，可能由于网络状态的问题，造成网络拥堵，此时引入拥塞控制机制，在保证TCP可靠性的同时，提高性能。</p>
<p>7、ARQ</p>
<p>8、超时重传（有个定时器，等待接收端发ack，等不到就重发）：</p>
<p>超时重传是指发送出去的数据包到接收到确认包之间的时间，如果超过了这个时间会被认为是丢包了，需要重传。最大超时时间是动态计算的。</p>
<p>9、滑动窗口：</p>
<p>滑动窗口既提高了报文传输的效率，也避免了发送方发送过多的数据而导致接收方无法正常处理的异常。</p>
<p>10、序列号&#x2F;确认应答：</p>
<p>序列号的作用不仅仅是应答的作用，有了序列号能够将接收到的数据根据序列号排序，并且去掉重复序列号的数据。</p>
<p>TCP传输的过程中，每次接收方收到数据后，都会对传输方进行确认应答。也就是发送ACK报文，这个ACK报文当中带有对应的确认序列号，告诉发送方，接收到了哪些数据，下一次的数据从哪里发。</p>
<h2 id="ARQ"><a href="#ARQ" class="headerlink" title="ARQ"></a>ARQ</h2><p>⾃动重传请求，它通过使⽤确认和超时这两个机制，在不可靠服务的基础上实现可靠的信息传输。如果发送⽅在发送后⼀段时间之内没有收到确认帧，它通常会重新发送。</p>
<p>ARQ包括停⽌等待ARQ协议和连续ARQ协议</p>
<h3 id="停⽌等待ARQ协议"><a href="#停⽌等待ARQ协议" class="headerlink" title="停⽌等待ARQ协议"></a>停⽌等待ARQ协议</h3><p>优点： 简单<br>缺点： 信道利⽤率低，等待时间⻓</p>
<p>1、⽆差错情况:<br>发送⽅发送分组,接收⽅在规定时间内收到,并且回复确认.发送⽅再次发送。</p>
<p>2、出现差错情况（超时重传） :<br>停⽌等待协议中超时重传是指只要超过⼀段时间仍然没有收到确认，就重传前⾯发送过的分组（认为刚才发送过的分组丢失了）。因此每发送完⼀个分组需要设置⼀个超时计时器。</p>
<p>3、确认丢失和确认迟到<br>确认丢失 ：syn  –ack丢失  客户端没收到ack  超时计时后  再syn</p>
<p>因此服务端收到俩syn，处理有2种：丢弃这个重复的syn和向A发送<br>确认消息。</p>
<h3 id="连续ARQ协议"><a href="#连续ARQ协议" class="headerlink" title="连续ARQ协议"></a>连续ARQ协议</h3><p>连续 ARQ 协议可提⾼信道利⽤率。发送⽅维持⼀个发送窗⼝，位于窗口内的分组可以连续发送，接受端对到达的最后⼀个分组发送确认，表明所有分组都已经正确收到了。</p>
<p>优点： 信道利⽤率⾼，容易实现，即使确认丢失，也不必重传。</p>
<p>缺点： 不能向发送⽅反映出接收⽅已经正确收到的所有分组的信息。 ⽐如：发送⽅发送了 5条消息，中间第三条丢失（3号），这时接收⽅只能对前两个发送确认。发送⽅⽆法知道后三个分组的下落，⽽只好把后三个全部重传⼀次。这也叫 Go-Back-N</p>
<h2 id="滑动窗⼝和流量控制"><a href="#滑动窗⼝和流量控制" class="headerlink" title="滑动窗⼝和流量控制"></a>滑动窗⼝和流量控制</h2><p>TCP 利⽤滑动窗⼝实现流量控制。流量控制是为了控制发送⽅发送速率，保证接收⽅来得及接收。</p>
<h2 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h2><p>拥塞：某段时间，若对⽹络中某⼀资源的需求超过了该资源所能提供的可⽤部分，⽹络的性能就要变坏。这种情况就叫拥塞。</p>
<p>拥塞控制：拥塞控制就是为了防⽌过多的数据注⼊到⽹络中，这样就可以使⽹络中的路由器或链路不致过载。</p>
<p>vs流量控制：拥塞是全局（涉及到所有主机路由器  ）流量是端到端</p>
<p>实操：维持⼀个 拥塞窗⼝</p>
<p>TCP 一共使用了四种算法来实现拥塞控制：</p>
<ul>
<li>慢开始 (slow-start)；</li>
<li>拥塞避免 (congestion avoidance)；</li>
<li>快速重传 (fast retransmit)；</li>
<li>快速恢复 (fast recovery)。</li>
</ul>
<p><strong>慢开始</strong>：不要一开始就发送大量的数据，由小到大逐渐增加拥塞窗口的大小。（每一个传播轮次加倍）</p>
<p><strong>拥塞避免</strong>：拥塞避免算法让拥塞窗口缓慢增长，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1而不是加倍。这样拥塞窗口按线性规律缓慢增长。一个RTT  cwnd+1）</p>
<p><strong>快重传：</strong>我们可以剔除一些不必要的拥塞报文，提高网络吞吐量。比如接收方在<strong>收到一个失序的报文段后就立即发出重复确认，而不要等到自己发送数据时捎带确认。</strong>快重传规定：发送方只要<strong>一连收到三个</strong>重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期。</p>
<p><img src="https://raw.githubusercontent.com/viacheung/img/main/image/image-20210520214123058.png" alt="img"></p>
<p><strong>快恢复：</strong>主要是配合快重传。当发送方连续收到三个重复确认时，就执行“乘法减小”算法，把ssthresh门限减半（为了预防网络发生拥塞），但<strong>接下来并不执行慢开始算法</strong>，因为如果网络出现拥塞的话就不会收到好几个重复的确认，收到三个重复确认说明网络状况还可以。</p>
<p><img src="https://raw.githubusercontent.com/viacheung/img/main/image/image-20210520214146324.png" alt="img"></p>
<p><strong>快重传与快恢复</strong>：</p>
<p>之前的重传是数据丢失导致接收端收不到数据导致发送端收不到ack，然后超时就会重新发syn，耗时且中间不能发其他数据了</p>
<p>但是有了FRR ，当接收端收到不按序的数据段 连发三个确认 那么发送端就立即重发 不等计时器</p>
<h2 id="HTTP常见的状态码有哪些？"><a href="#HTTP常见的状态码有哪些？" class="headerlink" title="HTTP常见的状态码有哪些？"></a><a target="_blank" rel="noopener" href="https://www.javalearn.cn/#/doc/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%9D%A2%E8%AF%95%E9%A2%98?id=_18-http%E5%B8%B8%E8%A7%81%E7%9A%84%E7%8A%B6%E6%80%81%E7%A0%81%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F">HTTP常见的状态码有哪些？</a></h2><p>常见状态码：</p>
<ul>
<li>200：服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页。</li>
<li>301 ： (永久移动) 请求的网页已永久移动到新位置。 服务器返回此响应(对 GET 或 HEAD 请求的响应)时，会自动将请求者转到新位置。</li>
<li>302：(临时移动) 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。</li>
<li>400 ：客户端请求有语法错误，不能被服务器所理解。</li>
<li>403 ：服务器收到请求，但是拒绝提供服务。</li>
<li>404 ：(未找到) 服务器找不到请求的网页。</li>
<li>500： (服务器内部错误) 服务器遇到错误，无法完成请求。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/viacheung/img/main/image/image-20210525114439748.png" alt="img"></p>
<h2 id="状态码301和302的区别是什么？"><a href="#状态码301和302的区别是什么？" class="headerlink" title="状态码301和302的区别是什么？"></a><a target="_blank" rel="noopener" href="https://www.javalearn.cn/#/doc/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%9D%A2%E8%AF%95%E9%A2%98?id=_19-%E7%8A%B6%E6%80%81%E7%A0%81301%E5%92%8C302%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F">状态码301和302的区别是什么？</a></h2><p><strong>共同点</strong>：301和302状态码都表示重定向，就是说浏览器在拿到服务器返回的这个状态码后会自动跳转到一个新的URL地址，这个地址可以从响应的Location首部中获取（<strong>用户看到的效果就是他输入的地址A瞬间变成了另一个地址B</strong>）。</p>
<p><strong>不同点</strong>：</p>
<p>301表示旧地址A的资源已经被永久地移除了(这个资源不可访问了)，搜索引擎在抓取新内容的同时也将旧的网址交换为重定向之后的网址；</p>
<p>302表示旧地址A的资源还在（仍然可以访问），这个重定向只是临时地从旧地址A跳转到地址B，搜索引擎会抓取新的内容而保存旧的网址。 SEO中302好于301。</p>
<p><strong>补充，重定向原因</strong>：</p>
<ol>
<li>网站调整（如改变网页目录结构）；</li>
<li>网页被移到一个新地址；</li>
<li>网页扩展名改变(如应用需要把.php改成.Html或.shtml)。</li>
</ol>
<h2 id="HTTP-常用的请求方式？"><a href="#HTTP-常用的请求方式？" class="headerlink" title="HTTP 常用的请求方式？"></a><a target="_blank" rel="noopener" href="https://www.javalearn.cn/#/doc/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%9D%A2%E8%AF%95%E9%A2%98?id=_20-http-%E5%B8%B8%E7%94%A8%E7%9A%84%E8%AF%B7%E6%B1%82%E6%96%B9%E5%BC%8F%EF%BC%9F">HTTP 常用的请求方式？</a></h2><ul>
<li>PUT：上传文件，向服务器添加数据，可以看作增</li>
<li>DELETE：删除文件</li>
<li>POST：传输数据，向服务器提交数据，对服务器数据进行更新。</li>
<li>GET：获取资源，查询服务器资源</li>
</ul>
<h2 id="GET请求和POST请求的区别？"><a href="#GET请求和POST请求的区别？" class="headerlink" title="GET请求和POST请求的区别？"></a><a target="_blank" rel="noopener" href="https://www.javalearn.cn/#/doc/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%9D%A2%E8%AF%95%E9%A2%98?id=_21-get%E8%AF%B7%E6%B1%82%E5%92%8Cpost%E8%AF%B7%E6%B1%82%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F">GET请求和POST请求的区别？</a></h2><p><strong>使用上的区别</strong>：</p>
<ul>
<li>GET使用URL或Cookie传参，而POST将数据放在BODY中，这个是因为HTTP协议用法的约定。</li>
<li>GET方式提交的数据有长度限制，则POST的数据则可以非常大”，这个是因为它们使用的操作系统和浏览器设置的不同引起的区别。</li>
<li>POST比GET安全，因为数据在地址栏上不可见”，这个说法没毛病，但依然不是GET和POST本身的区别。</li>
</ul>
<p><strong>本质区别</strong></p>
<p>GET和POST最大的区别主要是GET请求是幂等性的，POST请求不是。这个是它们本质区别。</p>
<p>幂等性是指一次和多次请求某一个资源应该具有同样的副作用。简单来说意味着对同一URL的多个请求应该返回同样的结果。</p>
<h2 id="在浏览器中输⼊url地址-gt-gt-显示主⻚的过程"><a href="#在浏览器中输⼊url地址-gt-gt-显示主⻚的过程" class="headerlink" title="在浏览器中输⼊url地址 -&gt;&gt; 显示主⻚的过程"></a>在浏览器中输⼊url地址 -&gt;&gt; 显示主⻚的过程</h2><ol>
<li>DNS解析（<strong>浏览器搜索自己的DNS缓存</strong>（维护一张域名与IP的对应表）；若没有，则搜索<strong>操作系统的DNS缓存</strong>（维护一张域名与IP的对应表）；若没有，则搜索操作系统的<strong>hosts文件</strong>（维护一张域名与IP的对应表）。<br>   若都没有，则找 tcp&#x2F;ip 参数中设置的首选 dns 服务器，即<strong>本地 dns 服务器</strong>（递归查询），<strong>本地域名服务器查询自己的dns缓存</strong>，如果没有，则进行迭代查询。将本地dns服务器将IP返回给操作系统，同时缓存IP。） </li>
<li>TCP连接（发起 tcp 的三次握手，建立 tcp 连接。浏览器会以一个随机端口（1024-65535）向服务端的 web 程序 80 端口发起 tcp 的连接。） </li>
<li>发送HTTP请求。 </li>
<li>服务器处理，客户端得到 html 代码。服务器 web 应用程序收到 http 请求后，就开始处理请求，处理之后就返回给浏览器 html 文件。 </li>
<li>浏览器解析，解析 html 代码，并请求 html 中的资源。浏览器对页面进行渲染，并呈现给用户 </li>
<li>连接结束</li>
</ol>
<p><img src="https://raw.githubusercontent.com/viacheung/img/main/image/image-20230313160513726.png" alt="img"></p>
<h2 id="各种协议与HTTP协议之间的关系"><a href="#各种协议与HTTP协议之间的关系" class="headerlink" title="各种协议与HTTP协议之间的关系"></a>各种协议与HTTP协议之间的关系</h2><p><img src="https://raw.githubusercontent.com/viacheung/img/main/image/image-20230313160546396.png" alt="img"></p>
<h2 id="HTTP⻓连接-短连接"><a href="#HTTP⻓连接-短连接" class="headerlink" title="HTTP⻓连接,短连接"></a>HTTP⻓连接,短连接</h2><p><strong>HTTP&#x2F;1.0中默认使⽤短连接</strong>  ，每次建立连接之后都中断</p>
<p>HTTP&#x2F;1.1里面默认使⽤⻓连接 ， 响应头加入Connection:keep-alive  ，再次访问这个服务器会继续使用已经建立的连接，但有时间限制，且客户端服务端都要支持长连接</p>
<p>HTTP协议的⻓连接和短连接，实质上是TCP协议的⻓连接和短连接。</p>
<h2 id="HTTP请求报文和响应报文的格式？"><a href="#HTTP请求报文和响应报文的格式？" class="headerlink" title="HTTP请求报文和响应报文的格式？"></a><a target="_blank" rel="noopener" href="https://www.javalearn.cn/#/doc/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%9D%A2%E8%AF%95%E9%A2%98?id=_23-http%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87%E5%92%8C%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87%E7%9A%84%E6%A0%BC%E5%BC%8F%EF%BC%9F">HTTP请求报文和响应报文的格式？</a></h2><p><strong>请求报文格式</strong>：</p>
<ol>
<li>请求行（请求方法+URI协议+版本）</li>
<li>请求头部</li>
<li>空行</li>
<li>请求主体</li>
</ol>
<pre><code class="html">GET/sample.jspHTTP/1.1 请求行
Accept:image/gif.image/jpeg, 请求头部
Accept-Language:zh-cn
Connection:Keep-Alive
Host:localhost
User-Agent:Mozila/4.0(compatible;MSIE5.01;Window NT5.0)
Accept-Encoding:gzip,deflate
username=jinqiao&amp;password=1234 请求主体
</code></pre>
<p><strong>响应报文</strong>：</p>
<ol>
<li>状态行（版本+状态码+原因短语）</li>
<li>响应首部</li>
<li>空行</li>
<li>响应主体</li>
</ol>
<pre><code class="html">HTTP/1.1 200 OK
Server:Apache Tomcat/5.0.12
Date:Mon,6Oct2003 13:23:42 GMT
Content-Length:112

&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;HTTP响应示例&lt;title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        Hello HTTP!
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h2 id="HTTP是不保存状态的协议-如何保存⽤户状态"><a href="#HTTP是不保存状态的协议-如何保存⽤户状态" class="headerlink" title="HTTP是不保存状态的协议,如何保存⽤户状态?"></a>HTTP是不保存状态的协议,如何保存⽤户状态?</h2><p>服务端放一个session记录用户状态，客户端我们通过在 Cookie 中附加⼀个 Session ID 来⽅式来跟踪。</p>
<h2 id="Cookie-被禁⽤怎么办"><a href="#Cookie-被禁⽤怎么办" class="headerlink" title="Cookie 被禁⽤怎么办?"></a>Cookie 被禁⽤怎么办?</h2><p>最常⽤的就是利⽤ URL 重写把 Session ID 直接附加在URL路径的后⾯  <a target="_blank" rel="noopener" href="https://javaguide.cn/?Session_id=xxx">https://javaguide.cn/?Session_id=xxx</a></p>
<h2 id="什么是-Cookie-和-Session"><a href="#什么是-Cookie-和-Session" class="headerlink" title="什么是 Cookie 和 Session ?"></a><a target="_blank" rel="noopener" href="https://www.javalearn.cn/#/doc/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%9D%A2%E8%AF%95%E9%A2%98?id=_30-%E4%BB%80%E4%B9%88%E6%98%AF-cookie-%E5%92%8C-session-">什么是 Cookie 和 Session ?</a></h2><p><strong>什么是 Cookie</strong></p>
<p>HTTP Cookie（也叫 Web Cookie或浏览器 Cookie）是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。通常，它用于告知服务端两个请求是否来自同一浏览器，如保持用户的登录状态。Cookie 使基于无状态的 HTTP 协议记录稳定的状态信息成为了可能。</p>
<p>Cookie 主要用于以下三个方面：</p>
<ul>
<li>会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）</li>
<li>个性化设置（如用户自定义设置、主题等）</li>
<li>浏览器行为跟踪（如跟踪分析用户行为等）</li>
</ul>
<p><strong>什么是 Session</strong></p>
<p>Session 代表着服务器和客户端一次会话的过程。Session 对象存储特定用户会话所需的属性及配置信息。这样，当用户在应用程序的 Web 页之间跳转时，存储在 Session 对象中的变量将不会丢失，而是在整个用户会话中一直存在下去。当客户端关闭会话，或者 Session 超时失效时会话结束。</p>
<p><strong>总结</strong></p>
<p>作用：保存⽤户信息  ，帮你登录的⼀些基本信息给填了  ，cookie里面存放了⼀个Token  ，下次登录的时候只需要根据 Token 值来查找⽤户即可</p>
<p>区别：Cookie 数据保存在客户端(浏览器端)， Session 数据保存在服务器端。  session安全些</p>
<h2 id="Cookie-和-Session-是如何配合的呢？"><a href="#Cookie-和-Session-是如何配合的呢？" class="headerlink" title="Cookie 和 Session 是如何配合的呢？"></a><a target="_blank" rel="noopener" href="https://www.javalearn.cn/#/doc/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%9D%A2%E8%AF%95%E9%A2%98?id=_31-cookie-%E5%92%8C-session-%E6%98%AF%E5%A6%82%E4%BD%95%E9%85%8D%E5%90%88%E7%9A%84%E5%91%A2%EF%BC%9F">Cookie 和 Session 是如何配合的呢？</a></h2><p>用户第一次请求服务器的时候，服务器根据用户提交的相关信息，创建对应的 Session ，请求返回时将此 Session 的唯一标识信息 SessionID 返回给浏览器，浏览器接收到服务器返回的 SessionID 信息后，会将此信息存入到 Cookie 中，同时 Cookie 记录此 SessionID 属于哪个域名。</p>
<p>当用户第二次访问服务器的时候，请求会自动判断此域名下是否存在 Cookie 信息，如果存在自动将 Cookie 信息也发送给服务端，服务端会从 Cookie 中获取 SessionID，再根据 SessionID 查找对应的 Session 信息，如果没有找到说明用户没有登录或者登录失效，如果找到 Session 证明用户已经登录可执行后面操作。</p>
<p>根据以上流程可知，SessionID 是连接 Cookie 和 Session 的一道桥梁，大部分系统也是根据此原理来验证用户登录状态。</p>
<h2 id="Cookie和Session的区别？"><a href="#Cookie和Session的区别？" class="headerlink" title="Cookie和Session的区别？"></a><a target="_blank" rel="noopener" href="https://www.javalearn.cn/#/doc/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%9D%A2%E8%AF%95%E9%A2%98?id=_32-cookie%E5%92%8Csession%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F">Cookie和Session的区别？</a></h2><ul>
<li><strong>作用范围</strong>不同，Cookie 保存在客户端（浏览器），Session 保存在服务器端。</li>
<li><strong>存取方式</strong>的不同，Cookie 只能保存 ASCII，Session 可以存任意数据类型，一般情况下我们可以在 Session 中保持一些常用变量信息，比如说 UserId 等。</li>
<li><strong>有效期</strong>不同，Cookie 可设置为长时间保持，比如我们经常使用的默认登录功能，Session 一般失效时间较短，客户端关闭或者 Session 超时都会失效。</li>
<li><strong>隐私策略</strong>不同，Cookie 存储在客户端，比较容易遭到不法获取，早期有人将用户的登录名和密码存储在 Cookie 中导致信息被窃取；Session 存储在服务端，<strong>安全性相对 Cookie 要好一些。</strong></li>
<li><strong>存储大小不同，</strong> 单个 Cookie 保存的数据不能超过 4K，Session 可存储数据远高于 Cookie。</li>
</ul>
<h2 id="如何考虑分布式-Session-问题？"><a href="#如何考虑分布式-Session-问题？" class="headerlink" title="如何考虑分布式 Session 问题？"></a><a target="_blank" rel="noopener" href="https://www.javalearn.cn/#/doc/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%9D%A2%E8%AF%95%E9%A2%98?id=_33-%E5%A6%82%E4%BD%95%E8%80%83%E8%99%91%E5%88%86%E5%B8%83%E5%BC%8F-session-%E9%97%AE%E9%A2%98%EF%BC%9F">如何考虑分布式 Session 问题？</a></h2><p>在互联网公司为了可以支撑更大的流量，后端往往需要多台服务器共同来支撑前端用户请求，那如果用户在 A 服务器登录了，第二次请求跑到服务 B 就会出现登录失效问题。</p>
<p>分布式 Session 一般会有以下几种解决方案：</p>
<ul>
<li><strong>客户端存储</strong>：直接将信息存储在cookie中，cookie是存储在客户端上的一小段数据，客户端通过http协议和服务器进行cookie交互，通常用来存储一些不敏感信息 </li>
<li><strong>Nginx ip_hash 策略</strong>：服务端使用 Nginx 代理，每个请求按访问 IP 的 hash 分配，这样来自同一 IP 固定访问一个后台服务器，避免了在服务器 A 创建 Session，第二次分发到服务器 B 的现象。 </li>
<li><strong>Session 复制</strong>：任何一个服务器上的 Session 发生改变（增删改），该节点会把这个 Session 的所有内容序列化，然后广播给所有其它节点。 </li>
<li><strong>共享 Session</strong>（√）：服务端无状态话，将用户的 Session 等信息使用缓存中间件（如Redis）来统一管理，保障分发到每一个服务器的响应结果都一致。</li>
</ul>
<p>建议采用共享 Session的方案。</p>
<h2 id="为什么-Cookie-无法防止-CSRF-攻击，而-Token-可以？"><a href="#为什么-Cookie-无法防止-CSRF-攻击，而-Token-可以？" class="headerlink" title="为什么 Cookie 无法防止 CSRF 攻击，而 Token 可以？"></a>为什么 Cookie 无法防止 CSRF 攻击，而 Token 可以？</h2><p><strong>跨站请求伪造</strong>：黑客在链接中藏了一个请求，这个请求直接利用小壮的身份给银行发送了一个转账请求,也就是通过你的 Cookie 向银行发出请求。</p>
<p>但是使用Token的话 即使有个你点击了非法链接发送了请求到服务端，这个非法请求是不会携带 <code>Token</code> 的，所以这个请求将是非法的。</p>
<p>需要注意的是：不论是 <code>Cookie</code> 还是 <code>Token</code> 都无法避免 <strong>跨站脚本攻击（Cross Site Scripting）XSS</strong> 。</p>
<h2 id="什么是DDos攻击？"><a href="#什么是DDos攻击？" class="headerlink" title="什么是DDos攻击？"></a><a target="_blank" rel="noopener" href="https://www.javalearn.cn/#/doc/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%9D%A2%E8%AF%95%E9%A2%98?id=_34-%E4%BB%80%E4%B9%88%E6%98%AFddos%E6%94%BB%E5%87%BB%EF%BC%9F">什么是DDos攻击？</a></h2><p><strong>和syn区别：syn洪泛是那些不存在的ip，DDos是存在而且是第三次握手客户端不确认</strong></p>
<p>DDos全称Distributed Denial of Service，分布式拒绝服务攻击。最基本的DOS攻击过程如下：</p>
<ol>
<li>客户端向服务端发送请求链接数据包。</li>
<li>服务端向客户端发送确认数据包。</li>
<li>客户端不向服务端发送确认数据包，服务器一直等待来自客户端的确认</li>
</ol>
<p>DDoS则是采用分布式的方法，通过在网络上占领多台“肉鸡”，用多台计算机发起攻击。</p>
<p>DOS攻击现在基本没啥作用了，因为服务器的性能都很好，而且是多台服务器共同作用，1V1的模式黑客无法占上风。对于DDOS攻击，预防方法有：</p>
<ul>
<li><strong>减少SYN timeout时间</strong>。在握手的第三步，服务器会等待30秒-120秒的时间，减少这个等待时间就能释放更多的资源。</li>
<li><strong>限制同时打开的SYN半连接数目。</strong></li>
</ul>
<h2 id="什么是XSS攻击？"><a href="#什么是XSS攻击？" class="headerlink" title="什么是XSS攻击？"></a><a target="_blank" rel="noopener" href="https://www.javalearn.cn/#/doc/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%9D%A2%E8%AF%95%E9%A2%98?id=_35-%E4%BB%80%E4%B9%88%E6%98%AFxss%E6%94%BB%E5%87%BB%EF%BC%9F">什么是XSS攻击？</a></h2><p>XSS也称 cross-site scripting，<strong>跨站脚本</strong>。这种攻击是<strong>由于服务器将攻击者存储的数据原原本本地显示给其他用户所致的</strong>。比如一个存在XSS漏洞的论坛，用户发帖时就可以引入<strong>带有＜script＞标签的代码</strong>，导致恶意代码的执行。</p>
<p>预防措施有：</p>
<ul>
<li>前端：过滤。</li>
<li>后端：转义，比如go自带的处理器就具有转义功能。</li>
</ul>
<h2 id="SQL注入是什么，如何避免SQL注入？"><a href="#SQL注入是什么，如何避免SQL注入？" class="headerlink" title="SQL注入是什么，如何避免SQL注入？"></a><a target="_blank" rel="noopener" href="https://www.javalearn.cn/#/doc/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%9D%A2%E8%AF%95%E9%A2%98?id=_36-sql%E6%B3%A8%E5%85%A5%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8Dsql%E6%B3%A8%E5%85%A5%EF%BC%9F">SQL注入是什么，如何避免SQL注入？</a></h2><pre><code class="sql">select distinct * from company where id=&#39;1&#39; OR &#39;1&#39; = &#39;1&#39;
</code></pre>
<p>SQL 注入就是在用户输入的字符串中加入 SQL 语句，如果在设计不良的程序中忽略了检查，那么这些注入进去的 SQL 语句就会被数据库服务器误认为是正常的 SQL 语句而运行，<strong>攻击者就可以执行计划外的命令或访问未被授权的数据。</strong></p>
<p><strong>SQL注入的原理主要有以下 4 点</strong></p>
<ul>
<li>恶意拼接查询</li>
<li>利用注释执行非法命令</li>
<li>传入非法参数</li>
<li>添加额外条件</li>
</ul>
<p><strong>避免SQL注入的一些方法</strong>：</p>
<ul>
<li><strong>限制数据库权限</strong>，给用户提供仅仅能够满足其工作的最低权限。</li>
<li>对进入数据库的特殊字符（’”\尖括号&amp;*;等）<strong>转义处理</strong>。</li>
<li>提供参数化查询接口，不要直接使用原生SQL。</li>
</ul>
<h2 id="负载均衡算法有哪些？"><a href="#负载均衡算法有哪些？" class="headerlink" title="负载均衡算法有哪些？"></a><a target="_blank" rel="noopener" href="https://www.javalearn.cn/#/doc/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%9D%A2%E8%AF%95%E9%A2%98?id=_37-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AE%97%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F">负载均衡算法有哪些？</a></h2><p>多台服务器以对称的方式组成一个服务器集合，每台服务器都具有等价的地位，能互相分担负载。</p>
<ul>
<li>轮询法：将请求按照顺序轮流的分配到服务器上。大锅饭，不能发挥某些高性能服务器的优势。</li>
<li>随机法：随机获取一台，和轮询类似。</li>
<li>哈希法：通过ip地址哈希化（我客户端的Ip地址 也就是每个客户端请求到的服务器固定）来确定要选择的服务器编号。好处是,每次客户端访问的服务器都是同一个服务器，能很好地利用session或者cookie。</li>
<li>加权轮询：根据服务器性能不同加权。</li>
</ul>
<h2 id="HTTP-1-0和HTTP-1-1的主要-区别"><a href="#HTTP-1-0和HTTP-1-1的主要-区别" class="headerlink" title="HTTP 1.0和HTTP 1.1的主要 区别"></a>HTTP 1.0和HTTP 1.1的主要 区别</h2><p>1、长连接</p>
<p>在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，在HTTP1.1中默认开启<code>Connection： keep-alive</code>，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点。</p>
<p>2、错误状态响应码多了</p>
<p>新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。</p>
<p>3、缓存策略多了</p>
<p>4、只请求资源一部分，优化带宽</p>
<p>5、Host头处理：在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）。</p>
<h2 id="HTTP1-1和-HTTP2-0的区别？"><a href="#HTTP1-1和-HTTP2-0的区别？" class="headerlink" title="HTTP1.1和 HTTP2.0的区别？"></a><a target="_blank" rel="noopener" href="https://www.javalearn.cn/#/doc/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%9D%A2%E8%AF%95%E9%A2%98?id=_25-http11%E5%92%8C-http20%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F">HTTP1.1和 HTTP2.0的区别？</a></h2><p>HTTP2.0相比HTTP1.1支持的特性：</p>
<ul>
<li><strong>新的二进制格式</strong>：HTTP1.1的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合。基于这种考虑HTTP2.0的协议解析决定采用二进制格式，实现方便且健壮。</li>
<li><strong>多路复用</strong>，即连接共享，即每一个request都是用作连接共享机制的。一个request对应一个id，这样一个连接上可以有多个request，每个连接的request可以随机的混杂在一起，接收方可以根据request的 id将request再归属到各自不同的服务端请求里面。</li>
<li><strong>头部压缩</strong>，HTTP1.1的头部（header）带有大量信息，而且每次都要重复发送；HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小。</li>
<li><strong>服务端推送</strong>：服务器除了对最初请求的响应外，服务器还可以额外的向客户端推送资源，而无需客户端明确的请求。</li>
</ul>
<h2 id="URI和URL的区别是什么"><a href="#URI和URL的区别是什么" class="headerlink" title="URI和URL的区别是什么?"></a>URI和URL的区别是什么?</h2><p>都可以标识一个资源 但URL可以定位到这个资源</p>
<h2 id="HTTP-和-HTTPS-的区别？"><a href="#HTTP-和-HTTPS-的区别？" class="headerlink" title="HTTP 和 HTTPS 的区别？"></a>HTTP 和 HTTPS 的区别？</h2><p><img src="https://raw.githubusercontent.com/viacheung/img/main/image/image-20230404211801661.png" alt="img"></p>
<p>1、端口  80-443  <a target="_blank" rel="noopener" href="http://---&gt;https//">http://---&gt;https://</a></p>
<p>2、安全性和资源消耗：HTTP协议运⾏在TCP之上，所有传输的内容都是明⽂，客户端和服务器端都⽆法验证对⽅的身份。 HTTPS是运⾏在SSL&#x2F;TLS之上的HTTP协议， SSL&#x2F;TLS 运⾏在TCP之上。所有传输的内容都经过加密，加密采⽤对称加密，但对称加密的密钥⽤服务器⽅的证书进⾏了⾮对称加密。所以说， HTTP 安全性没有 HTTPS⾼，但是 HTTPS ⽐HTTP耗费更多服务器资源</p>
<p>对称加密：密钥只有⼀个，加密解密为同⼀个密码   DES、 AES等；<br>⾮对称加密：密钥成对出现，加密解密使⽤不同密钥（公钥加密需要私钥解密，私钥加密需要公钥解密），相对对称加密速度较慢，典型的⾮对称加密算法有RSA、 DSA等</p>
<h2 id="HTTPS-的优缺点"><a href="#HTTPS-的优缺点" class="headerlink" title="HTTPS 的优缺点?"></a><a target="_blank" rel="noopener" href="https://www.javalearn.cn/#/doc/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%9D%A2%E8%AF%95%E9%A2%98?id=_27-https-%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9">HTTPS 的优缺点?</a></h2><p><strong>优点</strong>：</p>
<ul>
<li><p>安全性： </p>
</li>
<li><ul>
<li>使用HTTPS协议可认证用户和服务器，确保数据发送到正确的客户机和服务器；</li>
<li>HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全，可防止数据在传输过程中不被窃取、改变，确保数据的完整性。</li>
<li>HTTPS是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本。</li>
</ul>
</li>
<li><p>SEO方面：谷歌曾在2014年8月份调整搜索引擎算法，并称“比起同等HTTP网站，采用HTTPS加密的网站在搜索结果中的排名将会更高”。</p>
</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>在相同网络环境中，HTTPS 相比 HTTP 无论是响应时间还是耗电量都有大幅度上升。</li>
<li>HTTPS 的安全是有范围的，在黑客攻击、服务器劫持等情况下几乎起不到作用。</li>
<li>在现有的证书机制下，中间人攻击依然有可能发生。</li>
<li>HTTPS 需要更多的服务器资源，也会导致成本的升高。</li>
</ul>
<h2 id="讲一讲HTTPS-的原理？"><a href="#讲一讲HTTPS-的原理？" class="headerlink" title="讲一讲HTTPS 的原理？"></a><a target="_blank" rel="noopener" href="https://www.javalearn.cn/#/doc/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%9D%A2%E8%AF%95%E9%A2%98?id=_28-%E8%AE%B2%E4%B8%80%E8%AE%B2https-%E7%9A%84%E5%8E%9F%E7%90%86%EF%BC%9F">讲一讲HTTPS 的原理？</a></h2><p><img src="https://raw.githubusercontent.com/viacheung/img/main/image/image-20210525160006424.png" alt="img"></p>
<p>图片来源：<a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000021494676">https://segmentfault.com/a/1190000021494676</a></p>
<p>加密流程按图中的序号分为：</p>
<ol>
<li>客户端请求 HTTPS 网址，然后连接到 server 的 443 端口 (HTTPS 默认端口，类似于 HTTP 的80端口)。 </li>
<li>采用 HTTPS 协议的服务器必须要有一套数字 CA (Certification Authority)证书。颁发证书的同时会产生一个私钥和公钥。私钥由服务端自己保存，不可泄漏。公钥则是附带在证书的信息中，可以公开的。证书本身也附带一个证书电子签名，这个签名用来验证证书的完整性和真实性，可以防止证书被篡改。 </li>
<li>服务器响应客户端请求，将证书传递给客户端，证书包含公钥和大量其他信息，比如证书颁发机构信息，公司信息和证书有效期等。 </li>
<li>客户端解析证书并对其进行验证。如果证书不是可信机构颁布，或者证书中的域名与实际域名不一致，或者证书已经过期，就会向访问者显示一个警告，由其选择是否还要继续通信。<br>   如果证书没有问题，客户端就会从服务器证书中取出服务器的公钥A。然后客户端还会生成一个随机码 KEY，并使用公钥A将其加密。 </li>
<li>客户端把加密后的随机码 KEY 发送给服务器，作为后面对称加密的密钥。 </li>
<li>服务器在收到随机码 KEY 之后会使用私钥B将其解密。经过以上这些步骤，客户端和服务器终于建立了安全连接，完美解决了对称加密的密钥泄露问题，接下来就可以用对称加密愉快地进行通信了。 </li>
<li>服务器使用密钥 (随机码 KEY)对数据进行对称加密并发送给客户端，客户端使用相同的密钥 (随机码 KEY)解密数据。 </li>
<li>双方使用对称加密愉快地传输所有数据。</li>
</ol>
<h2 id="校验和"><a href="#校验和" class="headerlink" title="校验和"></a>校验和</h2><h3 id="常用校验算法简单说明："><a href="#常用校验算法简单说明：" class="headerlink" title="常用校验算法简单说明："></a>常用校验算法简单说明：</h3><p>1：<strong>校验和</strong>：按每个字节，计算累加和，</p>
<p>2：<strong>异或校验</strong>：定义初值，按每个字节异或，求结果。</p>
<p>3：<strong>CRC校验</strong>：已有很多的标准及计算方式，可以返回8字节，16字节，32字节的结果。</p>
<p>所谓校验和，就是将被校验数据进行累加，并舍弃累加溢出的位，最终得到的1个或多个字节的结果。验证数据的准确性</p>

    </div>

    
    
    
        <div class="reward-container">
  <div>“坚持原创技术分享，您的支持将鼓励我继续创作!“</div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/images/wechatpay.jpg" alt="ViaCheung 微信支付">
        <p>微信支付</p>
      </div>

  </div>
</div>

        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>ViaCheung
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://viacheung.github.io/2023/06/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" title="计算机网络">http://viacheung.github.io/2023/06/04/计算机网络/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/zh-CN" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2023/06/04/%E5%9B%9E%E6%BA%AF/" rel="prev" title="回溯">
      <i class="fa fa-chevron-left"></i> 回溯
    </a></div>
      <div class="post-nav-item">
    <a href="/2023/06/04/%E5%BC%80%E5%8F%91%E5%B2%97%E5%BC%80%E5%8F%91%E9%A2%98/" rel="next" title="开发岗开发题">
      开发岗开发题 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9A%84%E5%90%84%E5%B1%82%E5%8D%8F%E8%AE%AE%E5%8F%8A%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="nav-number">1.</span> <span class="nav-text">计算机网络的各层协议及作用？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%88%86%E5%B1%82%EF%BC%9F"><span class="nav-number">2.</span> <span class="nav-text">为什么分层？</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BE%8B%E5%AD%90"><span class="nav-number">2.1.</span> <span class="nav-text">例子</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B-%EF%BC%88%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5%EF%BC%89"><span class="nav-number">3.</span> <span class="nav-text">三次握手 （建立连接）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%EF%BC%8C%E8%80%8C%E4%B8%8D%E6%98%AF%E4%B8%A4%E6%AC%A1%EF%BC%9F"><span class="nav-number">4.</span> <span class="nav-text">为什么需要三次握手，而不是两次？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%EF%BC%8C%E8%80%8C%E4%B8%8D%E6%98%AF%E5%9B%9B%E6%AC%A1%EF%BC%9F"><span class="nav-number">5.</span> <span class="nav-text">为什么要三次握手，而不是四次？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-SYN%E6%B4%AA%E6%B3%9B%E6%94%BB%E5%87%BB%EF%BC%9F%E5%A6%82%E4%BD%95%E9%98%B2%E8%8C%83%EF%BC%9F"><span class="nav-number">6.</span> <span class="nav-text">什么是 SYN洪泛攻击？如何防范？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E8%BF%9E%E6%8E%A5%E9%98%B6%E6%AE%B5%EF%BC%8C%E6%9C%80%E5%90%8E%E4%B8%80%E6%AC%A1ACK%E5%8C%85%E4%B8%A2%E5%A4%B1%EF%BC%8C%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">7.</span> <span class="nav-text">三次握手连接阶段，最后一次ACK包丢失，会发生什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%EF%BC%88%E6%96%AD%E5%BC%80%E8%BF%9E%E6%8E%A5%EF%BC%89"><span class="nav-number">8.</span> <span class="nav-text">四次挥手（断开连接）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%9E%E6%8E%A5%E7%9A%84%E6%97%B6%E5%80%99%E6%98%AF%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%EF%BC%8C%E5%85%B3%E9%97%AD%E7%9A%84%E6%97%B6%E5%80%99%E5%8D%B4%E6%98%AF%E5%9B%9B%E6%AC%A1%E6%8F%A1%E6%89%8B%EF%BC%9F"><span class="nav-number">9.</span> <span class="nav-text">为什么连接的时候是三次握手，关闭的时候却是四次握手？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84-TIME-WAIT-%E7%8A%B6%E6%80%81%E5%BF%85%E9%A1%BB%E7%AD%89%E5%BE%85-2MSL-%EF%BC%9F"><span class="nav-number">10.</span> <span class="nav-text">为什么客户端的 TIME-WAIT 状态必须等待 2MSL ？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E6%9E%9C%E5%B7%B2%E7%BB%8F%E5%BB%BA%E7%AB%8B%E4%BA%86%E8%BF%9E%E6%8E%A5%EF%BC%8C%E4%BD%86%E6%98%AF%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%87%BA%E7%8E%B0%E6%95%85%E9%9A%9C%E4%BA%86%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F"><span class="nav-number">11.</span> <span class="nav-text">如果已经建立了连接，但是客户端出现故障了怎么办？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TIME-WAIT-%E7%8A%B6%E6%80%81%E8%BF%87%E5%A4%9A%E4%BC%9A%E4%BA%A7%E7%94%9F%E4%BB%80%E4%B9%88%E5%90%8E%E6%9E%9C%EF%BC%9F%E6%80%8E%E6%A0%B7%E5%A4%84%E7%90%86%EF%BC%9F"><span class="nav-number">12.</span> <span class="nav-text">TIME-WAIT 状态过多会产生什么后果？怎样处理？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TIME-WAIT-%E6%98%AF%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E7%9A%84%E7%8A%B6%E6%80%81-%E8%BF%98%E6%98%AF%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84%E7%8A%B6%E6%80%81"><span class="nav-number">13.</span> <span class="nav-text">TIME_WAIT 是服务器端的状态?还是客户端的状态?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%A6%E7%BB%86%E8%AE%B2%E4%B8%80%E4%B8%8BTCP%E7%9A%84%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%EF%BC%9F"><span class="nav-number">14.</span> <span class="nav-text">详细讲一下TCP的滑动窗口？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TCP-VS-UD"><span class="nav-number">15.</span> <span class="nav-text">TCP VS UD</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#UDP-%E5%92%8C-TCP-%E5%AF%B9%E5%BA%94%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">16.</span> <span class="nav-text">UDP 和 TCP 对应的应用场景是什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TCP-%E5%8D%8F%E8%AE%AE%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93"><span class="nav-number">17.</span> <span class="nav-text">TCP 协议如何保证可靠传输</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ARQ"><span class="nav-number">18.</span> <span class="nav-text">ARQ</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%81%9C%E2%BD%8C%E7%AD%89%E5%BE%85ARQ%E5%8D%8F%E8%AE%AE"><span class="nav-number">18.1.</span> <span class="nav-text">停⽌等待ARQ协议</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9E%E7%BB%ADARQ%E5%8D%8F%E8%AE%AE"><span class="nav-number">18.2.</span> <span class="nav-text">连续ARQ协议</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%BB%91%E5%8A%A8%E7%AA%97%E2%BC%9D%E5%92%8C%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6"><span class="nav-number">19.</span> <span class="nav-text">滑动窗⼝和流量控制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6"><span class="nav-number">20.</span> <span class="nav-text">拥塞控制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HTTP%E5%B8%B8%E8%A7%81%E7%9A%84%E7%8A%B6%E6%80%81%E7%A0%81%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="nav-number">21.</span> <span class="nav-text">HTTP常见的状态码有哪些？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%8A%B6%E6%80%81%E7%A0%81301%E5%92%8C302%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">22.</span> <span class="nav-text">状态码301和302的区别是什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HTTP-%E5%B8%B8%E7%94%A8%E7%9A%84%E8%AF%B7%E6%B1%82%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="nav-number">23.</span> <span class="nav-text">HTTP 常用的请求方式？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#GET%E8%AF%B7%E6%B1%82%E5%92%8CPOST%E8%AF%B7%E6%B1%82%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">24.</span> <span class="nav-text">GET请求和POST请求的区别？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E8%BE%93%E2%BC%8Aurl%E5%9C%B0%E5%9D%80-gt-gt-%E6%98%BE%E7%A4%BA%E4%B8%BB%E2%BB%9A%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="nav-number">25.</span> <span class="nav-text">在浏览器中输⼊url地址 -&gt;&gt; 显示主⻚的过程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%90%84%E7%A7%8D%E5%8D%8F%E8%AE%AE%E4%B8%8EHTTP%E5%8D%8F%E8%AE%AE%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-number">26.</span> <span class="nav-text">各种协议与HTTP协议之间的关系</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HTTP%E2%BB%93%E8%BF%9E%E6%8E%A5-%E7%9F%AD%E8%BF%9E%E6%8E%A5"><span class="nav-number">27.</span> <span class="nav-text">HTTP⻓连接,短连接</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HTTP%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87%E5%92%8C%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87%E7%9A%84%E6%A0%BC%E5%BC%8F%EF%BC%9F"><span class="nav-number">28.</span> <span class="nav-text">HTTP请求报文和响应报文的格式？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HTTP%E6%98%AF%E4%B8%8D%E4%BF%9D%E5%AD%98%E7%8A%B6%E6%80%81%E7%9A%84%E5%8D%8F%E8%AE%AE-%E5%A6%82%E4%BD%95%E4%BF%9D%E5%AD%98%E2%BD%A4%E6%88%B7%E7%8A%B6%E6%80%81"><span class="nav-number">29.</span> <span class="nav-text">HTTP是不保存状态的协议,如何保存⽤户状态?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Cookie-%E8%A2%AB%E7%A6%81%E2%BD%A4%E6%80%8E%E4%B9%88%E5%8A%9E"><span class="nav-number">30.</span> <span class="nav-text">Cookie 被禁⽤怎么办?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-Cookie-%E5%92%8C-Session"><span class="nav-number">31.</span> <span class="nav-text">什么是 Cookie 和 Session ?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Cookie-%E5%92%8C-Session-%E6%98%AF%E5%A6%82%E4%BD%95%E9%85%8D%E5%90%88%E7%9A%84%E5%91%A2%EF%BC%9F"><span class="nav-number">32.</span> <span class="nav-text">Cookie 和 Session 是如何配合的呢？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Cookie%E5%92%8CSession%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">33.</span> <span class="nav-text">Cookie和Session的区别？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E8%80%83%E8%99%91%E5%88%86%E5%B8%83%E5%BC%8F-Session-%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="nav-number">34.</span> <span class="nav-text">如何考虑分布式 Session 问题？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88-Cookie-%E6%97%A0%E6%B3%95%E9%98%B2%E6%AD%A2-CSRF-%E6%94%BB%E5%87%BB%EF%BC%8C%E8%80%8C-Token-%E5%8F%AF%E4%BB%A5%EF%BC%9F"><span class="nav-number">35.</span> <span class="nav-text">为什么 Cookie 无法防止 CSRF 攻击，而 Token 可以？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFDDos%E6%94%BB%E5%87%BB%EF%BC%9F"><span class="nav-number">36.</span> <span class="nav-text">什么是DDos攻击？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFXSS%E6%94%BB%E5%87%BB%EF%BC%9F"><span class="nav-number">37.</span> <span class="nav-text">什么是XSS攻击？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SQL%E6%B3%A8%E5%85%A5%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8DSQL%E6%B3%A8%E5%85%A5%EF%BC%9F"><span class="nav-number">38.</span> <span class="nav-text">SQL注入是什么，如何避免SQL注入？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AE%97%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="nav-number">39.</span> <span class="nav-text">负载均衡算法有哪些？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HTTP-1-0%E5%92%8CHTTP-1-1%E7%9A%84%E4%B8%BB%E8%A6%81-%E5%8C%BA%E5%88%AB"><span class="nav-number">40.</span> <span class="nav-text">HTTP 1.0和HTTP 1.1的主要 区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HTTP1-1%E5%92%8C-HTTP2-0%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">41.</span> <span class="nav-text">HTTP1.1和 HTTP2.0的区别？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#URI%E5%92%8CURL%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">42.</span> <span class="nav-text">URI和URL的区别是什么?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HTTP-%E5%92%8C-HTTPS-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">43.</span> <span class="nav-text">HTTP 和 HTTPS 的区别？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HTTPS-%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-number">44.</span> <span class="nav-text">HTTPS 的优缺点?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%B2%E4%B8%80%E8%AE%B2HTTPS-%E7%9A%84%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="nav-number">45.</span> <span class="nav-text">讲一讲HTTPS 的原理？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%A1%E9%AA%8C%E5%92%8C"><span class="nav-number">46.</span> <span class="nav-text">校验和</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E6%A0%A1%E9%AA%8C%E7%AE%97%E6%B3%95%E7%AE%80%E5%8D%95%E8%AF%B4%E6%98%8E%EF%BC%9A"><span class="nav-number">46.1.</span> <span class="nav-text">常用校验算法简单说明：</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="ViaCheung"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">ViaCheung</p>
  <div class="site-description" itemprop="description">el psy congroo</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">40</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/viacheung" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;viacheung" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:viacheung5@gmail.com" title="E-Mail → mailto:viacheung5@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/zh-CN" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ViaCheung</span>
</div>

<!--
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div> -->

<!-- 网站运行时间的设置 -->
<span id="timeDate">载入天数...</span>
<span id="times">载入时分秒...</span>
<script>
    var now = new Date();
    function createtime() {
        var grt= new Date("03/01/2023 10:00:00"); //此处修改你的建站时间或者网站上线时间
        now.setTime(now.getTime()+250);
        days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days);
        hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours);
        if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);
        mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;}
        seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
        snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;}
        document.getElementById("timeDate").innerHTML = "本站已安全运行 "+dnum+" 天 ";
        document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒.";
    }
setInterval("createtime()",250);
</script>
        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>

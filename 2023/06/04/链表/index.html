<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.1.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"viacheung.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="前言常用方法：dummyNode空结点 、双指针、快慢指针">
<meta property="og:type" content="article">
<meta property="og:title" content="链表">
<meta property="og:url" content="http://viacheung.github.io/2023/06/04/%E9%93%BE%E8%A1%A8/index.html">
<meta property="og:site_name" content="命运石之门">
<meta property="og:description" content="前言常用方法：dummyNode空结点 、双指针、快慢指针">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/viacheung/img/main/image/image-20220915164549004.png">
<meta property="og:image" content="https://raw.githubusercontent.com/viacheung/img/main/image/image-20221015173826107.png">
<meta property="og:image" content="https://raw.githubusercontent.com/viacheung/img/main/image/image-20221015163411413.png">
<meta property="og:image" content="https://raw.githubusercontent.com/viacheung/img/main/image/image-20221015163434779.png">
<meta property="og:image" content="https://raw.githubusercontent.com/viacheung/img/main/image/image-20221014152913347.png">
<meta property="og:image" content="https://raw.githubusercontent.com/viacheung/img/main/image/image-20221014152957745.png">
<meta property="og:image" content="https://raw.githubusercontent.com/viacheung/img/main/image/image-20221014160959772.png">
<meta property="og:image" content="https://raw.githubusercontent.com/viacheung/img/main/image/dacd1bf55dec5c8b38d0904f26e472e2024fc8bee4ea46e3aa676f340ba1eb9d-%E9%80%92%E5%BD%92.gif">
<meta property="og:image" content="https://raw.githubusercontent.com/viacheung/img/main/image/image-20221015175612893.png">
<meta property="og:image" content="https://raw.githubusercontent.com/viacheung/img/main/image/image-20221015181031942.png">
<meta property="og:image" content="https://raw.githubusercontent.com/viacheung/img/main/image/160_statement.png">
<meta property="og:image" content="https://raw.githubusercontent.com/viacheung/img/main/image/image-20220910174724580.png">
<meta property="og:image" content="https://raw.githubusercontent.com/viacheung/img/main/image/image-20221015175222441.png">
<meta property="og:image" content="https://raw.githubusercontent.com/viacheung/img/main/image/image-20230402185058710.png">
<meta property="og:image" content="https://raw.githubusercontent.com/viacheung/img/main/image/image-20230402185131136.png">
<meta property="og:image" content="https://raw.githubusercontent.com/viacheung/img/main/image/D024AA6BA7A670402678A9ACAD54EB10">
<meta property="og:image" content="https://raw.githubusercontent.com/viacheung/img/main/image/image-20230403212432459.png">
<meta property="og:image" content="https://raw.githubusercontent.com/viacheung/img/main/image/image-20230406191651380.png">
<meta property="article:published_time" content="2023-06-04T09:42:50.000Z">
<meta property="article:modified_time" content="2023-06-04T09:47:05.636Z">
<meta property="article:author" content="ViaCheung">
<meta property="article:tag" content="Java,python">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/viacheung/img/main/image/image-20220915164549004.png">

<link rel="canonical" href="http://viacheung.github.io/2023/06/04/%E9%93%BE%E8%A1%A8/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>链表 | 命运石之门</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">命运石之门</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">欢迎来到我的博客空间🙇</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://viacheung.github.io/2023/06/04/%E9%93%BE%E8%A1%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="ViaCheung">
      <meta itemprop="description" content="el psy congroo">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="命运石之门">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          链表
        </h1>

        <div class="post-meta">
	  <span class="post-time">

	  
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-06-04 17:42:50 / 修改时间：17:47:05" itemprop="dateCreated datePublished" datetime="2023-06-04T17:42:50+08:00">2023-06-04</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>常用方法：dummyNode空结点 、双指针、快慢指针<span id="more"></span></p>
<p>链表好多都可以用递归或者迭代，递归简洁不好想，但迭代好理解</p>
<p>ListNode是由自己定义的java中的链表对象</p>
<p><img src="https://raw.githubusercontent.com/viacheung/img/main/image/image-20220915164549004.png" alt="img"></p>
<p>类结构如下</p>
<pre><code class="plain">public class ListNode &#123;
        int val;
        ListNode next;
        public ListNode(int x) &#123;
             val = x;
        &#125;
 &#125;
</code></pre>
<h2 id="删除链表结点"><a href="#删除链表结点" class="headerlink" title="删除链表结点"></a>删除链表结点</h2><pre><code class="plain">class Solution &#123;
     public ListNode removeElements(ListNode head, int val) &#123;
         ListNode dumyNode=new ListNode();
         dumyNode.next=head;
         ListNode cur=dumyNode;
         while(cur.next!=null)&#123;
             if(cur.next.val==val)&#123;
                 cur.next=cur.next.next;
             &#125;else&#123;
                 cur=cur.next;
             &#125;
         &#125;
         return dumyNode.next;
     &#125;
 &#125;
</code></pre>
<h2 id="删除链表的倒数第-N-个结点"><a href="#删除链表的倒数第-N-个结点" class="headerlink" title="删除链表的倒数第 N 个结点"></a>删除链表的倒数第 N 个结点</h2><p>给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。</p>
<p>方法一：一种容易想到的方法是，我们首先从头节点开始对链表进行一次遍历，得到链表的长度 L。随后我们再从头节点开始对链表进行一次遍历，当遍历到第 L−n+1 个节点时，它就是我们需要删除的节点。</p>
<p>方法二：我们也可以在遍历链表的同时将所有节点依次入栈。根据栈「先进后出」的原则，我们弹出栈的第 n 个节点就是需要删除的节点，并且目前栈顶的节点就是待删除节点的前驱节点。这样一来，删除操作就变得十分方便了。</p>
<p><img src="https://raw.githubusercontent.com/viacheung/img/main/image/image-20221015173826107.png" alt="img"></p>
<p> ListNode dummy &#x3D; new ListNode(0, head);&#x2F;&#x2F;val为0 下一个结点为head</p>
<pre><code class="plain">//我喜欢方法三
 class Solution &#123;
     public ListNode removeNthFromEnd(ListNode head, int n) &#123;
         // 双指针
         ListNode dummyNode =new ListNode(0);
         dummyNode.next=head;
         //用dummyNode好删除
         ListNode node1=dummyNode;
         ListNode node2=dummyNode;
         //Node1先往后移动n个位置
         for(int i=0;i&lt;n;i++)&#123;
              node1=node1.next;
         &#125;
         //这俩同时移动 node1.next!=null这个判断条件是为了到最后一个节点 而不是null节点
         while(node1.next!=null)&#123;
             node1=node1.next;
             node2=node2.next;
         &#125;
         //删除
         node2.next=node2.next.next;
         return dummyNode.next;
     &#125;
 &#125;
</code></pre>
<h2 id="两两交换链表中的节点24"><a href="#两两交换链表中的节点24" class="headerlink" title="两两交换链表中的节点24"></a>两两交换链表中的节点24</h2><p>给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。</p>
<p><img src="https://raw.githubusercontent.com/viacheung/img/main/image/image-20221015163411413.png" alt="img"></p>
<pre><code class="plain">class Solution &#123;
     public ListNode swapPairs(ListNode head) &#123;
         if (head == null || head.next == null) &#123;
             return head;
         &#125;
         ListNode newHead = head.next;
         head.next = swapPairs(newHead.next);
         newHead.next = head;
         return newHead;
     &#125;
 &#125;
</code></pre>
<p>选择迭代！</p>
<p><img src="https://raw.githubusercontent.com/viacheung/img/main/image/image-20221015163434779.png" alt="img"></p>
<pre><code class="plain">class Solution &#123;
     public ListNode swapPairs(ListNode head) &#123;
         ListNode dummyNode=new ListNode(0);
         dummyNode.next=head;
         ListNode temp=dummyNode;
         while(temp.next!=null&amp;&amp;temp.next.next!=null)&#123;
            //存一下
             ListNode node1=temp.next;
             ListNode node2=temp.next.next;
             //node1指向node2指向的
             node1.next=node2.next;
             //temp指向node2
             temp.next=node2;
             //node2--&gt;node1
             node2.next=node1;
             //移动temp
             temp=node1;
         &#125;
         //返回头结点
         return dummyNode.next;
     &#125;
 &#125;
</code></pre>
<h2 id="移除链表元素203"><a href="#移除链表元素203" class="headerlink" title="移除链表元素203"></a>移除链表元素203</h2><p>优先迭代</p>
<p>给你一个链表的头节点 head 和一个整数 val ，请你删除链表中所有满足 Node.val &#x3D;&#x3D; val 的节点，并返回 <strong>新的头节点</strong> 。</p>
<p><img src="https://raw.githubusercontent.com/viacheung/img/main/image/image-20221014152913347.png" alt="img"></p>
<p>要求返回头节点 最好的方法 用一个dumyNode！！！！</p>
<pre><code class="plain">class Solution &#123;
     public ListNode removeElements(ListNode head, int val) &#123;
         ListNode dumyNode=new ListNode();
         dumyNode.next=head;
         ListNode cur=dumyNode;
         while(cur.next!=null)&#123;
             if(cur.next.val==val)&#123;
                 cur.next=cur.next.next;
             &#125;else&#123;
                 cur=cur.next;
             &#125;
         &#125;
         return dumyNode.next;
     &#125;
 &#125;
</code></pre>
<p>优先方法二，比较好理解。</p>
<p><img src="https://raw.githubusercontent.com/viacheung/img/main/image/image-20221014152957745.png" alt="img"></p>
<h2 id="设计链表"><a href="#设计链表" class="headerlink" title="设计链表"></a>设计链表</h2><p><img src="https://raw.githubusercontent.com/viacheung/img/main/image/image-20221014160959772.png" alt="img"></p>
<p><strong>单链表</strong></p>
<pre><code class="plain">class MyLinkedList &#123;
     //用哨兵节点（值为0）当作头结点(但不是真的头结点)
     int size;
     ListNode head;
     //初始化
     public MyLinkedList() &#123;
         size=0;
         head=new ListNode(0);
     &#125;
     
     public int get(int index) &#123;
         if(index&lt;0||index&gt;=size)&#123;
             return -1;
         &#125;
         ListNode cur=head;
         for(int i=0;i&lt;=index;i++)&#123;
             cur=cur.next;
         &#125;
         return cur.val;
     &#125;
     //操作某个结点 cur到它前面一个去
     public void addAtHead(int val) &#123;
         addAtIndex(0,val);
     &#125;
     
     public void addAtTail(int val) &#123;
         addAtIndex(size,val);
     &#125;
     
     public void addAtIndex(int index, int val) &#123;
         if(index&gt;size)&#123;
             return;
         &#125;
         //小于0设为0
         index=index&lt;0?0:index;
         ListNode tar=new ListNode(val);
         ListNode cur=head;
         for(int i=0;i&lt;index;i++)&#123;
             cur=cur.next;
         &#125;
         tar.next=cur.next;
         cur.next=tar;
         size++;
     &#125;
     
     public void deleteAtIndex(int index) &#123;
         if(index&lt;0||index&gt;=size)&#123;
             return;
         &#125;
         ListNode cur=head;
         for(int i=0;i&lt;index;i++)&#123;
             cur=cur.next;
         &#125;
         cur.next=cur.next.next;
         size--;
     &#125;
 &#125;
</code></pre>
<p>双链表就不写辣</p>
<h2 id="回文链表"><a href="#回文链表" class="headerlink" title="回文链表"></a>回文链表</h2><p><strong>方法一：将值复制到数组中后用双指针法</strong></p>
<p>一共为两个步骤：</p>
<ol>
<li>复制链表值到数组列表中。</li>
<li>使用双指针法判断是否为回文。node_1.val &#x3D;&#x3D; node_2.val</li>
</ol>
<p><strong>方法二：快慢指针</strong></p>
<ol>
<li>找到前半部分链表的尾节点。</li>
<li>根据前半部分分链表尾结点，反转后半部分链表。</li>
<li>判断是否回文。</li>
<li>恢复链表（再把步骤二做一次）。</li>
<li>返回结果。</li>
</ol>
<pre><code class="plain">/**
  * Definition for singly-linked list.
  * public class ListNode &#123;
  *     int val;
  *     ListNode next;
  *     ListNode() &#123;&#125;
  *     ListNode(int val) &#123; this.val = val; &#125;
  *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;
  * &#125;
  */
 class Solution &#123;
     public boolean isPalindrome(ListNode head) &#123;
         //方法一 辅助数组 双指针
         // ListNode cur=head;
         // int len=0;
         // while(cur!=null)&#123;
         //     len++;
         //     cur=cur.next;
         // &#125;
         // int[] result=new int[len];
         // cur=head;
         // for(int i=0;i&lt;len;i++)&#123;
         //     result[i]=cur.val;
         //     cur=cur.next;
         // &#125;
         // int l=0,r=len-1;
         // while(l&lt;r)&#123;
         //     if(result[l]!=result[r]) return false;
         //     l++;
         //     r--;
         // &#125;
         // return true;
         //方法二 快慢指针
         ListNode slow=head,fast=head,pre=head;
         while(fast!=null&amp;&amp;fast.next!=null)&#123;
             pre=slow;
             slow=slow.next;
             fast=fast.next.next;
         &#125;
         pre.next=null;
         ListNode node1=head;
         ListNode node2=reverseList(slow);
         while(node1!=null)&#123;
             if(node1.val!=node2.val) return false;
             node1=node1.next;
             node2=node2.next;
         &#125;
         return true;
 
     &#125;
     //反转链表
     public ListNode reverseList(ListNode head)&#123;
         ListNode pre=null,temp=null,cur=head;
         while(cur!=null)&#123;
             //记录当前节点的下一个节点
             temp=cur.next;
             //然后将当前节点指向pre            
             cur.next=pre;
             //pre和cur节点都前进一位
             pre=cur;
             cur=temp;
         &#125;
         return pre;
     &#125;
 &#125;
</code></pre>
<h2 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h2><p>最简单的不考虑复杂度的话，利用<strong>外部空间</strong></p>
<p>先申请一个动态扩容的数组或者容器，比如 ArrayList 这样的。然后不断遍历链表，将链表中的元素添加到这个容器中。再利用容器自身的 API，反转整个容器，这样就达到反转的效果了。最后同时遍历容器和链表，将链表中的值改为容器中的值。因为此时容器的值是：</p>
<p>5 4 3 2 1</p>
<p>链表按这个顺序重新被设置一边，就达到要求啦。</p>
<p><strong>一、迭代</strong>（好理解一点）</p>
<p>两个指针，cur和pre，pre先指向Null，cur指向head，然后遍历cur，每次迭代到cur，用一个tmp存储cur的下一结点，然后cur的Next指向pre，pre前进一位（pre指向cur，cur指向tmp）</p>
<p><strong>代码</strong></p>
<pre><code class="plain">class Solution &#123;
     public ListNode reverseList(ListNode head) &#123;
         //申请节点，pre和 cur，pre指向null
         ListNode pre = null;
         ListNode cur = head;
         ListNode tmp = null;
         while(cur!=null) &#123;
             //记录当前节点的下一个节点
             tmp = cur.next;
             //然后将当前节点指向pre
             cur.next = pre;
             //pre和cur节点都前进一位
             pre = cur;
             cur = tmp;
         &#125;
         return pre;
     &#125;
 &#125;
</code></pre>
<p><strong>二、递归（不好理解）</strong></p>
<p>递归的两个条件：</p>
<pre><code class="plain">终止条件是当前节点或者下一个节点==null
 在函数内部，改变节点的指向，也就是 head 的下一个节点指向 head 递归函数那句
</code></pre>
<p>head.next.next &#x3D; head</p>
<p>很不好理解，其实就是 head 的下一个节点指向head。递归函数中每次返回的 cur 其实只最后一个节点，在递归函数内部，改变的是当前节点的指向。动画演示如下：</p>
<p><img src="https://raw.githubusercontent.com/viacheung/img/main/image/dacd1bf55dec5c8b38d0904f26e472e2024fc8bee4ea46e3aa676f340ba1eb9d-%E9%80%92%E5%BD%92.gif" alt="img"></p>
<p>我的理解：先一直执行ListNode cur &#x3D; reverseList(head.next)，一直到head为4的时候，if里面成立（head.next&#x3D;&#x3D;null），跳出，此时cur为5，但是是在4这个结点的递归里面，因此head为4，所以head.next.next 就是5-&gt;4；防止链表循环（因为已经形成了一个环了），需要将head.next设置为空，然后返回cur，因为每层递归函数都返回cur。</p>
<pre><code class="plain">class Solution &#123;
     public ListNode reverseList(ListNode head) &#123;
         //递归终止条件是当前为空，或者下一个节点为空
         if(head==null || head.next==null) &#123;
             return head;
         &#125;
         //这里的cur就是最后一个节点
         ListNode cur = reverseList(head.next);
         //这里请配合动画演示理解
         //如果链表是 1-&gt;2-&gt;3-&gt;4-&gt;5，那么此时的cur就是5
         //而head是4，head的下一个是5，下下一个是空
         //所以head.next.next 就是5-&gt;4
         head.next.next = head;
         //防止链表循环，需要将head.next设置为空
         head.next = null;
         //每层递归函数都返回cur，也就是最后一个节点
         return cur;
     &#125;
 &#125;
</code></pre>
<h2 id="环形链表I"><a href="#环形链表I" class="headerlink" title="环形链表I"></a>环形链表I</h2><p><img src="https://raw.githubusercontent.com/viacheung/img/main/image/image-20221015175612893.png" alt="img"></p>
<p><strong>方法一：哈希表</strong></p>
<p>最容易想到的方法是遍历所有节点，每次遍历到一个节点时，判断该节点此前是否被访问过。</p>
<p>具体地，我们可以使用哈希表来存储所有已经访问过的节点。每次我们到达一个节点，如果该节点已经存在于哈希表中，则说明该链表是环形链表，否则就将该节点加入哈希表中。重复这一过程，直到我们遍历完整个链表即可。</p>
<pre><code class="plain">public class Solution &#123;
     public boolean hasCycle(ListNode head) &#123;
         Set&lt;ListNode&gt; seen = new HashSet&lt;ListNode&gt;();
         while (head != null) &#123;
             if (!seen.add(head)) &#123;
                 return true;
             &#125;
             head = head.next;
         &#125;
         return false;
     &#125;
 &#125;
</code></pre>
<p><strong>方法二：快慢指针</strong>（龟兔赛跑）</p>
<p>本方法需要读者对「Floyd 判圈算法」（又称龟兔赛跑算法）有所了解。</p>
<p>假想「乌龟」和「兔子」在链表上移动，「兔子」跑得快，「乌龟」跑得慢。当「乌龟」和「兔子」从链表上的同一个节点开始移动时，如果该链表中没有环，那么「兔子」将一直处于「乌龟」的前方；如果该链表中有环，那么「兔子」会先于「乌龟」进入环，并且一直在环内移动。等到「乌龟」进入环时，由于「兔子」的速度快，它一定会在某个时刻与乌龟相遇，即套了「乌龟」若干圈。</p>
<p>我们可以根据上述思路来解决本题。具体地，我们定义两个指针，一快一慢。慢指针每次只移动一步，而快指针每次移动两步。初始时，慢指针在位置 head，而快指针在位置 head.next。这样一来，如果在移动的过程中，快指针反过来追上慢指针，就说明该链表为环形链表。否则快指针将到达链表尾部，该链表不为环形链表。</p>
<p><strong>细节</strong></p>
<p>为什么我们要规定初始时慢指针在位置 head，快指针在位置 head.next，而不是两个指针都在位置 head（即与「乌龟」和「兔子」中的叙述相同）？</p>
<p>观察下面的代码，我们使用的是 while 循环，循环条件先于循环体。由于循环条件一定是判断快慢指针是否重合，如果我们将两个指针初始都置于 head，那么 while 循环就不会执行。因此，我们可以假想一个在 head 之前的虚拟节点，慢指针从虚拟节点移动一步到达 head，快指针从虚拟节点移动两步到达 head.next，这样我们就可以使用 while 循环了。</p>
<p>当然，我们也可以使用 do-while 循环。此时，我们就可以把快慢指针的初始值都置为 head。</p>
<pre><code class="plain">public class Solution &#123;
     public boolean hasCycle(ListNode head) &#123;
         if (head == null || head.next == null) &#123;
             return false;
         &#125;
         ListNode slow = head;
         ListNode fast = head.next;
         while (slow != fast) &#123;
             if (fast == null || fast.next == null) &#123;
                 return false;
             &#125;
             slow = slow.next;
             fast = fast.next.next;
         &#125;
         return true;
     &#125;
 &#125;
</code></pre>
<h2 id="环形链表II"><a href="#环形链表II" class="headerlink" title="环形链表II"></a>环形链表II</h2><p>给定一个链表的头节点 head ，返回链表开始入环的第一个节点。 <em>如果链表无环，则返回</em> <em>null**。</em></p>
<p>方法一 哈希</p>
<pre><code class="plain">public class Solution &#123;
     public ListNode detectCycle(ListNode head) &#123;
         Set&lt;ListNode&gt; seen=new HashSet&lt;&gt;();
         while(head!=null)&#123;
             //用contains也可
             if(seen.add(head))&#123;
                 head=head.next;
             &#125;else&#123;
                 return head;
             &#125;
         &#125;
         return null;
     &#125;
 &#125;
</code></pre>
<p>方法二</p>
<p><img src="https://raw.githubusercontent.com/viacheung/img/main/image/image-20221015181031942.png" alt="img"></p>
<p>环形链表和龟兔赛跑很像，也是相遇后，再有一个指针从头开始和slow一起移动，最后相遇即为结果</p>
<pre><code class="plain">public class Solution &#123;
     public ListNode detectCycle(ListNode head) &#123;
         ListNode slow=head,fast=head;
         while(fast!=null&amp;&amp;fast.next!=null)&#123;
             slow=slow.next;
             fast=fast.next.next;
             if(slow==fast)&#123;
                 ListNode node=head;
                 while(node!=slow)&#123;
                     slow=slow.next;
                     node=node.next;
                 &#125;
                 return node;
             &#125;
         &#125;
         return null;
     &#125;
 &#125;
</code></pre>
<p>弗洛伊德循环查找算法结论：</p>
<p>1、如果有环，兔子乌龟(兔子和乌龟可以不在一个位置出发，这个要看具体情况)必定会相遇（判断是否有环，循环问题，链表、快乐数）</p>
<p>2、如果有环，兔子乌龟同时同位置出发，相遇后，再有一个指针从头开始和slow一起移动，最后在入环点相遇。</p>
<h2 id="相交链表-√"><a href="#相交链表-√" class="headerlink" title="相交链表(√)"></a>相交链表(√)</h2><p>给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 null</p>
<p><img src="https://raw.githubusercontent.com/viacheung/img/main/image/160_statement.png" alt="img"></p>
<p><img src="https://raw.githubusercontent.com/viacheung/img/main/image/image-20220910174724580.png" alt="img"></p>
<p><img src="https://raw.githubusercontent.com/viacheung/img/main/image/image-20221015175222441.png" alt="img"></p>
<pre><code class="plain">public ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123;
     if (headA == null || headB == null) return null;
     ListNode pA = headA, pB = headB;
     while (pA != pB) &#123;
         pA = pA == null ? headB : pA.next;
         pB = pB == null ? headA : pB.next;
     &#125;
     return pA;
 &#125;
 总结：当某个结点为空就去另一个链表的头节点（目的是缩短差距 慢慢的这俩就可以一起到达相交结点），直到两者相遇，管他为空还是在一个结点处
</code></pre>
<p>还有一种基本的方法，就是构造一个哈希表，先把A链表的结点都存进去，然后遍历B链表，当某个节点在A里面有则返回之；</p>
<h2 id="两两交换链表中的节点"><a href="#两两交换链表中的节点" class="headerlink" title="两两交换链表中的节点"></a>两两交换链表中的节点</h2><p>给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。</p>
<p>题解：</p>
<p>模拟 娅结点 temp</p>
<pre><code class="plain">class Solution &#123;
     public ListNode swapPairs(ListNode head) &#123;
         ListNode dummyNode=new ListNode(0);
         dummyNode.next=head;
         ListNode temp=dummyNode;
         while(temp.next!=null&amp;&amp;temp.next.next!=null)&#123;
             ListNode node1=temp.next;
             ListNode node2=temp.next.next;
             temp.next=node2;
             node1.next=node2.next;
             node2.next=node1;
             temp=node1;
         &#125;
         return dummyNode.next;
     &#125;
 &#125;
</code></pre>
<h2 id="链表内指定区间反转"><a href="#链表内指定区间反转" class="headerlink" title="链表内指定区间反转"></a><strong>链表内指定区间反转</strong></h2><p><img src="https://raw.githubusercontent.com/viacheung/img/main/image/image-20230402185058710.png" alt="img"></p>
<p>题解：</p>
<p><img src="https://raw.githubusercontent.com/viacheung/img/main/image/image-20230402185131136.png" alt="img"></p>
<p>算法思路：</p>
<p>1、设置一个dummyNode指向头节点 方便后面返回结果</p>
<p>2、pre指到m位置前一个</p>
<p>3、开始工作 for(m-&gt;n )每次把后面一个节点放到头节点位置</p>
<p>4、返回结果</p>
<pre><code class="plain">public ListNode reverseBetween (ListNode head, int m, int n) &#123;
         // write code here
         ListNode dumyNode =new ListNode(-1);
         dumyNode.next=head;
         ListNode pre=dumyNode;
         for(int i=0;i&lt;m-1;i++)&#123;
             pre=pre.next;
         &#125;
         ListNode cur=pre.next;
         for(int i=m;i&lt;n;i++)&#123;
             ListNode curNext=cur.next;
             cur.next=curNext.next;
             curNext.next=pre.next;//这里我原本写的curNext.next=cur 这是不对的 这个算法思路就是每次把后面节点移动到最前面 如果我们在循环里面不改cur 那么此时cur并不是头节点  pre.next最保险；
             pre.next=curNext;
         &#125;
         return dumyNode.next;
     &#125;
</code></pre>
<h2 id="链表中的节点每k个一组翻转"><a href="#链表中的节点每k个一组翻转" class="headerlink" title="链表中的节点每k个一组翻转"></a><strong>链表中的节点每k个一组翻转</strong></h2><p>将给出的链表中的节点每 k 个一组翻转，返回翻转后的链表 如果链表中的节点数不是 k 的倍数，将最后剩下的节点保持原样 你不能更改节点中的值，只能更改节点本身。</p>
<p>题解：</p>
<p>须知：这个方法返回反转后的头节点</p>
<p>1、遍历到下一组的头节点 记为tail 中间如果发现tail为null 直接返回head</p>
<p>2、然后反转链表 此时pre为null 判断条件为cur!&#x3D;tail 平常反转链表条件为cur!&#x3D;null 有异曲同工之妙</p>
<p>3、head.next&#x3D;reverseKGroup(tail,k); 此处为递归 tail正好也是下一组的头节点</p>
<p>4、直接返回pre;</p>
<p><img src="https://raw.githubusercontent.com/viacheung/img/main/image/D024AA6BA7A670402678A9ACAD54EB10" alt="img"></p>
<pre><code class="plain">public ListNode reverseKGroup (ListNode head, int k) &#123;
         // write code here 
         // 这个方法返回的是反转后的头节点
         ListNode tail=head;
         // 此时tail为下一组的头节点
         for(int i=0;i&lt;k;i++)&#123;
             if(tail==null) return head;
             tail=tail.next;
         &#125;
         ListNode pre=null;
         ListNode cur=head;
         while(cur!=tail)&#123;
             ListNode curNext=cur.next;
             cur.next=pre;
             pre=cur;
             cur=curNext;
         &#125;
         head.next=reverseKGroup(tail,k);
         // 最后pre指向的是cur(tail的前一个 也就是本组的最后一个节点（现在变成头节点）)
         return pre;
     &#125;
</code></pre>
<h2 id="合并两个有序链表"><a href="#合并两个有序链表" class="headerlink" title="合并两个有序链表"></a>合并两个有序链表</h2><p>描述</p>
<p>输入两个递增的链表，单个链表的长度为n，合并这两个链表并使新链表中的节点仍然是递增排序的。</p>
<h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>1、如果有一个链表为空，返回另一个链表2、如果pHead1 节点值比小pHead2，下一个节点应该是 pHead1，应该return pHead1，在return之前，指定pHead1的下一个节点应该是pHead1.next和pHead2俩链表的合并后的头结点3、如果pHead1 节点值比pHead2大，下一个节点应该是pHead2，应该return pHead2，在return之前，指定pHead2的下一个节点应该是pHead1和pHead2.next俩链表的合并后的头结点</p>
<pre><code class="plain">public class Solution &#123;
     public ListNode Merge(ListNode list1, ListNode list2) &#123;
         if (list1 == null || list2 == null) return list1 == null ? list2 : list1;
         if (list1.val &gt; list2.val) &#123;
             list2.next = Merge(list2.next, list1);
             return list2;
         &#125; else &#123;
             list1.next = Merge(list1.next, list2);
             return list1;
         &#125;
     &#125;
 &#125;
</code></pre>
<h2 id="链表相加-二"><a href="#链表相加-二" class="headerlink" title="链表相加(二)"></a><strong>链表相加(二)</strong></h2><p><img src="https://raw.githubusercontent.com/viacheung/img/main/image/image-20230403212432459.png" alt="img"></p>
<p>题解：</p>
<p>反转链表后进行相加，每次记录相加后的进位数字</p>
<pre><code class="plain">public ListNode addInList (ListNode head1, ListNode head2) &#123;
         // 进行判空处理
         if(head1 == null)
             return head2;
         if(head2 == null)&#123;
             return head1;
         &#125;
         // 反转h1链表
         head1 = reverse(head1);
         // 反转h2链表
         head2 = reverse(head2);
         // 创建新的链表头节点
         ListNode head = new ListNode(-1);
         ListNode nHead = head;
         // 记录进位的数值
         int tmp = 0;
         while(head1 != null || head2 != null)&#123;
             // val用来累加此时的数值（加数+加数+上一位的进位=当前总的数值）
             int val = tmp;
             // 当节点不为空的时候，则需要加上当前节点的值
             if (head1 != null) &#123;
                 val += head1.val;
                 head1 = head1.next;
             &#125;
             // 当节点不为空的时候，则需要加上当前节点的值
             if (head2 != null) &#123;
                 val += head2.val;
                 head2 = head2.next;
             &#125;
             // 求出进位
             tmp = val/10;
             // 进位后剩下的数值即为当前节点的数值
             nHead.next = new ListNode(val%10);
             // 下一个节点
             nHead = nHead.next;
 
         &#125;
         // 最后当两条链表都加完的时候，进位不为0的时候，则需要再加上这个进位
         if(tmp &gt; 0)&#123;
             nHead.next = new ListNode(tmp);
         &#125;
         // 重新反转回来返回
         return reverse(head.next);
     &#125;
 
     // 反转链表
     public ListNode reverse(ListNode head)&#123;
         ListNode pre=null;
         ListNode cur=head;
         while(cur!=null)&#123;
             ListNode curNext=cur.next;
             cur.next=pre;
             pre=cur;
             cur=curNext;
         &#125;
         return pre;
     &#125;
</code></pre>
<h2 id="单链表的排序"><a href="#单链表的排序" class="headerlink" title="单链表的排序"></a><strong>单链表的排序</strong></h2><p>给定一个节点数为n的无序单链表，对其按升序排序</p>
<ul>
<li>step 1：遍历链表，将节点值加入数组。</li>
<li>step 2：使用内置的排序函数对数组进行排序。</li>
<li>step 3：依次遍历数组和链表，按照位置将链表中的节点值修改为排序后的数组值。</li>
</ul>
<pre><code class="plain">public class Solution &#123;
     /**
      * 
      * @param head ListNode类 the head node
      * @return ListNode类
      */
     public ListNode sortInList (ListNode head) &#123;
         // write code here
         /**
         1、复制到数组
         2、sort
         3、转为链表
          */
         List&lt;Integer&gt; list=new ArrayList&lt;&gt;();
         ListNode p=head;
         while(p!=null)&#123;
             list.add(p.val);
             p=p.next;
         &#125;
         p=head;
         Collections.sort(list);
         for(int num:list)&#123;
             p.val=num;
             p=p.next;
         &#125;
         return head;
     &#125;
</code></pre>
<h2 id="判断一个链表是否为回文结构"><a href="#判断一个链表是否为回文结构" class="headerlink" title="判断一个链表是否为回文结构"></a><strong>判断一个链表是否为回文结构</strong></h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>因为需要判断是否为回文结构，所以要比较头尾的数据，而链表无法随机查询数据，所以可以先将链表转换成list。</p>
<h3 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h3><ul>
<li>首先初始化一个list列表；</li>
<li>遍历链表，将链表中的值转移至list中；</li>
<li>在list中通过比较头尾的值来判断链表是否为回文结构。</li>
<li>代码如下：</li>
</ul>
<pre><code class="plain">import java.util.*;
 /*
 * public class ListNode &#123;
 *   int val;
 *   ListNode next = null;
 * &#125;
 */
 public class Solution &#123;
   /**
    * 
    * @param head ListNode类 the head
    * @return bool布尔型
    */
   public boolean isPail (ListNode head) &#123;
       // write code here
       // n==1，返回true
       if (head.next == null)&#123;
           return true;
       &#125;
       List&lt;Integer&gt; nums = new ArrayList&lt;Integer&gt;();
       // 将链表转换成list
       while(head!=null)&#123;
           nums.add(head.val);
           head = head.next;
       &#125;
       int i = 0;
       int j = nums.size()-1;
       while(i&lt;j)&#123;
           // 不等则返回false
           // 这边有一个坑，如果不适用equals而使用!=的话，在牛客上对于有负数的测试用例可能会无法通过。
           if (!nums.get(i).equals(nums.get(j)))&#123;
               return false;
           &#125;
           ++i;
           --j;
       &#125;
       return true;
   &#125;
 &#125;
</code></pre>
<h2 id="旋转链表"><a href="#旋转链表" class="headerlink" title="旋转链表"></a>旋转链表</h2><p>给你一个链表的头节点 head ，旋转链表，将链表每个节点向右移动 k 个位置。</p>
<p>记给定链表的长度为 ，注意到当向右移动的次数 k≥n 时，我们仅需要向右移动 k mod n次即可。因为每 n 次移动都会让链表变为原状。这样我们可以知道，新链表的最后一个节点为原链表的第 (n−1)−(k mod n)个节点（从 0 开始计数）。</p>
<p>这样，我们可以先将给定的链表连接成环，然后将指定位置断开。</p>
<p>具体代码中，我们首先计算出链表的长度 n，并找到该链表的末尾节点，将其与头节点相连。这样就得到了闭合为环的链表。然后我们找到新链表的最后一个节点（即原链表的第 (n−1)−(k mod n)个节点），将当前闭合为环的链表断开，即可得到我们所需要的结果。</p>
<p>特别地，当链表长度不大于 1，或者 k 为 n 的倍数时，新链表将与原链表相同，我们无需进行任何处理。</p>
<pre><code class="plain">class Solution &#123;
     public ListNode rotateRight(ListNode head, int k) &#123;
         
         if (k == 0 || head == null || head.next == null) &#123;
             return head;
         &#125;
         // 初始链表长度
         int n = 1;
         ListNode iter = head;
         // 到最后一个结点
         while (iter.next != null) &#123;
             iter = iter.next;
             n++;
         &#125;
         // 计算旧头节点和新头节点偏移量
         int add = n - k % n;
         if (add == n) &#123;
             return head;
         &#125;
         // 连接为环
         iter.next = head;
         // 移动到新头结点
         while (add-- &gt; 0) &#123;
             iter = iter.next;
         &#125;
         // 断开即可
         ListNode ret = iter.next;
         iter.next = null;
         // 返回
         return ret;
     &#125;
 &#125;
</code></pre>
<h2 id="重排链表"><a href="#重排链表" class="headerlink" title="重排链表"></a>重排链表</h2><p><img src="https://raw.githubusercontent.com/viacheung/img/main/image/image-20230406191651380.png" alt="img"></p>
<ol>
<li>创建一个队列</li>
<li>除了head 其他入队</li>
<li>维护一个count 根据count值奇偶连接链表</li>
</ol>
<pre><code class="plain">class Solution &#123;
     public void reorderList(ListNode head) &#123;
         // 使用双端队列的方法来解决
         Deque&lt;ListNode&gt; de = new LinkedList&lt;&gt;();
         // 这里是取head的下一个节点，head不需要再入队了，避免造成重复
         ListNode cur = head.next;  
         while (cur != null)&#123;
             de.offer(cur);
             cur = cur.next;
         &#125;
         cur = head;  // 回到头部
 
         int count = 0;
         while (!de.isEmpty())&#123;
             if (count % 2 == 0)&#123;
                 // 偶数，取出队列右边尾部的值
                 cur.next = de.pollLast();
             &#125;else &#123;
                 // 奇数，取出队列左边头部的值
                 cur.next = de.poll();
             &#125;
             cur  = cur.next;
             count++;
         &#125;
         cur.next = null;
     &#125;
 &#125;
</code></pre>

    </div>

    
    
    
        <div class="reward-container">
  <div>“如果觉得有用的话，支持一下吧!“</div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/images/wechat.jpg" alt="ViaCheung 微信支付">
        <p>微信支付</p>
      </div>

  </div>
</div>

        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>ViaCheung
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://viacheung.github.io/2023/06/04/%E9%93%BE%E8%A1%A8/" title="链表">http://viacheung.github.io/2023/06/04/链表/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/zh-CN" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2023/06/04/%E5%BC%80%E5%8F%91%E5%B2%97%E5%BC%80%E5%8F%91%E9%A2%98/" rel="prev" title="开发岗开发题">
      <i class="fa fa-chevron-left"></i> 开发岗开发题
    </a></div>
      <div class="post-nav-item">
    <a href="/2023/06/04/%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95/" rel="next" title="面试算法">
      面试算法 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%89%8D%E8%A8%80"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%BB%93%E7%82%B9"><span class="nav-number">2.</span> <span class="nav-text">删除链表结点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%AC-N-%E4%B8%AA%E7%BB%93%E7%82%B9"><span class="nav-number">3.</span> <span class="nav-text">删除链表的倒数第 N 个结点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B924"><span class="nav-number">4.</span> <span class="nav-text">两两交换链表中的节点24</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0203"><span class="nav-number">5.</span> <span class="nav-text">移除链表元素203</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%BE%E8%AE%A1%E9%93%BE%E8%A1%A8"><span class="nav-number">6.</span> <span class="nav-text">设计链表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8"><span class="nav-number">7.</span> <span class="nav-text">回文链表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8"><span class="nav-number">8.</span> <span class="nav-text">反转链表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8I"><span class="nav-number">9.</span> <span class="nav-text">环形链表I</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8II"><span class="nav-number">10.</span> <span class="nav-text">环形链表II</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8-%E2%88%9A"><span class="nav-number">11.</span> <span class="nav-text">相交链表(√)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9"><span class="nav-number">12.</span> <span class="nav-text">两两交换链表中的节点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%93%BE%E8%A1%A8%E5%86%85%E6%8C%87%E5%AE%9A%E5%8C%BA%E9%97%B4%E5%8F%8D%E8%BD%AC"><span class="nav-number">13.</span> <span class="nav-text">链表内指定区间反转</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9%E6%AF%8Fk%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC"><span class="nav-number">14.</span> <span class="nav-text">链表中的节点每k个一组翻转</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8"><span class="nav-number">15.</span> <span class="nav-text">合并两个有序链表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%92%E5%BD%92"><span class="nav-number">15.1.</span> <span class="nav-text">递归</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%93%BE%E8%A1%A8%E7%9B%B8%E5%8A%A0-%E4%BA%8C"><span class="nav-number">16.</span> <span class="nav-text">链表相加(二)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E6%8E%92%E5%BA%8F"><span class="nav-number">17.</span> <span class="nav-text">单链表的排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E9%93%BE%E8%A1%A8%E6%98%AF%E5%90%A6%E4%B8%BA%E5%9B%9E%E6%96%87%E7%BB%93%E6%9E%84"><span class="nav-number">18.</span> <span class="nav-text">判断一个链表是否为回文结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%9D%E8%B7%AF"><span class="nav-number">18.1.</span> <span class="nav-text">思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B7%E4%BD%93%E6%AD%A5%E9%AA%A4"><span class="nav-number">18.2.</span> <span class="nav-text">具体步骤</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%97%8B%E8%BD%AC%E9%93%BE%E8%A1%A8"><span class="nav-number">19.</span> <span class="nav-text">旋转链表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%87%8D%E6%8E%92%E9%93%BE%E8%A1%A8"><span class="nav-number">20.</span> <span class="nav-text">重排链表</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="ViaCheung"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">ViaCheung</p>
  <div class="site-description" itemprop="description">el psy congroo</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">41</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/viacheung" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;viacheung" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:viacheung5@gmail.com" title="E-Mail → mailto:viacheung5@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/zh-CN" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ViaCheung</span>
</div>

<!--
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div> -->

<!-- 网站运行时间的设置 -->
<span id="timeDate">载入天数...</span>
<span id="times">载入时分秒...</span>
<script>
    var now = new Date();
    function createtime() {
        var grt= new Date("03/01/2023 10:00:00"); //此处修改你的建站时间或者网站上线时间
        now.setTime(now.getTime()+250);
        days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days);
        hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours);
        if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);
        mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;}
        seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
        snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;}
        document.getElementById("timeDate").innerHTML = "本站已安全运行 "+dnum+" 天 ";
        document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒.";
    }
setInterval("createtime()",250);
</script>
        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>

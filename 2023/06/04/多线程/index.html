<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.1.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"viacheung.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="请简要描述线程与进程的关系,区别及优缺点？根本区别：进程是操作系统资源分配的基本单位，而线程是处理器任务调度和执行的基本单位资源开销：进程独享内存空间，进程之间的切换会有较大的开销；而线程有自己独立的运行栈和程序计数器（PC），线程之间切换的开销小。包含关系：线程是进程划分成更小的运行单位影响关系：一个进程崩溃后，不会对其他进程产生影响，但是一个线程崩溃整个进程都死掉。所以多进程要比多线程健壮。">
<meta property="og:type" content="article">
<meta property="og:title" content="命运石之门">
<meta property="og:url" content="http://viacheung.github.io/2023/06/04/%E5%A4%9A%E7%BA%BF%E7%A8%8B/index.html">
<meta property="og:site_name" content="命运石之门">
<meta property="og:description" content="请简要描述线程与进程的关系,区别及优缺点？根本区别：进程是操作系统资源分配的基本单位，而线程是处理器任务调度和执行的基本单位资源开销：进程独享内存空间，进程之间的切换会有较大的开销；而线程有自己独立的运行栈和程序计数器（PC），线程之间切换的开销小。包含关系：线程是进程划分成更小的运行单位影响关系：一个进程崩溃后，不会对其他进程产生影响，但是一个线程崩溃整个进程都死掉。所以多进程要比多线程健壮。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2023/gif/226907/1684751100102-13cfdaec-0df9-4904-963b-bd1ba83c68f9.gif#averageHue=%23000000&clientId=ubfd9bb9c-147a-4&from=paste&id=ufc9236fb&originHeight=1&originWidth=1&originalType=url&ratio=1.25&rotation=0&showTitle=false&size=70&status=done&style=none&taskId=u2e150207-f40d-4505-ad1d-d2a1488af63&title=">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2023/webp/226907/1684751100181-5421c582-3c61-4e25-adc5-98f4ffc5781d.webp#averageHue=%23121210&clientId=ubfd9bb9c-147a-4&from=paste&id=u005f7167&originHeight=456&originWidth=1154&originalType=url&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&taskId=uc6bde927-8fee-439f-8d05-21318e920ae&title=">
<meta property="article:published_time" content="2023-06-03T16:58:20.165Z">
<meta property="article:modified_time" content="2023-06-03T16:58:21.438Z">
<meta property="article:author" content="ViaCheung">
<meta property="article:tag" content="Java,python">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.nlark.com/yuque/0/2023/gif/226907/1684751100102-13cfdaec-0df9-4904-963b-bd1ba83c68f9.gif#averageHue=%23000000&clientId=ubfd9bb9c-147a-4&from=paste&id=ufc9236fb&originHeight=1&originWidth=1&originalType=url&ratio=1.25&rotation=0&showTitle=false&size=70&status=done&style=none&taskId=u2e150207-f40d-4505-ad1d-d2a1488af63&title=">

<link rel="canonical" href="http://viacheung.github.io/2023/06/04/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title> | 命运石之门</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">命运石之门</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">欢迎来到我的博客空间🙇</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-schedule">

    <a href="/schedule/" rel="section"><i class="fa fa-calendar fa-fw"></i>日程表</a>

  </li>
        <li class="menu-item menu-item-sitemap">

    <a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>站点地图</a>

  </li>
        <li class="menu-item menu-item-commonweal">

    <a href="/404/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>公益 404</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/viacheung" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://viacheung.github.io/2023/06/04/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="ViaCheung">
      <meta itemprop="description" content="el psy congroo">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="命运石之门">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
        </h1>

        <div class="post-meta">
	  <span class="post-time">

	  
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-06-04 00:58:20 / 修改时间：00:58:21" itemprop="dateCreated datePublished" datetime="2023-06-04T00:58:20+08:00">2023-06-04</time>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="请简要描述线程与进程的关系-区别及优缺点？"><a href="#请简要描述线程与进程的关系-区别及优缺点？" class="headerlink" title="请简要描述线程与进程的关系,区别及优缺点？"></a>请简要描述线程与进程的关系,区别及优缺点？</h2><p><strong>根本区别</strong>：进程是操作系统资源分配的基本单位，而线程是处理器任务调度和执行的基本单位<br><strong>资源开销</strong>：进程独享内存空间，进程之间的切换会有较大的开销；而线程有自己独立的运行栈和程序计数器（PC），线程之间切换的开销小。<br><strong>包含关系</strong>：线程是进程划分成更小的运行单位<br><strong>影响关系</strong>：一个进程崩溃后，不会对其他进程产生影响，但是一个线程崩溃整个进程都死掉。所以多进程要比多线程健壮。</p>
<h2 id="简述线程、程序、进程的基本概念。以及他们之间关系是什么"><a href="#简述线程、程序、进程的基本概念。以及他们之间关系是什么" class="headerlink" title="简述线程、程序、进程的基本概念。以及他们之间关系是什么?"></a>简述线程、程序、进程的基本概念。以及他们之间关系是什么?</h2><p>程序： 含有数据和指令的静态 文件（存在磁盘）<br>进程：程序的一次执行过程<br>线程：进程划分为更小的运行单位 同类的多个线程共享进程的堆和⽅法区 但每个线程有⾃⼰的程序计数器、 虚拟机栈和本地⽅法栈 </p>
<h2 id="创建线程的三种方式的对比？"><a href="#创建线程的三种方式的对比？" class="headerlink" title="创建线程的三种方式的对比？"></a>创建线程的三种方式的对比？</h2><ul>
<li>定义Thread类的子类，并重写该类的run方法(new完Thread,直接start)</li>
<li>定义Runnable接口的实现类，并重写该接口的run()方法(new完Thread,再实现一个Runnable接口放到Thread里面)</li>
<li>定义Callable接口的实现类，并重写该接口的call()方法，一般配合Future使用</li>
<li>线程池的方式</li>
</ul>
<p><strong>1、采用实现Runnable. Callable接口的方式创建多线程：</strong><br>优势：只是实现接口，还可以继承其他类，功能扩展好劣势：要访问当前线程，则必须使用Thread.currentThread()<br><strong>Runnable和Callable的区别</strong>：<br>1、重写方法一个run 一个call<br>2、有无返回值 <strong>callable有</strong><br>3、call可以抛出异常 run不可以<br>4、运行Callable任务可以拿到一个Future对象，表示异步计算的结果<br><strong>2、使用继承Thread类的方式创建多线程</strong>：<br><strong>优势是：</strong><br>如果需要访问当前线程，直接使用this即可获得当前线程。<br><strong>劣势是：</strong><br>已经继承了Thread类，所以不能再继承其他父类。</p>
<h2 id="多线程的好处"><a href="#多线程的好处" class="headerlink" title="多线程的好处"></a>多线程的好处</h2><p>1、基于高并发的需求<br>2、<strong>线程间的切换和调度的成本远远小于进程</strong></p>
<h2 id="程序计数器为什么是私有的"><a href="#程序计数器为什么是私有的" class="headerlink" title="程序计数器为什么是私有的?"></a>程序计数器为什么是私有的?</h2><p>程序计数器记录当前线程执行位置，主要是为了线程切换后能恢复到正确的执⾏位置。 </p>
<h2 id="虚拟机栈和本地⽅法栈为什么是私有的"><a href="#虚拟机栈和本地⽅法栈为什么是私有的" class="headerlink" title="**虚拟机栈和本地⽅法栈为什么是私有的? **"></a>**虚拟机栈和本地⽅法栈为什么是私有的? **</h2><p>为了保证当前线程的局部变量不被别的线程访问</p>
<h2 id="⼀句话简单了解堆和⽅法区"><a href="#⼀句话简单了解堆和⽅法区" class="headerlink" title="⼀句话简单了解堆和⽅法区"></a>⼀句话简单了解堆和⽅法区</h2><p>堆：对象<br>方法区：已经加载的类信息、常量、静态变量，JIT编译的代码</p>
<h2 id="说说并发与并⾏的区别"><a href="#说说并发与并⾏的区别" class="headerlink" title="说说并发与并⾏的区别?"></a>说说并发与并⾏的区别?</h2><p>并发：一段时间<br>并行：同一时刻</p>
<h2 id="为什么要使⽤多线程呢-（而不是多进程）"><a href="#为什么要使⽤多线程呢-（而不是多进程）" class="headerlink" title="为什么要使⽤多线程呢? （而不是多进程）"></a>为什么要使⽤多线程呢? （而不是多进程）</h2><p>线程间切换调度成本小于进程<br>多核时代 利用多个cpu 提高利用率</p>
<h2 id="使⽤多线程可能带来什么问题"><a href="#使⽤多线程可能带来什么问题" class="headerlink" title="使⽤多线程可能带来什么问题?"></a>使⽤多线程可能带来什么问题?</h2><p>内存泄漏、 上下⽂切换、 死锁 。 </p>
<h2 id="说说线程的⽣命周期和状态"><a href="#说说线程的⽣命周期和状态" class="headerlink" title="说说线程的⽣命周期和状态?"></a>说说线程的⽣命周期和状态?</h2><p>新建-可运行-运行-等待-超时等待-阻塞-中止</p>
<h2 id="什么是上下⽂切换"><a href="#什么是上下⽂切换" class="headerlink" title="什么是上下⽂切换?"></a>什么是上下⽂切换?</h2><p>每个线程分配时间片并轮转，当前任务切换到其他线程之前需要保存自己状态，以便回来时再继续加载之前状态</p>
<h2 id="线程有哪些基本状态"><a href="#线程有哪些基本状态" class="headerlink" title="线程有哪些基本状态?"></a>线程有哪些基本状态?</h2><p>新建<br>可运行（就绪）<br>运行<br>阻塞<br>等待<br>超时等待<br>终止<br>说下过程？<br>notify notifyAll</p>
<h2 id="什么是线程死锁-如何避免死锁"><a href="#什么是线程死锁-如何避免死锁" class="headerlink" title="什么是线程死锁?如何避免死锁?"></a>什么是线程死锁?如何避免死锁?</h2><p><strong>线程死锁：</strong><br>两个或两个以上的线程在执行过程中,因争夺资源而造成的一种互相等待的现象<br><strong>如何避免</strong>？：<strong>1、如果自己获取不到，主动释放自己占有的资源</strong> 2、按序申请资源 反序释放<br>破坏死锁条件：</p>
<ol>
<li>互斥条件：该资源任意⼀个时刻只由⼀个线程占⽤。（解决：不能破坏）</li>
<li>请求与保持条件：⼀个进程因请求资源⽽阻塞时，对加锁资源保持不放。（一直阻塞在那里）（解决：一次性申请所有资源）</li>
<li>不剥夺条件:线程已获得的资源在末使⽤完之前不能被其他线程强⾏剥夺，只有⾃⼰使⽤完毕（解决：<strong>如果自己获取不到，主动释放自己占有的资源</strong>）后才释放资源。（占着锁 非抢占式）</li>
<li>循环等待条件:若⼲进程之间形成⼀种头尾相接的循环等待资源关系。（解决：按序申请资源 反序释放 ）<h2 id="常见线程相关api对比"><a href="#常见线程相关api对比" class="headerlink" title="常见线程相关api对比"></a>常见线程相关api对比</h2><h3 id="Runnable-VS-Callable"><a href="#Runnable-VS-Callable" class="headerlink" title="Runnable VS Callable"></a>Runnable VS Callable</h3></li>
</ol>
<ul>
<li><p>Callable 接口可以返回结果或抛出检查异常</p>
</li>
<li><p>Runnable 接口不会</p>
</li>
<li><p>Executors 可以实现 Runnable 对象和 Callable 对象之间的相互转换</p>
<h3 id="shutdown-VS-shutdownNow"><a href="#shutdown-VS-shutdownNow" class="headerlink" title="shutdown() VS shutdownNow()"></a>shutdown() VS shutdownNow()</h3></li>
<li><p>shutdown（） :关闭线程池，线程池的状态变为 SHUTDOWN。线程池不再接受新任务了，但是队列里的任务得执行完毕。</p>
</li>
<li><p>shutdownNow（） :关闭线程池，线程的状态变为 STOP。线程池会终止当前正在运行的任务，并停止处理排队的任务并返回正在等待执行的 List。 shutdownNow的原理是遍历线程池中的工作线程，然后逐个调用线程的interrupt方法来中断线程，所以无法响应中断的任务可能永远无法终止</p>
<h3 id="isTerminated-VS-isShutdown"><a href="#isTerminated-VS-isShutdown" class="headerlink" title="isTerminated() VS isShutdown()"></a>isTerminated() VS isShutdown()</h3></li>
<li><p>isShutDown 当调用 shutdown() 方法后返回为 true。</p>
</li>
<li><p>isTerminated 当调用 shutdown() 方法后，并且所有提交的任务完成后返回为 true</p>
<h2 id="排查死锁"><a href="#排查死锁" class="headerlink" title="排查死锁"></a>排查死锁</h2><p><strong>命令</strong><br>jps -l 查看当前进程运行状况jstack 进程编号 查看该进程信息<br><strong>图形化</strong><br>jconsole 打开线程 ，点击 检测死锁 </p>
<h2 id="说说-sleep-⽅法和-wait-⽅法区别和共同点"><a href="#说说-sleep-⽅法和-wait-⽅法区别和共同点" class="headerlink" title="说说 sleep() ⽅法和 wait() ⽅法区别和共同点?"></a>说说 sleep() ⽅法和 wait() ⽅法区别和共同点?</h2><p>原理： </p>
</li>
<li><p>sleep方法：是Thread类的静态方法，当前线程将睡眠n毫秒，线程进入阻塞状态。当睡眠时间到了，会解除阻塞，进入可运行状态，等待CPU的到来。睡眠不释放锁（如果有的话）。</p>
</li>
<li><p>wait方法：是Object的方法，必须与synchronized关键字一起使用，线程进入阻塞状态，当notify或者notifyall被调用后，会解除阻塞。但是，只有重新占用互斥锁之后才会进入可运行状态。睡眠时，会释放互斥锁。</p>
</li>
</ul>
<p>区别：sleep() ⽅法没有释放锁，⽽ wait() ⽅法释放了锁<br>sleep之后自动苏醒，wait需要notify（）唤醒<br>共同点：两者都可以暂停线程的执⾏。</p>
<h2 id="为什么我们调⽤-start-⽅法时会执⾏-run-⽅法，为什么我们不能直接调⽤-run-⽅法"><a href="#为什么我们调⽤-start-⽅法时会执⾏-run-⽅法，为什么我们不能直接调⽤-run-⽅法" class="headerlink" title="为什么我们调⽤ start() ⽅法时会执⾏ run() ⽅法，为什么我们不能直接调⽤ run() ⽅法"></a>为什么我们调⽤ start() ⽅法时会执⾏ run() ⽅法，为什么我们不能直接调⽤ run() ⽅法</h2><p>直接调用就是main线程的一个普通方法，并不会在某个线程里面执行<br>而new 一个 Thread，线程进入了新建状态; 调用start() ，线程进入了就绪状态，然后获得时间片就可以运行了</p>
<h2 id="Thread类中的yield方法有什么作用？"><a href="#Thread类中的yield方法有什么作用？" class="headerlink" title="Thread类中的yield方法有什么作用？"></a>Thread类中的yield方法有什么作用？</h2><p>暂停当前正在执行的线程对象，让其它有相同优先级的线程执行。它是一个静态方法而且只保证当前线程放弃CPU占用而不能保证使其它线程一定能占用CPU，执行yield()的线程有可能在进入到暂停状态后马上又被执行（我暂停了我又回来了吼吼）。</p>
<h2 id="如何创建线程实例并运行"><a href="#如何创建线程实例并运行" class="headerlink" title="如何创建线程实例并运行"></a>如何创建线程实例并运行</h2><ol>
<li>创建 Thread 的子类并重写 run()</li>
</ol>
<p>run() 方在调用 start() 方法后被执行，而且一旦线程启动后 start() 方法后就会立即返回，而不是等到 run() 方法执行完毕后再返回。</p>
<ol>
<li>实现 Runnable 接口</li>
</ol>
<p>在新建类时实现 Runnable 接口，然后在 Thread 类的构造函数（new Thread的时候传参）中传入 MyRunnable 的实例对象，最后执行 start() 方法即可；</p>
<h2 id="线程阻塞的三种情况"><a href="#线程阻塞的三种情况" class="headerlink" title="线程阻塞的三种情况"></a>线程阻塞的三种情况</h2><ol>
<li><strong>等待阻塞（Object.wait -&gt; 等待队列）</strong></li>
</ol>
<p>RUNNING 状态的线程执行 Object.wait() 方法后，JVM 会将线程放入等待序列（waitting queue）；</p>
<ol>
<li><strong>同步阻塞（lock -&gt; 锁池）</strong></li>
</ol>
<p>RUNNING 状态的线程在获取对象的同步锁时，若该 <strong>同步锁被其他线程占用，则 JVM 将该线程放入锁池（lock pool）中</strong>；</p>
<ol>
<li><strong>其他阻塞（sleep&#x2F;join）</strong></li>
</ol>
<p>RUNNING 状态的线程执行 Thread.sleep(long ms) 或 Thread.join() 方法，或发出 I&#x2F;O 请求时，JVM 会将该线程置为阻塞状态。当 sleep() 状态超时，join() 等待线程终止或超时. 或者 I&#x2F;O 处理完毕时，线程重新转入可运行状态（RUNNABLE）；</p>
<h2 id="线程死亡的三种方式"><a href="#线程死亡的三种方式" class="headerlink" title="线程死亡的三种方式"></a>线程死亡的三种方式</h2><ol>
<li><strong>正常结束</strong></li>
</ol>
<p>run() 或者 call() 方法执行完成后，线程正常结束；</p>
<ol>
<li><strong>异常结束</strong></li>
</ol>
<p>线程抛出一个未捕获的 Exception 或 Error，导致线程异常结束；</p>
<ol>
<li><strong>调用 stop()</strong></li>
</ol>
<p>直接调用线程的 stop() 方法来结束该线程，但是一般不推荐使用该种方式，<strong>因为该方法通常容易导致死锁</strong>；</p>
<h2 id="守护线程是啥？"><a href="#守护线程是啥？" class="headerlink" title="守护线程是啥？"></a>守护线程是啥？</h2><p>运行在后台的一种特殊进程，在 Java 中垃圾回收线程就是特殊的守护线程。</p>
<h2 id="了解Fork-x2F-Join框架吗？"><a href="#了解Fork-x2F-Join框架吗？" class="headerlink" title="了解Fork&#x2F;Join框架吗？"></a>了解Fork&#x2F;Join框架吗？</h2><p>Java7提供 ，用于并行执行任务，把大任务分割成若干个小任务，最终汇总每个小任务结果后得到大任务结果的框架。<br><strong>「分而治之」</strong>和<strong>「工作窃取算法」</strong>。<br><strong>「分而治之」</strong><br><strong>「工作窃取算法」</strong><br>把大任务拆分成小任务，放到不同队列执行，交由不同的线程分别执行时。有的线程优先把自己负责的任务执行完了，其他线程还在慢慢悠悠处理自己的任务，这时候为了充分提高效率，就需要工作盗窃算法啦~<br><img src="https://cdn.nlark.com/yuque/0/2023/gif/226907/1684751100102-13cfdaec-0df9-4904-963b-bd1ba83c68f9.gif#averageHue=%23000000&clientId=ubfd9bb9c-147a-4&from=paste&id=ufc9236fb&originHeight=1&originWidth=1&originalType=url&ratio=1.25&rotation=0&showTitle=false&size=70&status=done&style=none&taskId=u2e150207-f40d-4505-ad1d-d2a1488af63&title=" alt="image.png"><br>工作盗窃算法就是，<strong>「某个线程从其他队列中窃取任务进行执行的过程」</strong>。一般就是指做得快的线程（盗窃线程）抢慢的线程的任务来做，同时为了减少锁竞争，通常使用双端队列，即快线程和慢线程各在一端。</p>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><h3 id="如何保证线程安全"><a href="#如何保证线程安全" class="headerlink" title="如何保证线程安全"></a>如何保证线程安全</h3><p>1、原子:Atomic synchronized<br>2、可见:synchronized volatile<br>3、有序：<br>synchronized lock接口</p>
<h2 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h2><h3 id="说说-synchronized-关键字和-volatile-关键字的区别"><a href="#说说-synchronized-关键字和-volatile-关键字的区别" class="headerlink" title="说说 synchronized 关键字和 volatile 关键字的区别"></a>说说 synchronized 关键字和 volatile 关键字的区别</h3><p>互补 存在<br>1、volatile 只能用于变量，syn可以变量、方法、类级别、代码块<br>2、volatile 关键字能保证数据的可⻅性，但不能保证数据的原⼦性。 synchronized 关键字两者都能保证<br>3、volatile <strong>不会造成线程的阻塞</strong>；synchronized <strong>可能会造成线程的阻塞</strong>。<br>4、volatile 关键字主要⽤于解决变量在多个线程之间的可⻅性，⽽ synchronized 关键字解决的是多个线程之间访问资源的同步性<br>5、volatile 本质是告诉当前变量工作内存中的值是不确定的，需要从主存中读取； synchronized 则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。</p>
<h3 id="synchronized-和-Lock-有什么区别？"><a href="#synchronized-和-Lock-有什么区别？" class="headerlink" title="synchronized 和 Lock 有什么区别？"></a>synchronized 和 Lock 有什么区别？</h3><ul>
<li><p>synchronized 可以给类. 方法. 代码块加锁；而 lock 只能给代码块加锁。</p>
</li>
<li><p>synchronized 不需要手动获取锁和释放锁，使用简单，发生异常会自动释放锁，不会造成死锁；而 lock 需要自己加锁和释放锁，如果使用不当没有 unLock()去释放锁就会造成死锁。</p>
</li>
<li><p>通过 Lock 可以知道有没有成功获取锁，而 synchronized 却无法办到。</p>
<h3 id="synchronized-和-ReentrantLock-区别是什么？"><a href="#synchronized-和-ReentrantLock-区别是什么？" class="headerlink" title="synchronized 和 ReentrantLock 区别是什么？"></a>synchronized 和 ReentrantLock 区别是什么？</h3><p><strong>相同：两者都是可重入锁</strong><br>递归锁，指的是在一个线程中可以多次获取同一把锁，比如： 一个线程在执行一个带锁的方法，该方法中又调用了另一个需要相同锁的方法，则该线程可以直接执行调用的方法，而无需重新获得锁， 两者都是同一个线程每进入一次，锁的计数器都自增1，所以要等到锁的计数器下降为0时才能释放锁。<br><strong>1.synchronized 依赖于 JVM 而 ReentrantLock 依赖于 jdk API</strong></p>
</li>
<li><p>synchronized 是依赖于 JVM 实现的， 虚拟机团队在 JDK1.6 为 synchronized 关键字进行了很多优化，但是这些优化都是在虚拟机层面实现的</p>
</li>
<li><p>ReentrantLock 是 JDK 层面实现的（也就是 API 层面，需要 lock() 和 unlock() 方法配合 try&#x2F;finally 语句块来完成）</p>
</li>
</ul>
<p><strong>2.ReentrantLock 比 synchronized 增加了一些高级功能</strong><br>相比synchronized，ReentrantLock增加了一些高级功能。主要来说主要有三点：①等待可中断；②可实现公平锁；③可实现选择性通知（锁可以绑定多个条件）</p>
<ul>
<li>2.1 等待可中断.通过lock.lockInterruptibly()来实现这个机制。也就是说正在等待的线程可以选择放弃等待，改为处理其他事情。</li>
<li>2.2 ReentrantLock可以指定是公平锁还是非公平锁。而synchronized只能是非公平锁。所谓的公平锁就是先等待的线程先获得锁。 ReentrantLock默认情况是非公平的，可以通过 ReentrantLock类的ReentrantLock(boolean fair)<strong>构造方法</strong>来制定是否是公平的。</li>
<li>2.3 ReentrantLock类线程对象可以注册在指定的Condition中，从而可以有选择性的进行线程通知，在调度线程上更加灵活。 在使用notify()&#x2F;notifyAll()方法进行通知时，被通知的线程是由 JVM 选择的，<strong>用ReentrantLock类结合Condition实例可以实现“选择性通知”</strong></li>
</ul>
<p><strong>4.使用选择</strong></p>
<ul>
<li><p>除非需要使用 ReentrantLock 的高级功能，否则<strong>优先使用 synchronized。</strong></p>
</li>
<li><p>synchronized 是 JVM 实现的一种锁机制，<strong>JVM 原生地支持</strong>它，而 ReentrantLock 不是所有的 JDK 版本都支持。并且使用 synchronized <strong>不用担心没有释放锁而导致死锁问题</strong>，因为 JVM 会确保锁的释放</p>
<h3 id="synchronized的用法有哪些"><a href="#synchronized的用法有哪些" class="headerlink" title="synchronized的用法有哪些?"></a>synchronized的用法有哪些?</h3></li>
<li><p>修饰普通方法:作用于当前对象实例，进入同步代码前要获得当前对象实例的锁</p>
</li>
<li><p>修饰静态方法:作用于当前类，进入同步代码前要获得当前类对象的锁,synchronized 关键字加到 static 静态方法和 synchronized(class)代码块上都是是给 Class 类上锁</p>
</li>
<li><p>修饰代码块:指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁（里面可以写.class（类锁）也可以写this（对象锁））</p>
</li>
</ul>
<p>特别注意：<br>①如果一个线程A调用一个实例对象的非静态 synchronized 方法，而线程B需要调用这个实例对象所属类的静态 synchronized 方法，是允许的，不会发生互斥现象，因为访问静态 synchronized 方法占用的锁是当前类的锁（因为加的不是一把锁）<br>②尽量不要使用 synchronized(String s) ,因为JVM中，字符串常量池具有缓冲功能<br>（就是说由于字符串常量池的原因不同的变量可能引用着同一个对象，锁不同变量的时候会锁成同一个对象，从而造成意料之外的同步，降低效率）</p>
<h3 id="Synchronized的作用有哪些？"><a href="#Synchronized的作用有哪些？" class="headerlink" title="Synchronized的作用有哪些？"></a>Synchronized的作用有哪些？</h3><ol>
<li><p>原子性：确保线程互斥的访问同步代码；</p>
</li>
<li><p>可见性：保证共享变量的修改能够及时可见，其实是通过Java内存模型中的 “<strong>对一个变量unlock操作之前，必须要同步到主内存中；如果对一个变量进行lock操作，则将会清空工作内存中此变量的值，在执行引擎使用此变量前，需要重新从主内存中load操作或assign操作初始化变量值</strong>（lock unlock里面可能对变量有改动）” 来保证的；</p>
</li>
<li><p>有序性：有效解决重排序问题，即 “一个unlock操作先行发生(happen-before)于后面对同一个锁的lock操作”。</p>
<h3 id="说⼀说⾃⼰对于-synchronized-关键字的了解"><a href="#说⼀说⾃⼰对于-synchronized-关键字的了解" class="headerlink" title="说⼀说⾃⼰对于 synchronized 关键字的了解"></a>说⼀说⾃⼰对于 synchronized 关键字的了解</h3><p>属于重量级锁，效率低，线程之间的切换通过操作系统层面，需要从⽤户态转换到内核态，这俩状态之间的转换成本高<br>1.6之后对synchronized引入大量优化，自旋 锁消除（每个线程一把锁）锁粗化（锁的都是一个对象） 偏向 轻量级锁来减少开销</p>
<h3 id="单例模式了解吗？来给我⼿写⼀下！给我解释⼀下双重检验锁⽅式实现单例模式的原理呗！"><a href="#单例模式了解吗？来给我⼿写⼀下！给我解释⼀下双重检验锁⽅式实现单例模式的原理呗！" class="headerlink" title="单例模式了解吗？来给我⼿写⼀下！给我解释⼀下双重检验锁⽅式实现单例模式的原理呗！"></a>单例模式了解吗？来给我⼿写⼀下！给我解释⼀下双重检验锁⽅式实现单例模式的原理呗！</h3><p>两个判断：防止加锁过程对象被其他线程实例化<br>uniqueInstance &#x3D; new Singleton();<br>1、分配内存空间<br>2、初始化<br>3、指向分配地址<br>jvm指令重排 导致线程获得还没初始化的实例，解决办法：volatile 保证多线程无指令重排</p>
<h3 id="构造⽅法可以使⽤-synchronized-关键字修饰么？"><a href="#构造⽅法可以使⽤-synchronized-关键字修饰么？" class="headerlink" title="构造⽅法可以使⽤ synchronized 关键字修饰么？"></a>构造⽅法可以使⽤ synchronized 关键字修饰么？</h3><p>不可</p>
<h3 id="对象锁是啥？"><a href="#对象锁是啥？" class="headerlink" title="对象锁是啥？"></a>对象锁是啥？</h3><p>管程</p>
<h3 id="什么是可重入锁"><a href="#什么是可重入锁" class="headerlink" title="什么是可重入锁"></a>什么是可重入锁</h3><p>同一个线程在外层方法获取锁的时候，再进入该线程的内层方法会自动获取<strong>锁</strong>(前提，锁对象得是同一个对象)，不会因为之前已经获取过还没释放而阻塞。<br>执行monitorenter，如果锁对象计数器0，那么说明没有被其他线程持有，jvm把该锁对象持有线程设为当前线程，当计数器不为0，如果持有线程是当前线程，jvm把计数器+1，否则等待。执行monitorexit时，Java虚拟机则需将锁对象的计数器减1。计数器为零代表锁已被释放。<br>ReentrantLock和synchronized都是可重入锁 （可以避免死锁）<strong>syn隐式，lock unlock显式</strong> 假如lock unlock不成对，单线程情况下问题不大，但多线程下出问题 </p>
<h3 id="讲⼀下-synchronized底层"><a href="#讲⼀下-synchronized底层" class="headerlink" title="讲⼀下 synchronized底层"></a>讲⼀下 synchronized底层</h3><p>反编译带syn的代码块，可以看到，同步代码块开始结束位置有个monitorenter 和 monitorexit，到<strong>monitorenter</strong>这个指令时，会先尝试获取对象的锁，本质上来说，Synchronized其实是通过在对象头上设置标记，锁的计数器就会+1，而当执行到<strong>monitorexit</strong>这个指令时，锁计数器就会-1，直到减到0，这个锁也就被释放了。如果获取对象锁失败，那当前线程就要阻塞等待，直到锁被另外一个线程释放为止<br>synchronized 修饰的方法并没有 monitorenter 指令和 monitorexit 指令，取得代之的确实是 ACC_SYNCHRONIZED 标识，该标识指明了该方法是一个同步方法，JVM 通过该 ACC_SYNCHRONIZED 访问标志来辨别一个方法是否声明为同步方法，从而执行相应的同步调用。</p>
<h4 id="为什么任何一个对象都可以成为一个锁？"><a href="#为什么任何一个对象都可以成为一个锁？" class="headerlink" title="为什么任何一个对象都可以成为一个锁？"></a>为什么任何一个对象都可以成为一个锁？</h4><p>追溯底层可以发现<strong>每个对象天生都带着一个对象监视器</strong>： ObjectMonitor ：记录线程获取锁次数，记录哪个线程持有我</p>
<pre><code>ObjectMonitor() &#123;
  _header       = NULL;
  _count        = 0; // 记录个数
  _waiters      = 0,
  _recursions   = 0;
  _object       = NULL;
  _owner        = NULL;
  _WaitSet      = NULL;  // 处于wait状态的线程，会被加入到_WaitSet
  _WaitSetLock  = 0 ;
  _Responsible  = NULL ;
  _succ         = NULL ;
  _cxq          = NULL ;
  FreeNext      = NULL ;
  _EntryList    = NULL ;  // 处于等待锁block状态的线程，会被加入到该列表
  _SpinFreq     = 0 ;
  _SpinClock    = 0 ;
  OwnerIsThread = 0 ;
&#125;
</code></pre>
<h4 id="synchronized-同步语句块的情况"><a href="#synchronized-同步语句块的情况" class="headerlink" title="synchronized 同步语句块的情况"></a>synchronized 同步语句块的情况</h4><p>synchronized 同步语句块的实现使⽤的是 monitorenter 和 monitorexit 指令，其中monitorenter 指令指向同步代码块的开始位置， monitorexit 指令则指明同步代码块的结束位置。当执⾏ monitorenter 指令时，线程试图获取锁也就是获取 对象监视器 monitor 的持有权。<br>moniter enter –&gt;exit<br>objectmoniter 类owner谁持有谁记录</p>
<h4 id="synchronized-修饰⽅法的的情况"><a href="#synchronized-修饰⽅法的的情况" class="headerlink" title="synchronized 修饰⽅法的的情况"></a>synchronized 修饰⽅法的的情况</h4><p>JVM 通过该ACC_SYNCHRONIZED (true or false)访问标志来辨别⼀个⽅法是否声明为同步⽅法，从⽽执⾏相应的同步调⽤。<br>为什么这俩不一样？ 我的理解：代码块里面锁可以重入 方法不可</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>synchronized 同步语句块的实现使⽤的是 monitorenter 和 monitorexit 指令，其中monitorenter 指令指向同步代码块的开始位置， monitorexit 指令则指明同步代码块的结束位置。 锁的计数器为 0 1 进＋1 出 -1synchronized 修饰的⽅法并没有 monitorenter 指令和 monitorexit 指令，取得代之的确实是<strong>ACC_SYNCHRONIZED</strong> 标识，该标识指明了该⽅法是⼀个同步⽅法。不过两者的本质都是对对象监视器 monitor 的获取。</p>
<h3 id="对象和moniter关联"><a href="#对象和moniter关联" class="headerlink" title="对象和moniter关联"></a>对象和moniter关联</h3><h3 id="多线程中-synchronized-锁升级的原理是什么？"><a href="#多线程中-synchronized-锁升级的原理是什么？" class="headerlink" title="多线程中 synchronized 锁升级的原理是什么？"></a>多线程中 synchronized 锁升级的原理是什么？</h3><h5 id="1、偏向锁"><a href="#1、偏向锁" class="headerlink" title="1、偏向锁"></a>1、偏向锁</h5><p>当一段同步代码一直被同一个线程多次访问，由于只有一个线程访问那么该线程在后续访问时便会自动获得锁。连CAS都无，（目的：防止不停的在用户态和内核态之间切换）<br>在锁对象的对象头里面MarkWord里面存的有当前线程id，第一次进，为空，把id设为自己的，以后每次进的时候没有加锁解锁，直接会去检查锁的MarkWord里面是不是放的自己的线程ID ，是的话，直接进，无CAS，如果不一致，尝试使用CAS来替换MarkWord里面的线程ID为新线程的ID ，竞争成功，表示之前的线程不存在了，MarkWord里面的线程ID为新线程的ID，锁不会升级，仍然为偏向锁； </p>
<h5 id="2、轻量级锁"><a href="#2、轻量级锁" class="headerlink" title="2、轻量级锁"></a>2、轻量级锁</h5><p>（续上）如果竞争失败，这时候会等待一个全局安全点，也就是没有代码执行，暂停原来持有偏向锁的线程，检查偏向锁线程是否处于代码块，处于代码块的话，升级为轻量，此时持有线程的还是之前原持有偏向锁的线程，线程B自旋等待；如果已经退出代码块了，锁设为无锁状态。<br>作用：有线程来参与锁的竞争，但是获取锁的冲突时间极短，本质就是自选锁CAS<br>轻量级锁是为了在线程近乎交替执行同步块时提高性能 ，说白了先自旋，不行才升级阻塞。<br>若一个线程获得锁时发现是轻量级锁，会把锁的MarkWord复制到自己的Displaced Mark Word（JVM会为每个线程在 当前线程的栈帧中创建用于存储锁记录的空间 ）里面。然后线程尝试用CAS将锁的MarkWord替换为指向锁记录的指针。 <strong>总结：就是这里MarkWord存的是指问线程栈中Lock Record的指针</strong><br>java6之后有个【自适应自选锁】：<br>线程如果自旋成功了，那下次自旋的最大次数会增加，因为JVM认为既然上次成功了，那么这一次也很大概率会成功。反之如果很少会自旋成功，那么下次会减少自旋的次数甚至不自旋，避免CPU空转。总之，自适应意味着自选的次数不是固定不变的，而是根据：<strong>同一个锁上一次自旋的时间和拥有锁线程的状态来决定。</strong></p>
<h5 id="轻量锁和偏向锁的区别和不同："><a href="#轻量锁和偏向锁的区别和不同：" class="headerlink" title="轻量锁和偏向锁的区别和不同："></a>轻量锁和偏向锁的区别和不同：</h5></li>
<li><p>争夺轻量级锁失败时，自旋尝试抢占锁</p>
</li>
<li><p>轻量级锁每次退出同步块都需要释放锁，而偏向锁是在竞争发生时才释放锁 </p>
<h5 id="3、重量级锁"><a href="#3、重量级锁" class="headerlink" title="3、重量级锁"></a>3、重量级锁</h5><p>Java中synchronized的重量级锁，是基于进入和退出Monitor对象实现的。在编译时会将同步块的开始位置插入monitor enter指令，在结束位置插入monitor exit指令。当线程执行到monitor enter指令时，会尝试获取对象所对应的Monitor所有权，如果获取到了，即获取到了锁，会在Monitor的owner中存放当前线程的id，这样它将处于锁定状态，除非退出同步块，否则其他线程无法获取到这个Monitor<br>锁的升级的目的：锁升级是为了减低了锁带来的性能消耗。在 Java 6 之后优化 synchronized 的实现方式，使用了偏向锁升级为轻量级锁再升级到重量级锁的方式，从而减低了锁带来的性能消耗。<br>此时Mark Word存的是指向互斥量的指针<br>锁升级为轻量级或重量级锁后，Mark Word中保存的分别是线程栈帧里的锁记录指针和重量级锁指针，己经没有位置再保存哈希码，GC年龄了，那么这些信息被移动到哪里去了呢 </p>
<h3 id="锁升级发生后，hashcode去哪啦"><a href="#锁升级发生后，hashcode去哪啦" class="headerlink" title="锁升级发生后，hashcode去哪啦"></a>锁升级发生后，hashcode去哪啦</h3><p>·1、在无锁状态下，Mark Word中可以存储对象的hashcode值。当对象的hashCode()方法第一次被调用时，JVM会生成对应的identity hash code值并将该值存储到Mark Word中。2、对于偏向锁，在线程获取偏向锁时，会用Thread ID和epoch值覆盖identity hash code所在的位置。如果一个对象的hashCode()方法己经被调用过一次之后，这个对象不能被设置偏向锁。因为如果可以的化，那Mark Word中的identity hash code必然会被偏向线程Id给覆盖，这就会造成同一个对象前后两次调用hashCode()方法得到的结果不一致。3、升级为轻量级锁时，JVM会在当前线程的栈帧中创建一个锁记录(Lock Record)空间，用于存储锁对象的Mark Word拷贝，该拷贝中可以包含identity hash code，所以轻量级锁可以和identity hashcode<strong>共存</strong>，哈希码和GC年龄自然保存在此，释放锁后会将这些信息写回到对象头。（加锁肯定没法访问啊）4、升级为重量级锁后，Mark Word保存的重量级锁指针，代表重量级锁的ObjectMonitor类里有字段记录非加锁状态下的Mark Word，锁释放后也会将信息写回到对象头。 </p>
<h3 id="synchronized-为什么是非公平锁？非公平体现在哪些地方？"><a href="#synchronized-为什么是非公平锁？非公平体现在哪些地方？" class="headerlink" title="synchronized 为什么是非公平锁？非公平体现在哪些地方？"></a><strong>synchronized 为什么是非公平锁？非公平体现在哪些地方？</strong></h3><p>synchronized 的非公平其实在源码中应该有不少地方，因为设计者就没按公平锁来设计，核心有以下几个点：<br>1）当持有锁的线程释放锁时，该线程会执行以下两个重要操作：</p>
</li>
<li><p>先将锁的持有者 owner 属性赋值为 null</p>
</li>
<li><p>唤醒等待链表中的一个线程（假定继承者）。</p>
</li>
</ol>
<p>在1和2之间，如果有其他线程刚好在尝试获取锁（例如自旋），则可以马上获取到锁。<br>2）<strong>当线程尝试获取锁失败，进入阻塞时，放入链表的顺序，和最终被唤醒的顺序是不一致的，也就是说你先进入链表，不代表你就会先被唤醒</strong>。</p>
<h3 id="JVM对synchronized的优化有哪些？"><a href="#JVM对synchronized的优化有哪些？" class="headerlink" title="JVM对synchronized的优化有哪些？"></a>JVM对synchronized的优化有哪些？</h3><h5 id="1-锁膨胀"><a href="#1-锁膨胀" class="headerlink" title="1. 锁膨胀"></a><strong>1. 锁膨胀</strong></h5><p>上面讲到锁有四种状态，并且会因实际情况进行膨胀升级，其膨胀方向是：<strong>无锁——&gt;偏向锁——&gt;轻量级锁——&gt;重量级锁</strong>，并且膨胀方向不可逆。</p>
<h5 id="2-锁消除"><a href="#2-锁消除" class="headerlink" title="2.锁消除"></a>2.锁消除</h5><p>每个线程一把锁 等于没有 直接消除</p>
<h5 id="3-锁粗化"><a href="#3-锁粗化" class="headerlink" title="3.锁粗化"></a>3.锁粗化</h5><p>锁同一个对象 合并<br>4.<strong>自适应自旋锁</strong><br>轻量级锁失败后，因为一个线程持有一把锁的时间并不长，切换线程不值得，因此就自旋等待<br>自适应自旋锁属于进一步优化，它的自旋的次数不再固定，其自旋的次数由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定，这就解决了自旋锁带来的缺点。</p>
<h3 id="synchronized-锁能降级吗？"><a href="#synchronized-锁能降级吗？" class="headerlink" title="synchronized 锁能降级吗？"></a>synchronized 锁能降级吗？</h3><p>可以的。<br>具体的触发时机：在全局安全点（safepoint）中，执行清理任务的时候会触发尝试降级锁。<br>当锁降级时，主要进行了以下操作：<br>1）恢复锁对象的 markword 对象头；（哦哦 原来所说的markword都是锁对象的呀）<br>2）重置 ObjectMonitor，然后将该 ObjectMonitor 放入全局空闲列表，等待后续使用。</p>
<h2 id="中断机制"><a href="#中断机制" class="headerlink" title="中断机制"></a>中断机制</h2><p>一种协作协商机制 ，中断的过程完全需要程序员自己实现 </p>
<h3 id="如何使用中断标识停止线程？"><a href="#如何使用中断标识停止线程？" class="headerlink" title="如何使用中断标识停止线程？"></a>如何使用中断标识停止线程？</h3><p>① 通过一个volatile变量实现<br>volatile保证了可见性，t2修改了标志位后能马上被t1看到<br>② 通过AtomicBoolean（原子布尔型）<br>③ 通过Thread类自带的中断api方法实现<br>interrupt() ：处于正常活动状态，那么会将该线程的中断标志设置为 true 仅此而已<br>如果线程处于被阻塞状态,在别的线程中调用当前线程对象的interrupt方法，那么线程将立即退出被阻塞状态（中断状态将被清除），并抛出一个InterruptedException异常<br>interrupted():1 返回当前线程的中断状态2 将当前线程的中断状态设为false<br><strong>isinterrupt</strong> 只是判断</p>
<h3 id="3种让线程等待和唤醒的方法"><a href="#3种让线程等待和唤醒的方法" class="headerlink" title="3种让线程等待和唤醒的方法"></a>3种让线程等待和唤醒的方法</h3><p>1、wait和notify方法必须要在同步块或者方法里面，且成对出现使用，先wait后notify才OK,顺序 </p>
<h3 id="LockSupport的阻塞唤醒"><a href="#LockSupport的阻塞唤醒" class="headerlink" title="LockSupport的阻塞唤醒"></a>LockSupport的阻塞唤醒</h3><p>3、LockSupport用来创建锁和其他同步类的基本线程阻塞原语 ，Lock Support调用的Unsafe中的native代码 ，使用了一种名为Permit（许可） 的概念来做到阻塞和唤醒线程的功能， 每个线程都有一个许可(permit)， -permit（许可）只有两个值1和0，默认是0。0 是阻塞，1是唤醒 - 可以把许可看成是一种(0,1)信号量（Semaphore），但与 Semaphore 不同的是，许可的累加上限是1<br>许可证只需要一个 先 unpark 再 park无效</p>
<h3 id="为什么可以突破wait-x2F-notify的原有调用顺序"><a href="#为什么可以突破wait-x2F-notify的原有调用顺序" class="headerlink" title="为什么可以突破wait&#x2F;notify的原有调用顺序?"></a>为什么可以突破wait&#x2F;notify的原有调用顺序?</h3><p>因为unpark获得了一个凭证， 之后再调用park方法， 就可以名正言顺的凭证消费， 故不会阻塞。 先发放了凭证后续可以畅通无阻。</p>
<h3 id="为什么唤醒两次后阻塞两次，但最终结果还会阻塞线程"><a href="#为什么唤醒两次后阻塞两次，但最终结果还会阻塞线程" class="headerlink" title="为什么唤醒两次后阻塞两次，但最终结果还会阻塞线程?"></a>为什么唤醒两次后阻塞两次，但最终结果还会阻塞线程?</h3><p>因为凭证的数量最多为1， 连续调用两次un park和调用一次un park效果一样， 只会增加一个凭证； 而调用两次park却需要消费两个凭证， 证不够， 不能放行。 </p>
<h2 id="JMM"><a href="#JMM" class="headerlink" title="JMM"></a>JMM</h2><h3 id="为什么要弄⼀个-CPU-⾼速缓存呢？"><a href="#为什么要弄⼀个-CPU-⾼速缓存呢？" class="headerlink" title="为什么要弄⼀个 CPU ⾼速缓存呢？"></a>为什么要弄⼀个 CPU ⾼速缓存呢？</h3><p><strong>CPU 缓存</strong> 解决 CPU 处理速度和内存处理速度不对等的问题。<br><strong>如何解决内存缓存不⼀致性问题？</strong><br>通过制定缓存⼀致协议</p>
<h3 id="讲⼀下-JMM-Java-内存模型"><a href="#讲⼀下-JMM-Java-内存模型" class="headerlink" title="讲⼀下 JMM(Java 内存模型)"></a>讲⼀下 JMM(Java 内存模型)</h3><p>每个线程都有自己的本地内存，读变量从自己内存里面，写变量，自己先改，改完刷回主存<br>volatile 关键字 除了防⽌ JVM 的指令重排 ，还有⼀个重要的作⽤就是保证变量的可⻅性<br>什么是JMM？<br>通过JMM来实现线程和主内存之间的读写关系，主要围绕三个特性展开<br>三大特性：原子性、可见性和有序性<br>原子性：一个操作是不可中断<br>可见：当一个线程修改了某一个共享变量的值，其他线程能够立即知道该变更 普通的共享变量不保证可见性 线程间变量值的传递均需要通过主内存来完成<br>有序性：指令重排 如果一个操作执行的结果需要对另一个操作可见性或者代码重新排序<br>happens-before：明确指定了一组排序规则，来保证线程间的可见性，这个规则就是happensbefore<br>如果一个操作happens-before另一个操作，那么<strong>第一个操作的执行结果将对第二个操作可见，</strong>而且第一个操作的执行顺序排在第二个操作之前**<br>要想保证 B 操作能够看到 A 操作的结果（无论它们是否在同一个线程），那么 A 和 B 之间必须满足 <strong>Happens-Before 关系</strong>：</p>
<ul>
<li><strong>单线程规则</strong>：一个线程中的每个动作都 happens-before 该线程中后续的每个动作</li>
<li><strong>监视器锁定规则</strong>：监听器的<strong>解锁</strong>动作 happens-before 后续对这个监听器的<strong>锁定</strong>动作 (unlock lock)</li>
<li><strong>volatile 变量规则</strong>：对 volatile 字段的写入动作 happens-before 后续对这个字段的每个读取动作</li>
<li><strong>线程 start 规则</strong>：线程 <strong>start()</strong> 方法的执行 happens-before 一个启动线程内的任意动作</li>
<li><strong>线程 join 规则</strong>：一个线程内的所有动作 happens-before 任意其他线程在该线程 <strong>join()</strong> 成功返回之前</li>
<li><strong>传递性</strong>：如果 A happens-before B, 且 B happens-before C, 那么 A happens-before C</li>
</ul>
<p>八条原则：1次序（unlock lock） 2传递 3线程启动（先写再读） （先start） 4 线程中断规则 (先interrupt() ，再Thread.interrupted()检测中断 ) 5线程终止规则(线程中的所有操作都先行发生于对此线程的终止检测 ) 6对象终结规则 （对象初始化先于finalize）<br><strong>Java 内存模型描述的是多线程对共享内存修改后彼此之间的可见性</strong></p>
<h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><p>volatile只能保证可见性和有序性 </p>
<h3 id="为什么volatile可以实现这些功能呢？-内存屏障"><a href="#为什么volatile可以实现这些功能呢？-内存屏障" class="headerlink" title="为什么volatile可以实现这些功能呢？(内存屏障)"></a>为什么volatile可以实现这些功能呢？(内存屏障)</h3><p>底层就是内存屏障 ,使得之前的所有读写操作都执行后才可以开始执行此点之后的操作 JVM指令<br>写指令后加store屏障 读指令前加load屏障<br>内存屏障之前的所有写操作都要回写到主内存， 内存屏障之后的所有读操作都能获得内存屏障之前的所有写操作的最新结果(实现了可见性)。 </p>
<h3 id="内存屏障能干嘛？"><a href="#内存屏障能干嘛？" class="headerlink" title="内存屏障能干嘛？"></a>内存屏障能干嘛？</h3><h3 id="volatile的内存语义"><a href="#volatile的内存语义" class="headerlink" title="volatile的内存语义"></a>volatile的内存语义</h3><p>volatile的写内存语义是直接刷新到主内存中，读的内存语义是直接从主内存中读取。一句话，volatile修饰的变量在某个工作内存修改后立刻会刷新会主内存，并把其他工作内存的该变量设置为无效。 </p>
<h3 id="读屏障和写屏障"><a href="#读屏障和写屏障" class="headerlink" title="读屏障和写屏障"></a>读屏障和写屏障</h3><p>写屏障：把存储在缓存的数据写回主内存 写屏障之前的写指令全部执行后面指令才能执行<br>读屏障：之后的读操作都需要在读屏障之后操作 保证读最新<br>我先写 你们后面先别读<br>隔断！我重新读主存</p>
<h3 id="happens-before之volatile变量规则"><a href="#happens-before之volatile变量规则" class="headerlink" title="happens-before之volatile变量规则"></a>happens-before之volatile变量规则</h3><p>1读2写</p>
<h3 id="为什么volatile不能保证原子性"><a href="#为什么volatile不能保证原子性" class="headerlink" title="为什么volatile不能保证原子性"></a>为什么volatile不能保证原子性</h3><p>i++<br>大家一起读，一起加一，就看谁提交的快了。提交快的直接让另一个计算失效<br>比如说你在计算的时候，别的线程已经提交了，所以你的计算直接失效了<br>本来是6 变成5<br>总结：第二个线程在第一个线程读取旧值和写回新值期间读取i的阈值，也就造成了线程安全问题 </p>
<h3 id="内存屏障的四大指令"><a href="#内存屏障的四大指令" class="headerlink" title="内存屏障的四大指令"></a>内存屏障的四大指令</h3><p>读屏障在每个volatile读操作的后面插入一个LoadLoad屏障在每个volatile读操作的后面插入一个LoadStore屏障<br>写屏障在每个volatile写操作的前面插入一个StoreStore屏障在每个volatile写操作的后面插入一个StoreLoad屏障 </p>
<h3 id="说说-synchronized-关键字和-volatile-关键字的区别-1"><a href="#说说-synchronized-关键字和-volatile-关键字的区别-1" class="headerlink" title="说说 synchronized 关键字和 volatile 关键字的区别"></a>说说 synchronized 关键字和 volatile 关键字的区别</h3><p>互补 存在<br>1、volatile 只能用于变量，syn可以变量、方法、类级别、代码块<br>2、volatile 关键字能保证数据的可⻅性，但不能保证数据的原⼦性。 synchronized 关键字两者都能保证<br>3、volatile <strong>不会造成线程的阻塞</strong>；synchronized <strong>可能会造成线程的阻塞</strong>。<br>4、volatile 关键字主要⽤于解决变量在多个线程之间的可⻅性，⽽ synchronized 关键字解决的是多个线程之间访问资源的同步性<br>5、volatile 本质是告诉当前变量工作内存中的值是不确定的，需要从主存中读取； synchronized 则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。</p>
<h3 id="策略"><a href="#策略" class="headerlink" title="策略"></a>策略</h3><p>是读用volatile，写用synchronized可以提高性能 </p>
<h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><p>DCL双锁案例 多线程指令重排 new 一个对象 空间–对象 –对象指向空间 解决：volatile</p>
<h3 id="凭什么我们java写了一个volatile关键字系统底层加入内存屏障？两者关系怎么勾搭上的？"><a href="#凭什么我们java写了一个volatile关键字系统底层加入内存屏障？两者关系怎么勾搭上的？" class="headerlink" title="凭什么我们java写了一个volatile关键字系统底层加入内存屏障？两者关系怎么勾搭上的？"></a>凭什么我们java写了一个volatile关键字系统底层加入内存屏障？两者关系怎么勾搭上的？</h3><p>字节码层面javap -c xx.class它其实添加了一个<strong>ACC_VOLATILE</strong></p>
<h2 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h2><h3 id="cas原理"><a href="#cas原理" class="headerlink" title="cas原理"></a>cas原理</h3><p>CAS （CompareAndSwap） CAS有3个操作数，位置内存值V，旧的预期值A，要修改的更新值B。 当且仅当旧的预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做或重来*当它重来重试的这种行为成为—自旋（do while）！ </p>
<h3 id="硬件级别保证"><a href="#硬件级别保证" class="headerlink" title="硬件级别保证"></a>硬件级别保证</h3><p>对总线加锁，效率比synchronized效率高<br>JDK提供的非阻塞原子性操作 <strong>Unsafe提供的CAS方法</strong>&#96;（如compareAndSwapXXX）底层实现即为CPU指令cmpxchg。<br><strong>CAS cpu并发原语</strong> 原子操作<br>AtomicInteger 类主要利用CAS (compare and swap) + volatile和 native 方法来保证原子操作，从而避免 synchronized 的高开销，执行效率大为提升。<br>执行cmpxchg指令的时候，会判断当前系统是否为多核系统，如果是就<strong>给总线加锁* *，</strong>只有一个_线程会对总线加锁<strong>成功，加锁成功之后会执行cas操作，也就是说CAS的原子性实际上是</strong>CPU实现的_</p>
<h3 id="unsafe"><a href="#unsafe" class="headerlink" title="unsafe"></a>unsafe</h3><p>Unsafe类中的方法都直接调用操作系统底层资源执行相应任务 </p>
<h3 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h3><p>尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试*获取锁 </p>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p><strong>1. ABA 问题</strong><br>并发环境下，假设初始条件是A，去修改数据时，发现是A就会执行修改。但是看到的虽然是A，中间可能发生了A变B，B又变回A的情况。此时A已经非彼A，数据即使成功修改，也可能有问题。<br>1、时间戳 2、版本号<br>可以通过AtomicStampedReference<strong>解决ABA问题</strong>，它，一个带有标记的原子引用类，通过控制变量值的版本来保证CAS的正确性。<br><strong>2. 循环时间长开销</strong><br>自旋CAS，如果一直循环执行，一直不成功，会给CPU带来非常大的执行开销。<br>很多时候，CAS思想体现，是有个自旋次数的，就是为了避开这个耗时问题~<br><strong>3. 只能保证一个变量的原子操作。</strong><br>CAS 保证的是对一个变量执行操作的原子性，如果对多个变量操作时，CAS 目前无法直接保证操作的原子性的。<br><strong>可以通过这两个方式解决这个问题</strong>：</p>
<ul>
<li><p>使用互斥锁来保证原子性；</p>
</li>
<li><p>将多个变量封装成对象，通过AtomicReference来保证原子性。</p>
<h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><p>ThreadLocal，即线程本地变量。如果你创建了一个ThreadLocal变量，那么访问这个变量的每个线程都会有这个变量的一个本地拷贝，多个线程操作这个变量的时候，实际是操作自己本地内存里面的变量，从而起到线程隔离的作用，避免了线程安全问题。<br><strong>ThreadLocal的应用场景有</strong></p>
</li>
<li><p>数据库连接池</p>
</li>
<li><p>会话管理中使用</p>
<h3 id="ThreadLocal-了解么？"><a href="#ThreadLocal-了解么？" class="headerlink" title="ThreadLocal 了解么？"></a>ThreadLocal 了解么？</h3></li>
<li><p>Thread类有一个类型为ThreadLocal.ThreadLocalMap的实例变量threadLocals，即每个线程都有一个属于自己的ThreadLocalMap。</p>
</li>
</ul>
<p>每⼀个线程都有⾃⼰的专属本地变量<br>可以使⽤ get 和 set ⽅法来获取默认值或将其值更改为当前线程所存的副本的值<br>最终变量存在ThreadLocalMap 中，key 为当前对象的 Thread 对象，值为 Object 对象 （ThreadLocalMap 是 ThreadLocal 的静态内部类。 ）</p>
<h3 id="ThreadLocal-内存泄露问题了解不？"><a href="#ThreadLocal-内存泄露问题了解不？" class="headerlink" title="ThreadLocal 内存泄露问题了解不？"></a>ThreadLocal 内存泄露问题了解不？</h3><p>ThreadLocalMap 中使⽤的 key 为 ThreadLocal 的弱引⽤,⽽ value 是强引⽤。<br>GC的时候，key变成Null，value无了，ThreadLocalMap 实现中已经考虑了这种情况，在调⽤ set() 、 get() 、 remove() ⽅法的时候，会清理掉 key 为 null的记录。使⽤完 ThreadLocal ⽅法后 最好⼿动调⽤ remove() ⽅法 最好需要手动调用remove方法。</p>
<h2 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h2><h3 id="了解ReentrantLock吗？"><a href="#了解ReentrantLock吗？" class="headerlink" title="了解ReentrantLock吗？"></a>了解ReentrantLock吗？</h3><p>ReetrantLock是一个可重入的独占锁，主要有两个特性，一个是支持公平锁和非公平锁，一个是可重入。 ReetrantLock实现依赖于AQS(AbstractQueuedSynchronizer)。<br>ReetrantLock主要依靠AQS维护一个阻塞队列，多个线程对加锁时，失败则会进入阻塞队列。等待唤醒，重新尝试加锁。</p>
<h3 id="ReadWriteLock是什么？"><a href="#ReadWriteLock是什么？" class="headerlink" title="ReadWriteLock是什么？"></a>ReadWriteLock是什么？</h3><p><strong>一句话 读读不影响</strong><br>首先ReentrantLock某些时候有局限，如果使用ReentrantLock，可能本身是为了防止线程A在写数据、线程B在读数据造成的数据不一致，但这样，如果线程C在读数据、线程D也在读数据，读数据是不会改变数据的，没有必要加锁，但是还是加锁了，降低了程序的性能。<br>因为这个，才诞生了读写锁ReadWriteLock。ReadWriteLock是一个读写锁接口，ReentrantReadWriteLock是ReadWriteLock接口的一个具体实现，实现了读写的分离，读锁是共享的，写锁是独占的，读和读之间不会互斥，读和写、写和读、写和写之间才会互斥，提升了读写的性能</p>
<h3 id="为什么要⽤线程池？"><a href="#为什么要⽤线程池？" class="headerlink" title="为什么要⽤线程池？"></a>为什么要⽤线程池？</h3><p>（线程池、数据库连接池、 Http 连接池 ）<br>主要是为了减少每次获取资源的消耗，提⾼对资源的利⽤率。<br>1、降低资源消耗：服用线程<br>2、提高速度：任务来的时候不用创建直接执行<br>3、使⽤线程池可以进⾏统⼀的分配，调优和监控。 </p>
<h2 id="Atomic"><a href="#Atomic" class="headerlink" title="Atomic"></a>Atomic</h2><h3 id="介绍⼀下-Atomic-原⼦类"><a href="#介绍⼀下-Atomic-原⼦类" class="headerlink" title="介绍⼀下 Atomic 原⼦类"></a>介绍⼀下 Atomic 原⼦类</h3><p>具有原⼦&#x2F;原⼦操作特征的类 </p>
<h3 id="JUC-包中的原⼦类是哪-4-类"><a href="#JUC-包中的原⼦类是哪-4-类" class="headerlink" title="JUC 包中的原⼦类是哪 4 类?"></a>JUC 包中的原⼦类是哪 4 类?</h3><p>4个类型 基本 数组 引用 属性修改<br>基本：Integer Long Boolean<br>数组： 后面加个Array<br>引用：去掉基本类型 加reference stampleReference<br>属性修改：基本后面加FileldUpdater</p>
<h3 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h3><p>AtomicInteger ：整形原⼦类AtomicLong ：⻓整型原⼦类AtomicBoolean ：布尔型原⼦类 </p>
<h3 id="数组类型"><a href="#数组类型" class="headerlink" title="数组类型"></a>数组类型</h3><p>使⽤原⼦的⽅式更新数组⾥的某个元素AtomicIntegerArray ：整形数组原⼦类AtomicLongArray ：⻓整形数组原⼦类AtomicReferenceArray ：引⽤类型数组原⼦类</p>
<h3 id="引⽤类型"><a href="#引⽤类型" class="headerlink" title="引⽤类型"></a>引⽤类型</h3><p>AtomicReference ：引⽤类型原⼦类AtomicStampedReference ：原⼦更新<strong>带有版本号</strong>的引⽤类型。该类将整数值与引⽤关联起来，可⽤于解决原⼦的更新数据和数据的版本号，可以解决使⽤ CAS 进⾏原⼦更新时可能出现的 ABA 问题。AtomicMarkableReference ：原⼦更新带有标记位的引⽤类型</p>
<h3 id="对象的属性修改类型"><a href="#对象的属性修改类型" class="headerlink" title="对象的属性修改类型"></a>对象的属性修改类型</h3><p>AtomicIntegerFieldUpdater ：原⼦更新整形字段的更新器AtomicLongFieldUpdater ：原⼦更新⻓整形字段的更新器AtomicReferenceFieldUpdater ：原⼦更新引⽤类型字段的更新器 </p>
<h3 id="Longadder"><a href="#Longadder" class="headerlink" title="Longadder"></a>Longadder</h3><p><strong>AtomicLong</strong>线程安全，可允许一些性能损耗，要求高精度时可使用AtomicLong是多个线程针对单个热点值value进行原子操作<strong>LongAdder</strong>当需要在高并发下有较好的性能表现，且对值的精确度要求不高时，可以使用保证性能，精度代价LongAdder是每个线程拥有自己的槽，各个线程一般只对自己槽中的那个值进行CAS操作<strong>小总结AtomicLong</strong>原理:CAS+自旋incrementAndGet场景:低并发下的全局计算AtomicLong能保证并发情况下计数的准确性，其内部通过<strong>CAS</strong>来解决并发安全性的问题缺陷高并发后性能急剧下降why?AtomicLong的自旋会称为瓶颈（N个线程CAS操作修改线程的值，每次只有一个成功过，其它N -1失败，失败的不停的自旋直到成功，这样大量失败自旋的情况，一下子cpu就打高了。）<strong>LongAdder</strong>原理CAS+Base+Cell数组分散空间换时间并分散了热点数据场景高并发的全局计算缺陷sum求和后还有计算线程修改结果的话，最后结果不够准确</p>
<h2 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h2><h3 id="AQS-了解么？"><a href="#AQS-了解么？" class="headerlink" title="AQS 了解么？"></a>AQS 了解么？</h3><p>AbstractQueuedSynchronizer<br>AbstractQueuedSynchronizer(AQS)提供了一套可用于实现锁同步机制的框架，不夸张地说，AQS是JUC同步框架的基石。AQS通过一个FIFO队列维护线程同步状态，实现类只需要继承该类，并重写指定方法即可实现一套线程同步机制。<br>AQS根据资源互斥级别提供了<strong>独占和共享</strong>两种资源访问模式；同时其定义Condition结构提供了wait&#x2F;signal等待唤醒机制。在JUC中，诸如ReentrantLock、CountDownLatch等都基于AQS实现。<br>抽象（基石）队列Queue（）同步器</p>
<h3 id="AQS原理概况"><a href="#AQS原理概况" class="headerlink" title="AQS原理概况"></a>AQS原理概况</h3><p>如果当前线程访问的资源空闲，将线程设置为有效工作线程，否则需要一套线程阻塞等待唤醒的机制，这个机制是由CLH队列（双向队列）实现的，即将暂时获取不到锁的线程加⼊到队列中。<br>AQS的原理并不复杂，AQS维护了一个volatile int state变量和一个CLH(三个人名缩写)双向队列，队列中的节点持有线程引用，每个节点均可通过getState()、setState()和compareAndSetState()对state进行修改和访问。<br>当线程获取锁时，即试图对state变量做修改，如修改成功则获取锁；如修改失败则包装为节点挂载到队列中，等待持有锁的线程释放锁并唤醒队列中的节点。<br><img src="https://cdn.nlark.com/yuque/0/2023/webp/226907/1684751100181-5421c582-3c61-4e25-adc5-98f4ffc5781d.webp#averageHue=%23121210&clientId=ubfd9bb9c-147a-4&from=paste&id=u005f7167&originHeight=456&originWidth=1154&originalType=url&ratio=1.25&rotation=0&showTitle=false&status=done&style=none&taskId=uc6bde927-8fee-439f-8d05-21318e920ae&title="></p>
<h3 id="AQS-对资源的共享⽅式"><a href="#AQS-对资源的共享⽅式" class="headerlink" title="AQS 对资源的共享⽅式"></a>AQS 对资源的共享⽅式</h3><ol>
<li>独占</li>
</ol>
<p>如reentrantLock<br>分为非公平（谁抢到是谁）和公平（排队顺序）</p>
<ol>
<li>共享</li>
</ol>
<p>CountDownLatch 、 Semaphore<br>ReentrantReadWriteLock 可以看成是组合式，因为 ReentrantReadWriteLock 也就是读写锁允许多个线程同时对某⼀资源进⾏读。 </p>
<h3 id="AQS-底层使⽤了模板⽅法模式"><a href="#AQS-底层使⽤了模板⽅法模式" class="headerlink" title="AQS 底层使⽤了模板⽅法模式"></a>AQS 底层使⽤了模板⽅法模式</h3><ol>
<li>⾃定义同步器时 ，使⽤者继承 AbstractQueuedSynchronizer 并重写指定的⽅法 </li>
<li>将AQS组合在自定义同步组件的实现中，并调用其模板方法，而这些模板方法会调用使用者重写的方法。</li>
<li><strong>AQS使用了模板方法模式，自定义同步器时需要重写下面几个AQS提供的模板方法：</strong><pre><code>isHeldExclusively()//该线程是否正在独占资源。只有用到condition才需要去实现它。
 tryAcquire(int)//独占方式。尝试获取资源，成功则返回true，失败则返回false。
 tryRelease(int)//独占方式。尝试释放资源，成功则返回true，失败则返回false。
 tryAcquireShared(int)//共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。
 tryReleaseShared(int)//共享方式。尝试释放资源，成功则返回true，失败则返回false。
</code></pre>
</li>
</ol>
<h3 id="⽤过-CountDownLatch-么？什么场景下⽤的？"><a href="#⽤过-CountDownLatch-么？什么场景下⽤的？" class="headerlink" title="⽤过 CountDownLatch 么？什么场景下⽤的？"></a>⽤过 CountDownLatch 么？什么场景下⽤的？</h3><p>允许 count 个线程阻塞在⼀个地⽅，直⾄所有线程的任务都执⾏完毕。<br>Service:十个service注入，多线程</p>
<h3 id="AQS-组件了解吗"><a href="#AQS-组件了解吗" class="headerlink" title="AQS 组件了解吗?"></a>AQS 组件了解吗?</h3><ul>
<li><strong>Semaphore(信号量)-允许多个线程同时访问：</strong> synchronized 和 ReentrantLock 都是一次只允许一个线程访问某个资源，Semaphore(信号量)可以指定多个线程同时访问某个资源。</li>
<li><strong>CountDownLatch （倒计时器）：</strong> CountDownLatch是一个同步工具类，用来协调多个线程之间的同步。这个工具通常用来控制线程等待，它可以让某一个线程等待直到倒计时结束，再开始执行。</li>
<li><strong>CyclicBarrier(循环栅栏)：</strong> CyclicBarrier 和 CountDownLatch 非常类似，它也可以实现线程间的技术等待，但是它的功能比 CountDownLatch 更加复杂和强大。主要应用场景和 CountDownLatch 类似。CyclicBarrier 的字面意思是可循环使用（Cyclic）的屏障（Barrier）。它要做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活。CyclicBarrier默认的构造方法是 CyclicBarrier(int parties)，其参数表示屏障拦截的线程数量，每个线程调用await方法告诉 CyclicBarrier 我已经到达了屏障，然后当前线程被阻塞。</li>
</ul>

    </div>

    
    
    
        <div class="reward-container">
  <div>“坚持原创技术分享，您的支持将鼓励我继续创作!“</div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/images/wechatpay.png" alt="ViaCheung 微信支付">
        <p>微信支付</p>
      </div>

  </div>
</div>

        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>ViaCheung
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://viacheung.github.io/2023/06/04/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" title="">http://viacheung.github.io/2023/06/04/多线程/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/zh-CN" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2023/06/04/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="prev" title="">
      <i class="fa fa-chevron-left"></i> 
    </a></div>
      <div class="post-nav-item">
    <a href="/2023/06/04/Java%E9%9B%86%E5%90%88/" rel="next" title="">
       <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%B7%E7%AE%80%E8%A6%81%E6%8F%8F%E8%BF%B0%E7%BA%BF%E7%A8%8B%E4%B8%8E%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%85%B3%E7%B3%BB-%E5%8C%BA%E5%88%AB%E5%8F%8A%E4%BC%98%E7%BC%BA%E7%82%B9%EF%BC%9F"><span class="nav-number">1.</span> <span class="nav-text">请简要描述线程与进程的关系,区别及优缺点？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%80%E8%BF%B0%E7%BA%BF%E7%A8%8B%E3%80%81%E7%A8%8B%E5%BA%8F%E3%80%81%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E3%80%82%E4%BB%A5%E5%8F%8A%E4%BB%96%E4%BB%AC%E4%B9%8B%E9%97%B4%E5%85%B3%E7%B3%BB%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">2.</span> <span class="nav-text">简述线程、程序、进程的基本概念。以及他们之间关系是什么?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F%E7%9A%84%E5%AF%B9%E6%AF%94%EF%BC%9F"><span class="nav-number">3.</span> <span class="nav-text">创建线程的三种方式的对比？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%A5%BD%E5%A4%84"><span class="nav-number">4.</span> <span class="nav-text">多线程的好处</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E7%A7%81%E6%9C%89%E7%9A%84"><span class="nav-number">5.</span> <span class="nav-text">程序计数器为什么是私有的?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88%E5%92%8C%E6%9C%AC%E5%9C%B0%E2%BD%85%E6%B3%95%E6%A0%88%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E7%A7%81%E6%9C%89%E7%9A%84"><span class="nav-number">6.</span> <span class="nav-text">**虚拟机栈和本地⽅法栈为什么是私有的? **</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E2%BC%80%E5%8F%A5%E8%AF%9D%E7%AE%80%E5%8D%95%E4%BA%86%E8%A7%A3%E5%A0%86%E5%92%8C%E2%BD%85%E6%B3%95%E5%8C%BA"><span class="nav-number">7.</span> <span class="nav-text">⼀句话简单了解堆和⽅法区</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%B9%B6%E2%BE%8F%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">8.</span> <span class="nav-text">说说并发与并⾏的区别?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E2%BD%A4%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%91%A2-%EF%BC%88%E8%80%8C%E4%B8%8D%E6%98%AF%E5%A4%9A%E8%BF%9B%E7%A8%8B%EF%BC%89"><span class="nav-number">9.</span> <span class="nav-text">为什么要使⽤多线程呢? （而不是多进程）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E2%BD%A4%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%8F%AF%E8%83%BD%E5%B8%A6%E6%9D%A5%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98"><span class="nav-number">10.</span> <span class="nav-text">使⽤多线程可能带来什么问题?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4%E7%BA%BF%E7%A8%8B%E7%9A%84%E2%BD%A3%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E7%8A%B6%E6%80%81"><span class="nav-number">11.</span> <span class="nav-text">说说线程的⽣命周期和状态?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%8A%E4%B8%8B%E2%BD%82%E5%88%87%E6%8D%A2"><span class="nav-number">12.</span> <span class="nav-text">什么是上下⽂切换?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%9C%89%E5%93%AA%E4%BA%9B%E5%9F%BA%E6%9C%AC%E7%8A%B6%E6%80%81"><span class="nav-number">13.</span> <span class="nav-text">线程有哪些基本状态?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%E6%AD%BB%E9%94%81-%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E6%AD%BB%E9%94%81"><span class="nav-number">14.</span> <span class="nav-text">什么是线程死锁?如何避免死锁?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3api%E5%AF%B9%E6%AF%94"><span class="nav-number">15.</span> <span class="nav-text">常见线程相关api对比</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Runnable-VS-Callable"><span class="nav-number">15.1.</span> <span class="nav-text">Runnable VS Callable</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#shutdown-VS-shutdownNow"><span class="nav-number">15.2.</span> <span class="nav-text">shutdown() VS shutdownNow()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#isTerminated-VS-isShutdown"><span class="nav-number">15.3.</span> <span class="nav-text">isTerminated() VS isShutdown()</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8E%92%E6%9F%A5%E6%AD%BB%E9%94%81"><span class="nav-number">16.</span> <span class="nav-text">排查死锁</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4-sleep-%E2%BD%85%E6%B3%95%E5%92%8C-wait-%E2%BD%85%E6%B3%95%E5%8C%BA%E5%88%AB%E5%92%8C%E5%85%B1%E5%90%8C%E7%82%B9"><span class="nav-number">17.</span> <span class="nav-text">说说 sleep() ⽅法和 wait() ⽅法区别和共同点?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E4%BB%AC%E8%B0%83%E2%BD%A4-start-%E2%BD%85%E6%B3%95%E6%97%B6%E4%BC%9A%E6%89%A7%E2%BE%8F-run-%E2%BD%85%E6%B3%95%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E4%BB%AC%E4%B8%8D%E8%83%BD%E7%9B%B4%E6%8E%A5%E8%B0%83%E2%BD%A4-run-%E2%BD%85%E6%B3%95"><span class="nav-number">18.</span> <span class="nav-text">为什么我们调⽤ start() ⽅法时会执⾏ run() ⽅法，为什么我们不能直接调⽤ run() ⽅法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Thread%E7%B1%BB%E4%B8%AD%E7%9A%84yield%E6%96%B9%E6%B3%95%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="nav-number">19.</span> <span class="nav-text">Thread类中的yield方法有什么作用？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E5%AE%9E%E4%BE%8B%E5%B9%B6%E8%BF%90%E8%A1%8C"><span class="nav-number">20.</span> <span class="nav-text">如何创建线程实例并运行</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E9%98%BB%E5%A1%9E%E7%9A%84%E4%B8%89%E7%A7%8D%E6%83%85%E5%86%B5"><span class="nav-number">21.</span> <span class="nav-text">线程阻塞的三种情况</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%AD%BB%E4%BA%A1%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="nav-number">22.</span> <span class="nav-text">线程死亡的三种方式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B%E6%98%AF%E5%95%A5%EF%BC%9F"><span class="nav-number">23.</span> <span class="nav-text">守护线程是啥？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%86%E8%A7%A3Fork-x2F-Join%E6%A1%86%E6%9E%B6%E5%90%97%EF%BC%9F"><span class="nav-number">24.</span> <span class="nav-text">了解Fork&#x2F;Join框架吗？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A1%A5%E5%85%85"><span class="nav-number">25.</span> <span class="nav-text">补充</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="nav-number">25.1.</span> <span class="nav-text">如何保证线程安全</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#synchronized"><span class="nav-number">26.</span> <span class="nav-text">synchronized</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4-synchronized-%E5%85%B3%E9%94%AE%E5%AD%97%E5%92%8C-volatile-%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">26.1.</span> <span class="nav-text">说说 synchronized 关键字和 volatile 关键字的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#synchronized-%E5%92%8C-Lock-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">26.2.</span> <span class="nav-text">synchronized 和 Lock 有什么区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#synchronized-%E5%92%8C-ReentrantLock-%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">26.3.</span> <span class="nav-text">synchronized 和 ReentrantLock 区别是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#synchronized%E7%9A%84%E7%94%A8%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="nav-number">26.4.</span> <span class="nav-text">synchronized的用法有哪些?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Synchronized%E7%9A%84%E4%BD%9C%E7%94%A8%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="nav-number">26.5.</span> <span class="nav-text">Synchronized的作用有哪些？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%B4%E2%BC%80%E8%AF%B4%E2%BE%83%E2%BC%B0%E5%AF%B9%E4%BA%8E-synchronized-%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BA%86%E8%A7%A3"><span class="nav-number">26.6.</span> <span class="nav-text">说⼀说⾃⼰对于 synchronized 关键字的了解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F%E6%9D%A5%E7%BB%99%E6%88%91%E2%BC%BF%E5%86%99%E2%BC%80%E4%B8%8B%EF%BC%81%E7%BB%99%E6%88%91%E8%A7%A3%E9%87%8A%E2%BC%80%E4%B8%8B%E5%8F%8C%E9%87%8D%E6%A3%80%E9%AA%8C%E9%94%81%E2%BD%85%E5%BC%8F%E5%AE%9E%E7%8E%B0%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8E%9F%E7%90%86%E5%91%97%EF%BC%81"><span class="nav-number">26.7.</span> <span class="nav-text">单例模式了解吗？来给我⼿写⼀下！给我解释⼀下双重检验锁⽅式实现单例模式的原理呗！</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E2%BD%85%E6%B3%95%E5%8F%AF%E4%BB%A5%E4%BD%BF%E2%BD%A4-synchronized-%E5%85%B3%E9%94%AE%E5%AD%97%E4%BF%AE%E9%A5%B0%E4%B9%88%EF%BC%9F"><span class="nav-number">26.8.</span> <span class="nav-text">构造⽅法可以使⽤ synchronized 关键字修饰么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E9%94%81%E6%98%AF%E5%95%A5%EF%BC%9F"><span class="nav-number">26.9.</span> <span class="nav-text">对象锁是啥？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81"><span class="nav-number">26.10.</span> <span class="nav-text">什么是可重入锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%B2%E2%BC%80%E4%B8%8B-synchronized%E5%BA%95%E5%B1%82"><span class="nav-number">26.11.</span> <span class="nav-text">讲⼀下 synchronized底层</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BB%BB%E4%BD%95%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E9%83%BD%E5%8F%AF%E4%BB%A5%E6%88%90%E4%B8%BA%E4%B8%80%E4%B8%AA%E9%94%81%EF%BC%9F"><span class="nav-number">26.11.1.</span> <span class="nav-text">为什么任何一个对象都可以成为一个锁？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#synchronized-%E5%90%8C%E6%AD%A5%E8%AF%AD%E5%8F%A5%E5%9D%97%E7%9A%84%E6%83%85%E5%86%B5"><span class="nav-number">26.11.2.</span> <span class="nav-text">synchronized 同步语句块的情况</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#synchronized-%E4%BF%AE%E9%A5%B0%E2%BD%85%E6%B3%95%E7%9A%84%E7%9A%84%E6%83%85%E5%86%B5"><span class="nav-number">26.11.3.</span> <span class="nav-text">synchronized 修饰⽅法的的情况</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">26.11.4.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E5%92%8Cmoniter%E5%85%B3%E8%81%94"><span class="nav-number">26.12.</span> <span class="nav-text">对象和moniter关联</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%AD-synchronized-%E9%94%81%E5%8D%87%E7%BA%A7%E7%9A%84%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">26.13.</span> <span class="nav-text">多线程中 synchronized 锁升级的原理是什么？</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81%E5%81%8F%E5%90%91%E9%94%81"><span class="nav-number">26.13.0.1.</span> <span class="nav-text">1、偏向锁</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E3%80%81%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81"><span class="nav-number">26.13.0.2.</span> <span class="nav-text">2、轻量级锁</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%BD%BB%E9%87%8F%E9%94%81%E5%92%8C%E5%81%8F%E5%90%91%E9%94%81%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E4%B8%8D%E5%90%8C%EF%BC%9A"><span class="nav-number">26.13.0.3.</span> <span class="nav-text">轻量锁和偏向锁的区别和不同：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3%E3%80%81%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81"><span class="nav-number">26.13.0.4.</span> <span class="nav-text">3、重量级锁</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%94%81%E5%8D%87%E7%BA%A7%E5%8F%91%E7%94%9F%E5%90%8E%EF%BC%8Chashcode%E5%8E%BB%E5%93%AA%E5%95%A6"><span class="nav-number">26.14.</span> <span class="nav-text">锁升级发生后，hashcode去哪啦</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#synchronized-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81%EF%BC%9F%E9%9D%9E%E5%85%AC%E5%B9%B3%E4%BD%93%E7%8E%B0%E5%9C%A8%E5%93%AA%E4%BA%9B%E5%9C%B0%E6%96%B9%EF%BC%9F"><span class="nav-number">26.15.</span> <span class="nav-text">synchronized 为什么是非公平锁？非公平体现在哪些地方？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JVM%E5%AF%B9synchronized%E7%9A%84%E4%BC%98%E5%8C%96%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="nav-number">26.16.</span> <span class="nav-text">JVM对synchronized的优化有哪些？</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-%E9%94%81%E8%86%A8%E8%83%80"><span class="nav-number">26.16.0.1.</span> <span class="nav-text">1. 锁膨胀</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-%E9%94%81%E6%B6%88%E9%99%A4"><span class="nav-number">26.16.0.2.</span> <span class="nav-text">2.锁消除</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-%E9%94%81%E7%B2%97%E5%8C%96"><span class="nav-number">26.16.0.3.</span> <span class="nav-text">3.锁粗化</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#synchronized-%E9%94%81%E8%83%BD%E9%99%8D%E7%BA%A7%E5%90%97%EF%BC%9F"><span class="nav-number">26.17.</span> <span class="nav-text">synchronized 锁能降级吗？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%AD%E6%96%AD%E6%9C%BA%E5%88%B6"><span class="nav-number">27.</span> <span class="nav-text">中断机制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E4%B8%AD%E6%96%AD%E6%A0%87%E8%AF%86%E5%81%9C%E6%AD%A2%E7%BA%BF%E7%A8%8B%EF%BC%9F"><span class="nav-number">27.1.</span> <span class="nav-text">如何使用中断标识停止线程？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E7%A7%8D%E8%AE%A9%E7%BA%BF%E7%A8%8B%E7%AD%89%E5%BE%85%E5%92%8C%E5%94%A4%E9%86%92%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">27.2.</span> <span class="nav-text">3种让线程等待和唤醒的方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LockSupport%E7%9A%84%E9%98%BB%E5%A1%9E%E5%94%A4%E9%86%92"><span class="nav-number">27.3.</span> <span class="nav-text">LockSupport的阻塞唤醒</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8F%AF%E4%BB%A5%E7%AA%81%E7%A0%B4wait-x2F-notify%E7%9A%84%E5%8E%9F%E6%9C%89%E8%B0%83%E7%94%A8%E9%A1%BA%E5%BA%8F"><span class="nav-number">27.4.</span> <span class="nav-text">为什么可以突破wait&#x2F;notify的原有调用顺序?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%94%A4%E9%86%92%E4%B8%A4%E6%AC%A1%E5%90%8E%E9%98%BB%E5%A1%9E%E4%B8%A4%E6%AC%A1%EF%BC%8C%E4%BD%86%E6%9C%80%E7%BB%88%E7%BB%93%E6%9E%9C%E8%BF%98%E4%BC%9A%E9%98%BB%E5%A1%9E%E7%BA%BF%E7%A8%8B"><span class="nav-number">27.5.</span> <span class="nav-text">为什么唤醒两次后阻塞两次，但最终结果还会阻塞线程?</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JMM"><span class="nav-number">28.</span> <span class="nav-text">JMM</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%BC%84%E2%BC%80%E4%B8%AA-CPU-%E2%BE%BC%E9%80%9F%E7%BC%93%E5%AD%98%E5%91%A2%EF%BC%9F"><span class="nav-number">28.1.</span> <span class="nav-text">为什么要弄⼀个 CPU ⾼速缓存呢？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%B2%E2%BC%80%E4%B8%8B-JMM-Java-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B"><span class="nav-number">28.2.</span> <span class="nav-text">讲⼀下 JMM(Java 内存模型)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#volatile"><span class="nav-number">29.</span> <span class="nav-text">volatile</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88volatile%E5%8F%AF%E4%BB%A5%E5%AE%9E%E7%8E%B0%E8%BF%99%E4%BA%9B%E5%8A%9F%E8%83%BD%E5%91%A2%EF%BC%9F-%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C"><span class="nav-number">29.1.</span> <span class="nav-text">为什么volatile可以实现这些功能呢？(内存屏障)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C%E8%83%BD%E5%B9%B2%E5%98%9B%EF%BC%9F"><span class="nav-number">29.2.</span> <span class="nav-text">内存屏障能干嘛？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#volatile%E7%9A%84%E5%86%85%E5%AD%98%E8%AF%AD%E4%B9%89"><span class="nav-number">29.3.</span> <span class="nav-text">volatile的内存语义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%BB%E5%B1%8F%E9%9A%9C%E5%92%8C%E5%86%99%E5%B1%8F%E9%9A%9C"><span class="nav-number">29.4.</span> <span class="nav-text">读屏障和写屏障</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#happens-before%E4%B9%8Bvolatile%E5%8F%98%E9%87%8F%E8%A7%84%E5%88%99"><span class="nav-number">29.5.</span> <span class="nav-text">happens-before之volatile变量规则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88volatile%E4%B8%8D%E8%83%BD%E4%BF%9D%E8%AF%81%E5%8E%9F%E5%AD%90%E6%80%A7"><span class="nav-number">29.6.</span> <span class="nav-text">为什么volatile不能保证原子性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C%E7%9A%84%E5%9B%9B%E5%A4%A7%E6%8C%87%E4%BB%A4"><span class="nav-number">29.7.</span> <span class="nav-text">内存屏障的四大指令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%B4%E8%AF%B4-synchronized-%E5%85%B3%E9%94%AE%E5%AD%97%E5%92%8C-volatile-%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E5%8C%BA%E5%88%AB-1"><span class="nav-number">29.8.</span> <span class="nav-text">说说 synchronized 关键字和 volatile 关键字的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AD%96%E7%95%A5"><span class="nav-number">29.9.</span> <span class="nav-text">策略</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A1%88%E4%BE%8B"><span class="nav-number">29.10.</span> <span class="nav-text">案例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%AD%E4%BB%80%E4%B9%88%E6%88%91%E4%BB%ACjava%E5%86%99%E4%BA%86%E4%B8%80%E4%B8%AAvolatile%E5%85%B3%E9%94%AE%E5%AD%97%E7%B3%BB%E7%BB%9F%E5%BA%95%E5%B1%82%E5%8A%A0%E5%85%A5%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C%EF%BC%9F%E4%B8%A4%E8%80%85%E5%85%B3%E7%B3%BB%E6%80%8E%E4%B9%88%E5%8B%BE%E6%90%AD%E4%B8%8A%E7%9A%84%EF%BC%9F"><span class="nav-number">29.11.</span> <span class="nav-text">凭什么我们java写了一个volatile关键字系统底层加入内存屏障？两者关系怎么勾搭上的？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CAS"><span class="nav-number">30.</span> <span class="nav-text">CAS</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#cas%E5%8E%9F%E7%90%86"><span class="nav-number">30.1.</span> <span class="nav-text">cas原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A1%AC%E4%BB%B6%E7%BA%A7%E5%88%AB%E4%BF%9D%E8%AF%81"><span class="nav-number">30.2.</span> <span class="nav-text">硬件级别保证</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#unsafe"><span class="nav-number">30.3.</span> <span class="nav-text">unsafe</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E6%97%8B%E9%94%81"><span class="nav-number">30.4.</span> <span class="nav-text">自旋锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%97%AE%E9%A2%98"><span class="nav-number">30.5.</span> <span class="nav-text">问题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ThreadLocal"><span class="nav-number">31.</span> <span class="nav-text">ThreadLocal</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ThreadLocal-%E4%BA%86%E8%A7%A3%E4%B9%88%EF%BC%9F"><span class="nav-number">31.1.</span> <span class="nav-text">ThreadLocal 了解么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ThreadLocal-%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E9%97%AE%E9%A2%98%E4%BA%86%E8%A7%A3%E4%B8%8D%EF%BC%9F"><span class="nav-number">31.2.</span> <span class="nav-text">ThreadLocal 内存泄露问题了解不？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ReentrantLock"><span class="nav-number">32.</span> <span class="nav-text">ReentrantLock</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%86%E8%A7%A3ReentrantLock%E5%90%97%EF%BC%9F"><span class="nav-number">32.1.</span> <span class="nav-text">了解ReentrantLock吗？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ReadWriteLock%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">32.2.</span> <span class="nav-text">ReadWriteLock是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E2%BD%A4%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%9F"><span class="nav-number">32.3.</span> <span class="nav-text">为什么要⽤线程池？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Atomic"><span class="nav-number">33.</span> <span class="nav-text">Atomic</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%8B%E7%BB%8D%E2%BC%80%E4%B8%8B-Atomic-%E5%8E%9F%E2%BC%A6%E7%B1%BB"><span class="nav-number">33.1.</span> <span class="nav-text">介绍⼀下 Atomic 原⼦类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JUC-%E5%8C%85%E4%B8%AD%E7%9A%84%E5%8E%9F%E2%BC%A6%E7%B1%BB%E6%98%AF%E5%93%AA-4-%E7%B1%BB"><span class="nav-number">33.2.</span> <span class="nav-text">JUC 包中的原⼦类是哪 4 类?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B"><span class="nav-number">33.3.</span> <span class="nav-text">基本类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E7%B1%BB%E5%9E%8B"><span class="nav-number">33.4.</span> <span class="nav-text">数组类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%95%E2%BD%A4%E7%B1%BB%E5%9E%8B"><span class="nav-number">33.5.</span> <span class="nav-text">引⽤类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B1%9E%E6%80%A7%E4%BF%AE%E6%94%B9%E7%B1%BB%E5%9E%8B"><span class="nav-number">33.6.</span> <span class="nav-text">对象的属性修改类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Longadder"><span class="nav-number">33.7.</span> <span class="nav-text">Longadder</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#AQS"><span class="nav-number">34.</span> <span class="nav-text">AQS</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#AQS-%E4%BA%86%E8%A7%A3%E4%B9%88%EF%BC%9F"><span class="nav-number">34.1.</span> <span class="nav-text">AQS 了解么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AQS%E5%8E%9F%E7%90%86%E6%A6%82%E5%86%B5"><span class="nav-number">34.2.</span> <span class="nav-text">AQS原理概况</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AQS-%E5%AF%B9%E8%B5%84%E6%BA%90%E7%9A%84%E5%85%B1%E4%BA%AB%E2%BD%85%E5%BC%8F"><span class="nav-number">34.3.</span> <span class="nav-text">AQS 对资源的共享⽅式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AQS-%E5%BA%95%E5%B1%82%E4%BD%BF%E2%BD%A4%E4%BA%86%E6%A8%A1%E6%9D%BF%E2%BD%85%E6%B3%95%E6%A8%A1%E5%BC%8F"><span class="nav-number">34.4.</span> <span class="nav-text">AQS 底层使⽤了模板⽅法模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E2%BD%A4%E8%BF%87-CountDownLatch-%E4%B9%88%EF%BC%9F%E4%BB%80%E4%B9%88%E5%9C%BA%E6%99%AF%E4%B8%8B%E2%BD%A4%E7%9A%84%EF%BC%9F"><span class="nav-number">34.5.</span> <span class="nav-text">⽤过 CountDownLatch 么？什么场景下⽤的？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AQS-%E7%BB%84%E4%BB%B6%E4%BA%86%E8%A7%A3%E5%90%97"><span class="nav-number">34.6.</span> <span class="nav-text">AQS 组件了解吗?</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="ViaCheung"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">ViaCheung</p>
  <div class="site-description" itemprop="description">el psy congroo</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">32</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/viacheung" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;viacheung" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:viacheung5@gmail.com" title="E-Mail → mailto:viacheung5@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/zh-CN" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ViaCheung</span>
</div>

<!--
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div> -->

<!-- 网站运行时间的设置 -->
<span id="timeDate">载入天数...</span>
<span id="times">载入时分秒...</span>
<script>
    var now = new Date();
    function createtime() {
        var grt= new Date("03/01/2023 10:00:00"); //此处修改你的建站时间或者网站上线时间
        now.setTime(now.getTime()+250);
        days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days);
        hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours);
        if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);
        mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;}
        seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
        snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;}
        document.getElementById("timeDate").innerHTML = "本站已安全运行 "+dnum+" 天 ";
        document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒.";
    }
setInterval("createtime()",250);
</script>
        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>

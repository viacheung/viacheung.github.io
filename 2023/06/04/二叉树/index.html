<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.1.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"viacheung.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="相关知识完全二叉树： 从满二叉树最后一个结点往前删除 二叉搜索树：左小右大 带数值">
<meta property="og:type" content="article">
<meta property="og:title" content="二叉树">
<meta property="og:url" content="http://viacheung.github.io/2023/06/04/%E4%BA%8C%E5%8F%89%E6%A0%91/index.html">
<meta property="og:site_name" content="命运石之门">
<meta property="og:description" content="相关知识完全二叉树： 从满二叉树最后一个结点往前删除 二叉搜索树：左小右大 带数值">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/viacheung/img/main/image/20210203155800503.png">
<meta property="og:image" content="https://raw.githubusercontent.com/viacheung/img/main/image/image-20221029171009163.png">
<meta property="og:image" content="https://raw.githubusercontent.com/viacheung/img/main/image/image-20221031151200655.png">
<meta property="og:image" content="https://raw.githubusercontent.com/viacheung/img/main/image/image-20221101131731698.png">
<meta property="og:image" content="https://raw.githubusercontent.com/viacheung/img/main/image/image-20221101131921565.png">
<meta property="og:image" content="https://raw.githubusercontent.com/viacheung/img/main/image/image-20221104202039345.png">
<meta property="og:image" content="https://raw.githubusercontent.com/viacheung/img/main/image/image-20221106213939182.png">
<meta property="og:image" content="https://raw.githubusercontent.com/viacheung/img/main/image/image-20221009174111479.png">
<meta property="og:image" content="https://raw.githubusercontent.com/viacheung/img/main/image/image-20221007210341362.png">
<meta property="og:image" content="https://raw.githubusercontent.com/viacheung/img/main/image/image-20220919202400688.png">
<meta property="og:image" content="https://raw.githubusercontent.com/viacheung/img/main/image/image-20221107120758813.png">
<meta property="og:image" content="https://raw.githubusercontent.com/viacheung/img/main/image/image-20221108190047074.png">
<meta property="og:image" content="https://raw.githubusercontent.com/viacheung/img/main/image/image-20221109113639092.png">
<meta property="og:image" content="https://raw.githubusercontent.com/viacheung/img/main/image/0f91f7cbf5740de86e881eb7427c6c3993f4eca3624ca275d71e21c5e3e2c550-226_2.gif">
<meta property="og:image" content="https://raw.githubusercontent.com/viacheung/img/main/image/f9e06159617cbf8372b544daee37be70286c3d9b762c016664e225044fc4d479-226_%E8%BF%AD%E4%BB%A3.gif">
<meta property="og:image" content="https://raw.githubusercontent.com/viacheung/img/main/image/image-20220923172523030.png">
<meta property="og:image" content="https://raw.githubusercontent.com/viacheung/img/main/image/image-20220923172455790.png">
<meta property="og:image" content="https://raw.githubusercontent.com/viacheung/img/main/image/image-20220923172606089.png">
<meta property="og:image" content="https://raw.githubusercontent.com/viacheung/img/main/image/20211030125421.png">
<meta property="og:image" content="https://raw.githubusercontent.com/viacheung/img/main/image/20211030125421.png">
<meta property="og:image" content="https://raw.githubusercontent.com/viacheung/img/main/image/717C18C1D3175AB683DE7E050A4236ED">
<meta property="og:image" content="https://raw.githubusercontent.com/viacheung/img/main/image/23368751A430C010C582743B0E2F9414">
<meta property="og:image" content="https://raw.githubusercontent.com/viacheung/img/main/image/05EE17BA6FA1FB90EDDEF5A26D0FEEF4">
<meta property="og:image" content="https://raw.githubusercontent.com/viacheung/img/main/image/07986E476EB2CECD3C5F81D0BCADBE12">
<meta property="og:image" content="https://raw.githubusercontent.com/viacheung/img/main/image/fdcd3bd27f4008948084f6ec86b58535e71f66862bd89a34bd6fe4cc42d68e89-16578569951531.gif">
<meta property="og:image" content="https://raw.githubusercontent.com/viacheung/img/main/image/fd1d63037d0e2f787d2140fee406e109094a4f66ab0837a7273f8b371eef8096.jpg">
<meta property="og:image" content="https://raw.githubusercontent.com/viacheung/img/main/image/4529bf559c6a2d84d550eebaee027c3b7ae25069e4ec91f27b29a4c6358d6662.gif">
<meta property="og:image" content="https://raw.githubusercontent.com/viacheung/img/main/image/9f178b56ff1c94388d893f2fb48e9e77e186aba7cfd7483637776359062d68b8.jpg">
<meta property="og:image" content="https://raw.githubusercontent.com/viacheung/img/main/image/94cd1fa999df0276f1dae77a9cca83f4cabda9e2e0b8571cd9550a8ee3545f56.gif">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2023/png/226907/1685799400993-fcd546a8-e08a-44c6-ada3-220be1d8330a.png">
<meta property="article:published_time" content="2023-06-04T06:12:10.000Z">
<meta property="article:modified_time" content="2023-06-04T06:33:37.565Z">
<meta property="article:author" content="ViaCheung">
<meta property="article:tag" content="Java,python">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/viacheung/img/main/image/20210203155800503.png">

<link rel="canonical" href="http://viacheung.github.io/2023/06/04/%E4%BA%8C%E5%8F%89%E6%A0%91/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>二叉树 | 命运石之门</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">命运石之门</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">欢迎来到我的博客空间🙇</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-schedule">

    <a href="/schedule/" rel="section"><i class="fa fa-calendar fa-fw"></i>日程表</a>

  </li>
        <li class="menu-item menu-item-sitemap">

    <a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>站点地图</a>

  </li>
        <li class="menu-item menu-item-commonweal">

    <a href="/404/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>公益 404</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/viacheung" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://viacheung.github.io/2023/06/04/%E4%BA%8C%E5%8F%89%E6%A0%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="ViaCheung">
      <meta itemprop="description" content="el psy congroo">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="命运石之门">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          二叉树
        </h1>

        <div class="post-meta">
	  <span class="post-time">

	  
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2023-06-04 14:12:10 / 修改时间：14:33:37" itemprop="dateCreated datePublished" datetime="2023-06-04T14:12:10+08:00">2023-06-04</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="相关知识"><a href="#相关知识" class="headerlink" title="相关知识"></a>相关知识</h2><p>完全二叉树： 从满二叉树最后一个结点往前删除</p>
<p>二叉搜索树：左小右大 带数值<span id="more"></span></p>
<p>平衡二叉搜索树：AVL 高度差值小于2</p>
<p>存储方式：数组 链式 <strong>如果父节点的数组下标是 i，那么它的左孩子就是 i</strong> ***** <strong>2 + 1，右孩子就是 i</strong> ***** <strong>2 + 2。</strong>想012就行</p>
<p>遍历方式：深度：前中后 迭代 递归 栈</p>
<p>​				 广度 层次 迭代 队列</p>
<p>定义：</p>
<pre><code class="plain">public class TreeNode &#123;
     int val;
     TreeNode left;
     TreeNode right;
     TreeNode() &#123;&#125;
     TreeNode(int val) &#123; this.val = val; &#125;
     TreeNode(int val, TreeNode left, TreeNode right) &#123;
             this.val = val;
             this.left = left;
             this.right = right;
     &#125;
 &#125;
</code></pre>
<p>二叉排序<a target="_blank" rel="noopener" href="http://data.biancheng.net/view/313.html">树</a>（Binary Sort Tree，简称 BST ）又叫二叉查找树和二叉搜索树，是一种实现动态查找表的树形存储结构。</p>
<ul>
<li>节点的左子树仅包含键 <strong>小于</strong> 节点键的节点。</li>
<li>节点的右子树仅包含键 <strong>大于</strong> 节点键的节点。</li>
<li>左右子树也必须是二叉搜索树。<strong>递归思路：</strong></li>
</ul>
<ol>
<li><strong>确定递归函数的参数和返回值：</strong> 确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数， 并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。</li>
<li><strong>确定终止条件：</strong> 写完了递归算法, 运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对，操作系统也是用一个栈的结构来保存每一层递归的信息，如果递归没有终止，操作系统的内存栈必然就会溢出。</li>
<li><strong>确定单层递归的逻辑：</strong> 确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程。</li>
</ol>
<h2 id="对称二叉树"><a href="#对称二叉树" class="headerlink" title="对称二叉树"></a>对称二叉树</h2><p>给你一个二叉树的根节点 root ， 检查它是否轴对称。</p>
<p>我们可以实现这样一个递归函数，通过「同步移动」两个指针的方法来遍历这棵树，p指针和 q 指针一开始都指向这棵树的根，随后 p 右移时，q 左移 p 左移时，q 右移。每次检查当前 p 和 q 节点的值是否相等，如果相等再判断左右子树是否对称。</p>
<pre><code class="plain">class Solution &#123;
     public boolean isSymmetric(TreeNode root) &#123;
         return check(root, root);
     &#125;
 
     public boolean check(TreeNode p, TreeNode q) &#123;
         if (p == null &amp;&amp; q == null) &#123;
             return true;
         &#125;
         if (p == null || q == null) &#123;
             return false;
         &#125;
         return p.val == q.val &amp;&amp; check(p.left, q.right) &amp;&amp; check(p.right, q.left);     
     &#125;
 &#125;
</code></pre>
<h2 id="二叉树的最大深度"><a href="#二叉树的最大深度" class="headerlink" title="二叉树的最大深度"></a>二叉树的最大深度</h2><p>给定一个二叉树，找出其最大深度。 二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p>
<pre><code class="plain">class Solution &#123;
     public int maxDepth(TreeNode root) &#123;
         if (root == null) &#123;
             return 0;
         &#125; else &#123;
             int leftHeight = maxDepth(root.left);
             int rightHeight = maxDepth(root.right);
             return Math.max(leftHeight, rightHeight) + 1;
         &#125;
     &#125;
 &#125;
 
 //return root == null ? 0 : Math.max(this.maxDepth(root.left), this.maxDepth(root.right)) + 1;
public int maxDepth (TreeNode root) &#123;
         // write code here
         if(root==null) return 0;
         return Math.max(maxDepth(root.left),maxDepth(root.right))+1;
     &#125;
</code></pre>
<h2 id="二叉树最小深度"><a href="#二叉树最小深度" class="headerlink" title="二叉树最小深度"></a>二叉树最小深度</h2><p>给定一个二叉树，找出其最小深度。</p>
<p>最小深度是从根节点到最近叶子节点的最短路径上的节点数量。（注意这里 和求最大深度不一样）</p>
<p><img src="https://raw.githubusercontent.com/viacheung/img/main/image/20210203155800503.png" alt="img"></p>
<pre><code class="plain">class Solution &#123;
     public int minDepth(TreeNode root) &#123;
         if (root == null) return 0;
         //这两个else if 很重要 就是为了防止出现上图所示情况
         else if (root.left == null) return minDepth(root.right) + 1;
         else if (root.right == null) return minDepth(root.left) + 1;
         else return Math.min(minDepth(root.left), minDepth(root.right)) + 1;
     &#125;
 &#125;
</code></pre>
<h2 id="完全二叉树的节点个数-×"><a href="#完全二叉树的节点个数-×" class="headerlink" title="完全二叉树的节点个数(×)"></a>完全二叉树的节点个数(×)</h2><p>给你一棵 <strong>完全二叉树</strong> 的根节点 root ，求出该树的节点个数。</p>
<p><img src="https://raw.githubusercontent.com/viacheung/img/main/image/image-20221029171009163.png" alt="img"></p>
<p><img src="https://raw.githubusercontent.com/viacheung/img/main/image/image-20221031151200655.png" alt="img"></p>
<pre><code class="plain">class Solution &#123;
     public int countNodes(TreeNode root) &#123;
         if(root == null) &#123;
             return 0;
         &#125;
         int left = countNodes(root.left);
         int right = countNodes(root.right);
         
         return left+right+1;
         
     &#125;
 &#125;
</code></pre>
<p>遍历树来统计节点是一种时间复杂度为 O(n) 的简单解决方案。你可以设计一个更快的算法吗</p>
<pre><code class="plain">class Solution &#123;
     public int countNodes(TreeNode root) &#123;
         if (root == null) &#123;
             return 0;
         &#125;
         int level = 0;
         TreeNode node = root;
         //去最下左结点  记录下结点和层数
         while (node.left != null) &#123;
             level++;
             node = node.left;
         &#125;
         //          2^level
         //当 0≤i&lt;h 时，第 i层包含 2^i 个节点，最底层包含的节点数最少为 1，最多为 2^h。
         int low = 1 &lt;&lt; level, high = (1 &lt;&lt; (level + 1)) - 1;
         while (low &lt; high) &#123;
             // 这一句一用就会超时  原因是防止溢出，可能出现两者相加超过int表示范围
             int mid = (high - low + 1) / 2 + low;
             if (exists(root, level, mid)) &#123;
                 low = mid;
             &#125; else &#123;
                 high = mid - 1;
             &#125;
         &#125;
         return low;
     &#125;
     bits:1000-&gt; 100&gt; 10 &gt;1
     k:1100 右 左 左   
     public boolean exists(TreeNode root, int level, int k) &#123;
         int bits = 1 &lt;&lt; (level - 1);
         TreeNode node = root;
         while (node != null &amp;&amp; bits &gt; 0) &#123;
             if ((bits &amp; k) == 0) &#123;
                 node = node.left;
             &#125; else &#123;
                 node = node.right;
             &#125;
             bits &gt;&gt;= 1;
         &#125;
         return node != null;
     &#125;
 &#125;
</code></pre>
<h2 id="二叉树的所有路径"><a href="#二叉树的所有路径" class="headerlink" title="二叉树的所有路径"></a>二叉树的所有路径</h2><p>给你一个二叉树的根节点 root ，按 <strong>任意顺序</strong> ，返回所有从根节点到叶子节点的路径。</p>
<p><strong>叶子节点</strong> 是指没有子节点的节点。</p>
<pre><code class="plain">//我写的 那就选这个！
 class Solution &#123;
     List&lt;String&gt; ans=new ArrayList&lt;&gt;();
     public List&lt;String&gt; binaryTreePaths(TreeNode root) &#123;
         StringBuilder sb=new StringBuilder();
         dfs(root,sb);
         return ans;
     &#125;
     public void dfs(TreeNode root, StringBuilder sb)&#123;
         if(root==null) return;
         if(sb.length()==0)&#123;
             sb.append(root.val);
         &#125;else&#123;
             sb.append(&quot;-&gt;&quot;).append(root.val);
         &#125;
         if(root.left==null&amp;&amp;root.right==null)&#123;
             ans.add(sb.toString());
             return;
         &#125;
         //注意这里 一定要new StringBuilder 递归左子树之后再传入右子树的sb已经变成左子树的路径了，因此不能用sb了，而应该把前面sb的值copy来
         dfs(root.left,new StringBuilder(sb)); 
         dfs(root.right,new StringBuilder(sb));
 
     &#125;
 &#125;
//还有一种方法，就是回溯。
     private void dfs(TreeNode root, StringBuilder cur, List&lt;String&gt; paths) &#123;
         if (root == null) return;
         if (root.left == null &amp;&amp; root.right == null) &#123;
             paths.add(cur.toString() + root.val);
             return;
         &#125;
         int sz = cur.length();
         cur.append(root.val).append(&quot;-&gt;&quot;);
         dfs(root.left, cur);
         dfs(root.right, cur);
         cur.delete(sz, cur.length());//在这里已经定义了dfs的回溯，因此dfs(root.left, cur);执行完毕就已经是回溯的了，也就不会影响        dfs(root.right, cur);的路径了！ 完美！
     &#125;
</code></pre>
<h2 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h2><p>给定一个二叉树，判断它是否是高度平衡的二叉树。</p>
<p>本题中，一棵高度平衡二叉树定义为：一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1 。</p>
<p><strong>方法一：自顶向下的递归</strong>（选这个）</p>
<p><img src="https://raw.githubusercontent.com/viacheung/img/main/image/image-20221101131731698.png" alt="img"></p>
<pre><code class="plain">class Solution &#123;
     public boolean isBalanced(TreeNode root) &#123;
         if(root==null) return true;
         //这个&amp;&amp;开始没想到 根节点高度满足还需要后面节点也都是如此  
         return Math.abs(getDepth(root.right)-getDepth(root.left))&lt;2&amp;&amp;isBalanced(root.right)&amp;&amp;isBalanced(root.left);
     &#125;
     public int getDepth(TreeNode root)&#123;
         if(root==null) return 0;
         return Math.max(getDepth(root.left),getDepth(root.right))+1;
     &#125;
 &#125;
 O(n^2)
</code></pre>
<p><img src="https://raw.githubusercontent.com/viacheung/img/main/image/image-20221101131921565.png" alt="img"></p>
<pre><code class="plain">class Solution &#123;
     public boolean isBalanced(TreeNode root) &#123;
         return height(root) &gt;= 0;
     &#125;
 
     public int height(TreeNode root) &#123;
         if (root == null) &#123;
             return 0;
         &#125;
         int leftHeight = height(root.left);
         int rightHeight = height(root.right);
         if (leftHeight == -1 || rightHeight == -1 || Math.abs(leftHeight - rightHeight) &gt; 1) &#123;
             return -1;
         &#125; else &#123;
             return Math.max(leftHeight, rightHeight) + 1;
         &#125;
     &#125;
 &#125;
 O(n)
     自底向上的递归就是及时止损 自顶向下的递归就是不管三七二十一先把所有的高度算一遍
</code></pre>
<h2 id="左叶子之和"><a href="#左叶子之和" class="headerlink" title="左叶子之和"></a>左叶子之和</h2><p>题目：计算二叉树左叶子的和</p>
<p>左叶子 是节点的左节点不为空且左节点的左右节点都为空 </p>
<p>1、出口：节点空或者节点无子节点</p>
<p>2、判断为左节点 加到ans</p>
<pre><code class="plain">//我的题解 我选择用自己的
 class Solution &#123;
     int ans=0;
     public int sumOfLeftLeaves(TreeNode root) &#123;
         dfs(root);
         return ans;
     &#125;
     public void dfs(TreeNode root)&#123;
         //出口
         if(root==null||(root.left==null&amp;&amp;root.right==null)) return;
         //左节点存在且为叶节点
         if(root.left!=null&amp;&amp;root.left.left==null&amp;&amp;root.left.right==null)&#123;
             ans+=root.left.val;
         &#125;
         //递归到左右节点
         dfs(root.left);
         dfs(root.right);
     &#125;
 &#125;
</code></pre>
<h2 id="找树左下角的值"><a href="#找树左下角的值" class="headerlink" title="找树左下角的值"></a>找树左下角的值</h2><p>给定一个二叉树的 <strong>根节点</strong>root，请找出该二叉树的 <strong>最底层 最左边</strong> 节点的值。</p>
<p>假设二叉树中至少有一个节点。</p>
<pre><code class="plain">class Solution &#123;
     //维护当前树高度和值
     int curval=0;
     int curheight=0;
     public int findBottomLeftValue(TreeNode root) &#123;
         dfs(root,0);
         return curval;
     &#125;
     public void dfs(TreeNode root,int height)&#123;
         if(root==null) return;
         height++;//向下递归一层加一
         //也就是说到最深高度且先遍历左边就能保证找到了左下角的节点值
         if(height&gt;curheight)&#123;
             curheight=height;
             curval=root.val;
         &#125;
         //因为是先左后右 相同高度左边结点优先遍历到
         //这个想法没问题 但是int数据表示范围32位有限 出现内存溢出 所以还是Left在前
         
         // if(height==curheight)&#123;
         //     Math.min(curval,root.val);
         // &#125;
         dfs(root.left,height);
         dfs(root.right,height);
 
     &#125;
 &#125;
</code></pre>
<h2 id="路径总和"><a href="#路径总和" class="headerlink" title="路径总和"></a>路径总和</h2><p>给你二叉树的根节点 root 和一个表示目标和的整数 targetSum 。判断该树中是否存在 <strong>根节点到叶子节点</strong> 的路径，这条路径上所有节点值相加等于目标和 targetSum 。如果存在，返回 true ；否则，返回 false 。</p>
<pre><code class="plain">class Solution &#123;
    //有待改进 需要剪枝。。。 因为就算找到targetSum==0 递归还在继续
     boolean ans=false;
     public boolean hasPathSum(TreeNode root, int targetSum) &#123;
         dfs(root,targetSum);
         return ans;
     &#125;
     public void dfs(TreeNode root,int targetSum)&#123;
         if(root==null) return;
         targetSum=targetSum-root.val;
         if(root.left==null&amp;&amp;root.right==null)&#123;
             if(targetSum==0)&#123;
                 ans=true;
                 return;
             &#125;
         &#125;
         dfs(root.left,targetSum);
         dfs(root.right,targetSum);
     &#125;
 &#125;
</code></pre>
<p>官方题解：简洁！</p>
<pre><code class="plain">class Solution &#123;
     public boolean hasPathSum(TreeNode root, int sum) &#123;
         if (root == null) &#123;
             return false;
         &#125;
         //递归到最后一层   最后只需要判断sum==root.val就行
         if (root.left == null &amp;&amp; root.right == null) &#123;
             return sum == root.val;
         &#125;
         //一直递归到最后一层  sum - root.val（传参到sum）一直在减少
         return hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val);
     &#125;
 &#125;
</code></pre>
<h2 id="从中序与后序遍历序列构造二叉树"><a href="#从中序与后序遍历序列构造二叉树" class="headerlink" title="从中序与后序遍历序列构造二叉树"></a>从中序与后序遍历序列构造二叉树</h2><p>给定两个整数数组 inorder 和 postorder ，其中 inorder 是二叉树的中序遍历， postorder 是同一棵树的后序遍历，请你构造并返回这颗 <em>二叉树</em> 。</p>
<pre><code class="plain">class Solution &#123;
     int post_idx;
     int[] postorder;
     int[] inorder;
     Map&lt;Integer, Integer&gt; idx_map = new HashMap&lt;Integer, Integer&gt;();
     
     public TreeNode buildTree(int[] inorder, int[] postorder) &#123;
         this.postorder = postorder;
         this.inorder = inorder;
         // 从后序遍历的最后一个元素开始
         post_idx = postorder.length - 1;
 
         // 建立（元素，下标）键值对的哈希表
         int idx = 0;
         for (Integer val : inorder) &#123;
             idx_map.put(val, idx++);
         &#125;
         
         return helper(0, inorder.length - 1);
     &#125;
     
     public TreeNode helper(int in_left, int in_right) &#123;
         // 如果这里没有节点构造二叉树了，就结束
         if (in_left &gt; in_right) &#123;
             return null;
         &#125;
 
         // 选择 post_idx 位置的元素作为当前子树根节点
         int root_val = postorder[post_idx];
         TreeNode root = new TreeNode(root_val);
         // 根据 root 所在位置分成左右两棵子树
         int index = idx_map.get(root_val);
         // 下标减一
         post_idx--;
         // 构造右子树
         root.right = helper(index + 1, in_right);
         // 构造左子树
         root.left = helper(in_left, index - 1);
         return root;
     &#125;
 
 &#125;
</code></pre>
<h2 id="最大二叉树"><a href="#最大二叉树" class="headerlink" title="最大二叉树"></a>最大二叉树</h2><p>给定一个不重复的整数数组 nums 。 <strong>最大二叉树</strong> 可以用下面的算法从 nums 递归地构建:</p>
<ol>
<li>创建一个根节点，其值为 nums 中的最大值。</li>
<li>递归地在最大值 <strong>左边</strong> 的 <strong>子数组前缀上</strong> 构建左子树。</li>
<li>递归地在最大值 <strong>右边</strong> 的 <strong>子数组后缀上</strong> 构建右子树。</li>
</ol>
<p>返回 <em>nums</em> <em>构建的</em><em><strong>最大二叉树</strong></em>**** 。</p>
<p><strong>递归</strong></p>
<pre><code class="plain">//我最初的解法
 class Solution &#123;
     int[] nums;
     public TreeNode constructMaximumBinaryTree(int[] nums) &#123;
         this.nums=nums;
         return buildTreee(0,nums.length-1);
     &#125;
     public TreeNode buildTreee(int left,int right)&#123;
         if(left&gt;right) return null;
         int index=getMaxNumIndex(left,right);
         TreeNode root=new TreeNode(nums[index]);
         root.left=buildTreee(left,index-1);
         root.right=buildTreee(index+1,right);
         return root;
     &#125;
     public int getMaxNumIndex(int left,int right)&#123;
         int max=Integer.MIN_VALUE;
         int index=0;
         for(int i=left;i&lt;=right;i++)&#123;
             if(nums[i]&gt;max)&#123;
                 max=nums[i];
                 index=i;
             &#125;
         &#125;
         return index;
     &#125;
 &#125;
 //优化后
 class Solution &#123;
     int[] nums;
     public TreeNode constructMaximumBinaryTree(int[] nums) &#123;
         this.nums=nums;
         return buildTreee(0,nums.length-1);
     &#125;
     public TreeNode buildTreee(int left,int right)&#123;
         if(left&gt;right) return null;
         int best=left;
         for (int i = left + 1; i &lt;= right; ++i) &#123;
             if (nums[i] &gt; nums[best]) &#123;
                 best = i;
             &#125;
         &#125;
         TreeNode root=new TreeNode(nums[best]);
         root.left=buildTreee(left,best-1);
         root.right=buildTreee(best+1,right);
         return root;
     &#125;
 &#125;
</code></pre>
<p><strong>单调栈</strong></p>
<h2 id="验证二叉搜索树"><a href="#验证二叉搜索树" class="headerlink" title="验证二叉搜索树"></a>验证二叉搜索树</h2><p>给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。</p>
<p><strong>有效</strong> 二叉搜索树定义如下：</p>
<ul>
<li>节点的左子树只包含 <strong>小于</strong> 当前节点的数。</li>
<li>节点的右子树只包含 <strong>大于</strong> 当前节点的数。</li>
<li>所有左子树和右子树自身必须也是二叉搜索树。</li>
</ul>
<pre><code class="plain">class Solution &#123;
     public boolean isValidBST(TreeNode root) &#123;
         return dfs(root,Long.MIN_VALUE,Long.MAX_VALUE);
     &#125;
     public boolean dfs(TreeNode root,long l,long r)&#123;
         if(root==null) return true;
         if(root.val&lt;=l||root.val&gt;=r) return false;
         return dfs(root.left,l,root.val)&amp;&amp;dfs(root.right,root.val,r);
     &#125;
 &#125;
</code></pre>
<h2 id="二叉搜索树的最小绝对差"><a href="#二叉搜索树的最小绝对差" class="headerlink" title="二叉搜索树的最小绝对差"></a>二叉搜索树的最小绝对差</h2><pre><code class="plain">class Solution &#123;
     int ans=Integer.MAX_VALUE;
     public int getMinimumDifference(TreeNode root) &#123;
         dfs(root);
         return ans;
     &#125;
     public void dfs(TreeNode root)&#123;
         if(root==null) return;
         //我的题解：寻找左子树里最大值和右子树里面最小值 然后同根节点做差求Min
         //左子树里最大值就是左孩子的最右结点 右子树同理
         TreeNode node_l=root.left,node_r=root.right;
         while(node_l!=null&amp;&amp;node_l.right!=null)&#123;
             node_l=node_l.right;
         &#125;
         while(node_r!=null&amp;&amp;node_r.left!=null)&#123;
             node_r=node_r.left;
         &#125;
         int l=node_l==null?Integer.MAX_VALUE:root.val-node_l.val;
         int r=node_r==null?Integer.MAX_VALUE:node_r.val-root.val;
         ans=Math.min(Math.min(l,r),ans);
         dfs(root.left);
         dfs(root.right);
     &#125;
 &#125;
</code></pre>
<p><img src="https://raw.githubusercontent.com/viacheung/img/main/image/image-20221104202039345.png" alt="img"></p>
<pre><code class="plain">class Solution &#123;
     int pre;
     int ans;
     public int getMinimumDifference(TreeNode root) &#123;
         ans = Integer.MAX_VALUE;
         pre = -1;
         dfs(root);
         return ans;
     &#125;
     public void dfs(TreeNode root) &#123;
         if (root == null) &#123;
             return;
         &#125;
         //中序 左根右  有序
         //只需要计算相邻结点差值的最小值就可
         dfs(root.left);
         if (pre == -1) &#123;
             pre = root.val;
         &#125; else &#123;
             ans = Math.min(ans, root.val - pre);
             pre = root.val;
         &#125;
         dfs(root.right);
     &#125;
 &#125;
 优雅！！！！！！！！
</code></pre>
<h2 id="二叉搜索树中的众数"><a href="#二叉搜索树中的众数" class="headerlink" title="二叉搜索树中的众数"></a>二叉搜索树中的众数</h2><p>给你一个含重复值的二叉搜索树（BST）的根节点 root ，找出并返回 BST 中的所有 <a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E4%BC%97%E6%95%B0/44796">众数</a>（即，出现频率最高的元素）。</p>
<p>如果树中有不止一个众数，可以按 <strong>任意顺序</strong> 返回。</p>
<p>假定 BST 满足如下定义：</p>
<ul>
<li>结点左子树中所含节点的值 <strong>小于等于</strong> 当前节点的值</li>
<li>结点右子树中所含节点的值 <strong>大于等于</strong> 当前节点的值</li>
<li>左子树和右子树都是二叉搜索树</li>
</ul>
<p>我的思路：</p>
<p>哈希表 dfs遍历结点 map存储结点以及结点出现个数，然后每个entrySet取value 打擂台的方式，最后得出最大的value以及key 然后根据value再遍历一次 看看有无相等的 有就加入结果集List but不想实现。。。。。</p>
<p><img src="https://raw.githubusercontent.com/viacheung/img/main/image/image-20221106213939182.png" alt="img"></p>
<pre><code class="plain">class Solution &#123;
     //记录众数
     List&lt;Integer&gt; answer=new ArrayList&lt;&gt;();
     //  当前数字 出现个数   最大出现个数
     int base,count,maxcount;
 
     public int[] findMode(TreeNode root) &#123;
         dfs(root);
         int[] ans=new int[answer.size()];
         for(int i=0;i&lt;answer.size();i++)&#123;
             ans[i]=answer.get(i);
         &#125;
         return ans;
     &#125;
     public void dfs(TreeNode root)&#123;
     //中序遍历 使得递增顺序
         if(root==null) return;
         dfs(root.left);
         update(root.val);
         dfs(root.right);
     &#125;
     public void update(int val)&#123;
         if(val==base)&#123;
             count++;
         &#125;else&#123;
             count=1;
             base=val;
         &#125;
         if(count==maxcount)&#123;
             answer.add(val);
         &#125;
         if(count&gt;maxcount)&#123;
             answer.clear();
             maxcount=count;
             answer.add(val);
         &#125;
     &#125;
 &#125;
</code></pre>
<h2 id="二叉树前序遍历"><a href="#二叉树前序遍历" class="headerlink" title="二叉树前序遍历"></a>二叉树前序遍历</h2><p><strong>递归</strong>（本质栈）</p>
<pre><code class="plain">class Solution &#123;
     public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123;
         List&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;();
         preorder(root, res);
         return res;
     &#125;
 
     public void preorder(TreeNode root, List&lt;Integer&gt; res) &#123;
         if (root == null) &#123;
             return;
         &#125;
         res.add(root.val);
         preorder(root.left, res);
         preorder(root.right, res);
     &#125;
 &#125;
</code></pre>
<p><strong>迭代</strong>（利用栈）</p>
<pre><code class="plain">class Solution &#123;
     public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123;
         List&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;();
         if (root == null) &#123;
             return res;
         &#125;
 
         Deque&lt;TreeNode&gt; stack = new LinkedList&lt;TreeNode&gt;();
         TreeNode node = root;
         //结束条件：栈为空且node为Null
         while (!stack.isEmpty() || node != null) &#123;
             //到达最左
             while (node != null) &#123;
                 res.add(node.val);
                 stack.push(node);
                 node = node.left;
             &#125;
             //到达最左后，node为Null，此时要出栈（也就是返回父结点）
             node = stack.pop();
             //遍历右结点
             node = node.right;
         &#125;
         return res;
     &#125;
 &#125;
</code></pre>
<p><strong>Morris 遍历</strong></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/liujia2115/article/details/109215284">https://blog.csdn.net/liujia2115/article/details/109215284</a></p>
<pre><code class="plain">class Solution &#123;
     public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123;
         return morrisMethod(root);
     &#125;
 
     /**
      * Morris遍历
      * @param root
      * @return
      */
     private List&lt;Integer&gt; morrisMethod(TreeNode root) &#123;
         List&lt;Integer&gt; list = new ArrayList&lt;&gt;();
         if (root == null) &#123;
             return list;
         &#125;
         TreeNode cur = root;
         TreeNode mostRight = null;
         while (cur != null) &#123;
             mostRight = cur.left;
             if (mostRight != null) &#123; 
                 //左子树最右结点 mostRight.right != cur防止循环回去了
                 while (mostRight.right != null &amp;&amp; mostRight.right != cur) &#123;
                     mostRight = mostRight.right;
                 &#125;
                 //第一次来
                 if (mostRight.right == null) &#123;
                     mostRight.right = cur;
                     list.add(cur.val); // 第一次到的时候打印
                     cur = cur.left;
                     continue;
                 &#125; else &#123;//第二次来
                     mostRight.right = null; // 第二次到的时候不打印
                 &#125;
             &#125; else &#123; // cur.left为空 直接add cur的值
                 list.add(cur.val);
             &#125;
             cur = cur.right;
             &#125;
         return list;
     &#125;
 &#125;
</code></pre>
<p>morris中序遍历就是在第一次到的时候不打印 第二次到的时候打印 list.add(cur.val);移到 mostRight.right &#x3D; null; 后面</p>
<h2 id="合并二叉树"><a href="#合并二叉树" class="headerlink" title="合并二叉树"></a>合并二叉树</h2><p><img src="https://raw.githubusercontent.com/viacheung/img/main/image/image-20221009174111479.png" alt="img"></p>
<pre><code class="plain">class Solution &#123;
     public TreeNode mergeTrees(TreeNode root1, TreeNode root2) &#123;
         if(root1 == null) return root2;
         if(root2 == null) return root1;
         TreeNode merged = new TreeNode(root1.val + root2.val);//返回结点
         merged.left=mergeTrees(root1.left, root2.left);//构造左边是啥
         merged.right=mergeTrees(root1.right, root2.right);//构造右边是啥
         return merged;
     &#125;
 &#125;
</code></pre>
<h2 id="二叉搜索数转累加数"><a href="#二叉搜索数转累加数" class="headerlink" title="二叉搜索数转累加数"></a>二叉搜索数转累加数</h2><p>给出二叉 搜索 树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），使每个节点 node 的新值等于原树中大于或等于 node.val 的值之和。</p>
<pre><code class="plain">class Solution &#123;
     int sum = 0;
     public TreeNode convertBST(TreeNode root) &#123;
         dfs(root);
         return root;
     &#125;
     void dfs(TreeNode node) &#123;
         if (node == null) return;
         dfs(node.right);
         sum += node.val;
         node.val = sum;
         dfs(node.left);
     &#125;
 &#125;
</code></pre>
<p>我对于本题递归的理解：dfs(node.right)直接递归到最右下结点，sum&#x3D;最右下结点的值，赋给最右下结点值， dfs(node.left); 判断为空 return出来</p>
<p>dfs(node.right)执行完毕，进入上一递归，此时为上一层根结点，然后sum +&#x3D; node.val;node.val &#x3D; sum;此时算的是根结点的累加值，同理，dfs(node.left)；</p>
<p>递归不要人肉递归，还是要套模板，只需要关注<img src="https://raw.githubusercontent.com/viacheung/img/main/image/image-20221007210341362.png" alt="img"></p>
<p>这一部分内容就行，让变量具有普适性</p>
<h2 id="二叉树遍历题和二叉树展开为链表题的对比（均为迭代）"><a href="#二叉树遍历题和二叉树展开为链表题的对比（均为迭代）" class="headerlink" title="二叉树遍历题和二叉树展开为链表题的对比（均为迭代）"></a>二叉树遍历题和二叉树展开为链表题的对比（均为迭代）</h2><p>做二叉树首先要想到用递归（and迭代）</p>
<pre><code class="plain">二叉树遍历
 class Solution &#123;
     public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123;
         List&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;();
         Deque&lt;TreeNode&gt; stk = new LinkedList&lt;TreeNode&gt;();
         while (root != null || !stk.isEmpty()) &#123;
             while (root != null) &#123;
                 stk.push(root);
                 root = root.left;
             &#125;
             root = stk.pop();
             res.add(root.val);
             root = root.right;
         &#125;
         return res;
     &#125;
 &#125;
 二叉树展开为链表
     class Solution &#123;
         //同中序遍历的题进行对比
         public void flatten(TreeNode root) &#123;
             List&lt;TreeNode&gt; list = new ArrayList&lt;&gt;();
             Deque&lt;TreeNode&gt; stk = new LinkedList&lt;&gt;();
             while (root != null || !stk.isEmpty()) &#123;
                 while (root != null) &#123;
                     list.add(root);//和中序比较多了这一行
                     stk.push(root);
                     root = root.left;
                 &#125;
                 root = stk.pop();
                 //少了一行list.add(root.val);
                 root = root.right;
             &#125;
             int size = list.size();
             for (int i = 1; i &lt; size; i++) &#123;
                 TreeNode pre = list.get(i - 1), cur = list.get(i);
                 pre.left = null;
                 pre.right = cur;
             &#125;
 
         &#125;
</code></pre>
<h2 id="二叉树的最近公共祖先"><a href="#二叉树的最近公共祖先" class="headerlink" title="二叉树的最近公共祖先"></a>二叉树的最近公共祖先</h2><p><img src="https://raw.githubusercontent.com/viacheung/img/main/image/image-20220919202400688.png" alt="img"></p>
<pre><code class="plain">*/
 class Solution &#123;
     private TreeNode ans;
     public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123;
 //        TreeNode ans=null;   //这一句不能有，有的话，ans=root就无法覆盖ans的值，ans=root只能识别到 private TreeNode ans;   如果有的话 下面必须return this.ans才行 把外面的引进来作为成员变量
         dfs(root,p,q);
         return ans;//想引用外面的变量需要加this.
     &#125;
     private boolean dfs(TreeNode root, TreeNode p, TreeNode q)&#123;
         if(root==null) return false;
         boolean lson=dfs(root.left,p,q);//这里必须加数据类型呀，因为lson rson第一次出现，都没初始化呢，要指定其数据类型
         boolean rson=dfs(root.right,p,q);
         if((lson&amp;&amp;rson)||(p.val==root.val||q.val==root.val)&amp;&amp;(lson||rson))&#123;
             ans=root;
             System.out.println(ans);
         &#125;
         return root.val==p.val||root.val==q.val||lson||rson;
     &#125;
 &#125;
</code></pre>
<h2 id="二叉搜索树最近公共祖先"><a href="#二叉搜索树最近公共祖先" class="headerlink" title="二叉搜索树最近公共祖先"></a>二叉搜索树最近公共祖先</h2><p>方法一：不用二叉搜索树的性质，直接用二叉树的也可以过。</p>
<p><strong>方法二：一次遍历</strong></p>
<p><img src="https://raw.githubusercontent.com/viacheung/img/main/image/image-20221107120758813.png" alt="img"></p>
<pre><code class="plain">class Solution &#123;
     public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123;
         TreeNode ancestor = root;
         while (true) &#123;
             if (p.val &lt; ancestor.val &amp;&amp; q.val &lt; ancestor.val) &#123;
                 ancestor = ancestor.left;
             &#125; else if (p.val &gt; ancestor.val &amp;&amp; q.val &gt; ancestor.val) &#123;
                 ancestor = ancestor.right;
             &#125; else &#123;
                 break;
             &#125;
         &#125;
         return ancestor;
     &#125;
 &#125;
</code></pre>
<h2 id="二叉搜索树中的插入操作"><a href="#二叉搜索树中的插入操作" class="headerlink" title="二叉搜索树中的插入操作"></a>二叉搜索树中的插入操作</h2><p>给定二叉搜索树（BST）的根节点 root 和要插入树中的值 value ，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据 <strong>保证</strong> ，新值和原始二叉搜索树中的任意节点值都不同。</p>
<p><strong>注意</strong>，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回 <strong>任意有效的结果</strong> 。</p>
<pre><code class="plain">class Solution &#123;
     public TreeNode insertIntoBST(TreeNode root, int val) &#123;
         //为空建一个返回
         if(root==null) return new TreeNode(val);
         dfs(root,val);
         return root;
     &#125;
     public void dfs(TreeNode root, int val)&#123;
         //大于的话 需要插入到左子树 看左节点是否为空，空的话直接加入，然后返回， 否则递归到左子树 
         if(root.val&gt;val)&#123;
             if(root.left==null)&#123;
                 root.left=new TreeNode(val);
                 return;
             &#125;
             dfs(root.left,val);
         &#125;else&#123;
             if(root.right==null)&#123;
                 root.right=new TreeNode(val);
                 return;
             &#125;
             dfs(root.right,val);
         &#125;
     &#125;
 &#125;
</code></pre>
<h2 id="删除二叉搜索树的节点"><a href="#删除二叉搜索树的节点" class="headerlink" title="删除二叉搜索树的节点"></a>删除二叉搜索树的节点</h2><p><img src="https://raw.githubusercontent.com/viacheung/img/main/image/image-20221108190047074.png" alt="img"></p>
<pre><code class="plain">class Solution &#123;
     public TreeNode deleteNode(TreeNode root, int key) &#123;
         if(root==null) return null;
         if(key&lt;root.val)&#123;
             root.left=deleteNode(root.left,key);
             return root;
         &#125;
         if(key&gt;root.val)&#123;
             root.right=deleteNode(root.right,key);
             return root;
         &#125;
         //key==root.val
         //左右都空
         if(key==root.val)&#123;
             if(root.right==null&amp;&amp;root.left==null)&#123;
                 return null;
             &#125;
             //左子树为空
             if(root.left==null)&#123;
                 return root.right;
             &#125;
             //右子树为空
             if(root.right==null)&#123;
                 return root.left;
             &#125;
             //左右都不为空
             if(root.right!=null&amp;&amp;root.left!=null)&#123;
                 //寻找左子树最大结点值val
                 int val=getMaxInLeft(root.left);
                 //对根节点赋值val 
                 root.val=val;
                 //删除等于val的那个结点，并更新左结点
                 root.left=deleteNode(root.left,val);
                 return root;
             &#125;
         &#125;
         return root;
         
     &#125;
      //找到左子树中最大的值
     public int getMaxInLeft(TreeNode root)&#123;
         //递归
         // if(root.right==null&amp;&amp;root.left==null) return root.val;
         // //右子树为空 必然最大的就是根节点
         // if(root.right==null) return root.val;
         // return getMaxInLeft(root.right);
         TreeNode node=root;
         while(node.right!=null)&#123;
             node=node.right;
         &#125;
         return node.val;
     &#125;
</code></pre>
<h2 id="修剪二叉搜索树"><a href="#修剪二叉搜索树" class="headerlink" title="修剪二叉搜索树"></a>修剪二叉搜索树</h2><p>给你二叉搜索树的根节点 root ，同时给定最小边界low 和最大边界 high。通过修剪二叉搜索树，使得所有节点的值在[low, high]中。修剪树 <strong>不应该</strong> 改变保留在树中的元素的相对结构 (即，如果没有被移除，原有的父代子代关系都应当保留)。 可以证明，存在 <strong>唯一的答案</strong> 。</p>
<p>所以结果应当返回修剪好的二叉搜索树的新的根节点。注意，根节点可能会根据给定的边界发生改变。</p>
<p><img src="https://raw.githubusercontent.com/viacheung/img/main/image/image-20221109113639092.png" alt="img"></p>
<pre><code class="plain">class Solution &#123;
     public TreeNode trimBST(TreeNode root, int low, int high) &#123;
         //在根结点把三种情况解决掉了 套用递归解决问题
         if(root==null) return null;
         if(root.val&gt;high)&#123;
             return trimBST(root.left,low,high);
         &#125;else if(root.val&lt;low)&#123;
             return trimBST(root.right,low,high);
         &#125;else&#123;
             root.right=trimBST(root.right,low,high);
             root.left=trimBST(root.left,low,high);
             return root;
         &#125;
     &#125;
 &#125;
</code></pre>
<h2 id="将有序数组转换为二叉搜索树"><a href="#将有序数组转换为二叉搜索树" class="headerlink" title="将有序数组转换为二叉搜索树"></a>将有序数组转换为二叉搜索树</h2><p>给你一个整数数组 nums ，其中元素已经按 <strong>升序</strong> 排列，请你将其转换为一棵 <strong>高度平衡</strong> 二叉搜索树。</p>
<p><strong>高度平衡</strong> 二叉树是一棵满足「每个节点的左右两个子树的高度差的绝对值不超过 1 」的二叉树。</p>
<pre><code class="plain">class Solution &#123;
 
     public TreeNode sortedArrayToBST(int[] nums) &#123;
         return dfs(nums,0,nums.length-1);
     &#125;
     public TreeNode dfs(int[] nums,int begin,int end)&#123;
         //越界返回空
         if(begin&gt;end) return null;
         //二分确定根结点
         int index=(begin+end)/2;
         int val=nums[index];
         //创建结点
         TreeNode root=new TreeNode(val);
         //递归  创建树
         root.right=dfs(nums,index+1,end);
         root.left=dfs(nums,begin,index-1);
         return root;
     &#125;
 &#125;
</code></pre>
<h2 id="把二叉搜索树转换为累加树"><a href="#把二叉搜索树转换为累加树" class="headerlink" title="把二叉搜索树转换为累加树"></a>把二叉搜索树转换为累加树</h2><p>给出二叉 <strong>搜索</strong> 树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），使每个节点 node 的新值等于原树中大于或等于 node.val 的值之和。</p>
<p>提醒一下，二叉搜索树满足下列约束条件：</p>
<ul>
<li>节点的左子树仅包含键 <strong>小于</strong> 节点键的节点。</li>
<li>节点的右子树仅包含键 <strong>大于</strong> 节点键的节点。</li>
<li>左右子树也必须是二叉搜索树。</li>
</ul>
<p><strong>方法一：反序中序遍历</strong></p>
<p>思路及算法</p>
<p>本题中要求我们将每个节点的值修改为原来的节点值加上所有大于它的节点值之和。这样我们只需要反序中序遍历该二叉搜索树，记录过程中的节点值之和，并不断更新当前遍历到的节点的节点值，即可得到题目要求的累加树。</p>
<pre><code class="plain">class Solution &#123;
     int sum=0;
     public TreeNode convertBST(TreeNode root) &#123;
         dfs(root);
         return root;
     &#125;
     public void dfs(TreeNode root)&#123;
         if(root==null) return;
         dfs(root.right);
         sum+=root.val;
         root.val=sum;
         dfs(root.left);
     &#125;
 &#125;
</code></pre>
<h2 id="翻转二叉树"><a href="#翻转二叉树" class="headerlink" title="翻转二叉树"></a>翻转二叉树</h2><p><strong>递归</strong></p>
<p>深度优先</p>
<p><img src="https://raw.githubusercontent.com/viacheung/img/main/image/0f91f7cbf5740de86e881eb7427c6c3993f4eca3624ca275d71e21c5e3e2c550-226_2.gif" alt="img"></p>
<pre><code class="plain">自顶向下(好理解  优先这个)
 class Solution &#123;
     public TreeNode invertTree(TreeNode root) &#123;
         //递归函数的终止条件，节点为空时返回
         if(root==null) &#123;
             return null;
         &#125;
         //下面三句是将当前节点的左右子树交换
         TreeNode tmp = root.right;
         root.right = root.left;
         root.left = tmp;
         //递归交换当前节点的 左子树
         invertTree(root.left);
         //递归交换当前节点的 右子树
         invertTree(root.right);
         //函数返回时就表示当前这个节点，以及它的左右子树
         //都已经交换完了
         return root;
     &#125;
 &#125;
 自底向上(代码简洁)   
 class Solution &#123;
     public TreeNode invertTree(TreeNode root) &#123;
         if (root == null) &#123;
             return null;
         &#125;
         TreeNode left = invertTree(root.left);
         TreeNode right = invertTree(root.right);
         root.left = right;
         root.right = left;
         return root;
     &#125;
 &#125;
</code></pre>
<p><strong>迭代</strong></p>
<p>广度优先</p>
<p><img src="https://raw.githubusercontent.com/viacheung/img/main/image/f9e06159617cbf8372b544daee37be70286c3d9b762c016664e225044fc4d479-226_%E8%BF%AD%E4%BB%A3.gif" alt="img"></p>
<pre><code class="plain">class Solution &#123;
     public TreeNode invertTree(TreeNode root) &#123;
         if(root==null) &#123;
             return null;
         &#125;
         //将二叉树中的节点逐层放入队列中，再迭代处理队列中的元素
         LinkedList&lt;TreeNode&gt; queue = new LinkedList&lt;TreeNode&gt;();
         queue.add(root);
         while(!queue.isEmpty()) &#123;
             //每次都从队列中拿一个节点，并交换这个节点的左右子树
             TreeNode tmp = queue.poll();
             TreeNode left = tmp.left;
             tmp.left = tmp.right;
             tmp.right = left;
             //如果当前节点的左子树不为空，则放入队列等待后续处理
             if(tmp.left!=null) &#123;
                 queue.add(tmp.left);
             &#125;
             //如果当前节点的右子树不为空，则放入队列等待后续处理
             if(tmp.right!=null) &#123;
                 queue.add(tmp.right);
             &#125;
             
         &#125;
         //返回处理完的根节点
         return root;
     &#125;
 &#125;
</code></pre>
<h2 id="二叉树的序列化和反序列化"><a href="#二叉树的序列化和反序列化" class="headerlink" title="二叉树的序列化和反序列化"></a>二叉树的序列化和反序列化</h2><p>题目：</p>
<p><img src="https://raw.githubusercontent.com/viacheung/img/main/image/image-20220923172523030.png" alt="img"></p>
<p>算法：</p>
<p><img src="https://raw.githubusercontent.com/viacheung/img/main/image/image-20220923172455790.png" alt="img"></p>
<p><img src="https://raw.githubusercontent.com/viacheung/img/main/image/image-20220923172606089.png" alt="img"></p>
<pre><code class="plain">public class Codec &#123;
     public String serialize(TreeNode root) &#123;
         return rserialize(root, &quot;&quot;);
     &#125;
   
     public TreeNode deserialize(String data) &#123;
         String[] dataArray = data.split(&quot;,&quot;);
         List&lt;String&gt; dataList = new LinkedList&lt;String&gt;(Arrays.asList(dataArray));
         return rdeserialize(dataList);
     &#125;
 
     public String rserialize(TreeNode root, String str) &#123;
         if (root == null) &#123;
             str += &quot;None,&quot;;
         &#125; else &#123;
             str += str.valueOf(root.val) + &quot;,&quot;;//或者这样写 str+=String.valueOf(root.val)+&quot;,&quot;;  把root.val转成String类型
             str = rserialize(root.left, str);
             str = rserialize(root.right, str);
         &#125;
         return str;
     &#125;
   
     public TreeNode rdeserialize(List&lt;String&gt; dataList) &#123;
         if (dataList.get(0).equals(&quot;None&quot;)) &#123;
             dataList.remove(0);
             return null;
         &#125;
   
         TreeNode root = new TreeNode(Integer.valueOf(dataList.get(0)));
         dataList.remove(0);
         root.left = rdeserialize(dataList);
         root.right = rdeserialize(dataList);
     
         return root;
     &#125;
 &#125;
</code></pre>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="https://raw.githubusercontent.com/viacheung/img/main/image/20211030125421.png" alt="img"><img src="https://raw.githubusercontent.com/viacheung/img/main/image/20211030125421.png" alt="img"></p>
<h2 id="二叉树的前序遍历"><a href="#二叉树的前序遍历" class="headerlink" title="二叉树的前序遍历"></a>二叉树的前序遍历</h2><p>1、递归</p>
<pre><code class="plain">public class Solution &#123;
     /**
      * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
      *
      * 
      * @param root TreeNode类 
      * @return int整型一维数组
      */
     List&lt;Integer&gt; ans=new ArrayList&lt;&gt;();;
     public int[] preorderTraversal (TreeNode root) &#123;
         // write code here
         dfs(root);
         int[] res=new int[ans.size()];
         for(int i=0;i&lt;ans.size();i++)&#123;
             res[i]=ans.get(i);
         &#125;
         return res;
         
     &#125;
     public void dfs(TreeNode root)&#123;
         if(root==null) return;
         ans.add(root.val);
         dfs(root.left);
         dfs(root.right);
     &#125;
 &#125;
</code></pre>
<p>2、迭代</p>
<p><img src="https://raw.githubusercontent.com/viacheung/img/main/image/717C18C1D3175AB683DE7E050A4236ED" alt="img"></p>
<pre><code class="plain">public int[] preorderTraversal (TreeNode root) &#123;
         List&lt;Integer&gt; ans=new ArrayList&lt;&gt;();
         Stack&lt;TreeNode&gt; stack=new Stack&lt;&gt;();
         // 判空
         if(root==null) return new int[0];
         stack.push(root);
         while(!stack.isEmpty())&#123;
             TreeNode node=stack.pop();
             ans.add(node.val);
             // 栈先进后出
             if(node.right!=null) stack.push(node.right);
             if(node.left!=null) stack.push(node.left);
         &#125;
         int[] finnal_ans=new int[ans.size()];
         for(int i=0;i&lt;ans.size();i++)&#123;
             finnal_ans[i]=ans.get(i);
         &#125;
         return finnal_ans;
     &#125;
</code></pre>
<h2 id="二叉树中序遍历"><a href="#二叉树中序遍历" class="headerlink" title="二叉树中序遍历"></a>二叉树中序遍历</h2><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>换个顺序就行</p>
<h3 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h3><p><img src="https://raw.githubusercontent.com/viacheung/img/main/image/23368751A430C010C582743B0E2F9414" alt="img"></p>
<pre><code class="plain">public class Solution &#123;
     /**
      * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
      *
      * 
      * @param root TreeNode类 
      * @return int整型一维数组
      */
     public int[] inorderTraversal (TreeNode root) &#123;
         // write code here
         List&lt;Integer&gt; list=new ArrayList&lt;&gt;();
         Stack&lt;TreeNode&gt; stack=new Stack&lt;&gt;();
         if(root==null) return new int[0];
         while(!stack.isEmpty()||root!=null)&#123;
             while(root!=null)&#123;
                 stack.push(root);
                 root=root.left;
             &#125;
             TreeNode node=stack.pop();
             list.add(node.val);
             root=node.right;
         &#125;
         int[] res=new int[list.size()];
         for(int i=0;i&lt;list.size();i++)&#123;
             res[i]=list.get(i);
         &#125;
         return res;
     &#125;
 &#125;
</code></pre>
<h2 id="二叉树的后序遍历"><a href="#二叉树的后序遍历" class="headerlink" title="二叉树的后序遍历"></a>二叉树的后序遍历</h2><h3 id="迭代-1"><a href="#迭代-1" class="headerlink" title="迭代"></a>迭代</h3><ul>
<li>step 1：开辟一个辅助栈，用于记录要访问的子节点，开辟一个前序指针pre。</li>
<li>step 2：从根节点开始，每次优先进入每棵的子树的最左边一个节点，我们将其不断加入栈中，用来保存父问题。</li>
<li>step 3：弹出一个栈元素，看成该子树的根，判断这个根的右边有没有节点或是有没有被访问过，如果没有右节点或是被访问过了，可以访问这个根，并将前序节点标记为这个根。</li>
<li>step 4：如果没有被访问，那这个根必须入栈，进入右子树继续访问，只有右子树结束了回到这里才能继续访问根。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/viacheung/img/main/image/05EE17BA6FA1FB90EDDEF5A26D0FEEF4" alt="img"></p>
<pre><code class="plain">import java.util.*;
 
 /*
  * public class TreeNode &#123;
  *   int val = 0;
  *   TreeNode left = null;
  *   TreeNode right = null;
  *   public TreeNode(int val) &#123;
  *     this.val = val;
  *   &#125;
  * &#125;
  */
 
 public class Solution &#123;
     /**
      * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
      *
      * 
      * @param root TreeNode类 
      * @return int整型一维数组
      */
     public int[] postorderTraversal (TreeNode root) &#123;
         // write code here
         // 牢记栈的特性  先入栈后访问
         TreeNode pre=null;//标记这个是访问过的前序节点
         List&lt;Integer&gt; list=new ArrayList&lt;&gt;();
         Stack&lt;TreeNode&gt; stack=new Stack&lt;&gt;();
         while(!stack.isEmpty()||root!=null)&#123;
             // 找最左边节点
             while(root!=null)&#123;
                 stack.push(root);
                 root=root.left;
             &#125;
             TreeNode node=stack.pop();
             // 如果右节点为空或者已经被访问了
             if(node.right==null||node.right==pre)&#123;
                 list.add(node.val);
                 pre=node;
             &#125;else&#123;
                 //该节点入栈
                 stack.push(node);
                 //先访问右边
                 root=node.right;
             &#125;
         &#125;
         int[] res=new int[list.size()];
         for(int i=0;i&lt;list.size();i++)&#123;
             res[i]=list.get(i);
         &#125;
         return res;
     &#125;
 &#125;
</code></pre>
<h2 id="求二叉树的层序遍历"><a href="#求二叉树的层序遍历" class="headerlink" title="求二叉树的层序遍历"></a>求二叉树的层序遍历</h2><ul>
<li>step 1：首先判断二叉树是否为空，空树没有遍历结果。</li>
<li>step 2：建立辅助队列，根节点首先进入队列。不管层次怎么访问，根节点一定是第一个，那它肯定排在队伍的最前面。</li>
<li>step 3：每次进入一层，统计队列中元素的个数。因为每当访问完一层，下一层作为这一层的子节点，一定都加入队列，而再下一层还没有加入，因此此时队列中的元素个数就是这一层的元素个数。</li>
<li>step 4：每次遍历这一层这么多的节点数，将其依次从队列中弹出，然后加入这一行的一维数组中，如果它们有子节点，依次加入队列排队等待访问。</li>
<li>step 5：访问完这一层的元素后，将这个一维数组加入二维数组中，再访问下一层。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/viacheung/img/main/image/07986E476EB2CECD3C5F81D0BCADBE12" alt="img"></p>
<h3 id="迭代-2"><a href="#迭代-2" class="headerlink" title="迭代"></a>迭代</h3><pre><code class="plain">import java.util.*;
 
 /*
  * public class TreeNode &#123;
  *   int val = 0;
  *   TreeNode left = null;
  *   TreeNode right = null;
  * &#125;
  */
 
 public class Solution &#123;
     /**
      * 
      * @param root TreeNode类 
      * @return int整型ArrayList&lt;ArrayList&lt;&gt;&gt;
      */
     public ArrayList&lt;ArrayList&lt;Integer&gt;&gt; levelOrder (TreeNode root) &#123;
         // write code here
         Queue&lt;TreeNode&gt; queue=new LinkedList&lt;&gt;();
         ArrayList&lt;ArrayList&lt;Integer&gt;&gt; ans=new ArrayList();
          //如果是空，则直接返回空数组
         if(root==null) return ans;
         // 根加进去
         queue.add(root);
         while(!queue.isEmpty())&#123;
             // 当前层个数
             int n=queue.size();
             // 当前层的集合
             ArrayList&lt;Integer&gt; temp = new ArrayList(); 
             for(int i=0;i&lt;n;i++)&#123;
                 // poll出来
                 TreeNode node=queue.poll();
                 temp.add(node.val);
                 //若是左右孩子存在，则存入左右孩子作为下一个层次
                 if(node.left!=null) queue.add(node.left);
                 if(node.right!=null) queue.add(node.right);
             &#125;
             // 每一层加进结果集
             ans.add(temp);
         &#125;
         return ans;
     &#125;
 &#125;
</code></pre>
<h2 id="按之字形顺序打印二叉树"><a href="#按之字形顺序打印二叉树" class="headerlink" title="按之字形顺序打印二叉树"></a>按之字形顺序打印二叉树</h2><p>给定一个二叉树，返回该二叉树的之字形层序遍历，（第一层从左向右，下一层从右向左，一直这样交替）</p>
<p>和二叉树层序遍历一样 无非就是加一个flag进行一个奇偶判断</p>
<p>注意一个API </p>
<p> Collections.reverse();&#x2F;&#x2F;反转集合</p>
<pre><code class="plain">import java.util.*;
 
 /*
 public class TreeNode &#123;
     int val = 0;
     TreeNode left = null;
     TreeNode right = null;
 
     public TreeNode(int val) &#123;
         this.val = val;
 
     &#125;
 &#125;
 */
 public class Solution &#123;
     public ArrayList&lt;ArrayList&lt;Integer&gt; &gt; Print(TreeNode pRoot) &#123;
         Queue&lt;TreeNode&gt; queue=new LinkedList&lt;&gt;();
         ArrayList&lt;ArrayList&lt;Integer&gt;&gt; ans=new ArrayList();
          //如果是空，则直接返回空数组
         if(pRoot==null) return ans;
         // 根加进去
         queue.add(pRoot);
         boolean flag=true;
         while(!queue.isEmpty())&#123;
             // 当前层个数
             int n=queue.size();
             // 当前层的集合
             ArrayList&lt;Integer&gt; temp = new ArrayList(); 
             for(int i=0;i&lt;n;i++)&#123;
                 // poll出来
                 TreeNode node=queue.poll();
                 temp.add(node.val);
                 //若是左右孩子存在，则存入左右孩子作为下一个层次
                 if(node.left!=null) queue.add(node.left);
                 if(node.right!=null) queue.add(node.right);
             &#125;
             // 每一层加进结果集
             if(flag) ans.add(temp);
             else &#123;
                 Collections.reverse(temp);
                 ans.add(temp);
             &#125;
             flag=!flag;
         &#125;
         return ans;
     &#125;
 
 &#125;
</code></pre>
<h2 id="求根节点到叶节点数字之和"><a href="#求根节点到叶节点数字之和" class="headerlink" title="求根节点到叶节点数字之和"></a>求根节点到叶节点数字之和</h2><p>给你一个二叉树的根节点 root ，树中每个节点都存放有一个 0 到 9 之间的数字。</p>
<p>每条从根节点到叶节点的路径都代表一个数字：</p>
<ul>
<li>例如，从根节点到叶节点的路径 1 -&gt; 2 -&gt; 3 表示数字 123 。</li>
</ul>
<p>计算从根节点到叶节点生成的 <strong>所有数字之和</strong> 。</p>
<p><strong>叶节点</strong> 是指没有子节点的节点。</p>
<pre><code class="plain">//  思路 我把这题类比二叉树的所有路径那题  append的时候简单了 不用加=&gt;  最后用一下Integer.parseInt(s)把字符串转为数字 然后求和就行！
 class Solution &#123;
     List&lt;String&gt; ans=new ArrayList&lt;&gt;();
     int sum=0;
     public int sumNumbers(TreeNode root) &#123;
         StringBuilder sb=new StringBuilder();
         dfs(root,sb);
         for(String s:ans)&#123;
             int i=Integer.parseInt(s);
             sum+=i;
         &#125;
         return sum;
     &#125;
     public void dfs(TreeNode root,StringBuilder sb)&#123;
         if(root==null) return;
         sb.append(root.val);
         if(root.right==null&amp;&amp;root.left==null)&#123;
             ans.add(sb.toString());
         &#125;
         dfs(root.left,new StringBuilder(sb));
         dfs(root.right,new StringBuilder(sb));
     &#125;
 &#125;
</code></pre>
<h2 id="将二叉搜索树变平衡"><a href="#将二叉搜索树变平衡" class="headerlink" title="将二叉搜索树变平衡"></a>将二叉搜索树变平衡</h2><p>给你一棵二叉搜索树，请你返回一棵 <strong>平衡后</strong> 的二叉搜索树，新生成的树应该与原来的树有着相同的节点值。如果有多种构造方法，请你返回任意一种。</p>
<p>如果一棵二叉搜索树中，每个节点的两棵子树高度差不超过 1 ，我们就称这棵二叉搜索树是 <strong>平衡的</strong> 。</p>
<p>题解 中序遍历把二叉树转变为有序数组，然后在根据有序数组构造平衡二叉搜索树。</p>
<pre><code class="plain">class Solution &#123;
     List&lt;Integer&gt; res=new ArrayList&lt;&gt;();
     public TreeNode balanceBST(TreeNode root) &#123;
         // 中序遍历把二叉树转变为有序数组，然后在根据有序数组构造平衡二叉搜索树。
         tranval(root);
         return getTree(0,res.size()-1);
     &#125;
     // 有序树转成有序数组
     public void tranval(TreeNode root)&#123;
         if(root==null) return;
         tranval(root.left);
         res.add(root.val);
         tranval(root.right);
     &#125;
     // 有序数组转成平衡二叉树
     public TreeNode getTree(int left,int right)&#123;
         if(left&gt;right) return null;
         // 二分
         int mid=(left+right)/2;
         // 创建结点
         TreeNode root=new TreeNode(res.get(mid));
         root.left=getTree(left,mid-1);
         root.right=getTree(mid+1,right);
         return root;
     &#125;
 &#125;
</code></pre>
<h2 id="相同的树"><a href="#相同的树" class="headerlink" title="相同的树"></a>相同的树</h2><p>给你两棵二叉树的根节点 p 和 q ，编写一个函数来检验这两棵树是否相同。</p>
<p>如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。</p>
<p>题解:和对称树基本一样</p>
<pre><code class="plain">class Solution &#123;
     public boolean isSameTree(TreeNode p, TreeNode q) &#123;
         if(p==null&amp;&amp;q==null) return true;
         if(p==null||q==null) return false;
         return p.val==q.val&amp;&amp;isSameTree(p.left,q.left)&amp;&amp;isSameTree(p.right,q.right);
     &#125;
 &#125;
</code></pre>
<h2 id="填充每个节点的下一个右侧节点指针"><a href="#填充每个节点的下一个右侧节点指针" class="headerlink" title="填充每个节点的下一个右侧节点指针"></a>填充每个节点的下一个右侧节点指针</h2><p>给定一个 <strong>完美二叉树</strong> ，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：</p>
<p>填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。</p>
<p>初始状态下，所有 next 指针都被设置为 NULL。</p>
<p>题解：递归</p>
<pre><code class="plain">if (cur.left != null) cur.left.next = cur.right; // 操作1
         if (cur.right != null) &#123;
             if(cur.next != null) cur.right.next = cur.next.left; //操作2
             else cur.right.next = null;
         &#125;
</code></pre>
<p>最终答案</p>
<pre><code class="plain">// 递归法
 class Solution &#123;
     public void traversal(Node cur) &#123;
         if (cur == null) return;
         if (cur.left != null) cur.left.next = cur.right; // 操作1
         if (cur.right != null) &#123;
             if(cur.next != null) cur.right.next = cur.next.left; //操作2
             else cur.right.next = null;
         &#125;
         traversal(cur.left);  // 左
         traversal(cur.right); //右
     &#125;
     public Node connect(Node root) &#123;
         traversal(root);
         return root;
     &#125;
 &#125;
</code></pre>
<h2 id="二叉树中和为某一值的路径-一"><a href="#二叉树中和为某一值的路径-一" class="headerlink" title="二叉树中和为某一值的路径(一)"></a><strong>二叉树中和为某一值的路径(一)</strong></h2><p>给定一个二叉树root和一个值 sum ，判断是否有从根节点到叶子节点的节点值之和等于 sum 的路径。</p>
<pre><code class="plain">import java.util.*;
 
 /*
  * public class TreeNode &#123;
  *   int val = 0;
  *   TreeNode left = null;
  *   TreeNode right = null;
  * &#125;
  */
 
 public class Solution &#123;
     /**
      * 
      * @param root TreeNode类 
      * @param sum int整型 
      * @return bool布尔型
      */
     public boolean hasPathSum (TreeNode root, int sum) &#123;
         // write code here
         if(root==null) return false;
         if(root.right==null&amp;&amp;root.left==null&amp;&amp;sum-root.val==0) return true;
         return hasPathSum(root.left,sum-root.val)||hasPathSum(root.right,sum-root.val);
     &#125;
 
 &#125;
</code></pre>
<h2 id="二叉搜索树与双向链表"><a href="#二叉搜索树与双向链表" class="headerlink" title="二叉搜索树与双向链表"></a>二叉搜索树与双向链表</h2><p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表</p>
<p><strong>思路：</strong></p>
<p>二叉搜索树最左端的元素一定最小，最右端的元素一定最大，符合“左中右”的特性，因此二叉搜索树的中序遍历就是一个递增序列，我们只要对它中序遍历就可以组装称为递增双向链表。每次遍历的时候构造好双向链表，注意次序；</p>
<p><strong>具体做法：</strong></p>
<ul>
<li>step 1：创建两个指针，一个指向题目中要求的链表头（head），一个指向当前遍历的前一节点（pre)。</li>
<li>step 2：首先递归到最左，初始化head与pre。</li>
<li>step 3：然后处理中间根节点，依次连接pre与当前节点，连接后更新pre为当前节点。</li>
<li>step 4：最后递归进入右子树，继续处理。</li>
<li>step 5：递归出口即是节点为空则返回。</li>
</ul>
<pre><code class="plain">public class Solution &#123;
     //返回的第一个指针，即为最小值，先定为null
     public TreeNode head = null; 
     //中序遍历当前值的上一位，初值为最小值，先定为null
     public TreeNode pre = null; 
     public TreeNode Convert(TreeNode pRootOfTree) &#123;
         if(pRootOfTree==null) return null;
         // 首先递归到最左最小值  中序的顺序
         Convert(pRootOfTree.left);
         //初始化
         if(pre==null)&#123;
             pre=pRootOfTree;
             head=pRootOfTree;//初始化头结点
         &#125;
         else &#123;
             //总之保证Pre在pRootOfTree的前面
             pre.right=pRootOfTree;
             pRootOfTree.left=pre;
             pre=pRootOfTree;
         &#125;
         Convert(pRootOfTree.right);
         return head;
     &#125;
 &#125;
</code></pre>
<h1 id="BFS-amp-DFS"><a href="#BFS-amp-DFS" class="headerlink" title="BFS&amp;DFS"></a>BFS&amp;DFS</h1><p>DFS 遍历使用递归：</p>
<pre><code class="plain">void dfs(TreeNode root) &#123;
    if (root == null) &#123;
        return;
    &#125;
    dfs(root.left);//递归到最后一层最左边节点，左右节点为空，return出来，到最后一层第二个节点
    dfs(root.right);
&#125;
</code></pre>
<p>BFS 遍历使用队列数据结构：</p>
<pre><code class="plain">void bfs(TreeNode root) &#123;
    Queue&lt;TreeNode&gt; queue = new ArrayDeque&lt;&gt;();
    queue.add(root);
    while (!queue.isEmpty()) &#123;
        TreeNode node = queue.poll(); // Java 的 pop 写作 poll()
        if (node.left != null) &#123;
            queue.add(node.left);//队列先进后出，所以是按层往外扩，一直从左往右遍历
        &#125;
        if (node.right != null) &#123;
            queue.add(node.right);
        &#125;
    &#125;
&#125;
</code></pre>
<p><img src="https://raw.githubusercontent.com/viacheung/img/main/image/fdcd3bd27f4008948084f6ec86b58535e71f66862bd89a34bd6fe4cc42d68e89-16578569951531.gif" alt="img"></p>
<h2 id="BFS-的应用一：层序遍历"><a href="#BFS-的应用一：层序遍历" class="headerlink" title="BFS 的应用一：层序遍历"></a><strong>BFS 的应用一：层序遍历</strong></h2><p>给定一个二叉树，返回其按层序遍历得到的节点值。 层序遍历即逐层地、从左到右访问所有结点。</p>
<p>层序遍历要求的输入结果和 BFS 是不同的。层序遍历要求我们区分每一层，也就是返回一个二维数组。而 BFS 的遍历结果是一个一维数组，无法区分每一层。</p>
<p><img src="https://raw.githubusercontent.com/viacheung/img/main/image/fd1d63037d0e2f787d2140fee406e109094a4f66ab0837a7273f8b371eef8096.jpg" alt="img"></p>
<p>截取 BFS 遍历过程中的某个时刻：</p>
<p><img src="https://raw.githubusercontent.com/viacheung/img/main/image/4529bf559c6a2d84d550eebaee027c3b7ae25069e4ec91f27b29a4c6358d6662.gif" alt="img"></p>
<p>BFS 遍历中某个时刻队列的状态</p>
<p><img src="https://raw.githubusercontent.com/viacheung/img/main/image/9f178b56ff1c94388d893f2fb48e9e77e186aba7cfd7483637776359062d68b8.jpg" alt="img"></p>
<p>可以看到，此时队列中的结点是 3、4、5，分别来自第 1 层和第 2 层。这个时候，第 1 层的结点还没出完，第 2 层的结点就进来了，而且两层的结点在队列中紧挨在一起，我们无法区分队列中的结点来自哪一层。</p>
<p>因此，我们需要稍微修改一下代码，在每一层遍历开始前，先记录队列中的结点数量 n（也就是这一层的结点数量），然后一口气处理完这一层的 n 个结点。</p>
<pre><code class="plain">// 二叉树的层序遍历
void bfs(TreeNode root) &#123;
    Queue&lt;TreeNode&gt; queue = new ArrayDeque&lt;&gt;();
    queue.add(root);
    while (!queue.isEmpty()) &#123;
        int n = queue.size();
        for (int i = 0; i &lt; n; i++) &#123; 
            // 变量 i 无实际意义，只是为了循环 n 次
            TreeNode node = queue.poll();
            if (node.left != null) &#123;
                queue.add(node.left);
            &#125;
            if (node.right != null) &#123;
                queue.add(node.right);
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<p>这样，我们就将 BFS 遍历改造成了层序遍历。在遍历的过程中，结点进队列和出队列的过程为：</p>
<p><img src="https://raw.githubusercontent.com/viacheung/img/main/image/94cd1fa999df0276f1dae77a9cca83f4cabda9e2e0b8571cd9550a8ee3545f56.gif" alt="img"></p>
<p>可以看到，在 while 循环的每一轮中，都是将当前层的所有结点出队列，再将下一层的所有结点入队列，这样就实现了层序遍历。</p>
<p>最终我们得到的题解代码为：</p>
<pre><code class="plain">public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;
    List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();

    Queue&lt;TreeNode&gt; queue = new ArrayDeque&lt;&gt;();
    if (root != null) &#123;
        queue.add(root);
    &#125;
    while (!queue.isEmpty()) &#123;
        int n = queue.size();
        List&lt;Integer&gt; level = new ArrayList&lt;&gt;();
        for (int i = 0; i &lt; n; i++) &#123; 
            TreeNode node = queue.poll();//弹出队头n次 正好就是把上一层的结点全部弹出 剩下的就是这一层的节点数量 
            level.add(node.val);//level放每一层的值
            if (node.left != null) &#123;
                queue.add(node.left);
            &#125;
            if (node.right != null) &#123;
                queue.add(node.right);
            &#125;
        &#125;
        res.add(level);//加入结果集
    &#125;

    return res;
&#125;
</code></pre>
<h1 id="递归-1"><a href="#递归-1" class="headerlink" title="递归"></a>递归</h1><p>我的理解：</p>
<p>主要函数里面return一个自定义函数，自定义函数里面前一部分写好递归的统一模板，然后开始递归下一层。</p>
<p>甩锅给后面的过程，然后得有一个出口。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/226907/1685799400993-fcd546a8-e08a-44c6-ada3-220be1d8330a.png" alt="img"></p>
<pre><code class="plain">/**
 * 合并两有序链表  递归方法 代码少 但效率不行
 */
public ListNode mergeTwoLists(ListNode list1,ListNode list2)&#123;
    if(list1==null||list2==null)&#123;
        return list1==null?list2:list1;
    &#125;else if(list1.val&lt;list2.val)&#123;
        list1.next=mergeTwoLists(list1.next,list2);
        return list1;
    &#125;else&#123;
        list2.next=mergeTwoLists(list2.next,list1);
        return list2;
    &#125;
&#125;
/**
 * 普通方法 代码多 但效率快
 */
/*
public ListNode mergeTwoLists(ListNode list1,ListNode list2)&#123;
    if(list1==null||list2==null)&#123;
        return list1==null?list2:list1;
    &#125;
    ListNode head=new ListNode(0);
    ListNode tail=head,aptr=list1,bptr=list2;
    while (list1!=null&amp;&amp;list2!=null)&#123;
        if(list1.val&lt;list2.val)&#123;
            tail.next=list1;
            list1=list1.next;
        &#125;else&#123;
            tail.next=list2;
            list2=list2.next;
        &#125;
        tail=tail.next;
    &#125;
    tail.next=list1!=null?list1:list2;
    return head.next;
&#125;
 */
</code></pre>

    </div>

    
    
    
        <div class="reward-container">
  <div>“坚持原创技术分享，您的支持将鼓励我继续创作!“</div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/images/wechatpay.jpg" alt="ViaCheung 微信支付">
        <p>微信支付</p>
      </div>

  </div>
</div>

        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>ViaCheung
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://viacheung.github.io/2023/06/04/%E4%BA%8C%E5%8F%89%E6%A0%91/" title="二叉树">http://viacheung.github.io/2023/06/04/二叉树/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/zh-CN" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2023/06/04/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" rel="prev" title="多线程">
      <i class="fa fa-chevron-left"></i> 多线程
    </a></div>
      <div class="post-nav-item">
    <a href="/2023/06/04/%E4%BA%8C%E5%88%86/" rel="next" title="二分">
      二分 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86"><span class="nav-number">1.</span> <span class="nav-text">相关知识</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">2.</span> <span class="nav-text">对称二叉树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6"><span class="nav-number">3.</span> <span class="nav-text">二叉树的最大深度</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6"><span class="nav-number">4.</span> <span class="nav-text">二叉树最小深度</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%8A%82%E7%82%B9%E4%B8%AA%E6%95%B0-%C3%97"><span class="nav-number">5.</span> <span class="nav-text">完全二叉树的节点个数(×)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84"><span class="nav-number">6.</span> <span class="nav-text">二叉树的所有路径</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">7.</span> <span class="nav-text">平衡二叉树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B7%A6%E5%8F%B6%E5%AD%90%E4%B9%8B%E5%92%8C"><span class="nav-number">8.</span> <span class="nav-text">左叶子之和</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%89%BE%E6%A0%91%E5%B7%A6%E4%B8%8B%E8%A7%92%E7%9A%84%E5%80%BC"><span class="nav-number">9.</span> <span class="nav-text">找树左下角的值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C"><span class="nav-number">10.</span> <span class="nav-text">路径总和</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%8E%E4%B8%AD%E5%BA%8F%E4%B8%8E%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">11.</span> <span class="nav-text">从中序与后序遍历序列构造二叉树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%80%E5%A4%A7%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">12.</span> <span class="nav-text">最大二叉树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="nav-number">13.</span> <span class="nav-text">验证二叉搜索树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E7%BB%9D%E5%AF%B9%E5%B7%AE"><span class="nav-number">14.</span> <span class="nav-text">二叉搜索树的最小绝对差</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E4%BC%97%E6%95%B0"><span class="nav-number">15.</span> <span class="nav-text">二叉搜索树中的众数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-number">16.</span> <span class="nav-text">二叉树前序遍历</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">17.</span> <span class="nav-text">合并二叉树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%95%B0%E8%BD%AC%E7%B4%AF%E5%8A%A0%E6%95%B0"><span class="nav-number">18.</span> <span class="nav-text">二叉搜索数转累加数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86%E9%A2%98%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%95%E5%BC%80%E4%B8%BA%E9%93%BE%E8%A1%A8%E9%A2%98%E7%9A%84%E5%AF%B9%E6%AF%94%EF%BC%88%E5%9D%87%E4%B8%BA%E8%BF%AD%E4%BB%A3%EF%BC%89"><span class="nav-number">19.</span> <span class="nav-text">二叉树遍历题和二叉树展开为链表题的对比（均为迭代）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88"><span class="nav-number">20.</span> <span class="nav-text">二叉树的最近公共祖先</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88"><span class="nav-number">21.</span> <span class="nav-text">二叉搜索树最近公共祖先</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C"><span class="nav-number">22.</span> <span class="nav-text">二叉搜索树中的插入操作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E8%8A%82%E7%82%B9"><span class="nav-number">23.</span> <span class="nav-text">删除二叉搜索树的节点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BF%AE%E5%89%AA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="nav-number">24.</span> <span class="nav-text">修剪二叉搜索树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="nav-number">25.</span> <span class="nav-text">将有序数组转换为二叉搜索树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BD%AC%E6%8D%A2%E4%B8%BA%E7%B4%AF%E5%8A%A0%E6%A0%91"><span class="nav-number">26.</span> <span class="nav-text">把二叉搜索树转换为累加树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">27.</span> <span class="nav-text">翻转二叉树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96"><span class="nav-number">28.</span> <span class="nav-text">二叉树的序列化和反序列化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">29.</span> <span class="nav-text">总结</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-number">30.</span> <span class="nav-text">二叉树的前序遍历</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-number">31.</span> <span class="nav-text">二叉树中序遍历</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%92%E5%BD%92"><span class="nav-number">31.1.</span> <span class="nav-text">递归</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%AD%E4%BB%A3"><span class="nav-number">31.2.</span> <span class="nav-text">迭代</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-number">32.</span> <span class="nav-text">二叉树的后序遍历</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%AD%E4%BB%A3-1"><span class="nav-number">32.1.</span> <span class="nav-text">迭代</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B1%82%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-number">33.</span> <span class="nav-text">求二叉树的层序遍历</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%AD%E4%BB%A3-2"><span class="nav-number">33.1.</span> <span class="nav-text">迭代</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8C%89%E4%B9%8B%E5%AD%97%E5%BD%A2%E9%A1%BA%E5%BA%8F%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">34.</span> <span class="nav-text">按之字形顺序打印二叉树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B1%82%E6%A0%B9%E8%8A%82%E7%82%B9%E5%88%B0%E5%8F%B6%E8%8A%82%E7%82%B9%E6%95%B0%E5%AD%97%E4%B9%8B%E5%92%8C"><span class="nav-number">35.</span> <span class="nav-text">求根节点到叶节点数字之和</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%86%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E5%8F%98%E5%B9%B3%E8%A1%A1"><span class="nav-number">36.</span> <span class="nav-text">将二叉搜索树变平衡</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9B%B8%E5%90%8C%E7%9A%84%E6%A0%91"><span class="nav-number">37.</span> <span class="nav-text">相同的树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A1%AB%E5%85%85%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%8F%B3%E4%BE%A7%E8%8A%82%E7%82%B9%E6%8C%87%E9%92%88"><span class="nav-number">38.</span> <span class="nav-text">填充每个节点的下一个右侧节点指针</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84-%E4%B8%80"><span class="nav-number">39.</span> <span class="nav-text">二叉树中和为某一值的路径(一)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8"><span class="nav-number">40.</span> <span class="nav-text">二叉搜索树与双向链表</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#BFS-amp-DFS"><span class="nav-number"></span> <span class="nav-text">BFS&amp;DFS</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#BFS-%E7%9A%84%E5%BA%94%E7%94%A8%E4%B8%80%EF%BC%9A%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-number">1.</span> <span class="nav-text">BFS 的应用一：层序遍历</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%80%92%E5%BD%92-1"><span class="nav-number"></span> <span class="nav-text">递归</span></a></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="ViaCheung"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">ViaCheung</p>
  <div class="site-description" itemprop="description">el psy congroo</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">20</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/viacheung" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;viacheung" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:viacheung5@gmail.com" title="E-Mail → mailto:viacheung5@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/zh-CN" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ViaCheung</span>
</div>

<!--
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div> -->

<!-- 网站运行时间的设置 -->
<span id="timeDate">载入天数...</span>
<span id="times">载入时分秒...</span>
<script>
    var now = new Date();
    function createtime() {
        var grt= new Date("03/01/2023 10:00:00"); //此处修改你的建站时间或者网站上线时间
        now.setTime(now.getTime()+250);
        days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days);
        hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours);
        if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);
        mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;}
        seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
        snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;}
        document.getElementById("timeDate").innerHTML = "本站已安全运行 "+dnum+" 天 ";
        document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒.";
    }
setInterval("createtime()",250);
</script>
        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>

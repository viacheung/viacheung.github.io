[{"title":"JAVA基础","url":"/2023/06/04/JAVA%E5%9F%BA%E7%A1%80/","content":"<h2 id=\"面向对象和⾯向过程的区别\"><a href=\"#面向对象和⾯向过程的区别\" class=\"headerlink\" title=\"面向对象和⾯向过程的区别\"></a>面向对象和⾯向过程的区别</h2><p>面向过程</p>\n<p>优点：性能高，适合单片机嵌入式开发 </p>\n<p>缺点：没有⾯向对象易维护、易复⽤、易扩展。<span id=\"more\"></span></p>\n<p>⾯向对象 ： </p>\n<p>优点：⾯向对象易维护、易复⽤、易扩展 </p>\n<p>缺点：性能低</p>\n<h2 id=\"Java-语⾔有哪些特点\"><a href=\"#Java-语⾔有哪些特点\" class=\"headerlink\" title=\"Java 语⾔有哪些特点?\"></a>Java 语⾔有哪些特点?</h2><ol>\n<li>简单易学；</li>\n<li>⾯向对象（封装，继承，多态）；</li>\n<li>平台⽆关性（ Java 虚拟机实现平台⽆关性） 一次编译 处处运行</li>\n<li>⽀持多线程（ C++ 语⾔没有内置的多线程机制，因此必须调⽤操作系统的多线程功能来进⾏多线程程序设计，⽽ Java 语⾔却提供了多线程⽀持）；</li>\n<li>⽀持⽹络编程、⽅便 Java 语⾔诞⽣本身就是为简化⽹络编程设计的</li>\n<li>半编译半解释；</li>\n</ol>\n<h2 id=\"JDK-和-JRE\"><a href=\"#JDK-和-JRE\" class=\"headerlink\" title=\"JDK 和 JRE\"></a>JDK 和 JRE</h2><p><strong>jdk包括jre</strong></p>\n<p>JDK用来创建和编译程序。JRE 是 Java 运⾏时环境。包括（JVM）， Java 类库等，但是，不能⽤于创建新程序。</p>\n<h2 id=\"Oracle-JDK-和-OpenJDK-的对⽐\"><a href=\"#Oracle-JDK-和-OpenJDK-的对⽐\" class=\"headerlink\" title=\"Oracle JDK 和 OpenJDK 的对⽐\"></a>Oracle JDK 和 OpenJDK 的对⽐</h2><p>OpenJDK 是⼀个参考模型、完全开源，⽽ Oracle JDK 是 OpenJDK 的⼀个实现，并不是完全开源的；</p>\n<p>Oracle JDK 更稳定 性能更好</p>\n<h2 id=\"Java-和-C-的区别\"><a href=\"#Java-和-C-的区别\" class=\"headerlink\" title=\"Java 和 C++的区别?\"></a>Java 和 C++的区别?</h2><p>都是⾯向对象的语⾔，都⽀持封装、继承和多态Java 不提供指针来直接访问内存，程序内存更加安全Java 的类是单继承（接口多继承）， C++ ⽀持多重继承；Java 有⾃动内存管理机制，不需要程序员⼿动释放⽆⽤内存在 C 语⾔中，字符串或字符数组最后都会有⼀个额外的字符‘\\0’来表示结束。但是， Java 语⾔中没有结束符这⼀概念。 这是⼀个值得深度思考的问题，具体原因推荐看这篇⽂章：<a href=\"https://blog.csdn.net/sszgg2006/article/details/49148189\">https://blog.csdn.net/sszgg2006/article/details/49148189</a></p>\n<p>java皆对象 可以通过length()知道长度 没必要加一个额外字符</p>\n<h2 id=\"采用字节码的好处是什么\"><a href=\"#采用字节码的好处是什么\" class=\"headerlink\" title=\"采用字节码的好处是什么?\"></a>采用字节码的好处是什么?</h2><p>解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点</p>\n<h2 id=\"字符型常量和字符串常量的区别\"><a href=\"#字符型常量和字符串常量的区别\" class=\"headerlink\" title=\"字符型常量和字符串常量的区别?\"></a>字符型常量和字符串常量的区别?</h2><ol>\n<li>形式上: 字符常量是单引号引起的⼀个字符; 字符串常量是双引号引起的若⼲个字符</li>\n<li>含义上: 字符常量相当于⼀个整型值( ASCII 值),可以参加表达式运算; 字符串常量代表⼀个地址值(该字符串在内存中存放位置)</li>\n<li>占内存⼤⼩ 字符常量只占 2 个字节; 字符串常量占若⼲个字节 (注意： char 在 Java 中占两个字节)</li>\n</ol>\n<h2 id=\"构造器-Constructor-是否可被-override\"><a href=\"#构造器-Constructor-是否可被-override\" class=\"headerlink\" title=\"构造器 Constructor 是否可被 override?\"></a>构造器 Constructor 是否可被 override?</h2><p>Constructor 不能被 override（重写） ,但是可以 overload（重载） ,所以你可以看到⼀个类中有多个构造函数的情况</p>\n<h2 id=\"重载和重写的区别\"><a href=\"#重载和重写的区别\" class=\"headerlink\" title=\"重载和重写的区别\"></a>重载和重写的区别</h2><p>都是实现多态方式，重载时编译时多态，重写时运行时多态</p>\n<p>重载就是同样的⼀个⽅法能够根据输⼊数据的不同，做出不同的处理 方法名一样 参数列表不同 返回值也可以不同 例如构造器重载</p>\n<p>重载的方法能否根据返回值类型进行区分？不可以</p>\n<p>重写就是当⼦类继承⾃⽗类的相同⽅法，输⼊数据⼀样，但要做出有别于⽗类的响应时，你就要覆盖⽗类⽅法 方法名一样 参数列表一样 返回类型一样 代码具体实现不一样</p>\n<h2 id=\"封装-继承-多态\"><a href=\"#封装-继承-多态\" class=\"headerlink\" title=\"封装 继承 多态\"></a>封装 继承 多态</h2><p>继承</p>\n<ul>\n<li><p>子类继承父类的特征和行为</p>\n</li>\n<li><p>特点：</p>\n</li>\n<li><ul>\n<li>Java只支持单继承，不支持多继承。一个类只能有一个父类，不可以有多个父类。</li>\n<li>private修饰的属性和方法都是无法被子类继承的。</li>\n<li>protected修饰的方法，就是用来给子类继承！！！</li>\n</ul>\n</li>\n<li><p>优点：</p>\n</li>\n<li><ul>\n<li>1、继承的出现减少了代码的重复，提高了代码的复用度，提高软件开发效率。</li>\n<li>2、继承的出现让类与类之间产生了关系，提供了多态的前提。</li>\n</ul>\n</li>\n</ul>\n<p>多态</p>\n<ul>\n<li><p>在继承基础上，才有多态</p>\n</li>\n<li><p>定义：父类引用指向子类实例</p>\n</li>\n<li><p>实现的必要条件</p>\n</li>\n<li><ul>\n<li>存在继承关系</li>\n<li>存在方法重写</li>\n<li>父类引用指向子类对象</li>\n</ul>\n</li>\n<li><p>优点：</p>\n</li>\n<li><ul>\n<li>简化了代码</li>\n<li>提高了维护性和扩展性</li>\n</ul>\n</li>\n</ul>\n<p>封装</p>\n<ul>\n<li><p>定义：封装就是把同一类事物的共性（包括属性和方法）归到同一类中，方便使用。</p>\n</li>\n<li><p>有两层含义</p>\n</li>\n<li><ul>\n<li>1、类，属性、方法这些定义在类</li>\n<li>2、为了安全考虑，在开发的过程中，会将属性私有化（private关键字修饰），需要提供对应接口完成设置和访问（公开的setter和getter方法）的过程。</li>\n</ul>\n</li>\n<li><p>好处</p>\n</li>\n<li><ul>\n<li><font color=\"red\">提高了代码的复用性。</font></li>\n<li>隐藏了实现细节，还要对外提供可以访问的方式。便于调用者的使用。这是核心之一，也可以理解为就是封装的概念。</li>\n<li><font color=\"red\">提高了安全性。</font></li>\n</ul>\n</li>\n</ul>\n<p>封装：对外界提供<strong>方法属性</strong>  隐藏不可信信息 数据方法让可信类对象操作</p>\n<p>继承：复用代码 父类私有属性方法 子类只读不写</p>\n<p>多态：表示一个对象具有多种的状态，具体表现为父类的引用指向子类的实例。</p>\n<p><strong>多态的特点:</strong></p>\n<ul>\n<li>对象类型和引用类型之间具有继承（类）&#x2F;实现（接口）的关系；</li>\n<li>引用类型变量发出的方法调用的到底是哪个类中的方法，必须在程序运行期间才能确定；</li>\n<li>多态不能调用“只在子类存在但在父类不存在”的方法；</li>\n<li>如果子类重写了父类的方法，真正执行的是子类覆盖的方法，如果子类没有覆盖父类的方法，执行的是父类的方法。</li>\n</ul>\n<h2 id=\"String-StringBuffer-和StringBuilder-的区别是什么-String-为什么是不可变的\"><a href=\"#String-StringBuffer-和StringBuilder-的区别是什么-String-为什么是不可变的\" class=\"headerlink\" title=\"String StringBuffer 和StringBuilder 的区别是什么?String 为什么是不可变的?\"></a>String StringBuffer 和StringBuilder 的区别是什么?String 为什么是不可变的?</h2><p>1、前两者可变 string不可变（final）（适用于操作少量数据）</p>\n<p>2、string线程安全 stringbuffer线程安全（synchronized） 那个不安全</p>\n<p>3、StringBuilder性能比stringbuffer多10-15%</p>\n<h2 id=\"String为什么要设计成不可变的？\"><a href=\"#String为什么要设计成不可变的？\" class=\"headerlink\" title=\"String为什么要设计成不可变的？\"></a>String为什么要设计成不可变的？</h2><p>1.便于实现字符串池（String pool）</p>\n<p>堆中开辟一块存储空间String pool，当初始化一个String变量时，如果该字符串已经存在了，就不会去创建一个新的字符串变量，而是会返回已经存在了的字符串的引用。</p>\n<p>2.多线程安全</p>\n<p>3.避免安全 网络连接地址URL，文件路径path，反射机制所需要的String参数保证连接安全性</p>\n<p>4.保证了hashcode的唯一性，因此创建对象即可缓存，Map将其当做key，速度块</p>\n<h2 id=\"String相关\"><a href=\"#String相关\" class=\"headerlink\" title=\"String相关\"></a>String相关</h2><h3 id=\"字符串常量-vs-字符常量\"><a href=\"#字符串常量-vs-字符常量\" class=\"headerlink\" title=\"字符串常量 vs 字符常量\"></a>字符串常量 vs 字符常量</h3><p>形式：字符数量 单双引号</p>\n<p>含义上: 字符常量：整型值( ASCII 值) 字符串常量：地址值 对象；</p>\n<p>占内存大小：字符常量2个字节；字符串常量占若干个字节</p>\n<h3 id=\"什么是字符串常量池？\"><a href=\"#什么是字符串常量池？\" class=\"headerlink\" title=\"什么是字符串常量池？\"></a>什么是字符串常量池？</h3><p>jvm为了提升性能、减少内存开销，开辟字符串常量池 ；当使用字符串 常量池有 直接拿 ； 不存在 初始化 放到池子里面</p>\n<p>jdk7 字符串常量池在永久代 常量池 存的是对象</p>\n<p>jdk8 字符串常量池在堆 常量池 存的堆的引用</p>\n<h3 id=\"String-str-x3D-”aaa”（1）与-String-str-x3D-new-String-“aaa”-2个-一样吗？new-String-“aaa”-创建了几个字符串对象\"><a href=\"#String-str-x3D-”aaa”（1）与-String-str-x3D-new-String-“aaa”-2个-一样吗？new-String-“aaa”-创建了几个字符串对象\" class=\"headerlink\" title=\"String str&#x3D;”aaa”（1）与 String str&#x3D;new String(“aaa”)(2个)一样吗？new String(“aaa”);创建了几个字符串对象?\"></a>String str&#x3D;”aaa”（1）与 String str&#x3D;new String(“aaa”)(2个)一样吗？new String(“aaa”);创建了几个字符串对象?</h3><ul>\n<li>String a &#x3D; “aaa” ;，常量池中查找”aaa”字符串，若没有，会将”aaa”字符串放进常量池，再将其地址赋给a；若有，将找到的”aaa”字符串的地址赋给a。</li>\n<li>使用String b &#x3D; new String(“aaa”);程序会在<strong>堆内存</strong>中开辟一片新空间存放新对象，同时会将”aaa”字符串放入常量池，相当于创建了两个对象，无论常量池中有没有”aaa”字符串，程序都会在堆内存中开辟一片新空间存放新对象。</li>\n</ul>\n<p><strong>intern()函数</strong>：</p>\n<p>在JDK1.6中，intern的处理是 先判断字符串常量是否在字符串常量池中，如果存在直接返回该常量，如果没有找到，则将该字符串常量加入到字符串常量区，也就是在字符串常量区建立该常量（复制对象）；<strong>（常量池有直接返回，没有的话字符串加入常量池）</strong></p>\n<p>在JDK1.7中，intern的处理是 先判断字符串常量是否在字符串常量池中，如果存在直接返回该常量，如果没有找到，说明该字符串常量在堆中，则处理是把堆区该对象的引用加入到字符串常量池中，以后别人拿到的是该字符串常量的引用（复制对象引用地址），实际存在堆中（常量池有直接返回，没有的话把堆里面字符串对象引用加入常量池）</p>\n<pre><code class=\"plain\">public void test()&#123;\n         String s = new String(&quot;2&quot;);\n         s.intern();\n         String s2 = &quot;2&quot;;\n         System.out.println(s == s2);\n \n \n         String s3 = new String(&quot;3&quot;) + new String(&quot;3&quot;);\n         s3.intern();\n         String s4 = &quot;33&quot;;\n         System.out.println(s3 == s4);\n     &#125;\n     \n jdk6\n false（没啥说的 一个堆对象  一个常量池对象）\n false（没啥说的 一个堆对象  一个常量池对象）\n \n jdk7\n false（一个在堆中的StringObject对象，一个是在堆中的“2”对象 常量池存了一下”2“对象的引用地址，Intern之后，一样 还是存的&quot;2&quot;对象引用 不一样）\n true（s3指向&quot;33&quot;  s3.intern 将s3对应的StringObject对象的地址保存到常量池中，返回StringObject对象的地址。String s4 = &quot;33&quot;，去常量池找，发现有，返回2，也就是StringObject对象的引用地址，因此一样）\n</code></pre>\n<h3 id=\"String特性\"><a href=\"#String特性\" class=\"headerlink\" title=\"String特性\"></a>String特性</h3><ul>\n<li>不变性：当一个对象需要被多线程共享并频繁访问时，可以保证数据的一致性；</li>\n<li>常量池优化：String 对象创建之后，会在字符串常量池中进行缓存，如果下次创建同样的对象时，会直接返回缓存的引用；</li>\n<li>final：使用 final 来定义 String 类，表示 String 类不能被继承，提高了系统的安全性。</li>\n</ul>\n<h3 id=\"在使用-HashMap-的时候，用-String-做-key-有什么好处？\"><a href=\"#在使用-HashMap-的时候，用-String-做-key-有什么好处？\" class=\"headerlink\" title=\"在使用 HashMap 的时候，用 String 做 key 有什么好处？\"></a>在使用 HashMap 的时候，用 String 做 key 有什么好处？</h3><p>HashMap 内部实现是通过 key 的 hashcode 来确定 value 的存储位置，因为字符串是不可变的，所以当创建字符串时，它的 hashcode 被缓存下来，不需要再次计算hashcode，维护一个HashMap（key,hashcode）所以相比于其他对象更快（存取快）。</p>\n<h2 id=\"八个基本数据类型\"><a href=\"#八个基本数据类型\" class=\"headerlink\" title=\"八个基本数据类型\"></a>八个基本数据类型</h2><p>short int long float double char byte boolean </p>\n<p>long后面要加L</p>\n<p>boolean类型数据在经过编译后在JVM中会通过int类型来表示</p>\n<h2 id=\"switch\"><a href=\"#switch\" class=\"headerlink\" title=\"switch\"></a>switch</h2><p>byte、short、char、int enum String</p>\n<h2 id=\"访问修饰符public、private、protected、以及不写（默认）时的区别？\"><a href=\"#访问修饰符public、private、protected、以及不写（默认）时的区别？\" class=\"headerlink\" title=\"访问修饰符public、private、protected、以及不写（默认）时的区别？\"></a>访问修饰符public、private、protected、以及不写（默认）时的区别？</h2><ul>\n<li><strong>default</strong> (即默认，什么也不写）: 在同一包内,使用对象：类、接口、变量、方法。</li>\n<li><strong>private</strong> : 在同一类内。使用对象：变量、方法。 <strong>注意：不能修饰类（外部类）</strong></li>\n<li><strong>public</strong> : 对所有类可见。使用对象：类、接口、变量、方法</li>\n<li><strong>protected</strong> : 对同一包内的类和所有子类(不同包也可)可见。使用对象：变量、方法。 <strong>注意：不能修饰类（外部类）</strong>。</li>\n</ul>\n<h2 id=\"关键字\"><a href=\"#关键字\" class=\"headerlink\" title=\"关键字\"></a>关键字</h2><h3 id=\"final、finally、finalize的区别？\"><a href=\"#final、finally、finalize的区别？\" class=\"headerlink\" title=\"final、finally、finalize的区别？\"></a>final、finally、finalize的区别？</h3><p><strong>final</strong>: 变量：引用不可变 必须初始化 方法：不可重写 类不可继承</p>\n<p>finally:异常执行，最后一定执行</p>\n<p>finalize 方法回收之前对对象的一些操作</p>\n<h3 id=\"static作用？\"><a href=\"#static作用？\" class=\"headerlink\" title=\"static作用？\"></a>static作用？</h3><p>1、属于类 不创建对象就能用这块资源 2、用类直接调用</p>\n<h3 id=\"是否可以在static环境中访问非static变量？\"><a href=\"#是否可以在static环境中访问非static变量？\" class=\"headerlink\" title=\"是否可以在static环境中访问非static变量？\"></a>是否可以在static环境中访问非static变量？</h3><p>不行，那岂不是不用new 对象了？</p>\n<h2 id=\"java静态变量、代码块、和静态方法的执行顺序是什么？\"><a href=\"#java静态变量、代码块、和静态方法的执行顺序是什么？\" class=\"headerlink\" title=\"java静态变量、代码块、和静态方法的执行顺序是什么？\"></a>java静态变量、代码块、和静态方法的执行顺序是什么？</h2><p>代码块执行顺序<strong>静态代码块——&gt; 构造代码块（什么都不加） ——&gt; 构造函数——&gt; 普通代码块（方法后面）</strong></p>\n<p>继承中：父类静态–子类静态–父类构造代码块–父类构造器—子类构造代码块—子类构造器</p>\n<h2 id=\"包装类型\"><a href=\"#包装类型\" class=\"headerlink\" title=\"包装类型\"></a>包装类型</h2><h3 id=\"包装类型是什么？基本类型和包装类型有什么区别？\"><a href=\"#包装类型是什么？基本类型和包装类型有什么区别？\" class=\"headerlink\" title=\"包装类型是什么？基本类型和包装类型有什么区别？\"></a>包装类型是什么？基本类型和包装类型有什么区别？</h3><p><strong>1、包装类型可以为 null，而基本类型不可以</strong> pojo里面查询结果可以null 如果基本类型为null 直接空指针</p>\n<p><strong>2、包装类型可用于泛型，而基本类型不可以</strong></p>\n<p><strong>3、基本类型比包装类型更高效</strong> 一个存数值 一个存堆的引用 总体包装占空间多</p>\n<h3 id=\"拆箱装箱\"><a href=\"#拆箱装箱\" class=\"headerlink\" title=\"拆箱装箱\"></a>拆箱装箱</h3><p>装箱就是 基本数据类型转换为（对象）<strong>包装器类型</strong>；拆箱 包装器类型（对象）转换为基本数据类型。</p>\n<p>装箱过程：valueOf方法实现的，而拆箱过程： xxxValue方法</p>\n<pre><code class=\"plain\">public` `class` `Main &#123;\n   ``public` `static` `void` `main(String[] args) &#123;\n     \n     ``Integer i1 = ``100``;\n     ``Integer i2 = ``100``;\n     ``Integer i3 = ``200``;\n     ``Integer i4 = ``200``;\n     \n     ``System.out.println(i1==i2);\n     ``System.out.println(i3==i4);\n   ``&#125;\n &#125;\n输出：\n true\n false\n</code></pre>\n<p>通过valueOf方法创建Integer对象的时候，如果数值在[-128,127]之间，便返回指向IntegerCache.cache（理解为提前把数值-128-127的数放到常量池）中已经存在的对象的引用；否则创建一个新的Integer对象。上面的代码中i1和i2的数值为100，因此会直接从cache中取已经存在的对象，所以i1和i2指向的是同一个对象，而i3和i4则是分别指向不同的对象。</p>\n<h3 id=\"谈谈Integer-i-x3D-new-Integer-xxx-和Integer-i-x3D-xxx-这两种方式的区别。\"><a href=\"#谈谈Integer-i-x3D-new-Integer-xxx-和Integer-i-x3D-xxx-这两种方式的区别。\" class=\"headerlink\" title=\"谈谈Integer i &#x3D; new Integer(xxx)和Integer i &#x3D;xxx;这两种方式的区别。\"></a>谈谈Integer i &#x3D; new Integer(xxx)和Integer i &#x3D;xxx;这两种方式的区别。</h3><p>（自动装箱与否、效率、指向对象还是值）</p>\n<p>当然，这个题目属于比较宽泛类型的。但是要点一定要答上，我总结一下主要有以下这两点区别：</p>\n<p>1）第一种方式不会触发自动装箱的过程；而第二种方式会触发；</p>\n<p>2）在执行效率和资源占用上的区别。第二种方式的执行效率和资源占用在一般性情况下要优于第一种情况（注意这并不是绝对的）。</p>\n<p>当 “&#x3D;&#x3D;”运算符的两个操作数都是 包装器类型的引用，则是比较指向的是否是同一个对象，而如果其中有一个操作数是表达式（即包含算术运算）则比较的是数值（即会触发自动拆箱的过程）。另外，对于包装器类型，equals方法并不会进行类型转换。</p>\n<h3 id=\"int-和-Integer-有什么区别\"><a href=\"#int-和-Integer-有什么区别\" class=\"headerlink\" title=\"int 和 Integer 有什么区别?\"></a>int 和 Integer 有什么区别?</h3><ul>\n<li>Integer是int的包装类；int是基本数据类型；</li>\n<li>Integer变量必须<strong>实例化</strong>后才能使用；int变量不需要；</li>\n<li>Integer实际是<strong>对象的引用</strong>，指向此new的Integer对象；int是直接存储数据值 ；</li>\n<li>Integer的<strong>默认值</strong>是null；int的默认值是0。</li>\n</ul>\n<pre><code class=\"plain\">Integer b = new Integer(10000);   (堆)\n \n  Integer c=10000;    （常量池）\n</code></pre>\n<h2 id=\"反射\"><a href=\"#反射\" class=\"headerlink\" title=\"反射\"></a>反射</h2><h3 id=\"反射是什么\"><a href=\"#反射是什么\" class=\"headerlink\" title=\"反射是什么\"></a>反射是什么</h3><p>运行状态时对于一个类可以知道他的所有属性方法，对于任何一个对象，可调用任何方法属性，这种动态获取对象方法并调用的功能叫做反射 </p>\n<h3 id=\"反射有缺点\"><a href=\"#反射有缺点\" class=\"headerlink\" title=\"反射有缺点\"></a>反射有缺点</h3><p>优点：能够在运行时动态获取类的实例，灵活性高；例如加载<a href=\"https://www.wkcto.com/courses/mysql.html\">MySQL</a>的驱动类。</p>\n<p>缺点：性能较低，需要解析字节码，将内存中的对象进行解析。其解决方案是：通过setAccessible(true)关闭JDK的安全检查来提升反射速度；</p>\n<p>多次创建一个类的实例时，有缓存会快很多；ReflflectASM工具类，通过字节码生成的方式加快反射速度。</p>\n<h3 id=\"如何获取反射的Class对象\"><a href=\"#如何获取反射的Class对象\" class=\"headerlink\" title=\"如何获取反射的Class对象\"></a>如何获取反射的Class对象</h3><p>1、Class.forName(“类的路径”)；</p>\n<p>2、类名.class</p>\n<p>3、对象名.getClass()</p>\n<h3 id=\"Java反射API有几类\"><a href=\"#Java反射API有几类\" class=\"headerlink\" title=\"Java反射API有几类\"></a>Java反射API有几类</h3><ul>\n<li>Class 类：类的属性，方法等信息。</li>\n<li>Field 类：用来获取和设置类之中的属性值。</li>\n<li>Method 类：获取类中的方法信息或者执行方法。</li>\n<li>Constructor 类：表示类的构造方法。</li>\n</ul>\n<h3 id=\"反射使用的步骤？\"><a href=\"#反射使用的步骤？\" class=\"headerlink\" title=\"反射使用的步骤？\"></a>反射使用的步骤？</h3><p>获取想要操作的类的Class对象，这是反射的核心，通过Class对象我们可以任意调用类的方法。</p>\n<p>调用 Class 类中的方法，既就是反射的使用阶段。</p>\n<p>使用反射 API 来操作这些信息。</p>\n<p>例如：获取对象实例–获取构造器对象–构造器newInstance获取反射对象–获取方法的Method对象–利用Invoke调用方法（方法.invoke(对象，值)）</p>\n<h3 id=\"为什么引入反射？反射应用\"><a href=\"#为什么引入反射？反射应用\" class=\"headerlink\" title=\"为什么引入反射？反射应用\"></a>为什么引入反射？反射应用</h3><p>原因：</p>\n<ul>\n<li>反射让开发人员可以通过外部类的全路径名创建对象，并使用这些类，实现一些扩展的功能。</li>\n<li>反射让开发人员可以枚举出类的全部成员，包括构造函数、属性、方法。以帮助开发者写出正确的代码。</li>\n<li>测试时可以利用反射 API 访问类的私有成员，以保证测试代码覆盖率。</li>\n</ul>\n<p>也就是说，Oracle 希望开发者将反射作为一个工具，用来帮助程序员实现本不可能实现的功能。</p>\n<p>应用：</p>\n<p>第一种：<strong>JDBC 的数据库的连接</strong></p>\n<ol>\n<li>通过Class.forName()加载数据库的驱动程序(（通过反射加载，前提是引入相关了Jar包）) ；</li>\n<li>通过 DriverManager 类进行数据库的连接（输入数据库的连接地址、用户名、密码）</li>\n<li>通过Connection 接口接收连接。</li>\n</ol>\n<p>第二种：<strong>Spring 框架的使用，最经典的就是xml的配置模式</strong>。</p>\n<p>Spring 通过 XML 配置模式装载 Bean 的过程：</p>\n<ol>\n<li>将程序内所有 XML 或 Properties 配置文件加载入内存中；</li>\n<li>Java类里面解析xml或properties里面的内容，得到对应实体类的字节码字符串以及相关的属性信息；</li>\n<li>使用反射机制，根据这个字符串获得某个类的Class实例；</li>\n<li>动态配置实例的属性。</li>\n</ol>\n<p>我的理解:</p>\n<ol>\n<li>读取xml properties文件</li>\n<li>遍历Bean 获取其id(key)和class名称(反射拿对象)</li>\n<li>对于每个Bean,遍历Property属性:name value,再用反射把这些值set到对象里面,最后把对象放到beanMap里面,key为id,value为对象</li>\n</ol>\n<p>Spring这样做的好处是：</p>\n<ul>\n<li>不用每一次都要在代码里面去new或者做其他的事情；</li>\n<li>以后要改的话直接改配置文件，代码维护起来就很方便了；</li>\n<li>有时为了适应某些需求，Java类里面不一定能直接调用另外的方法，可以通过反射机制来实现。</li>\n</ul>\n<h3 id=\"反射机制的原理是什么？\"><a href=\"#反射机制的原理是什么？\" class=\"headerlink\" title=\"反射机制的原理是什么？\"></a>反射机制的原理是什么？</h3><ol>\n<li>反射获取类实例 Class.forName()，并没有将实现留给了java,而是交给了jvm去加载！主要是先获取 ClassLoader, 然后调用 native 方法，获取信息，加载类则是回调 java.lang.ClassLoader。最后，jvm又会回调 ClassLoader 进类加载！</li>\n<li>newInstance() 主要做了三件事：</li>\n</ol>\n<ul>\n<li><ul>\n<li>权限检测，如果不通过直接抛出异常；</li>\n<li>查找无参构造器，并将其缓存起来；</li>\n<li>调用具体方法的无参构造方法，生成实例并返回。</li>\n</ul>\n</li>\n</ul>\n<ol>\n<li>获取Method对象</li>\n</ol>\n<p>上面的Class对象是在加载类时由JVM构造的，JVM为每个类管理一个独一无二的Class对象，<strong>这份Class对象里维护着该类的所有Method，Field，Constructor的cache，这份cache也可以被称作根对象</strong>。</p>\n<p>每次getMethod获取到的Method对象都持有对根对象的<strong>引用</strong>，因为一些重量级的Method的成员变量（主要是MethodAccessor），我们不希望每次创建Method对象都要重新初始化，于是所有代表同一个方法的Method对象都共享着根对象的MethodAccessor，每一次创建都会调用根对象的copy方法复制一份：</p>\n<p>4.调用invoke()方法。调用invoke方法的流程如下：</p>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2023/png/226907/1684743861424-6e23e9b9-9d7a-4a84-93ed-c2eb7085c2e8.png\" alt=\"img\"></p>\n<p>调用Method.invoke之后，会直接去调MethodAccessor.invoke。MethodAccessor就是上面提到的所有同名method共享的一个实例，由ReflectionFactory创建。</p>\n<p>创建机制采用了一种名为inflation的方式（JDK1.4之后）：如果该方法的累计调用次数&lt;&#x3D;15，会创建出NativeMethodAccessorImpl，它的实现就是直接调用native方法实现反射；如果该方法的累计调用次数&gt;15，会由java代码创建出字节码组装而成的MethodAccessorImpl。（是否采用inflation和15这个数字都可以在jvm参数中调整） 以调用MyClass.myMethod(String s)为例，生成出的MethodAccessorImpl字节码翻译成Java代码大致如下：</p>\n<h2 id=\"泛型\"><a href=\"#泛型\" class=\"headerlink\" title=\"泛型\"></a>泛型</h2><h3 id=\"Java中的泛型是什么\"><a href=\"#Java中的泛型是什么\" class=\"headerlink\" title=\"Java中的泛型是什么 ?\"></a>Java中的泛型是什么 ?</h3><p>泛型是 JDK1.5 的一个新特性，<strong>泛型就是将类型参数化，<strong><strong>其在编译时才确定具体的参数</strong></strong>。</strong>这种参数类型可以用在类、接口和方法的创建中，分别称为泛型类、泛型接口、泛型方法。</p>\n<h3 id=\"使用泛型的好处是什么\"><a href=\"#使用泛型的好处是什么\" class=\"headerlink\" title=\"使用泛型的好处是什么?\"></a>使用泛型的好处是什么?</h3><p>远在 JDK 1.4 版本的时候，那时候是没有泛型的概念的，如果使用 Object 来实现通用、不同类型的处理，有这么两个缺点：</p>\n<ol>\n<li>每次使用时都需要强制转换成想要的类型</li>\n<li>在编译时编译器并不知道类型转换是否正常，运行时才知道，不安全。</li>\n</ol>\n<p>如这个例子：</p>\n<pre><code class=\"plain\">List list = new ArrayList();\n list.add(&quot;www.cnblogs.com&quot;);\n list.add(23);\n String name = (String)list.get(0);\n String number = (String)list.get(1);    //ClassCastException\n</code></pre>\n<p>上面的代码在运行时会发生强制类型转换异常。这是因为我们在存入的时候，第二个是一个 Integer 类型，但是取出来的时候却将其强制转换为 String 类型了。Sun 公司为了使 Java 语言更加安全，减少运行时异常的发生。于是在 JDK 1.5 之后推出了泛型的概念。</p>\n<p>根据《Java 编程思想》中的描述，泛型出现的动机在于：有许多原因促成了泛型的出现，而最引人注意的一个原因，就是<strong>为了创建容器类</strong>。</p>\n<p><strong>使用泛型的好处有以下几点</strong>：</p>\n<ol>\n<li>类型安全</li>\n</ol>\n<ul>\n<li><ul>\n<li>泛型的主要目标是提高 Java 程序的类型安全</li>\n<li>编译时期就可以检查出因 Java 类型不正确导致的 ClassCastException 异常</li>\n<li>符合越早出错代价越小原则</li>\n</ul>\n</li>\n</ul>\n<ol>\n<li>消除强制类型转换</li>\n</ol>\n<ul>\n<li><ul>\n<li>泛型的一个附带好处是，使用时直接得到目标类型，消除许多强制类型转换</li>\n<li>所得即所需，这使得代码更加可读，并且减少了出错机会</li>\n</ul>\n</li>\n</ul>\n<ol>\n<li>潜在的性能收益</li>\n</ol>\n<ul>\n<li><ul>\n<li>由于泛型的实现方式，支持泛型（几乎）不需要 JVM 或类文件更改</li>\n<li>所有工作都在编译器中完成</li>\n<li>编译器生成的代码跟不使用泛型（和强制类型转换）时所写的代码几乎一致，只是更能确保类型安全而已</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Java泛型的原理是什么-什么是类型擦除\"><a href=\"#Java泛型的原理是什么-什么是类型擦除\" class=\"headerlink\" title=\"Java泛型的原理是什么 ? 什么是类型擦除 ?\"></a>Java泛型的原理是什么 ? 什么是类型擦除 ?</h3><p>泛型是一种语法糖，泛型这种语法糖的基本原理是类型擦除。Java中的泛型基本上都是在编译器这个层次来实现的，也就是说：<strong>泛型只存在于编译阶段，而不存在于运行阶段。</strong>在编译后的 class 文件中，是没有泛型这个概念的。</p>\n<p>类型擦除：使用泛型的时候加上的类型参数，编译器在编译的时候去掉类型参数。</p>\n<p>大部分情况下，泛型类型都会以 Object 进行替换，而有一种情况则不是。那就是使用到了extends和super语法的有界类型，如：</p>\n<pre><code class=\"plain\">public class Caculate&lt;T extends String&gt; &#123;\n     private T num;\n &#125;\n</code></pre>\n<p>这种情况的泛型类型，num 会被替换为 String 而不再是 Object。这是一个类型限定的语法，它限定 T 是 String 或者 String 的子类，也就是你构建 Caculate 实例的时候只能限定 T 为 String 或者 String 的子类，所以无论你限定 T 为什么类型，String 都是父类，不会出现类型不匹配的问题，于是可以使用 String 进行类型擦除。</p>\n<p>实际上编译器会正常的将使用泛型的地方编译并进行类型擦除，然后返回实例。但是除此之外的是，如果构建泛型实例时使用了泛型语法，那么编译器将标记该实例并关注该实例后续所有方法的调用，每次调用前都进行安全检查，非指定类型的方法都不能调用成功。</p>\n<p>实际上编译器不仅关注一个泛型方法的调用，它还会为某些返回值为限定的泛型类型的方法进行强制类型转换，由于类型擦除，返回值为泛型类型的方法都会擦除成 Object 类型，当这些方法被调用后，编译器会额外插入一行 checkcast 指令用于强制类型转换。这一个过程就叫做『泛型翻译』。</p>\n<h3 id=\"什么是泛型中的限定通配符和非限定通配符\"><a href=\"#什么是泛型中的限定通配符和非限定通配符\" class=\"headerlink\" title=\"什么是泛型中的限定通配符和非限定通配符 ?\"></a>什么是泛型中的限定通配符和非限定通配符 ?</h3><p>限定通配符对类型进行了限制。有两种限定通配符，一种是&lt;? extends T&gt;它通过确保类型必须是T的子类来设定类型的上界，另一种是&lt;? super T&gt;它通过确保类型必须是T的父类来设定类型的下界。泛型类型必须用限定内的类型来进行初始化，否则会导致编译错误。</p>\n<p>非限定通配符 <strong>？</strong>,可以用任意类型来替代。如List&lt;?&gt; 的意思是这个集合是一个可以持有任意类型的集合，它可以是List<A>，也可以是List<B>,或者List<C>等等。</C></B></A></p>\n<h3 id=\"List-lt-extends-T-gt-和List-lt-super-T-gt-之间有什么区别\"><a href=\"#List-lt-extends-T-gt-和List-lt-super-T-gt-之间有什么区别\" class=\"headerlink\" title=\"List&lt;? extends T&gt;和List&lt;? super T&gt;之间有什么区别 ?\"></a>List&lt;? extends T&gt;和List&lt;? super T&gt;之间有什么区别 ?</h3><p>这两个List的声明都是限定通配符的例子，List&lt;? extends T&gt;可以接受任何继承自T的类型的List，而List&lt;? super T&gt;可以接受任何T的父类构成的List。例如List&lt;? extends Number&gt;可以接受List<Double>或List<Float>。</Float></Double></p>\n<h3 id=\"可以把List传递给一个接受List参数的方法吗？\"><a href=\"#可以把List传递给一个接受List参数的方法吗？\" class=\"headerlink\" title=\"可以把List传递给一个接受List参数的方法吗？\"></a>可以把List传递给一个接受List参数的方法吗？</h3><p>不可以。真这样做的话会导致编译错误。因为List可以存储任何类型的对象包括String, Integer等等，而这样的话List却只能用来存储String。 </p>\n<pre><code class=\"plain\">List&lt;Object&gt; objectList;\n List&lt;String&gt; stringList;\n objectList = stringList;  //compilation error incompatible types\n</code></pre>\n<h3 id=\"Array中可以用泛型吗\"><a href=\"#Array中可以用泛型吗\" class=\"headerlink\" title=\"Array中可以用泛型吗?\"></a>Array中可以用泛型吗?</h3><p>不可以。这也是为什么 Joshua Bloch 在 《Effective Java》一书中建议使用 List 来代替 Array，因为 List 可以提供编译期的类型安全保证，而 Array 却不能。</p>\n<h3 id=\"判断ArrayList与ArrayList是否相等？\"><a href=\"#判断ArrayList与ArrayList是否相等？\" class=\"headerlink\" title=\"判断ArrayList与ArrayList是否相等？\"></a>判断ArrayList<String>与ArrayList<Integer>是否相等？</Integer></String></h3><pre><code class=\"plain\">ArrayList&lt;String&gt; a = new ArrayList&lt;String&gt;();\n ArrayList&lt;Integer&gt; b = new ArrayList&lt;Integer&gt;();\n Class c1 = a.getClass();\n Class c2 = b.getClass();\n System.out.println(c1 == c2);\n</code></pre>\n<p>输出的结果是 true。因为无论对于 ArrayList<String>还是 ArrayList<Integer>，它们的 Class 类型都是一致的，都是 ArrayList.class。</Integer></String></p>\n<p>那它们声明时指定的 String 和 Integer 到底体现在哪里呢？</p>\n<p><strong>答案是体现在类编译的时候。</strong>当 JVM 进行类编译时，会进行泛型检查，如果一个集合被声明为 String 类型，那么它往该集合存取数据的时候就会对数据进行判断，从而避免存入或取出错误的数据。</p>\n<h2 id=\"序列化\"><a href=\"#序列化\" class=\"headerlink\" title=\"序列化\"></a>序列化</h2><h3 id=\"Java序列化与反序列化是什么？\"><a href=\"#Java序列化与反序列化是什么？\" class=\"headerlink\" title=\"Java序列化与反序列化是什么？\"></a>Java序列化与反序列化是什么？</h3><p>Java序列化是指把Java对象转换为字节序列的过程，而Java反序列化是指把字节序列恢复为Java对象的过程：</p>\n<ul>\n<li><strong>序列化：</strong>序列化是把对象转换成有序字节流，以便在网络上传输或者保存在本地文件中。核心作用是<strong>对象状态的保存与重建</strong>。我们都知道，Java对象是保存在JVM的堆内存中的，也就是说，如果JVM堆不存在了，那么对象也就跟着消失了。而序列化提供了一种方案，可以让你在即使JVM停机的情况下也能把对象保存下来的方案。就像我们平时用的U盘一样。把Java对象序列化成可存储或传输的形式（如二进制流），比如保存在文件中。这样，当再次需要这个对象的时候，从文件中读取出二进制流，再从二进制流中反序列化出对象。</li>\n<li><strong>反序列化：</strong>客户端从文件中或网络上获得序列化后的对象字节流，根据字节流中所保存的对象状态及描述信息，通过反序列化重建对象。</li>\n</ul>\n<h3 id=\"为什么需要序列化与反序列化？\"><a href=\"#为什么需要序列化与反序列化？\" class=\"headerlink\" title=\"为什么需要序列化与反序列化？\"></a>为什么需要序列化与反序列化？</h3><p>简要描述：<strong>对内存中的对象进行持久化或网络传输, 这个时候都需要序列化和反序列化</strong></p>\n<p>深入描述：</p>\n<ol>\n<li>（分布式调用远程主机）<strong>对象序列化可以实现分布式对象。</strong></li>\n</ol>\n<p>主要应用例如：RMI(即远程调用Remote Method Invocation)要利用对象序列化运行远程主机上的服务，就像在本地机上运行对象时一样。</p>\n<ol>\n<li>（递归存对象序列）<strong>java对象序列化不仅保留一个对象的数据，而且递归保存对象引用的每个对象的数据。</strong></li>\n</ol>\n<p>可以将整个对象层次写入字节流中，可以保存在文件中或在网络连接上传递。利用对象序列化可以进行对象的”深复制”，即复制对象本身及引用的对象本身。序列化一个对象可能得到整个对象序列。</p>\n<ol>\n<li>（固化）<strong>序列化可以将内存中的类写入文件或数据库中。</strong></li>\n</ol>\n<p>比如：将某个类序列化后存为文件，下次读取时只需将文件中的数据反序列化就可以将原先的类还原到内存中。也可以将类序列化为流数据进行传输。</p>\n<p>总的来说就是将一个已经实例化的类转成文件存储，下次需要实例化的时候只要反序列化即可将类实例化到内存中并保留序列化时类中的所有变量和状态。</p>\n<ol>\n<li>（统一存储）<strong>对象、文件、数据，有许多不同的格式，很难统一传输和保存。</strong></li>\n</ol>\n<p>序列化以后就都是字节流了，无论原来是什么东西，都能变成一样的东西，就可以进行通用的格式传输或保存，传输结束以后，要再次使用，就进行反序列化还原，这样对象还是对象，文件还是文件。</p>\n<h3 id=\"序列化实现的方式有哪些？\"><a href=\"#序列化实现的方式有哪些？\" class=\"headerlink\" title=\"序列化实现的方式有哪些？\"></a>序列化实现的方式有哪些？</h3><p>实现<strong>Serializable</strong>接口或者<strong>Externalizable</strong>接口。</p>\n<h4 id=\"Serializable接口\"><a href=\"#Serializable接口\" class=\"headerlink\" title=\"Serializable接口\"></a><strong>Serializable</strong>接口</h4><p><strong>类通过实现</strong> <strong>java.io.Serializable</strong> <strong>接口以启用其序列化功能</strong>。可序列化类的所有子类型本身都是可序列化的。<strong>序列化接口没有方法或字段，仅用于标识可序列化的语义。</strong></p>\n<h4 id=\"Externalizable接口\"><a href=\"#Externalizable接口\" class=\"headerlink\" title=\"Externalizable接口\"></a><strong>Externalizable</strong>接口</h4><p>Externalizable继承自Serializable，该接口中定义了两个抽象方法：writeExternal()与readExternal()。</p>\n<p>当使用Externalizable接口来进行序列化与反序列化的时候需要开发人员重写writeExternal()与readExternal()方法。否则所有变量的值都会变成默认值。</p>\n<h4 id=\"两种序列化的对比\"><a href=\"#两种序列化的对比\" class=\"headerlink\" title=\"两种序列化的对比\"></a>两种序列化的对比</h4><table>\n<thead>\n<tr>\n<th><strong>实现Serializable接口</strong></th>\n<th><strong>实现Externalizable接口</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>系统自动存储必要的信息</td>\n<td>程序员决定存储哪些信息</td>\n</tr>\n<tr>\n<td>Java内建支持，易于实现，只需要实现该接口即可，无需任何代码支持</td>\n<td>必须实现接口内的两个方法</td>\n</tr>\n<tr>\n<td>性能略差</td>\n<td>性能略好</td>\n</tr>\n</tbody></table>\n<h3 id=\"什么是serialVersionUID？\"><a href=\"#什么是serialVersionUID？\" class=\"headerlink\" title=\"什么是serialVersionUID？\"></a>什么是serialVersionUID？</h3><p>serialVersionUID 用来表明类的不同版本间的兼容性</p>\n<p>Java的序列化机制是通过在运行时判断类的serialVersionUID来验证版本一致性的。在进行反序列化时，JVM会把传来的字节流中的serialVersionUID与本地相应实体（类）的serialVersionUID进行比较，如果相同就认为是一致的，可以进行反序列化，否则就会出现序列化版本不一致的异常。</p>\n<h3 id=\"为什么还要显示指定serialVersionUID的值\"><a href=\"#为什么还要显示指定serialVersionUID的值\" class=\"headerlink\" title=\"为什么还要显示指定serialVersionUID的值?\"></a>为什么还要显示指定serialVersionUID的值?</h3><p>如果不显示指定serialVersionUID, JVM在序列化时会根据属性自动生成一个serialVersionUID, 然后与属性一起序列化, 再进行持久化或网络传输. 在反序列化时, JVM会再根据属性自动生成一个新版serialVersionUID, 然后将这个新版serialVersionUID与序列化时生成的旧版serialVersionUID进行比较, 如果相同则反序列化成功, 否则报错.</p>\n<p>如果显示指定了, JVM在序列化和反序列化时仍然都会生成一个serialVersionUID, 但值为我们显示指定的值, 这样在反序列化时新旧版本的serialVersionUID就一致了.</p>\n<p>在实际开发中, 不显示指定serialVersionUID的情况会导致什么问题? 如果我们的类写完后不再修改, 那当然不会有问题, 但这在实际开发中是不可能的, 我们的类会不断迭代, 一旦类被修改了, 那旧对象反序列化就会报错. 所以在实际开发中, 我们都会显示指定一个serialVersionUID, 值是多少无所谓, 只要不变就行。</p>\n<h3 id=\"serialVersionUID什么时候修改？\"><a href=\"#serialVersionUID什么时候修改？\" class=\"headerlink\" title=\"serialVersionUID什么时候修改？\"></a>serialVersionUID什么时候修改？</h3><p>《阿里巴巴Java开发手册》中有以下规定：</p>\n<h3 id=\"Java-序列化中如果有些字段不想进行序列化，怎么办？\"><a href=\"#Java-序列化中如果有些字段不想进行序列化，怎么办？\" class=\"headerlink\" title=\"Java 序列化中如果有些字段不想进行序列化，怎么办？\"></a>Java 序列化中如果有些字段不想进行序列化，怎么办？</h3><p>对于不想进行序列化的变量，使用 transient 关键字修饰。</p>\n<p>transient 关键字的作用是控制变量的序列化，在变量声明前加上该关键字，可以阻止该变量被序列化到文件中，在被反序列化后，transient 变量的值被设为初始值，如 int 型的是 0，对象型的是 null。transient 只能修饰<strong>变量</strong>，不能修饰类和方法。</p>\n<h3 id=\"静态变量会被序列化吗\"><a href=\"#静态变量会被序列化吗\" class=\"headerlink\" title=\"静态变量会被序列化吗?\"></a>静态变量会被序列化吗?</h3><p>不会。因为<strong>序列化是针对对象而言的, 而静态变量优先于对象存在</strong>, 随着类的加载而加载, 所以不会被序列化.</p>\n<p>看到这个结论, 是不是有人会问, serialVersionUID也被static修饰, 为什么serialVersionUID会被序列化? 其实serialVersionUID属性并没有被序列化, JVM在序列化对象时会自动生成一个serialVersionUID, 然后将我们显示指定的serialVersionUID属性值赋给自动生成的serialVersionUID。</p>\n<h2 id=\"异常\"><a href=\"#异常\" class=\"headerlink\" title=\"异常\"></a>异常</h2><h3 id=\"Error-和-Exception-区别是什么？\"><a href=\"#Error-和-Exception-区别是什么？\" class=\"headerlink\" title=\"Error 和 Exception 区别是什么？\"></a>Error 和 Exception 区别是什么？</h3><p>Java 中，所有的异常都有一个共同的祖先 java.lang 包中的 Throwable 类。Throwable 类有两个重要的子类 Exception（异常）和 Error（错误）。</p>\n<p>Exception 和 Error 二者都是 Java 异常处理的重要子类，各自都包含大量子类。</p>\n<ul>\n<li><strong>Exception</strong> :程序本身可以处理的异常，可以通过 catch 来进行捕获，通常遇到这种错误，应对其进行处理，使应用程序可以继续正常运行。Exception 又可以分为<strong>运行时异常</strong>(RuntimeException, 又叫非受检查异常)和<strong>非运行时异常</strong>(又叫受检查异常) 。</li>\n<li><strong>Error</strong> ：Error 属于程序无法处理的错误 ，我们没办法通过 catch 来进行捕获 。例如，<strong>系统崩溃，内存不足，堆栈溢出</strong>等，编译器不会对这类错误进行检测，一旦这类错误发生，通常应用程序会被终止，仅靠应用程序本身无法恢复。</li>\n</ul>\n<h3 id=\"非受检查异常-运行时异常-和受检查异常-一般异常-区别是什么？\"><a href=\"#非受检查异常-运行时异常-和受检查异常-一般异常-区别是什么？\" class=\"headerlink\" title=\"非受检查异常(运行时异常)和受检查异常(一般异常)区别是什么？\"></a>非受检查异常(运行时异常)和受检查异常(一般异常)区别是什么？</h3><p>非受检查异常：包括 RuntimeException 类及其子类，<strong>表示 JVM 在运行期间可能出现的异常</strong>。 Java 编译器不会检查运行时异常。例如：NullPointException(空指针)、NumberFormatException（字符串转换为数字）、IndexOutOfBoundsException(数组越界)、ClassCastException(类转换异常)、ArrayStoreException(数据存储异常，操作数组时类型不一致)等。</p>\n<p>受检查异常：是Exception 中除 RuntimeException 及其子类之外的异常。 Java 编译器会检查受检查异常。常见的受检查异常有： IO 相关的异常、ClassNotFoundException 、SQLException等。</p>\n<p><strong>非受检查异常和受检查异常之间的区别</strong>：是否强制要求调用者必须处理此异常，如果强制要求调用者必须进行处理，那么就使用受检查异常，否则就选择非受检查异常。</p>\n<h3 id=\"throw-和-throws-的区别是什么？\"><a href=\"#throw-和-throws-的区别是什么？\" class=\"headerlink\" title=\"throw 和 throws 的区别是什么？\"></a>throw 和 throws 的区别是什么？</h3><p>Java 中的异常处理除了包括捕获异常和处理异常之外，还包括声明异常和拋出异常，可以通过 throws 关键字在方法上声明该方法要拋出的异常，或者在方法内部通过 throw 拋出异常对象。（方法上+方法内部）</p>\n<p>throws 关键字和 throw 关键字在使用上的几点区别如下：</p>\n<ul>\n<li>throw 关键字用在方法内部，只能用于<strong>抛出一种异常</strong>，用来抛出方法或代码块中的异常，受查异常和非受查异常都可以被抛出。</li>\n<li>throws 关键字用在方法声明上，可以<strong>抛出多个异常</strong>，用来标识该方法可能抛出的异常列表。一个方法用 throws 标识了可能抛出的异常列表，调用该方法的方法中必须包含可处理异常的代码，否则也要在方法签名中用 throws 关键字声明相应的异常。</li>\n</ul>\n<h3 id=\"NoClassDefFoundError-和-ClassNotFoundException-区别？\"><a href=\"#NoClassDefFoundError-和-ClassNotFoundException-区别？\" class=\"headerlink\" title=\"NoClassDefFoundError 和 ClassNotFoundException 区别？\"></a>NoClassDefFoundError 和 ClassNotFoundException 区别？</h3><p>NoClassDefFoundError 是一个 Error 类型的异常，是由 JVM 引起的，不应该尝试捕获这个异常。引起该异常的原因是 JVM 或 ClassLoader 尝试加载某类时在内存中找不到该类的定义，该动作发生在运行期间，即编译时该类存在，但是在运行时却找不到了，可能是编译后被删除了等原因导致。</p>\n<p>ClassNotFoundException 是一个受检查异常，需要显式地使用 try-catch 对其进行捕获和处理，或在方法签名中用 throws 关键字进行声明。当使用 Class.forName, ClassLoader.loadClass 或 ClassLoader.findSystemClass 动态加载类到内存的时候，通过传入的类路径参数没有找到该类，就会抛出该异常；另一种抛出该异常的可能原因是某个类已经由一个类加载器加载至内存中，另一个加载器又尝试去加载它。</p>\n<h3 id=\"Java常见异常有哪些？\"><a href=\"#Java常见异常有哪些？\" class=\"headerlink\" title=\"Java常见异常有哪些？\"></a>Java常见异常有哪些？</h3><ul>\n<li>java.lang.IllegalAccessError：违法访问错误。当一个应用试图访问、修改某个类的域（Field）或者调用其方法，但是又违反域或方法的可见性声明，则抛出该异常。</li>\n<li>java.lang.InstantiationError：实例化错误。当一个应用试图通过Java的new操作符构造一个抽象类或者接口时抛出该异常.</li>\n<li>java.lang.OutOfMemoryError：内存不足错误。当可用内存不足以让Java虚拟机分配给一个对象时抛出该错误。</li>\n<li>java.lang.StackOverflowError：堆栈溢出错误。当一个应用递归调用的层次太深而导致堆栈溢出或者陷入死循环时抛出该错误。</li>\n<li></li>\n</ul>\n<hr>\n<ul>\n<li>java.lang.ClassCastException：类造型异常。假设有类A和B（A不是B的父类或子类），O是A的实例，那么当强制将O构造为类B的实例时抛出该异常。该异常经常被称为<strong>强制类型转换异常。</strong></li>\n<li>java.lang.ClassNotFoundException：找不到类异常。当应用试图根据字符串形式的类名构造类，而在遍历CLASSPAH之后找不到对应名称的class文件时，抛出该异常。</li>\n<li>java.lang.ArithmeticException：算术条件异常。譬如：整数除零等。</li>\n<li>java.lang.ArrayIndexOutOfBoundsException：数组索引越界异常。当对数组的索引值为负数或大于等于数组大小时抛出。</li>\n<li>java.lang.IndexOutOfBoundsException：索引越界异常。当访问某个序列的索引值小于0或大于等于序列大小时，抛出该异常。</li>\n<li>java.lang.InstantiationException：实例化异常。当试图通过newInstance()方法创建某个类的实例，而该类是一个抽象类或接口时，抛出该异常。</li>\n<li>java.lang.NoSuchFieldException：属性不存在异常。当访问某个类的不存在的属性时抛出该异常。</li>\n<li>java.lang.NoSuchMethodException：方法不存在异常。当访问某个类的不存在的方法时抛出该异常。</li>\n<li>java.lang.NullPointerException：空指针异常。当应用试图在要求使用对象的地方使用了null时，抛出该异常。譬如：调用null对象的实例方法、访问null对象的属性、计算null对象的长度、使用throw语句抛出null等等。</li>\n<li>java.lang.NumberFormatException：数字格式异常。当试图将一个String转换为指定的数字类型，而该字符串确不满足数字类型要求的格式时，抛出该异常。</li>\n<li>java.lang.StringIndexOutOfBoundsException：字符串索引越界异常。当使用索引值访问某个字符串中的字符，而该索引值小于0或大于等于序列大小时，抛出该异常。</li>\n</ul>\n<h3 id=\"try-catch-finally-中哪个部分可以省略？\"><a href=\"#try-catch-finally-中哪个部分可以省略？\" class=\"headerlink\" title=\"try-catch-finally 中哪个部分可以省略？\"></a>try-catch-finally 中哪个部分可以省略？</h3><p>catch 可以省略。更为严格的说法其实是：try只适合处理运行时异常，try+catch适合处理运行时异常+普通异常。也就是说，如果你只用try去处理普通异常却不加以catch处理，编译是通不过的，因为编译器硬性规定，<strong>普通异常如果选择捕获，则必须用catch显示声明以便进一步处理</strong>。而运行时异常在编译时没有如此规定，所以catch可以省略，你加上catch编译器也觉得无可厚非。（运行时异常不加catch 普通异常必须加）</p>\n<p>理论上，编译器看任何代码都不顺眼，都觉得可能有潜在的问题，所以你即使对所有代码加上try，代码在运行期时也只不过是在正常运行的基础上加一层皮。但是你一旦对一段代码加上try，就<strong>等于显示地承诺编译器，对这段代码可能抛出的异常进行捕获而非向上抛出处理</strong>。如果是普通异常，编译器要求必须用catch捕获以便进一步处理；如果运行时异常，<strong>捕获然后丢弃并且+finally扫尾处理</strong>，或者加上catch捕获以便进一步处理。</p>\n<p><strong>至于加上finally，则是在不管有没捕获异常，都要进行的“扫尾”处理。</strong></p>\n<h3 id=\"try-catch-finally-中，如果-catch-中-return-了，finally-还会执行吗？\"><a href=\"#try-catch-finally-中，如果-catch-中-return-了，finally-还会执行吗？\" class=\"headerlink\" title=\"try-catch-finally 中，如果 catch 中 return 了，finally 还会执行吗？\"></a>try-catch-finally 中，如果 catch 中 return 了，finally 还会执行吗？</h3><p>会执行，在 return 前执行。catch有return的话，先finally再catch里面return 但如果finally里面有return catch不会执行</p>\n<p>在 finally 中改变返回值的做法是不好的，因为如果存在 finally 代码块，try中的 return 语句不会立马返回调用者，而是记录下返回值待 finally 代码块执行完毕之后再向调用者返回其值，然后如果在 finally 中修改了返回值，就会返回修改后的值。显然，在 finally 中返回或者修改返回值会对程序造成很大的困扰，Java 中也可以通过提升编译器的语法检查级别来产生警告或错误。</p>\n<pre><code class=\"plain\">//例1：\n public static int getInt() &#123;\n     int a = 10;\n     try &#123;\n         System.out.println(a / 0);\n         a = 20;\n     &#125; catch (ArithmeticException e) &#123;\n         a = 30;\n         return a;\n         /*\n          * return a 在程序执行到这一步的时候，这里不是return a 而是 return 30；这个返回路径就形成了\n          * 但是呢，它发现后面还有finally，所以继续执行finally的内容，a=40\n          * 再次回到以前的路径,继续走return 30，形成返回路径之后，这里的a就不是a变量了，而是常量30\n          */\n     &#125; finally &#123;\n         a = 40;\n     &#125;\n     return a;\n &#125;\n \n //执行结果：30\n //例2\n public static int getInt() &#123;\n     int a = 10;\n     try &#123;\n         System.out.println(a / 0);\n         a = 20;\n     &#125; catch (ArithmeticException e) &#123;\n         a = 30;\n         return a;\n     &#125; finally &#123;\n         a = 40;\n         //如果这样，就又重新形成了一条返回路径，由于只能通过1个return返回，所以这里直接返回40\n         return a; \n     &#125;\n \n &#125;\n \n // 执行结果：40\n</code></pre>\n<h3 id=\"JVM-是如何处理异常的？\"><a href=\"#JVM-是如何处理异常的？\" class=\"headerlink\" title=\"JVM 是如何处理异常的？\"></a>JVM 是如何处理异常的？</h3><p>在一个方法中如果发生异常，这个方法会创建一个异常对象，并转交给 JVM，该异常对象包含<strong>异常名称，异常描述以及异常发生时应用程序的状态</strong>。创建异常对象并转交给 JVM 的过程称为<strong>抛出异常</strong>。可能有一系列的方法调用，最终才进入抛出异常的方法，这一系列方法调用的有序列表叫做<strong>调用栈</strong>。</p>\n<p>JVM 会顺着调用栈去查找看是否有可以处理异常的代码，如果有，则调用异常处理代码。当 JVM 发现可以处理异常的代码时，会把发生的异常传递给它。如果 JVM 没有找到可以处理该异常的代码块，JVM 就会将该异常转交给默认的异常处理器（默认处理器为 JVM 的一部分），默认异常处理器打印出异常信息并终止应用程序。 想要深入了解的小伙伴可以看这篇文章：<a href=\"https://www.cnblogs.com/qdhxhz/p/10765839.html\">https://www.cnblogs.com/qdhxhz/p/10765839.html</a></p>\n<h2 id=\"IO\"><a href=\"#IO\" class=\"headerlink\" title=\"IO\"></a>IO</h2><h3 id=\"Java的IO-流分为几种？\"><a href=\"#Java的IO-流分为几种？\" class=\"headerlink\" title=\"Java的IO 流分为几种？\"></a>Java的IO 流分为几种？</h3><ul>\n<li>按照流的方向：输入流（inputStream）和输出流（outputStream）；</li>\n<li>按照实现功能分：节点流（可以从或向一个特定的地方读写数据，如 FileReader）和处理流（是对一个已存在的流的连接和封装，通过所封装的流的功能调用实现数据读写， BufferedReader）；</li>\n<li>按照处理数据的单位： 字节流和字符流。分别由四个抽象类来表示（每种流包括输入和输出两种所以一共四个）:InputStream，OutputStream，Reader，Writer。Java中其他多种多样变化的流均是由它们派生出来的。</li>\n</ul>\n<h3 id=\"字节流如何转为字符流？\"><a href=\"#字节流如何转为字符流？\" class=\"headerlink\" title=\"字节流如何转为字符流？\"></a>字节流如何转为字符流？</h3><p>（适配器）</p>\n<p>字节输入流转字符输入流通过 InputStreamReader 实现，该类的构造函数可以传入 InputStream 对象。</p>\n<p>字节输出流转字符输出流通过 OutputStreamWriter 实现，该类的构造函数可以传入 OutputStream 对象。</p>\n<h3 id=\"BIO、NIO、AIO的区别？\"><a href=\"#BIO、NIO、AIO的区别？\" class=\"headerlink\" title=\"BIO、NIO、AIO的区别？\"></a>BIO、NIO、AIO的区别？</h3><ul>\n<li>BIO：同步并阻塞，在服务器中实现的模式为<strong>一个连接一个线程</strong>。也就是说，客户端有连接请求的时候，服务器就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，当然这也可以通过线程池机制改善。BIO<strong>一般适用于连接数目小且固定的架构</strong>，这种方式对于服务器资源要求比较高，而且并发局限于应用中，是JDK1.4之前的唯一选择，但好在程序直观简单，易理解。</li>\n<li>NIO：同步并非阻塞，在服务器中实现的模式为<strong>一个请求一个线程</strong>，也就是说，客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到有连接IO请求时才会启动一个线程进行处理。<strong>NIO一般适用于连接数目多且连接比较短（轻操作）的架构</strong>，并发局限于应用中，编程比较复杂，从JDK1.4开始支持。</li>\n<li>AIO：异步并非阻塞，在服务器中实现的模式为<strong>一个有效请求一个线程</strong>，也就是说，客户端的IO请求都是通过操作系统先完成之后，再通知服务器应用去启动线程进行处理。AIO一般适用于连接数目多且连接比较长（重操作）的架构，充分调用操作系统参与并发操作，编程比较复杂，从JDK1.7开始支持。</li>\n</ul>\n<h3 id=\"Java-IO都有哪些设计模式\"><a href=\"#Java-IO都有哪些设计模式\" class=\"headerlink\" title=\"Java IO都有哪些设计模式\"></a>Java IO都有哪些设计模式</h3><p>使用了<strong>适配器模式</strong>和<strong>装饰器模式</strong></p>\n<p><strong>适配器模式</strong>：</p>\n<p> Reader reader &#x3D; new INputStreamReader(inputStream);</p>\n<p><strong>把一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口不匹配而无法在一起工作的两个类能够在一起工作</strong></p>\n<ul>\n<li><strong>类适配器</strong>：Adapter类（适配器）继承Adaptee类（源角色）实现Target接口（目标角色）</li>\n<li><strong>对象适配器</strong>：Adapter类（适配器）持有Adaptee类（源角色）对象实例，实现Target接口（目标角色）</li>\n</ul>\n<p><strong>装饰器模式</strong>：</p>\n<p> new BufferedInputStream(new FileInputStream(inputStream));</p>\n<p><strong>一种动态地往一个类中添加新的行为的设计模式。就功能而言，装饰器模式相比生成子类更为灵活，这样可以给某个对象而不是整个类添加一些功能。</strong></p>\n<ul>\n<li>ConcreteComponent（具体对象）和Decorator（抽象装饰器）实现相同的Conponent（接口）并且Decorator（抽象装饰器）里面持有Conponent（接口）对象，可以传递请求。</li>\n<li>ConcreteComponent（具体装饰器）覆盖Decorator（抽象装饰器）的方法并用super进行调用，传递请求。</li>\n</ul>\n<h2 id=\"在⼀个静态⽅法内调⽤⼀个⾮静态成员为什么是⾮法的\"><a href=\"#在⼀个静态⽅法内调⽤⼀个⾮静态成员为什么是⾮法的\" class=\"headerlink\" title=\"在⼀个静态⽅法内调⽤⼀个⾮静态成员为什么是⾮法的?\"></a>在⼀个静态⽅法内调⽤⼀个⾮静态成员为什么是⾮法的?</h2><p>否则不就类.任何变量了？</p>\n<h2 id=\"Java-中定义⼀个不做事且没有参数的构造⽅法的作⽤\"><a href=\"#Java-中定义⼀个不做事且没有参数的构造⽅法的作⽤\" class=\"headerlink\" title=\"Java 中定义⼀个不做事且没有参数的构造⽅法的作⽤\"></a>Java 中定义⼀个不做事且没有参数的构造⽅法的作⽤</h2><p>⽗类中只定义了有参数的构造⽅法（<strong>一旦父类有了属于自己的非空参数构造方法后，系统将不会再赠送父类没有参数的构造方法</strong>），⽽在⼦类的构造⽅法中⼜没有⽤ super() 来调⽤⽗类中特定的构造⽅法，则编译时将发⽣错误，因为不写super的话 默认子类无参构造 所以父类要手写无参构造</p>\n<h2 id=\"接⼝和抽象类的区别是什么？\"><a href=\"#接⼝和抽象类的区别是什么？\" class=\"headerlink\" title=\"接⼝和抽象类的区别是什么？\"></a>接⼝和抽象类的区别是什么？</h2><p>1 变量 接口只能有public static final修饰变量 抽象类无所谓</p>\n<p>2 实现继承 接口多实现 类单继承</p>\n<p>3 设计层面 一个模板设计 一个行为抽象（接口）</p>\n<p>4 方法 抽象类可以提供成员方法的具体细节 接口只能public abstract方法</p>\n<p>抽象类能用final修饰吗？ 不能 我这样搞就是让别人继承的 你干啥？</p>\n<h2 id=\"Java创建对象方式\"><a href=\"#Java创建对象方式\" class=\"headerlink\" title=\"Java创建对象方式\"></a>Java创建对象方式</h2><p>new 反射 clone 序列化</p>\n<h2 id=\"不可变对象\"><a href=\"#不可变对象\" class=\"headerlink\" title=\"不可变对象\"></a>不可变对象</h2><p>String Integer包装类 好处线程安全</p>\n<p>创建一个包含可变对象的不可变对象? inal Person[] persons &#x3D; new Persion[]{}</p>\n<h2 id=\"成员变量与局部变量的区别有哪些？\"><a href=\"#成员变量与局部变量的区别有哪些？\" class=\"headerlink\" title=\"成员变量与局部变量的区别有哪些？\"></a>成员变量与局部变量的区别有哪些？</h2><p>1、位置不同 成员是类的 局部变量是方法的</p>\n<p>2、成员属于对象 在堆上 局部变量在方法上 栈帧里面</p>\n<p>3、成员会自动以类型默认值赋初始值 （除开final） 局部变量必须显示赋值</p>\n<h2 id=\"若⼀个类没有声明构造⽅法，该程序能正确执⾏吗-（可以）为什么-（默认无参）\"><a href=\"#若⼀个类没有声明构造⽅法，该程序能正确执⾏吗-（可以）为什么-（默认无参）\" class=\"headerlink\" title=\"若⼀个类没有声明构造⽅法，该程序能正确执⾏吗? （可以）为什么?（默认无参）\"></a>若⼀个类没有声明构造⽅法，该程序能正确执⾏吗? （可以）为什么?（默认无参）</h2><h2 id=\"构造⽅法有哪些特性？\"><a href=\"#构造⽅法有哪些特性？\" class=\"headerlink\" title=\"构造⽅法有哪些特性？\"></a>构造⽅法有哪些特性？</h2><p>\\1. 名字与类名相同。\\2. 没有返回值\\3. ⽣成类的对象时⾃动执⾏，⽆需调⽤。 </p>\n<h2 id=\"对象的相等与指向他们的引⽤相等-两者有什么不同\"><a href=\"#对象的相等与指向他们的引⽤相等-两者有什么不同\" class=\"headerlink\" title=\"对象的相等与指向他们的引⽤相等,两者有什么不同?\"></a>对象的相等与指向他们的引⽤相等,两者有什么不同?</h2><p>对象的相等，⽐的是内存中存放的内容是否相等。⽽引⽤相等，⽐较的是他们指向的内存地址是否相等 </p>\n<h2 id=\"x3D-x3D-与-equals-重要\"><a href=\"#x3D-x3D-与-equals-重要\" class=\"headerlink\" title=\"&#x3D;&#x3D; 与 equals(重要)\"></a>&#x3D;&#x3D; 与 equals(重要)</h2><p>&#x3D;&#x3D;： 基本数据类型—内容 引用数据类型– 地址 </p>\n<p>equals： 都是内容</p>\n<p>equal特点：自反 传递 一致 对称</p>\n<p>不重写equals等价于&#x3D;&#x3D;，重写了比较的是内容</p>\n<h3 id=\"hashcode？\"><a href=\"#hashcode？\" class=\"headerlink\" title=\"hashcode？\"></a>hashcode？</h3><p>它实际上是返回一个int整数。对对象地址进行了一个散列，（压缩到某一固定长度的消息摘要的函数）这个哈希码的作用是确定该对象在哈希表中的索引位置</p>\n<p>因此对象相同hashcode必定相同，但hashcode同不一定对象相同</p>\n<h2 id=\"为什么重写-equals-方法必须重写-hashcode-方法-？\"><a href=\"#为什么重写-equals-方法必须重写-hashcode-方法-？\" class=\"headerlink\" title=\"为什么重写 equals 方法必须重写 hashcode 方法 ？\"></a>为什么重写 equals 方法必须重写 hashcode 方法 ？</h2><p>1、只重写equals的话，会造成俩对象hashcode的值不同（不重写hashcode默认返回的是对象的地址，那就不同了），因为是先根据hashcode进行判断，那么本来相同对象（equals相同）是覆盖的，结果都插进去了</p>\n<p>2、减少equals次数（equlas纯判断内容）</p>\n<h2 id=\"为什么-Java-中只有值传递？\"><a href=\"#为什么-Java-中只有值传递？\" class=\"headerlink\" title=\"为什么 Java 中只有值传递？\"></a>为什么 Java 中只有值传递？</h2><p>值传递就是把参数的值给你，调用函数时将实际参数复制一份传递到函数中，这样函数内部对参数内部进行修改不会影响到实际参数；</p>\n<p>而引用传递就不一样了，它直接把参数的实际地址给调用函数了，函数内部可直接修改该地址内容，会影响到实际参数</p>\n<p><strong>为什么？</strong></p>\n<p>基本类型作为参数被传递时肯定是值传递；引用类型作为参数被传递时也是值传递，只不过“值”为对应的引用。</p>\n<p><strong>那我说下值传递的特征</strong></p>\n<p>⼀个⽅法不能修改⼀个基本数据类型的参数（即数值型或布尔型）。（只是copy不影响原值）⼀个⽅法可以改变⼀个对象参数的状态。（引用可改变值）⼀个⽅法不能让对象参数引⽤⼀个新的对象。 （引用一旦传递，不可交换）</p>\n<h2 id=\"关于-final-关键字的⼀些总结\"><a href=\"#关于-final-关键字的⼀些总结\" class=\"headerlink\" title=\"关于 final 关键字的⼀些总结\"></a>关于 final 关键字的⼀些总结</h2><p>变量（数值引用不能改）、⽅法（锁定 不能改含义 效率高）、类（不能继承 成员方法均final）。 </p>\n<h2 id=\"Java-中的异常处理\"><a href=\"#Java-中的异常处理\" class=\"headerlink\" title=\"Java 中的异常处理\"></a>Java 中的异常处理</h2><p>Throwable:</p>\n<p>编译时异常：找不到类 ioexception</p>\n<p>try捕获 catch处理 finally最终 （return之前） </p>\n<p>如果finally和try都有return 以finally为主</p>\n<p><strong>在以下 3 种特殊情况下， finally 块不会被执⾏：</strong>在 try 或 finally 块中⽤了 System.exit(int) 退出程序。但是，如果 System.exit(int) 在异常语句之后， finally 还是会被执⾏线程死亡。关闭 CPU。 </p>\n<h2 id=\"Java-序列化中如果有些字段不想进⾏序列化，怎么办？\"><a href=\"#Java-序列化中如果有些字段不想进⾏序列化，怎么办？\" class=\"headerlink\" title=\"Java 序列化中如果有些字段不想进⾏序列化，怎么办？\"></a>Java 序列化中如果有些字段不想进⾏序列化，怎么办？</h2><p>对于不想进⾏序列化的变量（只能变量），使⽤ transient（转瞬即逝） 关键字修饰。 </p>\n<h2 id=\"获取⽤键盘输⼊常⽤的两种⽅\"><a href=\"#获取⽤键盘输⼊常⽤的两种⽅\" class=\"headerlink\" title=\"获取⽤键盘输⼊常⽤的两种⽅\"></a>获取⽤键盘输⼊常⽤的两种⽅</h2><p>⽅法 1：通过 Scanner nextLine(); close⽅法 2：通过 BufferedReader readline</p>\n<h2 id=\"Java-中-IO-流分为⼏种\"><a href=\"#Java-中-IO-流分为⼏种\" class=\"headerlink\" title=\"Java 中 IO 流分为⼏种?\"></a>Java 中 IO 流分为⼏种?</h2><p>按照流的流向分，可以分为输⼊流和输出流；按照操作单元划分，可以划分为字节流和字符流；按照流的⻆⾊划分为节点流和处理流。 </p>\n<p>字节：input （outsput）stream</p>\n<p>字符 reader writer</p>\n<h2 id=\"既然有了字节流-为什么还要有字符流\"><a href=\"#既然有了字节流-为什么还要有字符流\" class=\"headerlink\" title=\"既然有了字节流,为什么还要有字符流?\"></a>既然有了字节流,为什么还要有字符流?</h2><p>字符可以用字节转换 但是比较耗时 不如直接来个字符流 </p>\n<p>场景：⾳频⽂件、图⽚等媒体⽂件⽤字节流⽐较好，如果涉及到字符的话使⽤字符流⽐较好。 </p>\n<h2 id=\"BIO-NIO-AIO-有什么区别\"><a href=\"#BIO-NIO-AIO-有什么区别\" class=\"headerlink\" title=\"BIO,NIO,AIO 有什么区别?\"></a>BIO,NIO,AIO 有什么区别?</h2><p>BIO (Blocking I&#x2F;O): 同步阻塞 I&#x2F;O 模式：</p>\n<p>数据读取写入 必须阻塞在一个线程内等待完成 低并发 Socket 和 ServerSocket </p>\n<p>NIO (Non-blocking&#x2F;New I&#x2F;O): NIO 是⼀种同步⾮阻塞的 I&#x2F;O 模型 </p>\n<p><strong>面向缓冲（buffer） 基于通道(channel)的I&#x2F;O操作</strong> 高负载高并发 SocketChannel ServerSocketChannel </p>\n<p>AIO 异步⾮阻塞的 IO 模型 </p>\n<p>不广泛 基于事件和回调</p>\n<h2 id=\"深拷⻉-vs-浅拷⻉\"><a href=\"#深拷⻉-vs-浅拷⻉\" class=\"headerlink\" title=\"深拷⻉ vs 浅拷⻉\"></a>深拷⻉ vs 浅拷⻉</h2><p>浅拷贝：正常 基本数据类型进⾏值传递，对引⽤数据类型进⾏引⽤传递般 </p>\n<p>深拷贝：String 对基本数据类型进⾏值传递，对引⽤数据类型，创建⼀个新的对象，并复制其内容， </p>\n<h2 id=\"Object方法\"><a href=\"#Object方法\" class=\"headerlink\" title=\"Object方法\"></a>Object方法</h2><p>getclass equals hashcode notify wait finalize clone tostring</p>\n<h2 id=\"讲一讲快速失败-fail-fast-和安全失败-fail-safe\"><a href=\"#讲一讲快速失败-fail-fast-和安全失败-fail-safe\" class=\"headerlink\" title=\"讲一讲快速失败(fail-fast)和安全失败(fail-safe)\"></a>讲一讲快速失败(fail-fast)和安全失败(fail-safe)</h2><p><strong>快速失败（fail—fast）</strong></p>\n<ul>\n<li>在用迭代器遍历一个集合对象时，如果遍历过程中对集合对象的内容进行了修改（增加、删除、修改），则会抛出Concurrent Modification Exception。</li>\n<li>原理：迭代器在遍历时使用一个 modCount 变量。集合在被遍历期间如果内容发生变化，就会改变modCount的值。每当迭代器使用hashNext()&#x2F;next()遍历下一个元素之前，都会检测modCount变量是否为expectedmodCount值，是的话就返回遍历；否则抛出异常，终止遍历。</li>\n<li>注意：这里异常的抛出条件是检测到 modCount！&#x3D;expectedmodCount 这个条件。如果集合发生变化时修改modCount值刚好又设置为了expectedmodCount值，则异常不会抛出。因此，不能依赖于这个异常是否抛出而进行并发操作的编程，这个异常只建议用于检测并发修改的bug。</li>\n<li>场景：java.util包下的集合类都是快速失败的，不能在多线程下发生并发修改（迭代过程中被修改），比如HashMap、ArrayList 这些集合类。</li>\n</ul>\n<p><strong>安全失败（fail—safe）</strong></p>\n<ul>\n<li>采用安全失败机制的集合容器，在遍历时不是直接在集合内容上访问的，而是先复制原有集合内容，在拷贝的集合上进行遍历。</li>\n<li>原理：由于迭代时是对原集合的拷贝进行遍历，所以在遍历过程中对原集合所作的修改并不能被迭代器检测到，所以不会触发Concurrent Modification Exception。</li>\n<li>缺点：基于拷贝内容的优点是避免了Concurrent Modification Exception，但同样地，迭代器并不能访问到修改后的内容，即：迭代器遍历的是开始遍历那一刻拿到的集合拷贝，在遍历期间原集合发生的修改迭代器是不知道的。</li>\n<li>场景：java.util.concurrent包下的容器都是安全失败，可以在多线程下并发使用，并发修改，比如：ConcurrentHashMap。</li>\n</ul>\n<h2 id=\"转发-vs-重定向\"><a href=\"#转发-vs-重定向\" class=\"headerlink\" title=\"转发 vs 重定向\"></a>转发 vs 重定向</h2>","categories":["八股"]},{"title":"JAVA_API基础","url":"/2023/06/04/JAVA-API%E5%9F%BA%E7%A1%80/","content":"<h2 id=\"比较器\"><a href=\"#比较器\" class=\"headerlink\" title=\"比较器\"></a>比较器</h2><p>1、Arrays.sort(points, (a, b) -&gt; Integer.compare(a[0], b[0]));&#x2F;&#x2F;表升序<span id=\"more\"></span><br>2、java.lang包的Integer类的compare()方法比较作为参数给出的两个整数值(x，y)，如果(x &#x3D;&#x3D; y)则返回零，如果(x &lt;y)则返回小于零，如果(x&gt; y)，则返回大于零的值。</p>\n<h2 id=\"Switch\"><a href=\"#Switch\" class=\"headerlink\" title=\"Switch\"></a>Switch</h2><p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/image-20230225192923077.png\" alt=\"img\"></p>\n<h2 id=\"Boolean-amp-boolean\"><a href=\"#Boolean-amp-boolean\" class=\"headerlink\" title=\"Boolean &amp;boolean\"></a>Boolean &amp;boolean</h2><p>一个是泛型 一个是普通类型</p>\n<h3 id=\"超大数据\"><a href=\"#超大数据\" class=\"headerlink\" title=\"超大数据\"></a>超大数据</h3><p>BigDecimal b1 &#x3D; new BigDecimal(Double.toString(v1));</p>\n<p>cnblogs.com&#x2F;zhangyinhua&#x2F;p&#x2F;11545305.html</p>\n<h2 id=\"和-的区别\"><a href=\"#和-的区别\" class=\"headerlink\" title=\"|和||的区别\"></a><strong>|和||的区别</strong></h2><p>||会短路</p>\n<h2 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h2><p>int float double : 0</p>\n<p>boolean: false</p>\n<p>String : null</p>\n<p>char : 空格</p>\n<p>List&lt;int[]&gt; 转二维数组</p>\n<p> ans.toArray(new int[ans.size()][]);</p>\n<p>打印二维数组</p>\n<p> System.out.println(Arrays.deepToString(intervals));</p>\n<p>打印一维数组Arrays.toString();</p>\n<p>返回二维数组</p>\n<p> return new int[]{num0,num1};</p>\n<h2 id=\"求长度三剑客\"><a href=\"#求长度三剑客\" class=\"headerlink\" title=\"求长度三剑客\"></a>求长度三剑客</h2><p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/image-20220919155428203.png\" alt=\"img\"></p>\n<h2 id=\"String\"><a href=\"#String\" class=\"headerlink\" title=\"String\"></a>String</h2><p><strong>转Int</strong></p>\n<p>Integer.valueOf()和Integer.parseInt()</p>\n<p>valueOf(String)方法会返回Integer类的对象，而parseInt(String)方法返回原始的int值。</p>\n<p>xx.valueOf(a) 把a转为xx类型； xx.valueOf(a，0，n) 表示把a转为xx类型，同时取下标从0开始的n个数据；</p>\n<p><strong>判断字符串相等</strong></p>\n<p>1、&#x3D;&#x3D; 引用</p>\n<p>2、.equals() 内容 （用这个）</p>\n<h2 id=\"StringBuilder\"><a href=\"#StringBuilder\" class=\"headerlink\" title=\"StringBuilder\"></a>StringBuilder</h2><p>添加：append</p>\n<p>查询 CharAt</p>\n<p>删除 deleteCharAt(index) delete(start,end)</p>\n<h2 id=\"List系列\"><a href=\"#List系列\" class=\"headerlink\" title=\"List系列\"></a>List系列</h2><p><a href=\"https://zhuanlan.zhihu.com/p/181428633\">ArrayList</a></p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/182470738\">LinkedList</a></p>\n<p>add 添加</p>\n<p>remove 删除</p>\n<h2 id=\"Queue系列\"><a href=\"#Queue系列\" class=\"headerlink\" title=\"Queue系列\"></a>Queue系列</h2><ul>\n<li><strong>ArrayDeque</strong>ArrayDeque 是 Java 集合中<strong>双端队列</strong>的<strong>数组实现</strong>，双端队列的链表实现（<strong>LinkedList</strong>）我们在前几篇文章中讲过了。ArrayDeque 几乎没有容量限制，设计为<strong>线程不安全的</strong>，<strong>禁止 null 元素</strong>。ArrayDeque 作为<strong>栈</strong>使用时<strong>比 Stack 类效率要高</strong>，作为<strong>队列</strong>使用时<strong>比 LinkedList 要快</strong>。</li>\n</ul>\n<h3 id=\"ArrayList\"><a href=\"#ArrayList\" class=\"headerlink\" title=\"ArrayList\"></a>ArrayList</h3><p>ArrayList 类是一个可以动态修改的数组，与普通数组的区别就是它是没有固定大小的限制，我们可以添加或删除元素。</p>\n<p><strong>添加元素</strong></p>\n<p>ArrayList 类提供了很多有用的方法，添加元素到 ArrayList 可以使用 add() 方法:</p>\n<p><strong>访问元素</strong></p>\n<p>访问 ArrayList 中的元素可以使用 <strong>get()</strong> 方法</p>\n<p><strong>修改元素</strong></p>\n<p>如果要修改 ArrayList 中的元素可以使用 <strong>set()</strong> 方法：</p>\n<p><strong>删除元素</strong></p>\n<p>如果要删除 ArrayList 中的元素可以使用 <strong>remove()</strong> 方法：</p>\n<p><strong>计算大小</strong></p>\n<p>如果要计算 ArrayList 中的元素数量可以使用 <strong>size()</strong> 方法：</p>\n<p><strong>判断相等</strong></p>\n<p>.equals方法</p>\n<h3 id=\"LinkedList\"><a href=\"#LinkedList\" class=\"headerlink\" title=\"LinkedList\"></a>LinkedList</h3><p>可以把他当作队列 数组 栈来看待，因此不用单独记忆其api</p>\n<p>添加 add</p>\n<p>移除最后元素： removeLast</p>\n<p>获取最后一个元素：getLast</p>\n<p>效果其实和Array</p>\n<h3 id=\"HashSet\"><a href=\"#HashSet\" class=\"headerlink\" title=\"HashSet\"></a>HashSet</h3><p>不允许有重复元素 允许有 null 值 是无序的 不是线程安全的</p>\n<p>同样 add() remove() size() </p>\n<p>contains() 方法来判断元素是否存在于集合当中</p>\n<p>检查数字是否在哈希集合中需要 O(1)的时间，而对于其他数据结构，则需要 O(n 的时间。选择正确的数据结构是解决这些问题的关键部分。</p>\n<h3 id=\"HashMap\"><a href=\"#HashMap\" class=\"headerlink\" title=\"HashMap\"></a>HashMap</h3><p>散列表，存储的内容是键值对(key-value)映射。</p>\n<p>实现了 Map 接口，根据键的 HashCode 值存储数据，具有很快的访问速度，最多允许一条记录的键为 null，不支持线程同步。</p>\n<p>无序的，即不会记录插入的顺序。</p>\n<p><strong>api:</strong></p>\n<p>添加键值对(key-value)可以使用 put() 方法:</p>\n<p>get(key) 方法来获取 key 对应的 value:</p>\n<p>我们可以使用 remove(key) 方法来删除 key 对应的键值对(key-value):</p>\n<p><strong>size()</strong> 方法：</p>\n<p>isEmpty() containKey() containValue() entrySet() keySet() values()</p>\n<p>Map的<strong>entrySet()方法</strong>返回一个实现Map.Entry接口的对象集合。集合中每个对象都是底层Map中一个特定的键&#x2F;值对。通过这个集合的迭代器，获得每一个条目(唯一获取方式)的键或值并对值进行更改。Map.Entry中的常用方法如下所示：</p>\n<p>​\t (1) Object getKey(): 返回条目的关键字</p>\n<p>(2) Object getValue(): 返回条目的值 (3) Object setValue(Object value): 将相关映像中的值改为value，并且返回旧值</p>\n<p>Trie树</p>\n<p>「前缀树」又叫「字典树」或「单词查找树」</p>\n<p>「前缀树」的应用场景：给定一个字符串集合构建一棵前缀树，然后给一个字符串，判断前缀树中是否存在该字符串或者该字符串的前缀</p>\n<p><strong>分析</strong></p>\n<p>一般而言，字符串的集合都是仅由小写字母构成，所以本文章都是基于该情况展开分析！</p>\n<p>字符串集合：[them, zip, team, the, app, that]。这个样例的前缀树长什么样呢？</p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/1657540498-HHnzlV-1.svg\" alt=\"img\"></p>\n<p>由于都是小写字母，所以对于每个节点，均有 26 个孩子节点，上图中没有画出来，省略了而已…，但是要记住：每个节点均有 26 个孩子节点</p>\n<p>还有一个点要明确：节点仅仅表示从根节点到本节点的路径构成的字符串是否有效而已</p>\n<p>对于上图中橙色的节点，均为有效节点，即：从根节点到橙色节点的路径构成的字符串均在集合中</p>\n<pre><code class=\"plain\">如果现在要看目标字符串 te 是否存在，分两步：\n 首先看看表示 te 字符串的路径是否存在，这个例子是存在的\n 其次看看该路径的终点处的节点是否有效，很遗憾，此处为白色，无效\n 所以前缀 te 不存在！！\n</code></pre>\n<p><strong>构建前缀树 插入字符串 查找前缀过程</strong></p>\n<pre><code class=\"plain\">class Trie &#123;\n     //结点定义\n     class TrieNode &#123;\n         boolean val;\n         TrieNode[] children = new TrieNode[26];\n     &#125;\n     //根节点定义\n     private TrieNode root;\n     //根节点初始化\n     public Trie() &#123;\n         root = new TrieNode();\n     &#125;\n \n     public void insert(String word) &#123;\n         TrieNode p = root;\n         for (char c : word.toCharArray()) &#123;\n             int i = c - &#39;a&#39;;\n             if (p.children[i] == null) p.children[i] = new TrieNode();\n             p = p.children[i];\n         &#125;\n         p.val = true;\n     &#125;\n     //查询\n     public boolean search(String word) &#123;\n         TrieNode p = root;\n         for (char c : word.toCharArray()) &#123;\n             int i = c - &#39;a&#39;;\n             if (p.children[i] == null) return false;\n             p = p.children[i];\n         &#125;\n         return p.val;//成功，返回值（看看此处存不存在值）\n     &#125;\n     //查询前缀\n     public boolean startsWith(String prefix) &#123;\n         TrieNode p = root;\n         for (char c : prefix.toCharArray()) &#123;\n             int i = c - &#39;a&#39;;\n             if (p.children[i] == null) return false;\n             p = p.children[i];\n         &#125;\n         return true;//和查询一样的思路，只是返回的是true而已\n     &#125;\n \n &#125;\n//官方解法\n class Trie &#123;\n     private Trie[] children;//定义两个成员变量\n     private boolean isEnd;//\n \n     public Trie() &#123;\n         //两个成员变量\n         children = new Trie[26];\n         isEnd = false;\n     &#125;\n     //构建\n     public void insert(String word) &#123;\n         Trie node = this;\n         for (int i = 0; i &lt; word.length(); i++) &#123;\n             char ch = word.charAt(i);\n             int index = ch - &#39;a&#39;;//转化为数字，从左边往右边a到z\n             if (node.children[index] == null) &#123;\n                 node.children[index] = new Trie();//如果为空的话构建\n             &#125;\n             node = node.children[index];//向下移动\n         &#125;\n         node.isEnd = true;//置为true\n     &#125;\n     \n     public boolean search(String word) &#123;\n         Trie node = searchPrefix(word);\n         return node != null &amp;&amp; node.isEnd;//需要既是非Null，也得是最后一个(isend为true)\n     &#125;\n     \n     public boolean startsWith(String prefix) &#123;\n         return searchPrefix(prefix) != null;//看查到的node结点是否存在就行，因为是前缀，不用管Isend\n     &#125;\n     //查前缀\n     private Trie searchPrefix(String prefix) &#123;\n         Trie node = this;//指向当前对象的指针  可以理解为指向trie的根部节点\n         for (int i = 0; i &lt; prefix.length(); i++) &#123;\n             char ch = prefix.charAt(i);\n             int index = ch - &#39;a&#39;;\n             if (node.children[index] == null) &#123;\n                 return null;//发现其中一个为null就肯定查询失败\n             &#125;\n             node = node.children[index];\n         &#125;\n         return node;//返回最后一个Node，此时还没判断是否为Null,此时路径没问题\n     &#125;\n &#125;\n</code></pre>\n<p>时间复杂度：O(∣S∣)，其中 ∣S∣是每次插入或查询的字符串的长度。</p>\n<p>空间复杂度：O(∣T∣⋅Σ)，其中 ∣T∣为所有插入字符串的长度之和，Σ 为字符集的大小，本题 Σ&#x3D;26</p>\n<p>官方题解的for可以用增强for循环</p>\n<h2 id=\"ACM\"><a href=\"#ACM\" class=\"headerlink\" title=\"ACM\"></a>ACM</h2><p>nextInt()：读取到空格或回车之后结束本次的int值；同理还有nextDouble() 、nextFloat()、nextInt()</p>\n<p> int n&#x3D;sc.nextInt();只获取数字 换行符需要sc.nextLine();拿掉</p>\n<p>第二个字符串排序就不用nextLine了</p>\n<p>next()：直至读取到空格或回车之后结束本次的String值，不可读取回车；nextLine()：直至读取到换行符（回车）之后结束本次读取的String，可读取回车（空值）hasNextInt()：判断控制台接收是否为数字,是则接收 hasNextInt()只起到判断作用而不是接收数据</p>\n<p>导包建议：</p>\n<p> import java.util.*;</p>\n<p><strong>例子：</strong></p>\n<p>输入描述:输入有两行，第一行n</p>\n<p>第二行是n个字符串，字符串之间用空格隔开输出描述:输出一行排序后的字符串，空格隔开，无结尾空格</p>\n<pre><code class=\"plain\">import java.util.*;\n public class Main &#123;\n   public static void main(String[] args) &#123;\n       Scanner sc = new Scanner(System.in);\n       int n=sc.nextInt();\n       String enter=sc.nextLine();//把换车符拿掉\n       String line=sc.nextLine();\n       String[] s=line.split(&quot; &quot;);//转为数组好排序\n       Arrays.sort(s);\n       StringBuilder sb=new StringBuilder();\n       for(String ss:s)&#123;\n           sb.append(ss).append(&quot; &quot;);\n       &#125;\n       String s1 = sb.toString();\n       System.out.println(s1.substring(0,s1.length()-1));\n   &#125;\n &#125;\n</code></pre>\n<h3 id=\"接受输入的字符a\"><a href=\"#接受输入的字符a\" class=\"headerlink\" title=\"接受输入的字符a\"></a>接受输入的字符a</h3><pre><code class=\"plain\">String b = in.next\n if(b.equals(&quot;a&quot;))\n</code></pre>\n<h3 id=\"格式化输出\"><a href=\"#格式化输出\" class=\"headerlink\" title=\"格式化输出\"></a>格式化输出</h3><p>System.out.printf(“%.11f”, ans+sum);&#x2F;&#x2F;.11表示位数</p>\n","categories":["算法"]},{"title":"ACM输入输出说明","url":"/2023/06/01/ACM/","content":"<p>nextInt()：读取到空格或回车之后结束本次的int值；同理还有nextDouble() 、nextFloat()、nextInt()<span id=\"more\"></span></p>\n<p>int n&#x3D;sc.nextInt();只获取数字 换行符需要sc.nextLine();拿掉</p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/image-20230309134906020.png\" alt=\"img\"></p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/image-20230309134916246.png\" alt=\"img\"></p>\n<p>第二个字符串排序就不用nextLine了</p>\n<p>next()：直至读取到空格或回车之后结束本次的String值，不可读取回车；nextLine()：直至读取到换行符（回车）之后结束本次读取的String，可读取回车（空值）hasNextInt()：判断控制台接收是否为数字,是则接收 hasNextInt()只起到判断作用而不是接收数据</p>\n<p>导包建议：</p>\n<p>import java.util.*;</p>\n<p><strong>例子：</strong></p>\n<p>输入描述:输入有两行，第一行n</p>\n<p>第二行是n个字符串，字符串之间用空格隔开输出描述:输出一行排序后的字符串，空格隔开，无结尾空格</p>\n<pre><code class=\"plain\">import java.util.*;\npublic class Main &#123;\n  public static void main(String[] args) &#123;\n      Scanner sc = new Scanner(System.in);\n      int n=sc.nextInt();\n      String enter=sc.nextLine();//把换车符拿掉\n      String line=sc.nextLine();\n      String[] s=line.split(&quot; &quot;);//转为数组好排序\n      Arrays.sort(s);\n      StringBuilder sb=new StringBuilder();\n      for(String ss:s)&#123;\n          sb.append(ss).append(&quot; &quot;);\n      &#125;\n      String s1 = sb.toString();\n      System.out.println(s1.substring(0,s1.length()-1));\n  &#125;\n&#125;\n</code></pre>\n<h2 id=\"接受输入的字符a\"><a href=\"#接受输入的字符a\" class=\"headerlink\" title=\"接受输入的字符a\"></a>接受输入的字符a</h2><pre><code class=\"plain\">String b = in.next\nif(b.equals(&quot;a&quot;))\n</code></pre>\n<h3 id=\"格式化输出\"><a href=\"#格式化输出\" class=\"headerlink\" title=\"格式化输出\"></a>格式化输出</h3><p>System.out.printf(“%.11f”, ans+sum);&#x2F;&#x2F;.11表示位数</p>\n","categories":["算法"]},{"title":"MySQL","url":"/2023/06/04/MySQL/","content":"<h2 id=\"数据库三范式\"><a href=\"#数据库三范式\" class=\"headerlink\" title=\"数据库三范式\"></a>数据库三范式</h2><ul>\n<li>第一范式：<strong>列的原子性</strong>，数据库表的每一列都不可分割</li>\n<li>第二范式：要求确保表中每列与主键相关<span id=\"more\"></span>，而不能只与主键的某部分相关（主要针对联合主键），主键列与非主键列遵循完全函数依赖关系，也就是完全依赖</li>\n<li>第三范式：属性不依赖于其它非主属性。确保主键列之间没有传递函数依赖关系,<strong>消除传递依赖</strong></li>\n</ul>\n<h2 id=\"MyISAM-Maiˈzaem-VS-Innodb\"><a href=\"#MyISAM-Maiˈzaem-VS-Innodb\" class=\"headerlink\" title=\"MyISAM(Maiˈzæm) VS Innodb\"></a>MyISAM(Maiˈzæm) VS Innodb</h2><ul>\n<li>InnoDB <strong>支持事务</strong>，MyISAM 不支持</li>\n<li>InnoDB <strong>支持外键</strong>，而 MyISAM 不支持</li>\n<li>InnoDB 是<strong>聚集索引</strong>，数据文件是和索引绑在一起的，必须要有主键，通过主键索引效率很高；MyISAM 是非聚集索引，数据文件是分离的，索引保存的是数据文件的指针，主键索引和辅助索引是独立的。</li>\n<li>Innodb <strong>不支持全文索引，</strong>而 MyISAM 支持全文索引，查询效率上 MyISAM 要高；</li>\n<li>InnoDB 不保存表的具体行数，MyISAM 用一个变量保存了整个表的行数。</li>\n<li>MyISAM 采用表级<strong>锁</strong>(table-level locking)；InnoDB 支持行级锁(row-level locking)和表级锁,默认为行级锁。</li>\n</ul>\n<h2 id=\"超键、候选键、主键、外键分别是什么？\"><a href=\"#超键、候选键、主键、外键分别是什么？\" class=\"headerlink\" title=\"超键、候选键、主键、外键分别是什么？\"></a>超键、候选键、主键、外键分别是什么？</h2><p>超键：在关系中能唯一标识元组的属性集称为关系模式的超键。一个属性可以为作为一个超键，多个属性组合在一起也可以作为一个超键。</p>\n<p>超键包含候选键和主键。候选键：是最小超键，即没有冗余元素的超键。主键：数据库表中对储存数据对象予以<strong>唯一和完整标识的数据列或属性的组合</strong>。一个数据列只能有一个主键，且主键的取值不能缺失，即不能为空值（Null）。外键：<strong>在一个表中存在的另一个表的主键称此表的外键</strong>。</p>\n<h2 id=\"SQL-约束有哪几种？\"><a href=\"#SQL-约束有哪几种？\" class=\"headerlink\" title=\"SQL 约束有哪几种？\"></a>SQL 约束有哪几种？</h2><p>NOT NULL: 用于控制字段的内容一定不能为空（NULL）。UNIQUE: <strong>控件字段内容不能重复</strong>，一个表允许有多个 Unique 约束。PRIMARY KEY: 也是用于控件字段内容不能重复，但它在一个表<strong>只允许出现一个</strong>。FOREIGN KEY: 用于预防破坏表之间连接的动作，也能防止非法数据插入外键列，因为它必须是它指向的那个表中的值之一。CHECK: 用于控制字段的值范围。</p>\n<h2 id=\"MySQL-中的-varchar-和-char-有什么区别？\"><a href=\"#MySQL-中的-varchar-和-char-有什么区别？\" class=\"headerlink\" title=\"MySQL 中的 varchar 和 char 有什么区别？\"></a>MySQL 中的 varchar 和 char 有什么区别？</h2><p><strong>定长vs 不定长</strong></p>\n<p>char 是一个定长字段,假如申请了char(10)的空间,那么无论实际存储多少内容.该字段都占用 10 个字符,而 varchar 是变长的,也就是说申请的只是最大长度,占用的空间为实际字符长度+1,最后一个字符存储使用了多长的空间.</p>\n<p><strong>在检索效率上来讲,char &gt; varchar</strong>,因此在使用中,如果确定某个字段的值的长度,可以使用 char,否则应该尽量使用 varchar.</p>\n<p>例如存储用户 MD5 加密后的密码,则应该使用 char。</p>\n<h2 id=\"MySQL中-in-和-exists-区别\"><a href=\"#MySQL中-in-和-exists-区别\" class=\"headerlink\" title=\"MySQL中 in 和 exists 区别\"></a>MySQL中 in 和 exists 区别</h2><p>MySQL中的in语句是把外表和内表作hash 连接，而exists语句是对外表作loop循环，每次loop循环再对内表进行查询。</p>\n<p>如果查询的两个表大小相当，那么用in和exists差别不大。 如果两个表中一个较小，一个是大表，则子查询表大的用exists，子查询表小的用in。 <strong>in用的A索引 （B直接写出来 In(1,2,3)&#x3D;&gt;or&#x3D;&#x3D;1or &#x3D;&#x3D;2or &#x3D;&#x3D;3）exists用的B索引（从A逐条获取记录然后去B查）</strong></p>\n<p>not in 和not exists：如果查询语句使用了not in，那么内外表都进行全表扫描，没有用到索引；而not extsts的子查询依然能用到表上的索引。所以无论那个表大，用not exists都比not in要快。</p>\n<h2 id=\"drop、delete与truncate的区别\"><a href=\"#drop、delete与truncate的区别\" class=\"headerlink\" title=\"drop、delete与truncate的区别\"></a>drop、delete与truncate的区别</h2><p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/image-20230318201939118.png\" alt=\"img\"></p>\n<h2 id=\"索引\"><a href=\"#索引\" class=\"headerlink\" title=\"索引\"></a>索引</h2><p><img src=\"https://cdn.nlark.com/yuque/0/2023/webp/226907/1684914852818-1aaa8f79-c65e-4ea1-910b-51165202de03.webp\" alt=\"img\"></p>\n<p>概念：对数据表里所有记录的引用指针。类似目录 查字典</p>\n<p>优点：加快数据的检索速度 在查询的过程中，使用优化隐藏器，提高系统的性能。 缺点：索引的维护成本（增删改的时候要维护）+占物理空间</p>\n<h3 id=\"索引类型？\"><a href=\"#索引类型？\" class=\"headerlink\" title=\"索引类型？\"></a>索引类型？</h3><p>B+树索引：所有数据存储在叶子节点，复杂度为O(logn)，适合范围查询。</p>\n<p>哈希索引: 适合等值查询，检索效率高，一次到位。</p>\n<p>全文索引：MyISAM和InnoDB中都支持使用全文索引，一般在文本类型char,text,varchar类型上创建。</p>\n<p>R-Tree索引: 用来对GIS数据类型创建SPATIAL索引</p>\n<p>应用层：普通（单个列） 唯一 （值必须唯一，但允许有空值） 复合（组合搜索） 聚簇 非聚簇</p>\n<p><strong>物理存储维度</strong></p>\n<ul>\n<li>聚集索引：聚集索引就是以主键创建的索引，在叶子节点存储的是表中的数据。（Innodb存储引擎）</li>\n<li>非聚集索引：非聚集索引就是以非主键创建的索引，在叶子节点存储的是主键和索引列。（Innodb存储引擎）</li>\n</ul>\n<p><strong>逻辑维度：</strong></p>\n<ul>\n<li>主键索引：一种特殊的唯一索引，不允许有空值。</li>\n<li>普通索引：MySQL中基本索引类型，允许空值和重复值。</li>\n<li>联合索引：多个字段创建的索引，使用时遵循最左前缀原则。</li>\n<li>唯一索引：索引列中的值必须是唯一的，但是允许为空值。</li>\n</ul>\n<h3 id=\"hash索引\"><a href=\"#hash索引\" class=\"headerlink\" title=\"hash索引\"></a>hash索引</h3><p>适合等值查询，检索效率高，一次到位。</p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/image-20230314141544547.png\" alt=\"img\"></p>\n<h3 id=\"Hash-索引和-B-树区别是什么？你在设计索引是怎么抉择的？\"><a href=\"#Hash-索引和-B-树区别是什么？你在设计索引是怎么抉择的？\" class=\"headerlink\" title=\"Hash 索引和 B+树区别是什么？你在设计索引是怎么抉择的？\"></a>Hash 索引和 B+树区别是什么？你在设计索引是怎么抉择的？</h3><ul>\n<li>B+树可以进行范围查询，Hash 索引不能。</li>\n<li>B+树支持联合索引的最左侧原则，Hash 索引不支持。</li>\n<li>B+树支持 order by 排序，Hash 索引不支持。</li>\n<li>Hash 索引在等值查询上比 B+树效率更高。（但是索引列的重复值很多的话，Hash冲突，效率降低）。</li>\n<li>B+树使用 like 进行模糊查询的时候，like 后面（比如%开头）的话可以起到优化的作用，Hash 索引根本无法进行模糊查询。</li>\n</ul>\n<h3 id=\"B-Tree\"><a href=\"#B-Tree\" class=\"headerlink\" title=\"B+Tree\"></a>B+Tree</h3><p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/image-20230314141623990.png\" alt=\"img\"></p>\n<p>B-Tree数据分布在各个节点之中。</p>\n<p>B+Tree数据都在叶子节点上，并且增加了顺序访问指针，每个叶子节点都指向相邻的叶子节点的地址。相比B-Tree来说，进行范围查找时只需要查找两个节点，进行遍历即可。而B-Tree需要获取所有节点，相比之下B+Tree效率更高。</p>\n<p>B+tree性质：</p>\n<ul>\n<li>叶子结点包含了数据+指针，且叶子结点本身自小而大顺序链接。</li>\n<li>B+ 树中，数据对象的插入和删除仅在叶节点上进行。</li>\n<li>B+树有2个头指针，一个是树的根节点，一个是最小关键码的叶节点。</li>\n</ul>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/image-20230314141916699.png\" alt=\"img\"></p>\n<h3 id=\"为什么索引结构默认使用B-Tree，而不是B-Tree，Hash，二叉树，红黑树？\"><a href=\"#为什么索引结构默认使用B-Tree，而不是B-Tree，Hash，二叉树，红黑树？\" class=\"headerlink\" title=\"为什么索引结构默认使用B+Tree，而不是B-Tree，Hash，二叉树，红黑树？\"></a>为什么索引结构默认使用B+Tree，而不是B-Tree，Hash，二叉树，红黑树？</h3><p>B+非叶子节点不存数据，占用空间小，磁盘读写代价低 </p>\n<p>B+适合区间查询，扫一遍叶子节点就行，但B-需要中序遍历 所以B+树更加适合在区间查询的情况，所以通常B+树用于数据库索引。</p>\n<p>Hash：</p>\n<ul>\n<li>虽然可以快速定位，但是没有顺序，IO复杂度高；</li>\n<li>Hash碰撞</li>\n<li>索引的是列的全部内容 所以不支持匹配查找</li>\n</ul>\n<p>二叉树： 二叉树树化为链表变成线性查询 树的高度不均匀，不能自平衡，查找效率跟数据有关（树的高度），并且IO代价高。</p>\n<p>平衡二叉树：只能存储两个节点 多叉树可以存更多 树高降低</p>\n<p>红黑树： 树的高度随着数据量增加而增加，IO代价高。</p>\n<p><strong>那为什么不是 B 树而是 B+树呢？</strong>（理解即可）</p>\n<ul>\n<li>B+树非叶子节点上是不存储数据的，仅存储键值，而 B 树节点中不仅存储 键值，也会存储数据。innodb 中页的默认大小是 16KB，如果不存储数据，那 么就会存储更多的键值，相应的树的阶数（节点的子节点树）就会更大，树就 会更矮更胖，如此一来我们查找数据进行磁盘的 IO 次数有会再次减少，数据查 询的效率也会更快。</li>\n<li>B+树索引的所有数据均存储在叶子节点，而且数据是按照顺序排列的，链 表连着的。那么 B+树使得范围查找，排序查找，分组查找以及去重查找变得 异常简单。</li>\n</ul>\n<h3 id=\"非聚集索引与聚集索引区别？\"><a href=\"#非聚集索引与聚集索引区别？\" class=\"headerlink\" title=\"非聚集索引与聚集索引区别？\"></a>非聚集索引与聚集索引区别？</h3><ul>\n<li>非聚集索引的叶子节点不存储表中的数据，而是存储该列对应的主键（行号）右边这个就是</li>\n<li><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/image-20230318215801811.png\" alt=\"img\"></li>\n<li>对于InnoDB来说，想要查找数据我们还需要根据主键再去聚集索引中进行查找，这个再根据聚集索引查找数据的过程，我们称为<strong>回表</strong>。第一次索引一般是顺序IO，回表的操作属于随机IO。需要回表的次数越多，即随机IO次数越多，我们就越倾向于使用全表扫描 。（回表：回表就是先通过数据库索引扫描出数据所在的行，再通过行<a href=\"https://so.csdn.net/so/search?q=%E4%B8%BB%E9%94%AE&spm=1001.2101.3001.7020\">主键</a>id取出索引中未提供的数据，即基于非主键索引的查询需要多扫描一棵索引树）</li>\n<li>通常情况下， 主键索引（聚簇索引）查询只会查一次，而非主键索引（非聚簇索引）需要回表查询多次。当然，如果是覆盖索引的话，查一次即可（单列索引(name)升级为联合索引(name, sex)，即可避免回表。）</li>\n<li>注意：MyISAM无论主键索引还是二级索引都是非聚簇索引，而InnoDB的主键索引是聚簇索引，二级索引是非聚簇索引。我们自己建的索引基本都是非聚簇索引。</li>\n</ul>\n<h3 id=\"非聚簇索引一定会回表查询吗？\"><a href=\"#非聚簇索引一定会回表查询吗？\" class=\"headerlink\" title=\"非聚簇索引一定会回表查询吗？\"></a>非聚簇索引一定会回表查询吗？</h3><p>不一定，这涉及到查询语句所要求的字段是否全部命中了索引，如果全部命中了索引，那么就不必再进行回表查询。一个索引包含（覆盖）所有需要查询字段的值，被称之为”覆盖索引”。</p>\n<p>举个简单的例子，假设我们在员工表的年龄上建立了索引，那么当进行select score from student where score &gt; 90的查询时，在索引的叶子节点上，已经包含了score 信息，不会再次进行回表查询。 如果select score sex from student where score &gt; 90 需要回表</p>\n<h3 id=\"联合索引是什么？为什么需要注意联合索引中的顺序？\"><a href=\"#联合索引是什么？为什么需要注意联合索引中的顺序？\" class=\"headerlink\" title=\"联合索引是什么？为什么需要注意联合索引中的顺序？\"></a>联合索引是什么？为什么需要注意联合索引中的顺序？</h3><p>MySQL可以使用多个字段同时建立一个索引，叫做联合索引。在联合索引中，如果想要命中索引，需要按照建立索引时的字段顺序挨个使用，否则无法命中索引。</p>\n<pre><code class=\"plain\">index(name，age，school)\n)engine=innodb;\n</code></pre>\n<p>具体原因为:</p>\n<p>MySQL使用索引时需要索引有序，假设现在建立了”name，age，school”的联合索引，那么索引的排序为: 先按照name排序，如果name相同，则按照age排序，如果age的值也相等，则按照school进行排序。</p>\n<p>当进行查询时，此时索引仅仅按照name严格有序，因此必须首先使用name字段进行等值查询，之后对于匹配到的列而言，其按照age字段严格有序，此时可以使用age字段用做索引查找，以此类推。因此在建立联合索引的时候应该注意索引列的顺序，一般情况下，将查询需求频繁或者字段选择性高的列放在前面。此外可以根据特例的查询或者表结构进行单独的调整。</p>\n<h3 id=\"讲一讲MySQL的最左前缀原则\"><a href=\"#讲一讲MySQL的最左前缀原则\" class=\"headerlink\" title=\"讲一讲MySQL的最左前缀原则?\"></a>讲一讲MySQL的最左前缀原则?</h3><p>最左前缀原则就是最左优先，在创建多列索引时，要根据业务需求，where子句中使用最频繁的一列放在最左边。 **mysql会一直向右匹配直到遇到范围查询(&gt;、&lt;、between、like)就停止匹配**，比如a &#x3D; 1 and b &#x3D; 2 and c &gt; 3 and d &#x3D; 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。</p>\n<p><strong>&#x3D;和in可以乱序</strong>，比如a &#x3D; 1 and b &#x3D; 2 and c &#x3D; 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式。</p>\n<h3 id=\"讲一讲前缀索引？\"><a href=\"#讲一讲前缀索引？\" class=\"headerlink\" title=\"讲一讲前缀索引？\"></a>讲一讲前缀索引？</h3><p>索引的字段非常长会占内存空间，也不利于维护。因此把很长字段的前面的<strong>公共部分作为一个索引</strong>，就会产生超级加倍的效果。但是，我们需要注意，order by不支持前缀索引 。</p>\n<p>流程是：</p>\n<p>先计算完整列的选择性 : select count(distinct col_1)&#x2F;count(1) from table_1 </p>\n<p>再计算不同前缀长度的选择性 :select count(distinct left(col_1,4))&#x2F;count(1) from table_1 </p>\n<p>找到最优长度之后，创建前缀索引 : create index idx_front on table_1 (col_1(4))</p>\n<h3 id=\"了解索引下推吗？\"><a href=\"#了解索引下推吗？\" class=\"headerlink\" title=\"了解索引下推吗？\"></a>了解索引下推吗？</h3><p>MySQL 5.6引入了索引下推优化。默认开启，使用SET optimizer_switch &#x3D; ‘index_condition_pushdown&#x3D;off’;可以将其关闭。</p>\n<p>有了索引下推优化，可以减少回表次数</p>\n<p>在InnoDB中只针对非聚集索引有效</p>\n<p>总结：有一个是查数据 判断数据是不是复合条件 </p>\n<p>一个是查索引 判断索引是不是复合条件 如果符合 再去查数据</p>\n<p>例子：</p>\n<p>给你这个SQL：</p>\n<p>select * from employee where name like ‘小%’ and age&#x3D;28 and sex&#x3D;’0’;</p>\n<p>其中，name和age为联合索引（idx_name_age）。</p>\n<p>如果是<strong>Mysql5.6之前</strong>，在idx_name_age索引树，找出所有名字第一个字是“小”的人，拿到它们的主键id，然后回表找出数据行，再去对比年龄和性别等其他字段。如图：</p>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2023/webp/226907/1684914852806-f98db344-7f27-4981-aa7a-ad288881a3fb.webp\" alt=\"img\"></p>\n<p>有些朋友可能觉得奇怪，idx_name_age（name,age)不是联合索引嘛？为什么选出包含“小”字后，不再顺便看下年龄age再回表呢，不是更高效嘛？所以呀，MySQL 5.6就引入了<strong>索引下推优化</strong>，可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。</p>\n<p>因此，MySQL5.6版本之后，选出包含“小”字后，顺表过滤age&#x3D;28</p>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2023/webp/226907/1684914852686-3b2dfd7c-0461-40c4-9ce7-7c488f02b1c8.webp\" alt=\"img\"></p>\n<h3 id=\"大表如何添加索引\"><a href=\"#大表如何添加索引\" class=\"headerlink\" title=\"大表如何添加索引\"></a>大表如何添加索引</h3><p>如果一张表数据量级是千万级别以上的，那么，如何给这张表添加索引？</p>\n<p>我们需要知道一点，<strong>给表添加索引的时候</strong>，<strong>是会对表加锁的</strong>。如果不谨慎操作，有可能出现生产事故的。可以参考以下方法：</p>\n<ol>\n<li>先创建一张跟原表A数据结构相同的新表B。</li>\n<li>在新表B添加需要加上的新索引。</li>\n<li>把原表A数据导到新表B</li>\n<li>rename新表B为原表的表名A，原表A换别的表名；</li>\n</ol>\n<h3 id=\"explain\"><a href=\"#explain\" class=\"headerlink\" title=\"explain\"></a>explain</h3><p>EXPLAIN SELECT * FROM employees.titles WHERE emp_no&#x3D;’10001’ AND title&#x3D;’Senior Engineer’ AND from_date&#x3D;’1986-06-26’;</p>\n<ul>\n<li>id：在⼀个⼤的查询语句中每个<strong>SELECT</strong>关键字都对应⼀个唯⼀的id ，如explain select * from s1 where id &#x3D; (select id from s1 where name &#x3D; ‘egon1’);第一个select的id是1，第二个select的id是2。有时候会出现两个select，但是id却都是1，这是因为优化器把子查询变成了连接查询 。</li>\n<li>select_type：select关键字对应的那个查询的类型，如SIMPLE,PRIMARY,SUBQUERY,DEPENDENT,SNION 。</li>\n<li>table：每个查询对应的表名 。</li>\n<li>type：通过 type 字段, 我们判断此次查询是 全表扫描 还是 索引扫描 等通常来说, 不同的 type 类型的性能关系如下: ALL &lt; index &lt; range ~ index_merge &lt; ref &lt; eq_ref &lt; const &lt; systemALL 类型因为是全表扫描, 因此在相同的查询条件下, 它是速度最慢的. 而 index 类型的查询虽然不是全表扫描, 但是它扫描了所有的索引, 因此比 ALL 类型的稍快.</li>\n<li>possible_key：查询中可能用到的索引*(可以把用不到的删掉，降低优化器的优化时间)* 。</li>\n<li>key：此字段是 MySQL 在当前查询时所<strong>真正使用到的索引</strong>。</li>\n<li>filtered：查询器预测满足下一次<strong>查询条件的百分比</strong> 。</li>\n<li>rows 估算 SQL 要查找到结果集需要扫描读取的数据行数. 原则上 rows 越少越好。</li>\n<li>extra：表示额外信息，如Using where,Start temporary,End temporary,Using temporary等。</li>\n</ul>\n<h3 id=\"为什么官方建议使用自增长主键作为索引？\"><a href=\"#为什么官方建议使用自增长主键作为索引？\" class=\"headerlink\" title=\"为什么官方建议使用自增长主键作为索引？\"></a>为什么官方建议使用自增长主键作为索引？</h3><p>结合B+Tree的特点，自增主键是连续的，在插入过程中尽量减少页分裂，即使要进行页（16kb）分裂，也只会分裂很少一部分。并且能减少数据的移动，每次插入都是插入到最后。总之就是减少分裂和移动的频率。</p>\n<h3 id=\"如何创建索引\"><a href=\"#如何创建索引\" class=\"headerlink\" title=\"如何创建索引\"></a>如何创建索引</h3><p>1、 在执行CREATE TABLE时创建索引</p>\n<p>2、 使用ALTER TABLE命令去增加索引。（普通索引、UNIQUE索引或PRIMARY KEY索引。）</p>\n<p>table_name：增加索引的表名，</p>\n<p>column_list指出对哪些列进行索引，多列时各列之间用逗号分隔。</p>\n<p>索引名index_name可自己命名，缺省时，MySQL将根据第一个索引列赋一个名称。另外，ALTER TABLE允许在单个语句中更改多个表，因此可以在同时创建多个索引。</p>\n<p>ALTER TABLE table_name ADD INDEX index_name (column_list);</p>\n<p>3、 使用CREATE INDEX命令创建。</p>\n<p>CREATE INDEX index_name ON table_name (column_list);</p>\n<h3 id=\"创建索引时需要注意什么？\"><a href=\"#创建索引时需要注意什么？\" class=\"headerlink\" title=\"创建索引时需要注意什么？\"></a>创建索引时需要注意什么？</h3><p>非空字段：应该指定列为NOT NULL，除非你想存储NULL。在mysql中，含有空值的列很难进行查询优化，因为它们使得索引、索引的统计信息以及比较运算更加复杂。你应该用0、一个特殊的值或者一个空串代替空值；取值离散大的字段：（变量各个取值之间的差异程度）的列放到联合索引的前面，可以通过count()函数查看字段的差异值，返回值越大说明字段的唯一值越多字段的离散程度高；索引字段越小越好：数据库的数据存储以页为单位一页存储的数据越多一次IO操作获取的数据越大效率越高。</p>\n<h3 id=\"建索引的原则有哪些？\"><a href=\"#建索引的原则有哪些？\" class=\"headerlink\" title=\"建索引的原则有哪些？\"></a>建索引的原则有哪些？</h3><p>1、最左前缀匹配原则，范围查询(&gt;、&lt;、between、like)停止匹配</p>\n<p>2、&#x3D;和in可以乱序，mysql的查询优化器会帮你优化成索引可以识别的形式。</p>\n<p>3、<strong>尽量选择区分度高的列作为索引</strong>，区分度的公式是count(distinct col)&#x2F;count(*)，表示字段不重复的比例，比例越大我们扫描的记录数越少，唯一键的区分度是1，而一些状态、性别字段可能在大数据面前区分度就是0，那可能有人会问，这个比例有什么经验值吗？使用场景不同，这个值也很难确定，一般需要join的字段我们都要求是0.1以上，即平均1条扫描10条记录。</p>\n<p>4、<strong>索引列不能参与计算</strong>，保持列“干净”，比如from_unixtime(create_time) &#x3D; ’2014-05-29’就不能使用到索引，原因很简单，b+树中存的都是数据表中的字段值，但进行检索时，需要把所有元素都应用函数才能比较，显然成本太大。所以语句应该写成create_time &#x3D; unix_timestamp(’2014-05-29’)。</p>\n<p>from_unixtime：时间戳(1970-1-1至今的秒)-&gt;yyyy-MM-dd HH:mm:ss unix_timestamp-&gt;yyyy-MM-dd HH:mm:ss</p>\n<p>5、<strong>尽量的扩展索引</strong>，不要新建索引。比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可。(联合索引)</p>\n<h3 id=\"使用索引查询一定能提高查询的性能吗？（优缺点）\"><a href=\"#使用索引查询一定能提高查询的性能吗？（优缺点）\" class=\"headerlink\" title=\"使用索引查询一定能提高查询的性能吗？（优缺点）\"></a>使用索引查询一定能提高查询的性能吗？（优缺点）</h3><p>优点：</p>\n<p>1、通常通过索引查询数据比全表扫描要快。但是我们也必须注意到它的代价。</p>\n<p>2、唯一索引可以保证数据库表中每一行的数据的唯一性</p>\n<p>缺点：</p>\n<ul>\n<li>创建索引和维护索引要耗费时间</li>\n<li>索引需要占物理空间，除了数据表占用数据空间之外，每一个索引还要占用一定的物理空间</li>\n<li>以表中的数据进行增、删、改的时候，索引也要动态的维护。</li>\n</ul>\n<h3 id=\"什么情况下不走索引（索引失效）？\"><a href=\"#什么情况下不走索引（索引失效）？\" class=\"headerlink\" title=\"什么情况下不走索引（索引失效）？\"></a>什么情况下不走索引（索引失效）？</h3><p>1、使用!&#x3D; 或者 &lt; &gt;，not in NOT EXISTS 导致索引失效2、<strong>类型</strong>不一致导致的索引失效3、<strong>函数</strong>导致的索引失效如：</p>\n<p>SELECT * FROM user WHERE DATE(create_time) &#x3D; ‘2020-09-03’;如果使用函数在索引列，这是不走索引的。</p>\n<p>4、<strong>运算符</strong>导致的索引失效SELECT * FROM user WHERE age - 1 &#x3D; 20;如果你对列进行了（+，-，*，&#x2F;，!）, 那么都将不会走索引。</p>\n<p>5、<strong>OR</strong>引起的索引失效SELECT * FROM user WHERE name &#x3D; ‘张三’ OR height &#x3D; ‘175’;OR导致索引是在特定情况下的，并不是所有的OR都是使索引失效，<strong>如果OR连接的是同一个字段，那么索引不会失效，反之索引失效。</strong></p>\n<p>6、<strong>模糊搜索</strong>导致的索引失效SELECT * FROM user WHERE name LIKE ‘%冰’;<strong>当%放在匹配字段前是不走索引的，放在后面才会走索引。</strong></p>\n<p>7、mysql 估计使用全表扫描要比使用索引快,则不使用索引。</p>\n<p>8、 如果字段类型是字符串，where时一定用引号括起来，否则索引失效</p>\n<p>9、索引字段上使用is null， is not null，可能导致索引失效。</p>\n<h2 id=\"事务\"><a href=\"#事务\" class=\"headerlink\" title=\"事务\"></a>事务</h2><h3 id=\"MVCC\"><a href=\"#MVCC\" class=\"headerlink\" title=\"MVCC\"></a>MVCC</h3><p>多版本并发控制。MVCC 的实现，是通过保存数据在某个时间点的快照来实现的。根据事务开始的时间不同，每个事务对同一张表，同一时刻看到的数据可能是不一样的。</p>\n<p>前置知识</p>\n<ul>\n<li>快照读：读取的是记录数据的可见版本（有旧的版本）。不加锁,普通的select语句都是快照读。</li>\n<li>当前读：读取的是记录数据的最新版本，显式加锁的都是当前读。</li>\n<li>ROW ID：隐藏的自增 ID，如果表没有主键，InnoDB 会自动按 ROW ID 产生一个聚集索引树。</li>\n<li>事务 ID：记录最后一次修改该记录的事务 ID。</li>\n<li>回滚指针：多个事务并行操作某一行数据时，不同事务对该行数据的修改会产生多个版本然后通过回滚指针（roll_pointer），连成一个链表，这个链表就称为版本链。如下：</li>\n</ul>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2023/webp/226907/1684914852717-05fdda6f-8056-43dc-a54a-552328314ff8.webp\" alt=\"img\"></p>\n<ul>\n<li>隐式字段：对于InnoDB存储引擎，每一行记录都有两个隐藏列trx_id(当前事务id)、roll_pointer，如果表中没有主键和非NULL唯一键时，则还会有第三个隐藏的主键列row_id。</li>\n<li>undo log：回滚日志，用于记录数据被修改前的信息。在表记录修改之前，会先把数据拷贝到undo log里，如果事务回滚，即可以通过undo log来还原数据</li>\n</ul>\n<p><strong>原子性</strong></p>\n<p>当delete一条记录时，undo log中会记录一条对应的insert记录，当update一条记录时，它记录一条对应相反的update记录。</p>\n<p>1、事务回滚时，保证原子性和一致性。2、用于MVCC快照读。</p>\n<p><strong>什么是Read View</strong></p>\n<p>Read View是什么呢？ 它就是事务执行SQL语句时，产生的读视图。每个SQL语句执行前都会得到一个Read View。它主要是用来做可见性判断的，即判断当前事务可见哪个版本的数据~</p>\n<p>在Read View中，有这几个重要的属性。</p>\n<ul>\n<li>m_ids:当前系统中，那些未提交的读写事务ID列表。</li>\n<li>min_limit_id:表示在生成Read View时，当前系统中活跃的读写事务中最小的事务id，即m_ids中的最小值。</li>\n<li>max_limit_id:表示生成Read View时，系统中应该分配给下一个事务的id值。</li>\n<li>creator_trx_id: 创建当前Read View的事务ID</li>\n</ul>\n<p><strong>Read view 匹配条件规则（很重要）</strong></p>\n<ol>\n<li>如果数据事务ID trx_id &lt; min_limit_id，表明生成该版本的事务在生成Read View前，已经提交(因为事务ID是递增的)，所以该版本可以被当前事务访问。</li>\n<li>如果trx_id&gt;&#x3D; max_limit_id，表明生成该版本的事务在生成Read View后才生成，所以该版本不可以被当前事务访问。</li>\n<li>如果 min_limit_id &#x3D;&lt;trx_id&lt; max_limit_id,需腰分3种情况讨论</li>\n</ol>\n<ul>\n<li>（1）.如果m_ids包含trx_id,则代表Read View生成时刻，这个事务还未提交，但是如果数据的trx_id等于creator_trx_id的话，表明数据是自己生成的，因此是<strong>可见</strong>的。</li>\n<li>（2）如果m_ids包含trx_id，并且trx_id不等于creator_trx_id（ 创建当前Read View的事务ID），则Read View生成时，事务未提交，并且不是自己生产的，所以当前事务也是<strong>看不见</strong>的；</li>\n<li>（3）.如果m_ids不包含trx_id，则说明你这个事务在Read View生成之前就已经提交了，修改的结果，当前事务是能看见的。</li>\n</ul>\n<h4 id=\"查询一条记录，基于MVCC，是怎样的流程\"><a href=\"#查询一条记录，基于MVCC，是怎样的流程\" class=\"headerlink\" title=\"查询一条记录，基于MVCC，是怎样的流程\"></a>查询一条记录，基于MVCC，是怎样的流程</h4><ol>\n<li>获取事务自己的版本号，即事务ID（trx_id）</li>\n<li>获取Read View</li>\n<li>查询得到的数据，然后Read View中的事务版本号进行比较。</li>\n<li>如果不符合Read View的可见性规则， 即就需要Undo log中历史快照;</li>\n<li>最后返回符合规则的数据</li>\n</ol>\n<p>InnoDB 实现MVCC，是通过Read View+ Undo Log实现的，Undo Log保存了历史快照，Read View可见性规则帮助判断当前版本的数据是否可见。</p>\n<p>举例：</p>\n<p><strong>RC级别下：</strong></p>\n<p>先插入一条这个数据</p>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2023/webp/226907/1684914852707-cc807236-dd94-4c6f-b88c-45430f531855.webp\" alt=\"img\"></p>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2023/webp/226907/1684914853130-d6501e0b-950b-4a7c-a24d-47eca5b7094d.webp\" alt=\"img\"></p>\n<p>事务AB先后开启事务 trx_id 为100 101</p>\n<p>事务A第一次查到name是孙权 (trx_id&#x3D;最新trx_id 符合可见性原则)</p>\n<p>事务B把name改为曹操 最新版本链101</p>\n<p>事务A再查（trx_id&#x3D;101 但此时因为B提交了 m_ids里面已经没101了 所以依旧符合可见性原则 查出来是曹操） 出现不可重读的问题</p>\n<p><strong>RR级别下：</strong></p>\n<ul>\n<li>在读已提交（RC）隔离级别下，同一个事务里面，<strong>每一次查询都会产生一个新的Read View副本</strong>，这样就可能造成同一个事务里前后读取数据可能不一致的问题（不可重复读并发问题）。</li>\n<li>而在可重复读（RR）隔离级别下，<strong>一个事务里只会获取一次read view</strong>，都是副本共用的，从而保证每次查询的数据都是一样的。</li>\n</ul>\n<p>分析一下：</p>\n<p>主要是A再查这部分：</p>\n<p>事务A再查（trx_id&#x3D;101 因为A事务共用一个readview 所以m_ids里面有101 但creator_trx_id（100）!&#x3D;trx_id（101） 不符合可见性规则，版本链roll_pointer跳到下一个版本，trx_id&#x3D;100这个记录，再次校验是否可见，creator_trx_id (100) 等于trx_id（100），所以查到孙权这个记录） 出现不可重读的问题</p>\n<hr>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/modb_95751916-225c-11eb-b0bb-5254001c05fe.png\" alt=\"img\"></p>\n<p>如图，首先 insert 语句向表 t1 中插入了一条数据，a 字段为 1，b 字段为 1， ROW ID 也为 1 ，事务 ID 假设为 1，回滚指针假设为 null。当执行 update t1 set b&#x3D;666 where a&#x3D;1 时，大致步骤如下：</p>\n<ul>\n<li>数据库会先对满足 a&#x3D;1 的行加排他锁；</li>\n<li>然后将原记录复制到 undo 表空间中；</li>\n<li>修改 b 字段的值为 666，修改事务 ID 为 2；</li>\n<li>并通过隐藏的回滚指针指向 undo log 中的历史记录；</li>\n<li>事务提交，释放前面对满足 a&#x3D;1 的行所加的排他锁。</li>\n</ul>\n<p>总结：</p>\n<p>InnoDB 每一行数据都有一个隐藏的回滚指针，用于指向该行修改前的最后一个历史版本，这个历史版本存放在 undo log 中。如果要执行更新操作，会将原记录放入 undo log 中，并通过隐藏的回滚指针指向 undo log 中的原记录。其它事务此时需要查询时，就是查询 undo log 中这行数据的最后一个历史版本。</p>\n<p>MVCC 最大的好处是读不加锁，读写不冲突，极大地增加了 MySQL 的并发性。通过 MVCC，保证了事务 ACID 中的 I（隔离性）特性。</p>\n<h3 id=\"如何处理大事务和长事务？请给出一些处理方法。\"><a href=\"#如何处理大事务和长事务？请给出一些处理方法。\" class=\"headerlink\" title=\"如何处理大事务和长事务？请给出一些处理方法。\"></a>如何处理大事务和长事务？请给出一些处理方法。</h3><p>处理大事务和长事务是数据库设计和优化中非常重要的一部分，以下是一些常用的处理方法：</p>\n<ul>\n<li><strong>大事务拆分为小事务</strong>：将大事务拆分为多个小事务，减少每个事务操作的数据量，可以减少锁竞争和死锁的风险，提高并发性能。</li>\n<li><strong>优化查询语句</strong>：对于长事务中的查询操作，可以通过优化查询语句来提高查询性能，如添加索引、优化SQL结构等。</li>\n<li><strong>避免长时间占用锁</strong>：长事务会占用锁资源，导致其他事务无法访问相应的数据，因此需要尽可能<strong>缩短事务的执行时间</strong>，避免长时间占用锁。</li>\n<li><strong>避免长时间的事务等待</strong>：长事务可能会导致其他事务的等待时间过长，影响系统的性能和可用性，因此需要尽可能缩短事务的执行时间，避免长时间的事务等待。</li>\n<li><strong>优化事务日志</strong>：长事务会占用大量的事务日志，导致数据库性能下降，因此需要通过优化事务日志的写入和刷盘策略来提高性能。</li>\n<li><strong>使用定时任务</strong>：长时间运行的事务可以通过定时任务来定期执行，以避免长时间占用资源。</li>\n<li><strong>适当增加硬件资源</strong>：如果以上方法不能解决问题，可以适当增加硬件资源，如增加内存、CPU、存储等，以提高系统性能。</li>\n</ul>\n<h3 id=\"如何优化-MySQL-事务的性能？请列举一些优化方法。\"><a href=\"#如何优化-MySQL-事务的性能？请列举一些优化方法。\" class=\"headerlink\" title=\"如何优化 MySQL 事务的性能？请列举一些优化方法。\"></a>如何优化 MySQL 事务的性能？请列举一些优化方法。</h3><p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/image-20230402233303314.png\" alt=\"img\"></p>\n<h3 id=\"事务-1\"><a href=\"#事务-1\" class=\"headerlink\" title=\"事务?\"></a>事务?</h3><p>事务是一个不可分割的数据库操作序列 事务是逻辑上的⼀组操作，要么都执⾏，要么都不执⾏ </p>\n<h3 id=\"事务的四大特性\"><a href=\"#事务的四大特性\" class=\"headerlink\" title=\"事务的四大特性\"></a>事务的四大特性</h3><p>事务，由一个<strong>有限的数据库操作序列</strong>构成，这些操作要么全部执行,要么全部不执行，是一个不可分割的工作单位。</p>\n<p>原子性： 事务作为一个整体被执行，包含在其中的对数据库的操作要么全部都执行，要么都不执行。</p>\n<p>一致性： 指在事务开始之前和事务结束以后，数据不会被破坏，假如A账户给B账户转10块钱，不管成功与否，A和B的总金额是不变的。</p>\n<p>隔离性： 多个事务并发访问时，事务之间是相互隔离的，一个事务不应该被其他事务干扰，多个并发事务之间要相互隔离。</p>\n<p>持久性： 表示事务完成提交后，该事务对数据库所作的操作更改，将持久地保存在数据库之中</p>\n<h3 id=\"事务的实现原理\"><a href=\"#事务的实现原理\" class=\"headerlink\" title=\"事务的实现原理\"></a>事务的实现原理</h3><p>重做日志文件(redo log)和回滚日志(undo log)实现的。</p>\n<p>提交一个事务必须先将该事务的所有日志写入到redo log进行持久化，数据库就可以通过重做日志来保证事务的原子性和持久性。</p>\n<p>每当有修改事务时，还会产生 undo log，如果需要回滚，则<strong>根据 undo log 的反向语句进行逻辑操作</strong>，比如 insert 一条记录就 delete 一条记录。undo log 主要实现数据库的一致性。</p>\n<h2 id=\"MySQL事务日志\"><a href=\"#MySQL事务日志\" class=\"headerlink\" title=\"MySQL事务日志\"></a>MySQL事务日志</h2><p>包括二进制日志binlog（归档日志）、事务日志redo log（重做日志）和undo log（回滚日志）。</p>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2023/webp/226907/1684914853148-2313c454-6d7e-4756-83b9-9192279ee142.webp\" alt=\"img\"></p>\n<h4 id=\"redolog\"><a href=\"#redolog\" class=\"headerlink\" title=\"redolog\"></a>redolog</h4><p>InnoDB存储引擎独有的，它让MySQL有了崩溃恢复的能力</p>\n<p>当MySQL实例挂了或者宕机了，重启的时候InnoDB存储引擎会使用rede log日志恢复数据，保证事务的持久性和完整性。如下图：</p>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2023/webp/226907/1684914853170-416ab41b-800b-4c86-a100-2c996de62bf4.webp\" alt=\"img\"></p>\n<p>MySQL中数据是以页存储，当查询一条记录时，硬盘会把一整页的数据加载出来(数据页)放到Buffer Pool中。后续的查询都是先从Buffer Pool中找，没有找到再去硬盘加载其他的数据页直到命中，这样子可以减少磁盘IO的次数，提高性能。更新数据的时候也是一样，优先去Buffer Pool中找，如果存在需要更新的数据就直接更新。然后会把“在某个数据页做了什么修改”记录到重做日志缓存（redo log buffer）里，在刷盘的时候会写入redo log日志文件里。</p>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2023/webp/226907/1684914853201-0890ba57-4906-4b90-9639-2259cb851812.webp\" alt=\"img\"></p>\n<h5 id=\"内存池\"><a href=\"#内存池\" class=\"headerlink\" title=\"内存池\"></a>内存池</h5><p>读取页 操作：</p>\n<ul>\n<li>首先将从磁盘读到的页存放在缓冲池中</li>\n<li>下一次再读相同的页时，首先判断该页是否在缓冲池中。若在缓冲池中，称该页在缓冲池中被命中，直接读取该页。否则，读取磁盘上的页。</li>\n</ul>\n<p>修改页操作：</p>\n<ul>\n<li>首先修改在缓冲池中的页；然后再以一定的频率刷新到磁盘上。</li>\n</ul>\n<p>脏页：就发生在修改这个操作中，如果缓冲池中的页已经被修改了，但是还没有刷新到磁盘上，那么我们就称缓冲池中的这页是 ”脏页“，即缓冲池中的页的版本要比磁盘的新。缓冲池的大小直接影响着数据库的整体性能。</p>\n<p>| 每条redo记录由“表空间号+数据页号+偏移量+修改数据长度+具体修改的数据”组成|</p>\n<h5 id=\"后台线程\"><a href=\"#后台线程\" class=\"headerlink\" title=\"后台线程\"></a>后台线程</h5><p>后台线程的主要作用就是刷新内存池中的数据，保证内存池中缓存的是最近的数据；此外将已修改的数据文件刷新到磁盘文件，同时保证在数据库发生异常的情况下 InnoDB 能恢复到正常运行状态。</p>\n<h5 id=\"WAL-策略\"><a href=\"#WAL-策略\" class=\"headerlink\" title=\"WAL 策略\"></a><strong>WAL 策略</strong></h5><p>当缓冲池中的某页数据被修改后，该页就被标记为 ”脏页“，脏页的数据会被定期刷新到磁盘上。</p>\n<p>倘若每次一个页发生变化，就将新页的版本刷新到磁盘，那么这个开销是非常大的。并且，如果热点数据都集中在某几个页中，那么数据库的性能将变得非常差。另外，如果在从缓冲池将页的新版本刷新到磁盘时发生了宕机，那么这个数据就不能恢复了。</p>\n<p>所以，为了避免发生数据丢失的问题，当前事务数据库系统（并非 MySQL 所独有）普遍都采用了 WAL（Write Ahead Log，<strong>预写日志</strong>）策略：即<strong>当事务提交时，先写重做日志（redo log），再修改页（先修改缓冲池，再刷新到磁盘）；当由于发生宕机而导致数据丢失时，通过 redo log 来完成数据的恢复</strong>。这也是事务 ACID 中 D（Durability 持久性）的要求。</p>\n<p>有了 redo log，InnoDB 就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为 <strong>crash-safe</strong>。</p>\n<ul>\n<li>redo log file 不能设置得太大，如果设置得很大，在恢复时可能需要很长的时间</li>\n<li>redo log file 又不能设置得太小了，否则可能导致一个事务的日志需要多次切换重做日志文件</li>\n</ul>\n<h5 id=\"刷盘时机\"><a href=\"#刷盘时机\" class=\"headerlink\" title=\"刷盘时机\"></a>刷盘时机</h5><p>理想情况下，事务一提交就会进行刷盘操作，但是实际上是刷盘的时机是根据策略来决定的。</p>\n<p>InnoDB存储引擎为redo log的刷盘策略提供了innodb_flush_log_at_trx_commit参数，它支持三种策略：</p>\n<ul>\n<li>0：设置为0的时候，每次提交事务时不刷盘。</li>\n<li>1：设置为1的时候，每次提交事务时刷盘。</li>\n<li>2：设置为2的时候，每次提交事务时都只把redo log buffer写入page cache。</li>\n</ul>\n<p>innodb_flush_log_at_trx_commit参数默认为1，当事务提交的时候会调用fsync对redo log进行刷盘，将redo log buffer写入redo log文件中。</p>\n<p>另外，Innodb存储引擎有一个后台线程，每隔1秒，就会把会redo log buffer中的内容写入到文件系统缓存page cache，然后调用fsync刷盘。（因此这三种策略都会有刷盘）</p>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2023/webp/226907/1684914853331-d087d2d2-c86d-4555-885f-8926ce8f3c10.webp\" alt=\"img\"></p>\n<h5 id=\"三种情况：\"><a href=\"#三种情况：\" class=\"headerlink\" title=\"三种情况：\"></a>三种情况：</h5><p>1、innodb_flush_log_at_trx_commit &#x3D; 0</p>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2023/webp/226907/1684914853572-bdaea9ab-c01f-4fb1-90e3-7f71b30f2704.webp\" alt=\"img\"></p>\n<p>如果宕机了或者MySQL挂了可能造成1秒内的数据丢失。</p>\n<p>2、innodb_flush_log_at_trx_commit &#x3D; 1</p>\n<p>只要事务提交成功，redo log记录就一定在磁盘里，不会有任务数据丢失。</p>\n<p>如果执行事务的时候MySQL挂了或者宕机了，这部分日志丢失了，但是因为事务没有提交，所以日志丢了也不会有损失。</p>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2023/webp/226907/1684914853671-9ed640d3-4607-4d80-a91b-d40f3af5c121.webp\" alt=\"img\"></p>\n<p>3、innodb_flush_log_at_trx_commit &#x3D; 2</p>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2023/webp/226907/1684914853700-65d81cb5-44ad-4104-98ef-0740d0a7d4bd.webp\" alt=\"img\"></p>\n<p>当事务提交成功时，redo log buffer日志会被写入page cache，然后后台线程会刷盘写入redo log，由于后台线程是1秒执行一次所以宕机或者MySQL挂了可能造成1秒内的数据丢失。</p>\n<p>1和3实际上都是事务提交了，但是没有被刷进盘，所以会造成1s的数据丢失，而2是事务提交就刷盘，不会丢失数据；</p>\n<h5 id=\"日志文件组\"><a href=\"#日志文件组\" class=\"headerlink\" title=\"日志文件组\"></a>日志文件组</h5><p>硬盘上存储redo log日志文件以一个<strong>日志文件组</strong>的形式出现，每个的redo log文件大小都是一样的（至少需要两个）。它采用的是环形数组形式，从头开始写，写到末尾回到头循环写，如下图所示：</p>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2023/webp/226907/1684914853784-84999655-d6a4-45be-8ec3-7e9d05cae724.webp\" alt=\"img\"></p>\n<p>在<strong>日志文件组</strong>中有两个重要的属性，分别是witre pos、checkpoint</p>\n<ul>\n<li><strong>wirte pos</strong>：是当前记录的位置，一边写一边后移。</li>\n<li><strong>checkpoint</strong>：是当前要擦除的位置，也是后台推移。</li>\n</ul>\n<p>checkpoint：在 redo log file 中找到一个位置，将这个位置前的页都刷新到磁盘中去，这个位置就称为 CheckPoint（检查点）。举个例子来具体解释下：一组 4 个文件，每个文件的大小是 1GB，那么总共就有 4GB 的 redo log file 空间。write pos 是当前 redo log 记录的位置，随着不断地写入磁盘，write pos 也不断地往后移，就像我们上文说的，写到 file 3 末尾后就回到 file 0 开头。CheckPoint 是当前要擦除的位置（将 Checkpoint 之前的页刷新回磁盘），也是往后推移并且循环的：</p>\n<p>每次刷盘redo log记录到<strong>日志文件组</strong>中，wirte log位置就会后移更新。</p>\n<p>每次MySQL加载<strong>日志文件组</strong>恢复数据时，会清空加载过的redo log，并把checkpoint后移更新。</p>\n<p>write pos 和 checkpoint 之间的还空着的部分可以用来写入新的 redo log 记录。</p>\n<p>如果 witre pos追上checkpoint，表示<strong>日志文件组</strong>满了，这时候不能再写入新的redo log记录，MySQL得停下来，清空一些记录，把checkpoint推进一下。</p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/4fb7d59d20b816d7782f74b3a9fa728d.png\" alt=\"img\"></p>\n<h5 id=\"CheckPoint-技术\"><a href=\"#CheckPoint-技术\" class=\"headerlink\" title=\"CheckPoint 技术\"></a><strong>CheckPoint 技术</strong></h5><p>有了 redo log 我们仍然面临这样 3 个问题：</p>\n<p>1）缓冲池不是无限大的，也就是说不能没完没了的存储我们的数据等待一起刷新到磁盘</p>\n<p>2）redo log 是循环使用而不是无限大的（也许可以，但是成本太高，同时不便于运维），那么当所有的 redo log file 都写满了怎么办？</p>\n<p>3）当数据库运行了几个月甚至几年时，这时如果发生宕机，重新应用 redo log 的时间会非常久，此时恢复的代价将会非常大。</p>\n<p>因此 Checkpoint 技术的目的就是解决上述问题：</p>\n<ul>\n<li>缓冲池不够用时，将脏页刷新到磁盘缓冲池的空间无法存放新读取到的页，用LRU 算法）</li>\n</ul>\n<p>（最频繁使用的页在 LRU 列表（LRU List）的前端，最少使用的页在 LRU 列表的尾端；当缓冲池的空间无法存放新读取到的页时，将首先释放 LRU 列表中尾端的页。这个被释放出来（溢出）的页，如果是脏页，那么就需要强制执行 CheckPoint，将脏页刷新到磁盘中去。）</p>\n<ul>\n<li>redo log 不可用（没啥用）时，将脏页刷新到磁盘</li>\n<li>缩短数据库的恢复时间（当数据库宕机，不需要重做所有日志，只需要对Checkpoint后面的redolog进行恢复，缩短恢复时间）</li>\n</ul>\n<hr>\n<p>所谓 CheckPoint 技术简单来说其实就是在 redo log file 中找到一个位置，将这个位置前的页都刷新到磁盘中去，这个位置就称为 CheckPoint（检查点）。</p>\n<p>针对上面这三点我们依次来解释下：</p>\n<p>1）<strong>缓冲池不够用时，将脏页刷新到磁盘</strong>：所谓缓冲池不够用的意思就是缓冲池的空间无法存放新读取到的页，这个时候 InnoDB 引擎会怎么办呢？LRU 算法。InnoDB 存储引擎对传统的 LRU 算法做了一些优化，用其来管理缓冲池这块空间。</p>\n<p>总的思路还是传统 LRU 那套，具体的优化细节这里就不再赘述了：即最频繁使用的页在 LRU 列表（LRU List）的前端，最少使用的页在 LRU 列表的尾端；当缓冲池的空间无法存放新读取到的页时，将首先释放 LRU 列表中尾端的页。这个被释放出来（溢出）的页，如果是脏页，那么就需要强制执行 CheckPoint，将脏页刷新到磁盘中去。</p>\n<p>2）<strong>redo log 不可用时，可以覆盖重用</strong>：</p>\n<p>所谓 redo log 不可用就是所有的 redo log file 都写满了。但事实上，其实 redo log 中的数据并不是时时刻刻都是有用的，那些已经不再需要的部分就称为 ”可以被重用的部分“，即当数据库发生宕机时，<a href=\"https://cloud.tencent.com/product/dbs?from=20065&from_column=20065\">数据库恢复</a>操作不需要这部分的 redo log，因此这部分就可以被覆盖重用（或者说被擦除）。</p>\n<p>3）<strong>缩短数据库的恢复时间</strong>：当数据库发生宕机时，数据库不需要重做所有的日志，因为 Checkpoint 之前的页都已经刷新回磁盘。故数据库只需对 Checkpoint 后的 redo log 进行恢复就行了。这显然大大缩短了恢复的时间。</p>\n<p>综上所述，Checkpoint 所做的事情无外乎是将缓冲池中的脏页刷新到磁盘。不同之处在于每次刷新多少页到磁盘，每次从哪里取脏页，以及什么时间触发 Checkpoint</p>\n<h5 id=\"redo-log小结\"><a href=\"#redo-log小结\" class=\"headerlink\" title=\"redo log小结\"></a>redo log小结</h5><p>redo log的作用和它的刷盘时机、存储形式。</p>\n<p>可以思考一个问题：<strong>只要每次把修改后的数据页直接刷盘不就好了，为什么还要用<strong><strong>redo log</strong></strong>刷盘？不都是刷盘吗？有什么区别？</strong></p>\n<p>实际上，数据页大小是16KB，刷盘比较耗时，可能就修改了数据页的几byte数据，没有必要把整页的数据刷盘。而且数据页刷盘都是随机写，因为一个数据页对应的位置可能是在硬盘文件的随机位置，所以性能很差。</p>\n<p>如果是写redo log，一行记录就占了几十byte，只要包含了表空间号、数据页号、磁盘文件偏移量、修改值，再加上是顺序写，所以刷盘效率很高。</p>\n<p>所以用 redo log 形式记录修改内容，性能会远远超过刷数据页的方式，这也让数据库的并发能力更强。</p>\n<h5 id=\"有了-bin-log-为什么还需要-redo-log？\"><a href=\"#有了-bin-log-为什么还需要-redo-log？\" class=\"headerlink\" title=\"有了 bin log 为什么还需要 redo log？\"></a><strong>有了 bin log 为什么还需要 redo log？</strong></h5><p>MySQL 架构可以分成俩层，一层是 Server 层，它主要做的是 MySQL 功能层面的事情；另一层就是存储引擎，负责存储与提取相关的具体事宜。</p>\n<p>redo log 是 InnoDB 引擎特有的日志，而 Server 层也有自己的日志，包括错误日志（error log）、二进制日志（binlog）、慢查询日志（slow query log）、查询日志（log）。</p>\n<p>binlog 日志只能用于归档，因此 binlog 也被称为<strong>归档日志</strong>，显然如果 MySQL 只依靠 binlog 等这四种日志是没有 crash-safe 能力的，所以为了弥补这种先天的不足，得益于 MySQL 可插拔的存储引擎架构，InnoDB 开发了另外一套日志系统 — 也就是 redo log 来实现 crash-safe 能力。</p>\n<p>这就是为什么有了 bin log 为什么还需要 redo log 的答案。</p>\n<p>回顾下 redo log 存储的东西，可以发现 redo log 是<strong>物理日志</strong>，记录的是 “在某个数据页上做了什么修改”。</p>\n<p>另外，还有一点不同的是：binlog 是追加写入的，就是说 binlog 文件写到一定大小后会切换到下一个，并不会覆盖以前的日志；而 redo log 是循环写入的。</p>\n<p>总结：写的内容少，目的一样， 性能好</p>\n<h4 id=\"binlog\"><a href=\"#binlog\" class=\"headerlink\" title=\"binlog\"></a>binlog</h4><p>redo log是物理日志，记录的是“在某个数据页做了什么修改”，属于Innodb存储引擎。</p>\n<p>而binlog日志是逻辑日志，记录内容是语句的原始逻辑，属于MySQL Server层。所有的存储引擎只要发生了数据更新，都会产生binlog日志。</p>\n<h5 id=\"binlog日志的作用\"><a href=\"#binlog日志的作用\" class=\"headerlink\" title=\"binlog日志的作用\"></a>binlog日志的作用</h5><p>可以说MySQL数据库的<strong>数据备份、主备、主主、住从</strong>都离不开binlog，需要依赖binlog来同步数据，保证数据一致性。binlog会记录所有涉及更新数据的逻辑规则，并且按顺序写。</p>\n<h5 id=\"记录格式\"><a href=\"#记录格式\" class=\"headerlink\" title=\"记录格式\"></a>记录格式</h5><p>可以通过binlog_format参数设置，有以下三种：</p>\n<ul>\n<li><strong>statement：</strong> 基于 SQL 语句的模式，某些语句和函数如 UUID, LOAD DATA INFILE 等在复制过程可能导致数据不一致甚至出错。</li>\n<li><strong>row：</strong> 基于行的模式，记录的是行的变化，很安全。但是 binlog 会大很多</li>\n<li><strong>mixed：</strong> 混合模式，根据语句来选用是 statement 还是 row 模式</li>\n</ul>\n<p>1、statement记录SQL语句原文，但是有个问题，比如update T set update_time &#x3D; now() where id &#x3D; 1，更新的是当前系统的时间，可能和原来数据库的数据不一样，所以-&gt;row</p>\n<p>2、记录的不再是简单的SQL语句了，还包含了操作的具体数据，记录内容如下</p>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2023/webp/226907/1684914853997-78acae84-d7cf-452f-b632-8caab76d031f.webp\" alt=\"img\"></p>\n<p>但是这种格式需要大量的容量来记录，比较占用空间，恢复与同步时会更消耗IO资源，影响执行速度。-&gt;3</p>\n<p>3、所以又有了一种折中方案，设置为mixed，记录的内容是前两者的混合。MySQL会判断这条SQL语句是否会引起数据不一致，如果是就用row格式，否则就用statement格式。</p>\n<p>redo log 是在事务的执行过程中，开始写入 redo 中。防止在发生故障的时间点，尚有脏页(<strong>当内存数据页跟磁盘数据页内容不一致</strong>的时候，我们称这个内存页为“脏页”。)未写入磁盘，在重启 MySQL 服务的时候，根据 redo log 进行重做，从而达到事务的未入磁盘数据进行持久化这一特性。RedoLog 是为了实现事务的持久性而出现的产物。</p>\n<h5 id=\"写入机制\"><a href=\"#写入机制\" class=\"headerlink\" title=\"写入机制\"></a>写入机制</h5><p>binlog的写入时机为事务执行过程中，先把日志写到binlog cache，事务提交的时候再把binlog cache写到binlog文件中（实际先会写入page cache，然后再由fsync写入binlog文件）。</p>\n<p>因为一个事务的binlog不能被拆开，无论这个事务多大，也要确保一次性写入，所以系统会给每个线程分配一块内存作为binlog cache。可以通过binlog_cache_size参数控制单线程binlog_cache大小，如果存储内容超过了这个参数，就要暂存到磁盘。</p>\n<p>binlog日志刷盘流程如下：</p>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2023/webp/226907/1684914854445-39c279b2-8808-4d37-b1f2-a20715e7ca1c.webp\" alt=\"img\"></p>\n<ul>\n<li><strong>上图的<strong><strong>write</strong></strong>，是指把日志写入到文件系统的<strong><strong>page cache</strong></strong>，并没有把数据持久化硬盘，所以速度比较快。</strong></li>\n<li><strong>上图的<strong><strong>fsync</strong></strong>才是将数据库持久化到硬盘的操作。</strong></li>\n</ul>\n<p>write和fsync的时机可以由参数sync_binlog控制，可以配置成0、1、N(N&gt;1)。</p>\n<ul>\n<li>设置成0时：表示每次提交事务都只会write，由系统自行判断什么时候执行fsync。</li>\n<li>设置成1时：表示每次提交事务都会执行fsync，就和redo log日志刷盘流程一样。</li>\n<li>设置成N时：表示每次提交事务都会write，但是积累N个事务后才fsync。</li>\n</ul>\n<p>1、sync_bilog &#x3D; 0设置成0，只把日志写入page cache虽然性能得到了提高，但是事务提交了fsync的时候宕机了，可能造成binlog日志的丢失。</p>\n<p>2、在出现IO瓶颈的场景里，将sync_binlog设置成一个比较大的值，可以提升性能。同样的，如果机器宕机，会丢失最近N个事务的binlog日志。</p>\n<p>3、不会出现日志丢失</p>\n<p>和redolog一样，提交事务了但宕机了没有fsync就会丢失日志</p>\n<h5 id=\"两阶段提交\"><a href=\"#两阶段提交\" class=\"headerlink\" title=\"两阶段提交\"></a>两阶段提交</h5><p>redo log（重做日志）让InnoDB存储引擎有了<strong>崩溃恢复</strong>的能力。</p>\n<p>binlog（归档日志）保证了MySQL集群架构数据的<strong>一致性</strong>。</p>\n<p>虽然它们都属于持久化的保证，但是侧重点不一样。</p>\n<p>在执行更新语句过程，会记录redo log与binlog两块日志，以基本的事务为单位，redo log在事务执行过程中可以不断写入(提交事务后刷盘)，而binlog日志只有在提交事务的时候才会写入，所以它们写入的时机不一样。</p>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2023/webp/226907/1684914854283-b92b59c1-a888-4c15-91fa-0cd79fedb436.webp\" alt=\"img\"></p>\n<p>思考一个问题，如果redo log和binlog两份日志之间的逻辑不一样，会出现什么问题呢？MySQL是怎么解决这个问题的呢？</p>\n<p>比如有这样一个场景，假设有这么一条语句update T set c &#x3D; 1 where id &#x3D; 2（c原值为0），假如执行过程中写完redo log日志后，在写入binlog的时候发生了异常，会出现什么情况呢？</p>\n<p>如下图：</p>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2023/webp/226907/1684914854314-5db14ff9-a752-4834-bfd0-e38fa58d7d6b.webp\" alt=\"img\"></p>\n<p>由于binlog日志没写完就异常，这个时候binlog日志里面没有对应的修改记录，之后使用binlog同步的数据的时候就会少这一次的更新，这一行数据c &#x3D; 0，而原库使用redo log日志恢复（恢复数据库），这一行数据c &#x3D; 1，最终数据不一致。如下图：</p>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2023/webp/226907/1684914854323-1b182897-9d1b-457e-ac3f-5cb173b22c9b.webp\" alt=\"img\"></p>\n<p>为了解决两份日志之间的逻辑不一致的问题，InnoDB存储引擎使用<strong>两阶段提交</strong>方案。</p>\n<p>将redo log日志的写入拆分成两个步骤prepare和commit，如下图： <img src=\"https://cdn.nlark.com/yuque/0/2023/webp/226907/1684914854514-a9604e5c-0e99-4f8d-bf9f-582de591cfa3.webp\" alt=\"img\"></p>\n<p>使用<strong>两阶段提交</strong>后，写入binlog时发生异常也没关系，因为MySQL根据redo log日志恢复数据时，发现redo log日志处于prepare阶段，并且没有对应binlog日志（根据事务id对应），所以就会回滚事务。</p>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2023/webp/226907/1684914854671-fc586292-8946-4bc8-a7f2-060c98149a77.webp\" alt=\"img\"></p>\n<p>本质就是把redolog分为两个阶段（prepare+commit）把写入binlog插入其中，一旦写binlog失败，发生异常，也就没有commit了，也没有binlog了，那么直接判断redolog处于prepare以及binlog不存在条件成立，即可回滚事务。</p>\n<p>再想一个场景，redo logo设置commit阶段发生异常，事务会不会回滚呢？</p>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2023/webp/226907/1684914854712-7e6f5f72-70dd-4220-88bd-28e975b1e846.webp\" alt=\"img\"></p>\n<p>并不会回滚事务，虽然redo log是处于prepare阶段，但是存在对应的事务binlog日志，所以MySQL认为是完整的，所以不会回滚事务。</p>\n<h4 id=\"undo-log\"><a href=\"#undo-log\" class=\"headerlink\" title=\"undo log\"></a>undo log</h4><p>想要保证事务的原子性，就需要在发生异常时，对已经执行的操作进行回滚，在MySQL中恢复机制是通过undo log（回滚日志）实现的，所有事务进行的修改都会先被记录到这个回滚日志，然后再执行其他相关的操作。如果执行过程中遇到异常的话，我们直接利用回滚日志中的信息将数据回滚到修改之前的样子。并且，回滚日志会先于数据持久化到磁盘上。这样就保证了即使遇到数据库突然宕机等情况，当用户再次启动数据库的时候，数据库还能够通过查询回滚日志来回滚将之前未完成的事务。</p>\n<p>另外，MVCC的实现依赖：<strong>隐藏字段、<strong><strong>Read View</strong></strong>、****undo log</strong>。在底层实现中，InnoDB通过数据行的DB_TRX_ID（事务Id）和Read View来判断数据的可见性，如不可见，则通过数据行DB_ROLL_PTR找到undo log中的历史版本。每个事务读到的数据版本可能是不一样的，在同一个事务里，用户只能看到该事务创建Read View之前已经提交的修改和该事务本身做的修改。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>MySQL InnoDB引擎使用redo log日志保证事务的持久性，使用undo log日志保证事务的原子性。</p>\n<p>MySQL数据库的<strong>数据备份、主备、主主、主从</strong>离不开binlog，需要依赖binlog来同步数据，保证数据的一致性。binlog 的主要目的是复制和恢复。</p>\n<p>undo log 用来回滚行记录到某个版本。事务未提交之前，Undo 保存了未提交之前的版本数据(修改前的数据)Undo 中的数据可作为数据旧版本快照供其他并发事务进行快照读。是为了实现事务的原子性而出现的产物,在 MySQL innodb 存储引擎中用来实现多版本并发控制。</p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/image-20230319000345372.png\" alt=\"img\"></p>\n<p>事务A修改时，这时B事务来读 直接读Undolog的内容</p>\n<h3 id=\"在事务中可以混合使用存储引擎吗？\"><a href=\"#在事务中可以混合使用存储引擎吗？\" class=\"headerlink\" title=\"在事务中可以混合使用存储引擎吗？\"></a>在事务中可以混合使用存储引擎吗？</h3><p>尽量不要</p>\n<p>如果该事务需要回滚，非事务型的表上的变更就无法撤销（无法通过undolog），这会导致数据库处于不一致的状态</p>\n<h3 id=\"MySQL中是如何实现事务隔离的\"><a href=\"#MySQL中是如何实现事务隔离的\" class=\"headerlink\" title=\"MySQL中是如何实现事务隔离的?\"></a>MySQL中是如何实现事务隔离的?</h3><p>读未提交和串行化基本上是不需要考虑的隔离级别，前者不加锁限制，后者相当于单线程执行，效率太差</p>\n<p>MySQL 在可重复读级别解决了幻读问题，是通过行锁和间隙锁的组合 Next-Key 锁实现的。</p>\n<h3 id=\"数据库的乐观锁和悲观锁是什么？怎么实现的？\"><a href=\"#数据库的乐观锁和悲观锁是什么？怎么实现的？\" class=\"headerlink\" title=\"数据库的乐观锁和悲观锁是什么？怎么实现的？\"></a>数据库的乐观锁和悲观锁是什么？怎么实现的？</h3><ul>\n<li>悲观锁：假定会发生并发冲突，在查询完数据的时候就把事务锁起来，直到提交事务。实现方式：使用数据库中的锁机制（多写）</li>\n<li>乐观锁：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。在修改数据的时候把事务锁起来，通过version的方式来进行锁定。实现方式：乐一般会使用版本号机制或CAS算法实现。（多读）</li>\n</ul>\n<h3 id=\"InnoDB引擎的行锁是怎么实现的？\"><a href=\"#InnoDB引擎的行锁是怎么实现的？\" class=\"headerlink\" title=\"InnoDB引擎的行锁是怎么实现的？\"></a>InnoDB引擎的行锁是怎么实现的？</h3><p>InnoDB是基于索引来完成行锁</p>\n<h3 id=\"四⼤特性-ACID\"><a href=\"#四⼤特性-ACID\" class=\"headerlink\" title=\"四⼤特性(ACID)\"></a>四⼤特性(ACID)</h3><p>\\1. 原⼦性（Atomicity）： 事务要么全部发生，要么全部不发生\\2. ⼀致性（Consistency）： 执⾏事务前后，数据保持⼀致\\3. 隔离性（Isolation）： ，⼀个⽤户的事务不被其他事务所⼲扰\\4. 持久性（Durability）： ⼀个事务被提交之后。它对数据库中数据的改变是持久的， </p>\n<h3 id=\"并发事务带来哪些问题\"><a href=\"#并发事务带来哪些问题\" class=\"headerlink\" title=\"并发事务带来哪些问题\"></a>并发事务带来哪些问题</h3><p>脏读 写中读 事务 A 读取了事务 B 更新的数据，然后 B 回滚操作，那么 A 读取到的数据是脏数据</p>\n<p>丢失修改 写写</p>\n<p>不可重复读：两次读的不一样 读写读</p>\n<p>幻读：突然有数据插入</p>\n<h3 id=\"事务隔离级别有哪些-MySQL的默认隔离级别是\"><a href=\"#事务隔离级别有哪些-MySQL的默认隔离级别是\" class=\"headerlink\" title=\"事务隔离级别有哪些?MySQL的默认隔离级别是?\"></a>事务隔离级别有哪些?MySQL的默认隔离级别是?</h3><p>实际上就是数据控制和数据一致性的一个平衡</p>\n<p><strong>READ-UNCOMMITTED(读取未提交) ：最低</strong></p>\n<p><strong>READ-COMMITTED(读取已提交) ：防止脏读</strong></p>\n<p><strong>REPEATABLE-READ(可重复读) ：可以阻⽌脏读和不可重复读，但幻读仍有可能发⽣。</strong></p>\n<p><strong>SERIALIZABLE(可串⾏化) ：最⾼的隔离级别 ，该级别可以防⽌脏读、不可重复读以及幻读</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/image-20230313170422853.png\" alt=\"img\"></p>\n<p><strong>脏读：</strong>一个事务读取数据并且对数据进行了修改，这个修改对其他事务来说是可见的，即使当前事务没有提交。这时另外一个事务读取了这个还未提交的数据，但第一个事务突然回滚，导致数据并没有被提交到数据库，那第二个事务读取到的就是脏数据，这也就是脏读的由来。</p>\n<p><strong>丢失修改：</strong>第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。</p>\n<p><strong>不可重复读：</strong>事务 1 读取某表中的数据 A&#x3D;20，事务 2 也读取 A&#x3D;20，事务 1 修改 A&#x3D;A-1，事务 2 再次读取 A &#x3D;19，此时读取的结果和第一次读取的结果不同。</p>\n<p><strong>幻读：</strong>事务 2 读取某个范围的数据，事务 1 在这个范围插入了新的数据，事务 2 再次读取这个范围的数据发现相比于第一次读取的结果多了新的数据。</p>\n<p>事务隔离机制的实现基于锁机制和并发调度。其中并发调度使用的是MVVC（多版本并发控制），<strong>通过保存修改的旧版本信息来支持并发一致性读和回滚等特性。</strong></p>\n<p><strong>mysql默认REPEATABLE-READ（可重读）</strong> 但mysql的InnoDB 存储引擎 使⽤的是Next-Key Lock 锁算法 ，因此可以避免幻读的产⽣ ，即达到了SQL标准的 SERIALIZABLE(可串⾏化) 隔离级别。 </p>\n<p>InnoDB 存储引擎在 <strong>分布式事务</strong> 的情况下⼀般会⽤到 SERIALIZABLE(可串⾏化) 隔离级别。 </p>\n<h3 id=\"Mysql为什么会选择RR作为默认隔离级别呢？\"><a href=\"#Mysql为什么会选择RR作为默认隔离级别呢？\" class=\"headerlink\" title=\"Mysql为什么会选择RR作为默认隔离级别呢？\"></a><strong>Mysql为什么会选择RR作为默认隔离级别呢？</strong></h3><p>我们的MySQL数据库一般都是集群部署的，会有主库、从库。主库负责写，从库负责读。主库写入之后，会进行主从复制，把数据同步到从库。</p>\n<p>insert into t values(666,2),(233,1);</p>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2023/webp/226907/1684914854724-18475053-6a72-4708-85bd-3e234965b45c.webp\" alt=\"img\"></p>\n<p>执行这两个事务，如果是RC级别，主库数据是（888，2）（233，2）但是binlog是根据事务提交顺序写进去，所以到从库是先B再A 那就数据不一致了</p>\n<p>而在RR（可重复读的数据库隔离级别）下，因为会有<strong>间隙锁</strong>的存在，这种情况就不会发生，因此，Mysql默认选择RR作为隔离级别。</p>\n<h3 id=\"很多大厂为什么选择RC数据库隔离级别？\"><a href=\"#很多大厂为什么选择RC数据库隔离级别？\" class=\"headerlink\" title=\"很多大厂为什么选择RC数据库隔离级别？\"></a>很多大厂为什么选择RC数据库隔离级别？</h3><p>互联网大厂和一些传统企业，最明显的特点就是高并发。那么大厂就<strong>更倾向提高系统的并发读</strong>。</p>\n<p>RC隔离级别，并发度是会比RR更好的，为什么呢？</p>\n<p>因为RC隔离级别，加锁过程中，只需要对修改的记录加行锁。而RR隔离级别，还需要加Gap Lock和Next-Key Lock，即RR隔离级别下，出现死锁的概率大很多。并且，RC还支持半一致读，可以大大的减少了更新语句时行锁的冲突；如果对于不满足更新条件的记录，就可以提前释放锁，提升并发度</p>\n<h3 id=\"解决幻读\"><a href=\"#解决幻读\" class=\"headerlink\" title=\"解决幻读\"></a>解决幻读</h3><p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/image-20230319011414887.png\" alt=\"img\"></p>\n<p><strong>MVCC加上间隙锁的方式</strong>（1）在<strong>快照读</strong>读情况下，mysql通过mvcc来避免幻读。（无锁化）（2）在<strong>当前读</strong>读情况下，mysql通过next-key来避免幻读。锁住某个条件下的数据不能更改。</p>\n<h3 id=\"MySQL的隔离级别是如何实现的？\"><a href=\"#MySQL的隔离级别是如何实现的？\" class=\"headerlink\" title=\"MySQL的隔离级别是如何实现的？\"></a>MySQL的隔离级别是如何实现的？</h3><p>MySQL的隔离级别是通过MVCC和锁机制来实现的。</p>\n<ul>\n<li>RU隔离级别最低，没有加锁，存在脏读问题。事务读不加锁，不阻塞其他事务的读和写</li>\n<li>RC和RR隔离级别可以通过MVCC来实现。</li>\n<li>串行化是通过<strong>锁机制</strong>实现。读加共享锁，写加排他锁，读写互斥。如果有未提交的事务正在修改某些行，所有select这些行的语句都会阻塞。</li>\n</ul>\n<h2 id=\"锁\"><a href=\"#锁\" class=\"headerlink\" title=\"锁\"></a>锁</h2><h3 id=\"为何加锁\"><a href=\"#为何加锁\" class=\"headerlink\" title=\"为何加锁\"></a>为何加锁</h3><p>多用户环境下保证数据库完整性和一致性。</p>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2023/webp/226907/1684914854879-afa0249a-bb45-4f78-ab48-f6c3b02a381b.webp\" alt=\"img\"></p>\n<h3 id=\"锁机制与InnoDB锁算法\"><a href=\"#锁机制与InnoDB锁算法\" class=\"headerlink\" title=\"锁机制与InnoDB锁算法\"></a>锁机制与InnoDB锁算法</h3><p>MyISAM采⽤表级锁(table-level locking)。InnoDB⽀持⾏级锁(row-level locking)和表级锁,默认为⾏级锁 </p>\n<h3 id=\"表级行级对比（按照锁的粒度分数据库锁有哪些？）\"><a href=\"#表级行级对比（按照锁的粒度分数据库锁有哪些？）\" class=\"headerlink\" title=\"表级行级对比（按照锁的粒度分数据库锁有哪些？）\"></a>表级行级对比（按照锁的粒度分数据库锁有哪些？）</h3><p>表级锁： MySQL对当前操作的整张表加锁，实现简单，资源消耗也⽐较少，加锁快，不会出现死锁。，触发锁冲突的概率最⾼，并发度最低， MyISAM和 InnoDB引擎都⽀持表级锁。⾏级锁： MySQL中锁定 粒度最⼩ 的⼀种锁，只针对当前操作的⾏进⾏加锁。 ⾏级锁能⼤⼤减少数据库操作的冲突。其加锁粒度最⼩，并发度⾼，但加锁的开销也最⼤，加锁慢，会出现死锁 </p>\n<h3 id=\"锁的类别来分？\"><a href=\"#锁的类别来分？\" class=\"headerlink\" title=\"锁的类别来分？\"></a>锁的类别来分？</h3><h4 id=\"共享锁\"><a href=\"#共享锁\" class=\"headerlink\" title=\"共享锁\"></a><strong>共享锁</strong></h4><p>其他用户可以并发读取数据，但任何事务都不能获取数据上的排他锁，直到已释放所有共享锁，其他事务只能加共享锁 </p>\n<p>简称为S锁，在事务要读取一条记录时，需要先获取该记录的S锁。</p>\n<h4 id=\"排他锁\"><a href=\"#排他锁\" class=\"headerlink\" title=\"排他锁\"></a><strong>排他锁</strong></h4><p>若事务T对数据对象A加上X锁，则只允许T读取和修改A，其它任何事务都不能再对A加任何类型的锁，直到T释放A上的锁，更新操作始终用排他锁</p>\n<p>简称X锁，在事务需要改动一条记录时，需要先获取该记录的X锁。</p>\n<p><strong>区别</strong>：共享锁上只能再加共享，且只能读不能写。排他锁加上之后其他不能再加任何锁，获取排他锁能写能读。</p>\n<p>他们的加锁开销从大到小，并发能力也是从大到小。</p>\n<p><strong>InnoDB存储引擎的锁</strong>的算法有三种：Record lock：单个⾏记录上的锁Gap lock：间隙锁，锁定⼀个范围，不包括记录本身Next-key lock： record+gap 锁定⼀个范围，包含记录本身，可解决幻读问题</p>\n<p>相关知识点</p>\n<p>innodb对于⾏的查询使⽤next-key lock当查询的索引含有唯⼀属性时，将next-key lock降级为record key</p>\n<h4 id=\"意向锁\"><a href=\"#意向锁\" class=\"headerlink\" title=\"意向锁\"></a>意向锁</h4><p>什么是意向锁呢？意向锁是<strong>一种不与行级锁冲突的表级锁</strong>。未来的某个时刻，事务可能要加共享或者排它锁时，先提前声明一个意向。注意一下，意向锁，是一个<strong>表级别的锁哈</strong></p>\n<ul>\n<li>意向共享锁：简称IS锁，当事务准备在某些记录上加S锁时，需要现在表级别加一个IS锁。</li>\n<li>意向排他锁：简称IX锁，当事务准备在某条记录上加上X锁时，需要现在表级别加一个IX锁。</li>\n</ul>\n<p>意向锁又是如何解决这个效率低的问题呢：</p>\n<p>如果一个事务A获取到某一行的排他锁，并未提交,这时候表上就有意向排他锁和这一行的排他锁。这时候事务B想要获取这个表的共享锁，此时因为检测到事务A持有了表的意向排他锁，因此事务A必然持有某些行的排他锁，也就是说事务B对表的加锁请求需要阻塞等待，不再需要去检测表的每一行数据是否存在排他锁啦。</p>\n<h4 id=\"记录锁\"><a href=\"#记录锁\" class=\"headerlink\" title=\"记录锁\"></a>记录锁</h4><p>记录锁是最简单的行锁，仅仅锁住一行。如：SELECT c1 FROM t WHERE c1 &#x3D; 10 FOR UPDATE，如果C1字段是主键或者是唯一索引的话，这个SQL会加一个记录锁（Record Lock）</p>\n<p>记录锁永远都是加在索引上的，即使一个表没有索引，InnoDB也会隐式的创建一个索引，并使用这个索引实施记录锁。它会阻塞其他事务对这行记录的插入、更新、删除。</p>\n<h4 id=\"间隙锁（Gap-Lock）\"><a href=\"#间隙锁（Gap-Lock）\" class=\"headerlink\" title=\"间隙锁（Gap Lock）\"></a>间隙锁（Gap Lock）</h4><p>为了解决幻读问题，InnoDB引入了间隙锁(Gap Lock)。间隙锁是一种加在两个索引之间的锁，或者加在第一个索引之前，或最后一个索引之后的间隙。它锁住的是<strong>一个区间</strong>，而不仅仅是这个区间中的每一条数据</p>\n<h4 id=\"临键锁-Next-Key-Lock\"><a href=\"#临键锁-Next-Key-Lock\" class=\"headerlink\" title=\"临键锁(Next-Key Lock)\"></a>临键锁(Next-Key Lock)</h4><p>Next-key锁是<strong>记录锁和间隙锁的组合</strong>，它指的是加在某条记录以及这条记录前面间隙上的锁。说得更具体一点就是:临键锁会封锁索引记录本身，以及索引记录之前的区间，即它的锁区间是前开后闭，比如(5,10]。</p>\n<p>如果一个会话占有了索引记录R的共享&#x2F;排他锁，其他会话不能立刻在R之前的区间插入新的索引记录。</p>\n<h3 id=\"插入意向锁\"><a href=\"#插入意向锁\" class=\"headerlink\" title=\"插入意向锁\"></a>插入意向锁</h3><p>插入意向锁,是插入一行记录操作之前设置的<strong>一种间隙锁</strong>，这个锁释放了一种插入方式的信号。 它解决的问题：多个事务，在同一个索引，同一个范围区间插入记录时，如果插入的位置不冲突，不会阻塞彼此。</p>\n<p>假设有索引值4、7，几个不同的事务准备插入5、6，每个锁都在获得插入行的独占锁之前用插入意向锁各自锁住了4、7之间的间隙，但是不阻塞对方因为插入行不冲突。以下就是一个插入意向锁的日志：</p>\n<h3 id=\"自增锁\"><a href=\"#自增锁\" class=\"headerlink\" title=\"自增锁\"></a>自增锁</h3><p><strong>自增锁是一种特殊的表级别锁</strong>。它是专门针对AUTO_INCREMENT类型的列，对于这种列，如果表中新增数据时就会去持有自增锁。简言之，如果一个事务正在往表中插入记录，所有其他事务的插入必须等待，以便第一个事务插入的行，是连续的主键值。</p>\n<h4 id=\"乐观悲观\"><a href=\"#乐观悲观\" class=\"headerlink\" title=\"乐观悲观\"></a>乐观悲观</h4><p>一个事务拥有（获得）悲观锁后，其他任何事务都不能对数据进行修改啦，只能等待锁被释放才可以执行。 select…for update就是<strong>MySQL悲观锁</strong>的应用。</p>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2023/webp/226907/1684914854879-1771c7d7-9b36-4654-9cfe-b44e6a8f3f7d.webp\" alt=\"img\"></p>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2023/webp/226907/1684914855061-bf94295e-5089-4ec5-8977-0dbca9c59501.webp\" alt=\"img\"></p>\n<p>乐观锁的“乐观情绪”体现在，它认为数据的变动不会太频繁。因此，它允许多个事务同时对数据进行变动。实现方式：乐观锁一般会通过version版本号&#x2F;时间戳判断记录是否被更改过，一般配合CAS算法实现。</p>\n<h3 id=\"select-for-update加的是表锁还是行锁\"><a href=\"#select-for-update加的是表锁还是行锁\" class=\"headerlink\" title=\"select for update加的是表锁还是行锁\"></a>select for update加的是表锁还是行锁</h3><p>这道面试题，一般需要分两种数据库隔离级别（RR和RC），还需要分查询条件是唯一索引、主键、一般索引、无索引等几种情况分开讨论</p>\n<p><strong>在RC隔离级别下</strong></p>\n<ul>\n<li>如果查询条件是唯一索引，会加IX意向排他锁（表级别的锁，不影响插入）、两把X排他锁（行锁，分别对应唯一索引，主键索引）</li>\n<li>如果查询条件是主键，会加IX意向排他锁（表级别的锁，不影响插入）、一把对应主键的X排他锁（行锁，会锁住主键索引那一行）。</li>\n<li>如果查询条件是普通索引，<strong>如果查询命中记录</strong>，会加IX意向排他锁（表锁）、两把X排他锁（行锁，分别对应普通索引的X锁，对应主键的X锁）;<strong>如果没有命中数据库表的记录</strong>，只加了一把IX意向排他锁（表锁，不影响插入）</li>\n<li>如果查询条件是无索引，会加两把锁，IX意向排他锁（表锁）、一把X排他锁（行锁，对应主键的X锁）。</li>\n</ul>\n<p>查询条件是无索引，为什么不锁表呢？ MySQL会走聚簇(主键)索引进行全表扫描过滤。每条记录都会加上X锁。但是，为了效率考虑，MySQL在这方面进行了改进，在扫描过程中，若记录不满足过滤条件，会进行解锁操作。同时优化违背了2PL原则&#96;&#96;&#96;。</p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/640\" alt=\"img\"></p>\n<p><strong>引申：</strong></p>\n<p><strong>为什么不是唯一索引上加X锁就可以了呢？为什么主键索引上的记录也要加锁呢？</strong></p>\n<p>如果并发的一个SQL，通过<strong>主键索引来更新</strong>：update user_info_tab set user_name &#x3D; ‘学友’ where id &#x3D; ‘1570068’;此时，如果select…for update语句没有将主键索引上的记录加锁，那么并发的update就会感知不到select…for update语句的存在，违背了<strong>同一记录</strong>上的<strong>更新&#x2F;删除</strong>需要串行执行的约束。</p>\n<p><strong>在RR隔离级别</strong></p>\n<ul>\n<li>如果查询条件是唯一索引，命中数据库表记录时，一共会加三把锁：一把IX意向排他锁 （表锁，不影响插入），一把对应主键的X排他锁（行锁），一把对应唯一索引的X排他锁 （行锁）。</li>\n<li>如果查询条件是主键，会加IX意向排他锁（表级别的锁，不影响插入）、一把对应主键的X排他锁（行锁，会锁住主键索引那一行）。</li>\n<li>如果查询条件是普通索引，命中查询记录的话，除了会加X锁（行锁），IX锁（表锁，不影响插入），还会加Gap 锁（间隙锁，会影响插入）。</li>\n<li>如果查询条件是无索引，会加一个IX锁（表锁，不影响插入），每一行实际记录行的X锁，还有对应于supremum pseudo-record的虚拟全表行锁。这种场景，通俗点讲，其实就是锁表了。</li>\n</ul>\n<h3 id=\"InnoDB引擎的行锁是怎么实现的？-1\"><a href=\"#InnoDB引擎的行锁是怎么实现的？-1\" class=\"headerlink\" title=\"InnoDB引擎的行锁是怎么实现的？\"></a>InnoDB引擎的行锁是怎么实现的？</h3><p>InnoDB是基于索引来完成行锁</p>\n<p>例: select * from tab_with_index where id &#x3D; 1 for update;</p>\n<p>for update 可以根据条件来完成行锁锁定，并且 id 是有索引键的列，如果 id 不是索引键那么InnoDB将完成表锁，并发将无从谈起</p>\n<h3 id=\"死锁？避免死锁？\"><a href=\"#死锁？避免死锁？\" class=\"headerlink\" title=\"死锁？避免死锁？\"></a><strong>死锁？避免死锁？</strong></h3><p>两个或多个事务在同一资源上相互占用，并请求锁定对方的资源，从而导致恶性循环的现象。</p>\n<p>1、用表级锁</p>\n<p>2、约定相同顺序</p>\n<p>3、尽可能一次锁定所有资源</p>\n<p>4、尽量避免大事务，建议拆成多个小事务。因为大事务占用的锁资源越多，越容易出现死锁。</p>\n<p>5、降低数据库隔离级别，比如RR降低为RC，因为RR隔离级别，存在GAP锁，死锁概率大很多。</p>\n<p>6、死锁与索引是密不可分的，合理优化你的索引，死锁概率降低。</p>\n<p>7、如果业务处理不好可以用分布式事务锁或者使用乐观锁</p>\n<h3 id=\"隔离级别与锁的关系\"><a href=\"#隔离级别与锁的关系\" class=\"headerlink\" title=\"隔离级别与锁的关系\"></a>隔离级别与锁的关系</h3><p>在Read Uncommitted级别下，读取数据不需要加共享锁，这样就不会跟被修改的数据上的排他锁冲突</p>\n<p>在Read Committed级别下，读操作需要加共享锁，但是在语句执行完以后释放共享锁；</p>\n<p>在Repeatable Read级别下，读操作需要加共享锁，但是在事务提交之前并不释放共享锁，也就是必须等待事务执行完毕以后才释放共享锁。</p>\n<p>SERIALIZABLE 是限制性最强的隔离级别，因为该级别锁定整个范围的键，并一直持有锁，直到事务完成。</p>\n<h3 id=\"数据库的乐观锁和悲观锁是什么？怎么实现的？-1\"><a href=\"#数据库的乐观锁和悲观锁是什么？怎么实现的？-1\" class=\"headerlink\" title=\"数据库的乐观锁和悲观锁是什么？怎么实现的？\"></a>数据库的乐观锁和悲观锁是什么？怎么实现的？</h3><p>数据库管理系统（DBMS）中的并发控制的任务是确保在多个事务同时存取数据库中同一数据时不破坏事务的隔离性和统一性以及数据库的统一性。乐观并发控制（乐观锁）和悲观并发控制（悲观锁）是并发控制主要采用的技术手段。</p>\n<p>悲观锁（多写）：假定会发生并发冲突，在查询完数据的时候就把事务锁起来，直到提交事务。实现方式：使用数据库中的锁机制</p>\n<p>乐观锁(多读)：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。在修改数据的时候把事务锁起来,实现方式：一般会使用版本号机制或CAS算法实现。</p>\n<h3 id=\"优化锁方面的意见？\"><a href=\"#优化锁方面的意见？\" class=\"headerlink\" title=\"优化锁方面的意见？\"></a>优化锁方面的意见？</h3><p>较低的隔离级别设计索引，尽量使用索引去访问数据</p>\n<p>加锁更加精确，从而减少锁冲突申请合适的锁。最好一次性请求足够级别的锁且不要申请超过实际需要的锁级别。列如，修改数据的话，最好申请排他锁，而不是先申请共享锁不同的程序访问一组表的时候，应尽量约定一个相同的顺序访问各表，对于一个表而言，尽可能的固定顺序的获取表中的行。这样大大的减少死锁的机会。尽量使用相等条件访问数据，这样可以避免间隙锁对并发插入的影响数据查询的时候不是必要，不要使用加锁。MySQL的MVCC可以实现事务中的查询不用加锁，优化事务性能：MVCC只在committed read（读提交）和 repeatable read （可重复读）两种隔离级别对于特定的事务，可以使用表锁来提高处理速度活着减少死锁的可能。</p>\n<h2 id=\"分库分表\"><a href=\"#分库分表\" class=\"headerlink\" title=\"分库分表\"></a>分库分表</h2><h3 id=\"为什么要分库分表\"><a href=\"#为什么要分库分表\" class=\"headerlink\" title=\"为什么要分库分表\"></a>为什么要分库分表</h3><p>单表数据量太大，会极大影响你的 sql执行的性能</p>\n<p>分表：</p>\n<p>分表就是把一个表的数据放到多个表中，然后查询的时候你就查一个表。比如按照用户 id 来分表，将一个用户的数据就放在一个表中。然后操作的时候你对一个用户就操作那个表就好了。这样可以控制每个表的数据量在可控的范围内，比如每个表就固定在 200 万以内。</p>\n<p>分库：</p>\n<p>一个库一般我们经验而言，最多支撑到并发 2000，一定要扩容了，可以将一个库的数据拆分到多个库中，访问的时候就访问一个库好了。</p>\n<h3 id=\"如何对数据库如何进行垂直拆分或水平拆分的？\"><a href=\"#如何对数据库如何进行垂直拆分或水平拆分的？\" class=\"headerlink\" title=\"如何对数据库如何进行垂直拆分或水平拆分的？\"></a>如何对数据库如何进行垂直拆分或水平拆分的？</h3><p><strong>水平拆分</strong>的意思，就是把一个表的数据给弄到多个库的多个表里去，但是每个库的表结构都一样，水平拆分的意义，就是将数据均匀放更多的库里，然后用多个库来抗更高的并发</p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/10089464-0e01dfe246b5c7ac.png\" alt=\"img\"></p>\n<p><strong>垂直拆分</strong>的意思，就是<strong>把一个有很多字段的表给拆分成多个表</strong>，<strong>或者是多个库上去</strong>。每个库表的结构都不一样，每个库表都包含部分字段。一般来说，会<strong>将较少的访问频率很高的字段放到一个表里去</strong>，然后<strong>将较多的访问频率很低的字段放到另外一个表里去</strong>。因为数据库是有缓存的，<strong>你访问频率高的行字段越少，就可以在缓存里缓存更多的行</strong>，性能就越好。这个一般在表层面做的较多一些。</p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/10089464-ab3069913c0f097c.png\" alt=\"img\"></p>\n<p>两种<strong>分库分表的方式</strong>：</p>\n<ul>\n<li>一种是按照 <strong>range</strong> 来分，就是每个库一段连续的数据，这个一般是按比如<strong>时间范围</strong>来的，但是这种一般较少用，因为很容易产生<strong>热点问题</strong>，大量的流量都打在最新的数据上了。</li>\n<li>或者是<strong>按照某个字段hash一下均匀分散</strong>，这个较为常用。</li>\n</ul>\n<p>range 来分，好处在于说，扩容的时候很简单，因为你只要预备好，给每个月都准备一个库就可以了，到了一个新的月份的时候，自然而然，就会写新的库了；缺点，<strong>但是大部分的请求，都是访问最新的数据</strong>。实际生产用 range，要看场景。</p>\n<p>hash 分发，好处在于说，可以平均分配每个库的数据量和请求压力；坏处在于说扩容起来比较麻烦，会有一个数据迁移的过程，<strong>之前的数据需要重新计算 hash 值重新分配到不同的库或表</strong></p>\n<h2 id=\"读写分离、主从复制\"><a href=\"#读写分离、主从复制\" class=\"headerlink\" title=\"读写分离、主从复制\"></a>读写分离、主从复制</h2><h3 id=\"什么是MySQL主从复制\"><a href=\"#什么是MySQL主从复制\" class=\"headerlink\" title=\"什么是MySQL主从复制\"></a>什么是MySQL主从复制</h3><p>使得数据可以从一个数据库服务器复制到其他服务器上，在复制数据时，一个服务器充当主服务器（master），其余的服务器充当从服务器（slave）。</p>\n<h3 id=\"主从复制目的？为什么主从复制\"><a href=\"#主从复制目的？为什么主从复制\" class=\"headerlink\" title=\"主从复制目的？为什么主从复制\"></a>主从复制目的？为什么主从复制</h3><ol>\n<li>**提高数据库的性能，***<strong>在主服务器上执行写入和更新，在从服务器上向外提供读功能</strong></li>\n<li><strong>提高数据安全</strong>-从服务器上备份主服务器相应数据</li>\n<li>在主服务器上<strong>生成实时数据，而在从服务器上分析这些数据</strong>，从而提高主服务器的性能</li>\n<li>数据备份。</li>\n</ol>\n<h3 id=\"如何实现MySQL的读写分离？\"><a href=\"#如何实现MySQL的读写分离？\" class=\"headerlink\" title=\"如何实现MySQL的读写分离？\"></a>如何实现MySQL的读写分离？</h3><p>搞一个主库，挂多个从库，然后我们只写主库，读从库，然后主库会自动把数据给同步到从库上去。</p>\n<h3 id=\"MySQL主从复制流程和原理？\"><a href=\"#MySQL主从复制流程和原理？\" class=\"headerlink\" title=\"MySQL主从复制流程和原理？\"></a>MySQL主从复制流程和原理？</h3><p>基本原理流程，是3个线程以及之间的关联</p>\n<p>主：binlog线程——记录下所有改变了数据库数据的语句，放进master上的binlog中；</p>\n<p>从：io线程——在使用start slave 之后，负责从master上拉取 binlog 内容，放进自己的relay log中；</p>\n<p>从：sql执行线程——执行relay log中的语句；</p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/image-20230319151800745.png\" alt=\"img\"></p>\n<p>Binary log：主数据库的二进制日志</p>\n<p>Relay log：从服务器的中继日志</p>\n<p>第一步：master在每个事务更新数据完成之前，将该操作记录串行地写入到binlog文件中。</p>\n<p>第二步：salve开启一个I&#x2F;O Thread，该线程在master打开一个普通连接，主要工作是binlog dump process。如果读取的进度已经跟上了master，就进入睡眠状态并等待master产生新的事件。I&#x2F;O线程最终的目的是将这些事件写入到中继日志中。</p>\n<p>第三步：SQL Thread会读取中继日志，并顺序执行该日志中的SQL事件，从而与主数据库中的数据保持一致。</p>\n<h3 id=\"MySQL主从同步延时问题如何解决？\"><a href=\"#MySQL主从同步延时问题如何解决？\" class=\"headerlink\" title=\"MySQL主从同步延时问题如何解决？\"></a>MySQL主从同步延时问题如何解决？</h3><p>两个同步机制，一个是半同步复制，用来 解决主库数据丢失问题；</p>\n<p>一个是并行复制，用来 解决主从同步延时问题。</p>\n<p>半同步复制，也叫 semi-sync 复制，指的就是主库写入 binlog 日志之后，就会将强制此时立即将数据同步到从库，从库将日志写入自己本地的 relay log 之后，接着会返回一个 ack 给主库，主库接收到至少一个从库的 ack 之后才会认为写操作完成了。<strong>并行复制，</strong>指的是从库开启多个线程，并行读取 relay log 中不同库的日志，然后并行重放不同库的日志，这是库级别的并行。</p>\n<p>DDL:数据定义语言 CREATE（建表）、ALTER（增删字段）、DROP和TRUNCATE（删除表）</p>\n<p>DML：数据操纵语言（insert、update、delete）</p>\n<p>DQL：数据查询语言</p>\n<h2 id=\"优化\"><a href=\"#优化\" class=\"headerlink\" title=\"优化\"></a>优化</h2><h3 id=\"如何定位及优化SQL语句的性能问题？\"><a href=\"#如何定位及优化SQL语句的性能问题？\" class=\"headerlink\" title=\"如何定位及优化SQL语句的性能问题？\"></a>如何定位及优化SQL语句的性能问题？</h3><p>explain：是否使用索引、使用什么索引、使用索引相关信息</p>\n<h3 id=\"大表数据查询优化？\"><a href=\"#大表数据查询优化？\" class=\"headerlink\" title=\"大表数据查询优化？\"></a>大表数据查询优化？</h3><p>1、加缓存 redis</p>\n<p>2、sql语句+索引</p>\n<p>3、主从复制、读写分离</p>\n<p>4、垂直拆分 水平拆分</p>\n<h3 id=\"超大分页怎么处理-MySQL深分页\"><a href=\"#超大分页怎么处理-MySQL深分页\" class=\"headerlink\" title=\"超大分页怎么处理(MySQL深分页)\"></a>超大分页怎么处理(MySQL深分页)</h3><p>limit:1000000开始取10条</p>\n<p>select * from table where age &gt; 20 limit 1000000，10优化为&#x3D;》</p>\n<p>我们先来看下这个SQL的执行流程：</p>\n<ol>\n<li>通过<strong>普通二级索引树</strong>idx_update_time，过滤update_time条件，找到满足条件的记录ID。</li>\n<li>通过ID，回到<strong>主键索引树</strong>，找到满足记录的行，然后取出展示的列（<strong>回表</strong>）</li>\n<li>扫描满足条件的100010行，然后扔掉前100000行，返回。</li>\n</ol>\n<p><strong>SQL变慢原因有两个</strong>：</p>\n<ol>\n<li>limit语句会先扫描offset+n行，然后再丢弃掉前offset行，返回后n行数据。也就是说limit 100000,10，就会扫描100010行，而limit 0,10，只扫描10行。</li>\n<li>limit 100000,10 扫描更多的行数，也意味着<strong>回表</strong>更多的次数。</li>\n</ol>\n<p><strong>通过子查询优化</strong></p>\n<p>select * from table where id in (select id from table where age &gt; 20 limit 1000000,10)</p>\n<p>子查询 table a查询是用到了idx_update_time索引。首先在索引上拿到了聚集索引的主键ID,省去了回表操作，然后第二查询直接根据第一个查询的 ID往后再去查10个就可以了!</p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/1669949ca6818e4a0c87f754364a94d5.png\" alt=\"img\"></p>\n<p>虽然也 load 了一百万的数据,但是由于索引覆盖,要查询的所有字段都在索引中（age）,所以速度会很快。</p>\n<h3 id=\"统计过慢查询吗？慢查询怎么优化\"><a href=\"#统计过慢查询吗？慢查询怎么优化\" class=\"headerlink\" title=\"统计过慢查询吗？慢查询怎么优化\"></a>统计过慢查询吗？慢查询怎么优化</h3><ul>\n<li>首先分析语句，<strong>看看是否load了额外的数据</strong>，可能是查询了多余的行并且抛弃掉了，可能是加载了许多结果中并不需要的列，对语句进行分析以及重写。</li>\n<li>分析语句的执行计划，然后获得其使用索引的情况，之后<strong>修改语句或者修改索引，使得语句可以尽可能的命中索引。</strong></li>\n<li>如果对语句的优化已经无法进行，可以考虑表中的<strong>数据量</strong>是否太大，如果是的话可以进行横向或者纵向的分表。</li>\n</ul>\n<p>1、Load额外数据-2、修改索引，尽量命中3、数据量大？分表</p>\n<h3 id=\"如何优化查询过程中的数据访问\"><a href=\"#如何优化查询过程中的数据访问\" class=\"headerlink\" title=\"如何优化查询过程中的数据访问\"></a>如何优化查询过程中的数据访问</h3><ul>\n<li>访问数据太多导致查询性能下降</li>\n<li>确定应用程序是否在检索大量超过需要的数据，可能是太多行或列</li>\n<li>确认MySQL服务器是否在分析大量不必要的数据行</li>\n<li>查询不需要的数据。解决办法：使用<strong>limit</strong>解决</li>\n<li>多表关联返回全部列。解决办法：指定列名</li>\n<li>总是返回全部列。解决办法：<strong>避免使用SELECT *</strong></li>\n<li>重复查询相同的数据。解决办法：可以缓存数据，下次直接读取缓存</li>\n<li>是否在扫描额外的记录。解决办法： 使用explain进行分析，如果发现查询需要扫描大量的数据，但只返回少数的行，可以通过如下技巧去优化： <strong>使用索引覆盖扫描，把所有的列都放到索引中，这样存储引擎不需要回表获取对应行就可以返回结果。</strong></li>\n<li>改变数据库和表的结构，修改数据表范式</li>\n<li>重写SQL语句，让优化器可以以更优的方式执行查询。</li>\n</ul>\n<h3 id=\"优化关联查询\"><a href=\"#优化关联查询\" class=\"headerlink\" title=\"优化关联查询\"></a>优化关联查询</h3><ul>\n<li>确定ON或者USING子句中是否有索引。</li>\n<li>确保GROUP BY和ORDER BY只有一个表中的列，这样MySQL才有可能使用索引。</li>\n</ul>\n<h3 id=\"数据库结构优化\"><a href=\"#数据库结构优化\" class=\"headerlink\" title=\"数据库结构优化\"></a>数据库结构优化</h3><p><strong>1、将字段很多的表分解成多个表</strong></p>\n<p>因为当一个表的数据量很大时，会由于使用频率低的字段的存在而变慢。</p>\n<p><strong>2、增加中间表</strong>对于需要经常联合查询的表，可以建立中间表以提高查询效率。</p>\n<p>通过建立中间表，将需要通过联合查询的数据插入到中间表中，然后将原来的联合查询改为对中间表的查询。</p>\n<p><strong>3、增加冗余字段</strong>合理的加入冗余字段可以提高查询速度。</p>\n<p>表的规范化程度越高，表和表之间的关系越多，需要连接查询的情况也就越多，性能也就越差。</p>\n<p>注意：</p>\n<p>冗余字段的值在一个表中修改了，就要想办法在其他表中更新，否则就会导致数据不一致的问题。</p>\n<h3 id=\"MySQL数据库cpu飙升到500-的话他怎么处理？\"><a href=\"#MySQL数据库cpu飙升到500-的话他怎么处理？\" class=\"headerlink\" title=\"MySQL数据库cpu飙升到500%的话他怎么处理？\"></a>MySQL数据库cpu飙升到500%的话他怎么处理？</h3><p>top 命令观察是不是 MySQLd 占用导致的，不是，占用高进程杀死</p>\n<p>是的话， show processlist，看看里面跑的 session 情况，找出消耗高的 sql，看是不是Index少了或者数据量大</p>\n<p>kill掉，加索引、改sql、改内存参数，重新跑</p>\n<p>session变多，限制连接数</p>\n<h3 id=\"大表优化\"><a href=\"#大表优化\" class=\"headerlink\" title=\"大表优化\"></a>大表优化</h3><p>1、限定数据范围</p>\n<p>2、读写分离 主库负责写，从库负责读 </p>\n<p>3、垂直分区 优点：列数据变小 缺点：主键冗余，产生join</p>\n<p>4、水平分区 每⼀⽚数据分散到不同的表或者库中，达到了分布式的⽬的。 ⽔平拆分可以⽀撑⾮常⼤的数据量 </p>\n<p>数据库分⽚的两种常⻅⽅案：<strong>客户端代理</strong>： 分⽚逻辑在应⽤端，封装在jar包中，通过修改或者封装JDBC层来实现。<strong>中间件代理</strong>： 在应⽤和数据中间加了⼀个代理层。分⽚逻辑统⼀维护在中间件服务中。 </p>\n<h2 id=\"解释⼀下什么是池化设计思想。什么是数据库连接池-为什么需要数据库连接池\"><a href=\"#解释⼀下什么是池化设计思想。什么是数据库连接池-为什么需要数据库连接池\" class=\"headerlink\" title=\"解释⼀下什么是池化设计思想。什么是数据库连接池?为什么需要数据库连接池?\"></a>解释⼀下什么是池化设计思想。什么是数据库连接池?为什么需要数据库连接池?</h2><p>java线程池、 jdbc连接池、 redis连接池 </p>\n<p>数据库连接池：多个socket 的连接 </p>\n<p>为什么需要？：减少用户等待时间</p>\n<h2 id=\"分库分表之后-id-主键如何处理？\"><a href=\"#分库分表之后-id-主键如何处理？\" class=\"headerlink\" title=\"分库分表之后,id 主键如何处理？\"></a>分库分表之后,id 主键如何处理？</h2><p>自增 设置不同步长 有序 不好部署</p>\n<p>redis生成</p>\n<p>leaf分布式id 保证证全局唯⼀性、趋势递增、单调递增、信息安全</p>\n<p>雪花算法 ：分布式id mp</p>\n<h2 id=\"⼀条SQL语句在MySQL中如何执⾏的\"><a href=\"#⼀条SQL语句在MySQL中如何执⾏的\" class=\"headerlink\" title=\"⼀条SQL语句在MySQL中如何执⾏的\"></a>⼀条SQL语句在MySQL中如何执⾏的</h2><p>查询：</p>\n<p>1、客户端通过 TCP 连接发送连接请求到 MySQL连接器,检查账号密码，再检查该语句是否有权限，如果没有权限，返回错误信息，如果有权限，会以这条 sql 语句为 key先查询缓存（8.0之后取消了，因为一更新缓存失效，缓存了个寂寞）， 如果有，直接返回，如果没有，执行下一步。</p>\n<p>2、通过分析器进行<strong>词法分析</strong>，提取 sql 语句的关键元素，（构建SQL语法树，表名 select啥的），然后语法分析，判断 sql 语句是否有错误，如果检查没问题就执行下一步。</p>\n<p>3、优化器根据自己的优化算法进行优化（比如先查谁再执行谁，优化器认为，有时候不一定最好），开始执行</p>\n<p>4、交给执行器，将数据保存到结果集中，同时会逐步将数据缓存到查询缓存中，最终将结果集返回给客户端</p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/4102b7d60fa20a0caabb127ecbb4d2f3.jpeg\" alt=\"img\"></p>\n<p>更新：</p>\n<p>需要检查表是否有排它锁，写 binlog，刷盘，是否执行 commit。</p>\n<ol>\n<li>前面和查询一样，走缓存</li>\n<li>拿到查询的语句，然后更新，然后调用引擎 API 接口，写入这一行数据，InnoDB 引擎把数据保存在内存中，同时记录 redo log，此时 redo log 进入 prepare 状态，然后告诉执行器，执行完成了，随时可以提交。</li>\n<li>执行器收到通知后记录 binlog，然后调用引擎接口，提交 redo log 为提交状态，更新完成。</li>\n</ol>\n<p>总结：redolog—redolog_prepare—-binlog—redolog_commit</p>\n<h3 id=\"假设-redo-log-处于预提交状态，binglog-也已经写完了，这个时候发生了异常重启会怎么样呢？\"><a href=\"#假设-redo-log-处于预提交状态，binglog-也已经写完了，这个时候发生了异常重启会怎么样呢？\" class=\"headerlink\" title=\"假设 redo log 处于预提交状态，binglog 也已经写完了，这个时候发生了异常重启会怎么样呢？\"></a>假设 redo log 处于预提交状态，binglog 也已经写完了，这个时候发生了异常重启会怎么样呢？</h3><p>这个就要依赖于 MySQL 的处理机制了，MySQL 的处理过程如下：</p>\n<p>•判断 redo log 是否完整，如果判断是完整的，就立即提交。</p>\n<p>•如果 redo log 只是预提交但不是 commit 状态，这个时候就会去判断 binlog 是否完整，如果完整就提交 redo log, 不完整就回滚事务。</p>\n<p>这样就解决了数据一致性的问题</p>\n","categories":["八股"]},{"title":"JAVA集合","url":"/2023/06/04/JAVA%E9%9B%86%E5%90%88/","content":"<h2 id=\"常见的集合有哪些？\"><a href=\"#常见的集合有哪些？\" class=\"headerlink\" title=\"常见的集合有哪些？\"></a>常见的集合有哪些？</h2><p>Java集合类主要由两个根接口<strong>Collection</strong>和<strong>Map</strong>派生出来的，Collection派生出了三个子接口：List、Set、Queue<span id=\"more\"></span>（Java5新增的队列），因此Java集合大致也可分成List、Set、Queue、Map四种接口体系。</p>\n<p><strong>注意：Collection是一个接口，Collections是一个工具类，Map不是Collection的子接口</strong>。</p>\n<p>Java集合框架图如下：</p>\n<p>图中，List代表了有序可重复集合，可直接根据元素的索引来访问；Set代表无序不可重复集合，只能根据元素本身来访问；Queue是队列集合。</p>\n<p>Map代表的是存储key-value对的集合，可根据元素的key来访问value。</p>\n<p>上图中淡绿色背景覆盖的是集合体系中常用的实现类，分别是ArrayList、LinkedList、ArrayQueue、HashSet、TreeSet、HashMap、TreeMap等实现类</p>\n<h2 id=\"线程安全的集合有哪些？线程不安全的呢？\"><a href=\"#线程安全的集合有哪些？线程不安全的呢？\" class=\"headerlink\" title=\"线程安全的集合有哪些？线程不安全的呢？\"></a>线程安全的集合有哪些？线程不安全的呢？</h2><p>线程安全的：</p>\n<ul>\n<li>Hashtable：比HashMap多了个线程安全。</li>\n<li>ConcurrentHashMap:是一种高效但是线程安全的集合。</li>\n<li>Vector：比Arraylist多了个同步化机制。</li>\n<li>Stack：栈，也是线程安全的，继承于Vector。</li>\n</ul>\n<p>线性不安全的：</p>\n<ul>\n<li>HashMap</li>\n<li>Arraylist</li>\n<li>LinkedList</li>\n<li>HashSet</li>\n<li>TreeSet</li>\n</ul>\n<h2 id=\"说说List-Set-Map三者的区别？\"><a href=\"#说说List-Set-Map三者的区别？\" class=\"headerlink\" title=\"说说List,Set,Map三者的区别？\"></a>说说List,Set,Map三者的区别？</h2><p>List 有序的、可重复的。Set⽆序的、不可重复的。Map ⽆序的，key不可重复、value 可重复</p>\n<p><strong>HashSet 和 HashMap 区别?</strong></p>\n<p>HashSet的底层其实就是HashMap，只不过我们<strong>HashSet是实现了Set接口并且把数据作为K值，而V值一直使用一个相同的虚值来保存</strong>。</p>\n<p>由于HashMap的K值本身就不允许重复，并且在HashMap中如果K&#x2F;V相同时，会用新的V覆盖掉旧的V，然后返回旧的V，那么在HashSet中执行这一句话始终会返回一个false，导致插入失败，这样就保证了数据的不可重复性。</p>\n<h2 id=\"Arraylist-与-LinkedList-区别\"><a href=\"#Arraylist-与-LinkedList-区别\" class=\"headerlink\" title=\"Arraylist 与 LinkedList 区别?\"></a>Arraylist 与 LinkedList 区别?</h2><p>1、底层一个数组 一个双向链表</p>\n<p>2、增删 和查的效率问题</p>\n<p>3、内存空间，Arraylist 预留空间 LinkedList指针</p>\n<h2 id=\"说⼀说-ArrayList-的扩容机制吧\"><a href=\"#说⼀说-ArrayList-的扩容机制吧\" class=\"headerlink\" title=\"说⼀说 ArrayList 的扩容机制吧\"></a>说⼀说 ArrayList 的扩容机制吧</h2><p>if 容量&#x3D;&#x3D;0，第一次添加元素容量为 10 </p>\n<p>else 会将修改次数 modCount++，并且会将原数组中的元素，拷贝至新数组中，新数组的大小是</p>\n<p>原数组的 1.5 倍</p>\n<h2 id=\"Array-和-ArrayList-有什么区别？什么时候该应-Array-而不是-ArrayList-呢？\"><a href=\"#Array-和-ArrayList-有什么区别？什么时候该应-Array-而不是-ArrayList-呢？\" class=\"headerlink\" title=\"Array 和 ArrayList 有什么区别？什么时候该应 Array 而不是 ArrayList 呢？\"></a>Array 和 ArrayList 有什么区别？什么时候该应 Array 而不是 ArrayList 呢？</h2><ul>\n<li>Array 可以包含基本类型和对象类型，ArrayList 只能包含对象类型。</li>\n<li>Array 大小是固定的，ArrayList 的大小是动态变化的。</li>\n<li>ArrayList 提供了更多的方法和特性，比如：addAll()，removeAll()，iterator() 等等。</li>\n</ul>\n<h2 id=\"ArrayList-与-Vector-区别？\"><a href=\"#ArrayList-与-Vector-区别？\" class=\"headerlink\" title=\"ArrayList 与 Vector 区别？\"></a>ArrayList 与 Vector 区别？</h2><ul>\n<li>Vector是线程安全的，ArrayList不是线程安全的。其中，Vector在关键性的方法前面都加了<strong>synchronized</strong>关键字，来保证线程的安全性。如果有多个线程会访问到集合，那最好是使用 Vector，因为不需要我们自己再去考虑和编写线程安全的代码。</li>\n<li>ArrayList在底层数组不够用时在原来的基础上扩展0.5倍，Vector是扩展1倍，这样ArrayList就有利于节约内存空间。</li>\n</ul>\n<h2 id=\"HashMap系列\"><a href=\"#HashMap系列\" class=\"headerlink\" title=\"HashMap系列\"></a>HashMap系列</h2><h3 id=\"HashMap-和-HashSet（底层HashMap）区别\"><a href=\"#HashMap-和-HashSet（底层HashMap）区别\" class=\"headerlink\" title=\"HashMap 和 HashSet（底层HashMap）区别\"></a>HashMap 和 HashSet（底层HashMap）区别</h3><h3 id=\"HashSet如何检查重复\"><a href=\"#HashSet如何检查重复\" class=\"headerlink\" title=\"HashSet如何检查重复\"></a>HashSet如何检查重复</h3><p>hashcode—equals</p>\n<h3 id=\"HashMap的底层实现\"><a href=\"#HashMap的底层实现\" class=\"headerlink\" title=\"HashMap的底层实现\"></a>HashMap的底层实现</h3><h3 id=\"HashMap构造函数\"><a href=\"#HashMap构造函数\" class=\"headerlink\" title=\"HashMap构造函数\"></a>HashMap构造函数</h3><p>三个 初始容量+默认加载因子</p>\n<p>数组 +链表+红黑树</p>\n<h3 id=\"HashMap-的扩容方式？\"><a href=\"#HashMap-的扩容方式？\" class=\"headerlink\" title=\"HashMap 的扩容方式？\"></a>HashMap 的扩容方式？</h3><p><strong>扩容：</strong></p>\n<p>首先 HashMap 的初始容量是 16，并且每次对原数组长度 * 2 进行扩容，HashMap 在容量超过负载因子所定义的容量之后，就会扩容，默认0.75，构造函数可以调整，无参有参构造</p>\n<p>当链表大于8，如果数组&lt;64 先数组扩容，否则链表转为红黑树</p>\n<p>HashMap扩容：</p>\n<h3 id=\"HashMap为什么默认加载因子是0-75？\"><a href=\"#HashMap为什么默认加载因子是0-75？\" class=\"headerlink\" title=\"HashMap为什么默认加载因子是0.75？\"></a>HashMap为什么默认加载因子是0.75？</h3><p>作为一般规则，默认负载因子（0.75）在时间和空间成本上提供了很好的折衷。较高的值会降低空间开销，但提高查找成本（体现在大多数的HashMap类的操作，包括get和put）。设置初始大小时，应该考虑预计的entry数在map及其负载系数，并且尽量减少rehash操作的次数。如果初始容量大于最大条目数除以负载因子，rehash操作将不会发生</p>\n<h3 id=\"HashMap-中-key-的存储索引是怎么计算的？\"><a href=\"#HashMap-中-key-的存储索引是怎么计算的？\" class=\"headerlink\" title=\"HashMap 中 key 的存储索引是怎么计算的？\"></a>HashMap 中 key 的存储索引是怎么计算的？</h3><p><strong>取key的 hashCode 值、根据 hashcode 计算出hash值（hashcode 异或其右移十六位）、通过取模计算下标</strong></p>\n<h4 id=\"1、JDK1-8-为什么要-hashcode-异或其右移十六位的值？\"><a href=\"#1、JDK1-8-为什么要-hashcode-异或其右移十六位的值？\" class=\"headerlink\" title=\"1、JDK1.8 为什么要 hashcode 异或其右移十六位的值？\"></a>1、JDK1.8 为什么要 hashcode 异或其右移十六位的值？</h4><p>右移后再亦或，高位和低位做了混合，在之后的hash &amp; (length-1) 中高位就也参与进运算了，增加了散列程度。</p>\n<p>由于和 (length -1) 运算，length 绝大多数情况小于 2 的 16 次方。 所以始终是 hashcode 的低 16 位（甚至更低） 参与运算。 但是这样高 16 位是用不到的，为了让得到的下标更加散列，需要让高16位也参与运算，所以就需要低16位和高16位进行 ^ 运算。</p>\n<h4 id=\"2、为什么-hash-值要与length-1相与？\"><a href=\"#2、为什么-hash-值要与length-1相与？\" class=\"headerlink\" title=\"2、为什么 hash 值要与length-1相与？\"></a>2、为什么 hash 值要与length-1相与？</h4><p>位运算快</p>\n<p>充分散列</p>\n<h3 id=\"HashMap-的put方法流程？\"><a href=\"#HashMap-的put方法流程？\" class=\"headerlink\" title=\"HashMap 的put方法流程？\"></a>HashMap 的put方法流程？</h3><ol>\n<li>首先根据 key 的值计算 hash 值，找到该元素在数组中存储的下标；</li>\n<li>如果数组是空的，则调用 resize 进行初始化；</li>\n<li>如果没有哈希冲突直接放在对应的数组下标里；</li>\n<li>如果冲突后，发现该节点是红黑树，则调用equals判断TreeNode是否已存在，如果存在更新之；不存在则直接插入红黑树，++size，超出threshold容量就扩容，然后将这个节点挂在树上；</li>\n<li>如果是链表，则判断Node是否已存在，如果存在更新之；不存在则直接插入链表尾部，判断链表长度，如果大于8则转为红黑树存储，++size，超出threshold容量就扩容； 判断该链表是否大于 8 ，如果大于 8 并且数组容量小于 64，就进行扩容；如果链表节点大于 8 并且数组的容量大于 64，则将这个结构转换为红黑树；</li>\n</ol>\n<h3 id=\"解决hash冲突的办法有哪些？HashMap用的哪种？\"><a href=\"#解决hash冲突的办法有哪些？HashMap用的哪种？\" class=\"headerlink\" title=\"解决hash冲突的办法有哪些？HashMap用的哪种？\"></a>解决hash冲突的办法有哪些？HashMap用的哪种？</h3><p>解决Hash冲突方法有:开放定址法（线性探测法）、再哈希法（多个hash函数算）、链地址法（拉链法）、建立公共溢出区。HashMap中采用的是 链地址法 </p>\n<p>线性探测法和</p>\n<h3 id=\"HashMap-多线程操作死链问题\"><a href=\"#HashMap-多线程操作死链问题\" class=\"headerlink\" title=\"HashMap 多线程操作死链问题\"></a>HashMap 多线程操作死链问题</h3><p>1.7头插会产生，1.8尾插没有了</p>\n<p>线程2完成移动 线程1才开始移动 因此就会产生环形链表</p>\n<h3 id=\"HashMap为什么线程不安全\"><a href=\"#HashMap为什么线程不安全\" class=\"headerlink\" title=\"HashMap为什么线程不安全\"></a>HashMap为什么线程不安全</h3><p>A判断好这个地方没有数据，准备插入的时候，这时候B线程抢夺到时间片，来插入，然后A再插入就把B覆盖了</p>\n<ul>\n<li>多线程下扩容死循环。JDK1.7中的 HashMap 使用头插法插入元素，在多线程的环境下，扩容的时候有可能导致环形链表的出现，形成死循环。因此，JDK1.8使用尾插法插入元素，在扩容时会保持链表元素原本的顺序，不会出现环形链表的问题。</li>\n<li>多线程的put可能导致元素的丢失。多线程同时执行 put 操作，如果计算出来的索引位置是相同的，那会造成前一个 key 被后一个 key 覆盖，从而导致元素的丢失。此问题在JDK 1.7和 JDK 1.8 中都存在。</li>\n<li>put和get并发时，可能导致get为null。线程1执行put时，因为元素个数超出threshold而导致rehash，线程2此时执行get，有可能导致这个问题。此问题在JDK 1.7和 JDK 1.8 中都存在。</li>\n</ul>\n<h3 id=\"为什么链表长度8树化\"><a href=\"#为什么链表长度8树化\" class=\"headerlink\" title=\"为什么链表长度8树化\"></a>为什么链表长度8树化</h3><p>链表阈值和产生冲突概率为泊松分布 选择8是千万分之6 7是十万分之一，差1000倍，降低冲突概率</p>\n<h3 id=\"退化\"><a href=\"#退化\" class=\"headerlink\" title=\"退化\"></a>退化</h3><p>当扩容后链表长度小于等于 6 进行树的退化 长度为6的话链表和红黑树查找效率忽略不计。此时维护红黑树的平衡反而加大开销，所以退化</p>\n<h3 id=\"红黑树特点\"><a href=\"#红黑树特点\" class=\"headerlink\" title=\"红黑树特点\"></a>红黑树特点</h3><p>1.节点是红色或黑色。</p>\n<p>2.根节点是黑色。</p>\n<p>3.每个叶子节点都是黑色的空节点（NIL节点）。</p>\n<p>4 每个红色节点的两个子节点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点)</p>\n<p>5.从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。</p>\n<p>当插入打破规则可以采取变色或者旋转（左旋转和右旋转）</p>\n<h3 id=\"红黑树vsAVL\"><a href=\"#红黑树vsAVL\" class=\"headerlink\" title=\"红黑树vsAVL\"></a>红黑树vsAVL</h3><p>1、增删性能红黑树好</p>\n<p>2、查询性能AVL好</p>\n<p>3、内存空间红黑树消耗大</p>\n<h3 id=\"HashMap-的⻓度为什么是2的幂次⽅\"><a href=\"#HashMap-的⻓度为什么是2的幂次⽅\" class=\"headerlink\" title=\"HashMap 的⻓度为什么是2的幂次⽅\"></a>HashMap 的⻓度为什么是2的幂次⽅</h3><p>1、2 的幂次可以用 与 的方式进行取余运算，效率更高；</p>\n<p>2）在扩容移动链表节点时，节点在新数组中的位置只可能是原位置 i 或 i + oldCap 旧数组长度，扩容时效率更高</p>\n<h2 id=\"一般用什么作为HashMap的key\"><a href=\"#一般用什么作为HashMap的key\" class=\"headerlink\" title=\"一般用什么作为HashMap的key?\"></a>一般用什么作为HashMap的key?</h2><p>一般用Integer、String 这种不可变类当 HashMap 当 key，而且 String 最为常用。</p>\n<ul>\n<li>因为字符串是不可变的，所以在它创建的时候 hashcode 就被缓存了，不需要重新计算。这就是 HashMap 中的键往往都使用字符串的原因。</li>\n<li>因为获取对象的时候要用到 equals() 和 hashCode() 方法，那么键对象正确的重写这两个方法是非常重要的,这些类已经很规范的重写了 hashCode() 以及 equals() 方法。</li>\n</ul>\n<h2 id=\"ConcurrentHashMap\"><a href=\"#ConcurrentHashMap\" class=\"headerlink\" title=\"ConcurrentHashMap\"></a>ConcurrentHashMap</h2><h3 id=\"ConcurrentHashMap线程安全的具体实现⽅式-x2F-底层具体实现\"><a href=\"#ConcurrentHashMap线程安全的具体实现⽅式-x2F-底层具体实现\" class=\"headerlink\" title=\"ConcurrentHashMap线程安全的具体实现⽅式&#x2F;底层具体实现\"></a>ConcurrentHashMap线程安全的具体实现⽅式&#x2F;底层具体实现</h3><p><strong>1.7:</strong> 分段锁 （可重入锁）Segment 数组 + HashEntry 数组 + 链表 </p>\n<p>JDK1.7中的ConcurrentHashMap 是由 Segment 数组结构和 HashEntry 数组结构组成，即ConcurrentHashMap 把哈希桶切分成小数组（Segment ），每个小数组有 n 个 HashEntry 组成。</p>\n<p>其中，Segment 继承了 ReentrantLock，所以 Segment 是一种可重入锁，扮演锁的角色；HashEntry 用于存储键值对数据。</p>\n<p>首先将数据分为一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据时，其他段的数据也能被其他线程访问，能够实现真正的并发访问。</p>\n<p><strong>1.8</strong> CAS syn</p>\n<p>在数据结构上， JDK1.8 中的ConcurrentHashMap 选择了与 HashMap 相同的<strong>数组+链表+红黑树</strong>结构；在锁的实现上，抛弃了原有的 Segment 分段锁，采用CAS + synchronized实现更加低粒度的锁。</p>\n<p>将锁的级别控制在了更细粒度的哈希桶元素级别，也就是说只需要锁住这个链表头结点（红黑树的根节点），就不会影响其他的哈希桶元素的读写，大大提高了并发度。</p>\n<p>node数组+链表+红黑树</p>\n<p>synchronized 只锁定当前链表或红⿊⼆叉树的⾸节点，这样只要 hash 不冲突，就不会产⽣并发，效率⼜提升 N 倍 </p>\n<h3 id=\"ConcurrentHashMap-的-put-方法执行逻辑是什么？\"><a href=\"#ConcurrentHashMap-的-put-方法执行逻辑是什么？\" class=\"headerlink\" title=\"ConcurrentHashMap 的 put 方法执行逻辑是什么？\"></a>ConcurrentHashMap 的 put 方法执行逻辑是什么？</h3><p><strong>先来看JDK1.7</strong></p>\n<p>首先，会尝试获取锁，如果获取失败，利用自旋获取锁；如果自旋重试的次数超过 64 次，则改为阻塞获取锁。</p>\n<p>获取到锁后：</p>\n<ol>\n<li>将当前 Segment 中的 table 通过 key 的 hashcode 定位到 HashEntry。</li>\n<li>遍历该 HashEntry，如果不为空则判断传入的 key 和当前遍历的 key 是否相等，相等则覆盖旧的 value。</li>\n<li>没有相等的话则需要新建一个 HashEntry 并加入到 Segment 中，同时会先判断是否需要扩容。</li>\n<li>释放 Segment 的锁。</li>\n</ol>\n<p><strong>再来看JDK1.8</strong></p>\n<p>大致可以分为以下步骤：</p>\n<ol>\n<li>根据 key 计算出 hash值。</li>\n<li>判断是否需要进行初始化。</li>\n<li>定位到 Node，拿到首节点 f，判断首节点 f：</li>\n</ol>\n<ul>\n<li><ul>\n<li>如果为 null ，则通过cas的方式尝试添加。</li>\n<li>如果为 f.hash &#x3D; MOVED &#x3D; -1 ，说明其他线程在扩容，参与一起扩容。</li>\n<li>如果都不满足 ，synchronized 锁住 f 节点，判断是链表还是红黑树，遍历插入。</li>\n</ul>\n</li>\n</ul>\n<ol>\n<li>当在链表长度达到8的时候，数组扩容或者将链表转换为红黑树。</li>\n</ol>\n<h3 id=\"ConcurrentHashMap-的-get-方法是否要加锁，为什么？\"><a href=\"#ConcurrentHashMap-的-get-方法是否要加锁，为什么？\" class=\"headerlink\" title=\"ConcurrentHashMap 的 get 方法是否要加锁，为什么？\"></a>ConcurrentHashMap 的 get 方法是否要加锁，为什么？</h3><p>get 方法不需要加锁。因为 Node 的元素 val 和指针 next 是用 volatile 修饰的，在多线程环境下线程A修改结点的val或者新增节点的时候是对线程B可见的。</p>\n<p>这也是它比其他并发集合比如 Hashtable、用 Collections.synchronizedMap()包装的 HashMap 安全效率高的原因之一。</p>\n<h3 id=\"ConcurrentHashMap-不支持-key-或者-value-为-null-的原因？\"><a href=\"#ConcurrentHashMap-不支持-key-或者-value-为-null-的原因？\" class=\"headerlink\" title=\"ConcurrentHashMap 不支持 key 或者 value 为 null 的原因？\"></a>ConcurrentHashMap 不支持 key 或者 value 为 null 的原因？</h3><p>1、我们先来说value 为什么不能为 null ，因为ConcurrentHashMap是用于多线程的 ，如果map.get(key)得到了 null ，无法判断，是映射的value是 null ，还是没有找到对应的key而为 null ，这就有了二义性。</p>\n<p><strong>追问：说说为什么ConcurrentHashMap判断不了呢？</strong></p>\n<p>此时如果有A、B两个线程，A线程调用ConcurrentHashMap.get(key)方法返回null，但是我们不知道这个null是因为key没有在map中映射还是本身存的value值就是null，此时我们假设有一个key没有在map中映射过，也就是map中不存在这个key，此时我们调用ConcurrentHashMap.containsKey(key)方法去做一个判断，我们期望的返回结果是false。但是恰好在A线程get(key)之后，调用constainsKey(key)方法之前B线程执行了ConcurrentHashMap.put(key,null)，那么当A线程执行完containsKey(key)方法之后我们得到的结果是true，与我们预期的结果就不相符了。</p>\n<p>而用于单线程状态的HashMap却可以用containsKey(key) 去判断到底是否包含了这个 null 。</p>\n<p>2、至于ConcurrentHashMap 中的key为什么也不能为 null 的问题，源码就是这样写的，哈哈。就回答作者Doug不喜欢 null ，所以在设计之初就不允许了 null 的key存在</p>\n<h3 id=\"get方法不需要加锁与volatile修饰的哈希桶有关吗？\"><a href=\"#get方法不需要加锁与volatile修饰的哈希桶有关吗？\" class=\"headerlink\" title=\"get方法不需要加锁与volatile修饰的哈希桶有关吗？\"></a>get方法不需要加锁与volatile修饰的哈希桶有关吗？</h3><p>没有关系。哈希桶table用volatile修饰主要是保证在数组扩容的时候保证可见性。</p>\n<h3 id=\"ConcurrentHashMap-的并发度是多少？\"><a href=\"#ConcurrentHashMap-的并发度是多少？\" class=\"headerlink\" title=\"ConcurrentHashMap 的并发度是多少？\"></a>ConcurrentHashMap 的并发度是多少？</h3><p>jdk1.7里面，程序在运行时能够同时更新ConcurrentHashMap且不产生锁竞争的最大线程数默认是16，这个值可以在构造函数中设置。如果自己设置了并发度，ConcurrentHashMap 会使用大于等于该值的最小的2的幂指数作为实际并发度，也就是比如你设置的值是17，那么实际并发度是32。</p>\n<h3 id=\"ConcurrentHashMap-迭代器是强一致性还是弱一致性？\"><a href=\"#ConcurrentHashMap-迭代器是强一致性还是弱一致性？\" class=\"headerlink\" title=\"ConcurrentHashMap 迭代器是强一致性还是弱一致性？\"></a>ConcurrentHashMap 迭代器是强一致性还是弱一致性？</h3><p><strong>类似快速失败和安全失败</strong></p>\n<p>快速失败就是HashMap 安全失败是Con~</p>\n<p>与HashMap迭代器是强一致性不同，ConcurrentHashMap 迭代器是弱一致性。</p>\n<p>ConcurrentHashMap 的迭代器创建后，就会按照哈希表结构遍历每个元素，但在遍历过程中，内部元素可能会发生变化，如果变化发生在已遍历过的部分，迭代器就不会反映出来，而如果变化发生在未遍历过的部分，迭代器就会发现并反映出来，这就是弱一致性。</p>\n<p>这样迭代器线程可以使用原来老的数据，而写线程也可以并发的完成改变，更重要的，这保证了多个线程并发执行的连续性和扩展性，是性能提升的关键。想要深入了解的小伙伴，可以看这篇文章[为什么ConcurrentHashMap 是弱一致的](<a href=\"http://ifeve.com/ConcurrentHashMap\">http://ifeve.com/ConcurrentHashMap</a> -weakly-consistent&#x2F;)</p>\n<h3 id=\"JDK1-7与JDK1-8-中ConcurrentHashMap-的区别？\"><a href=\"#JDK1-7与JDK1-8-中ConcurrentHashMap-的区别？\" class=\"headerlink\" title=\"JDK1.7与JDK1.8 中ConcurrentHashMap 的区别？\"></a>JDK1.7与JDK1.8 中ConcurrentHashMap 的区别？</h3><ul>\n<li>数据结构：取消了Segment分段锁的数据结构，取而代之的是数组+链表+红黑树的结构。</li>\n<li>保证线程安全机制：JDK1.7采用Segment的分段锁机制实现线程安全，其中segment继承自ReentrantLock。JDK1.8 采用CAS+Synchronized保证线程安全。</li>\n<li>锁的粒度：原来是对需要进行数据操作的Segment加锁，现调整为对每个数组元素加锁（Node）。</li>\n<li>链表转化为红黑树:定位结点的hash算法简化会带来弊端,Hash冲突加剧,因此在链表节点数量大于8时，会将链表转化为红黑树进行存储。</li>\n<li>查询时间复杂度：从原来的遍历链表O(n)，变成遍历红黑树O(logN)。</li>\n</ul>\n<h3 id=\"ConcurrentHashMap-和Hashtable的效率哪个更高？为什么？\"><a href=\"#ConcurrentHashMap-和Hashtable的效率哪个更高？为什么？\" class=\"headerlink\" title=\"ConcurrentHashMap 和Hashtable的效率哪个更高？为什么？\"></a>ConcurrentHashMap 和Hashtable的效率哪个更高？为什么？</h3><p>ConcurrentHashMap 的效率要高于Hashtable，因为<strong>Hashtable给整个哈希表加了一把大锁从而实现线程安全</strong>。而ConcurrentHashMap 的锁粒度更低，在JDK1.7中采用分段锁实现线程安全，在JDK1.8 中采用CAS+Synchronized实现线程安全。</p>\n<h3 id=\"说一下Hashtable的锁机制\"><a href=\"#说一下Hashtable的锁机制\" class=\"headerlink\" title=\"说一下Hashtable的锁机制 ?\"></a>说一下Hashtable的锁机制 ?</h3><p>Hashtable是使用Synchronized来实现线程安全的，给整个哈希表加了一把大锁，多线程访问时候，只要有一个线程访问或操作该对象，那其他线程只能阻塞等待需要的锁被释放，在竞争激烈的多线程场景中性能就会非常差！</p>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2023/png/226907/1684750974008-15007cd1-0b39-4594-9798-11b0e05a95dc.png\" alt=\"img\"></p>\n<h3 id=\"多线程下安全的操作-map还有其他方法吗？\"><a href=\"#多线程下安全的操作-map还有其他方法吗？\" class=\"headerlink\" title=\"多线程下安全的操作 map还有其他方法吗？\"></a>多线程下安全的操作 map还有其他方法吗？</h3><p>还可以使用Collections.synchronizedMap方法，对方法进行加同步锁</p>\n<p>如果传入的是 HashMap 对象，其实也是对 HashMap 做的方法做了一层包装，里面使用对象锁来保证多线程场景下，线程安全，本质也是对 HashMap 进行全表锁。<strong>在竞争激烈的多线程环境下性能依然也非常差，不推荐使用！</strong></p>\n<h2 id=\"⽐较-HashSet、-LinkedHashSet-和-TreeSet-三者的异同\"><a href=\"#⽐较-HashSet、-LinkedHashSet-和-TreeSet-三者的异同\" class=\"headerlink\" title=\"⽐较 HashSet、 LinkedHashSet 和 TreeSet 三者的异同\"></a>⽐较 HashSet、 LinkedHashSet 和 TreeSet 三者的异同</h2><p>HashSet 是 Set 接⼝的主要实现类 ， HashSet 的底层是 HashMap ，线程不安全的，可以存储 null 值；LinkedHashSet 按照添加的顺序遍历；TreeSet 底层红⿊树</p>\n<h2 id=\"如何选⽤集合\"><a href=\"#如何选⽤集合\" class=\"headerlink\" title=\"如何选⽤集合?\"></a>如何选⽤集合?</h2><p>Map</p>\n<p>collection：set list</p>\n<h2 id=\"collection框架中实现比较要怎么做？\"><a href=\"#collection框架中实现比较要怎么做？\" class=\"headerlink\" title=\"collection框架中实现比较要怎么做？\"></a>collection框架中实现比较要怎么做？</h2><p>第一种，实体类实现Comparable接口，并实现 compareTo(T t) 方法，称为内部比较器。</p>\n<p>第二种，创建一个外部比较器，这个外部比较器要实现Comparator接口的 compare(T t1, T t2)方法。</p>\n<h2 id=\"Iterator-和-ListIterator-有什么区别？\"><a href=\"#Iterator-和-ListIterator-有什么区别？\" class=\"headerlink\" title=\"Iterator 和 ListIterator 有什么区别？\"></a>Iterator 和 ListIterator 有什么区别？</h2><ul>\n<li>遍历。使用Iterator，可以遍历所有集合，如Map，List，Set；但只能在向前方向上遍历集合中的元素。</li>\n</ul>\n<p>使用ListIterator，只能遍历List实现的对象，但可以向前和向后遍历集合中的元素。</p>\n<ul>\n<li>添加元素。Iterator无法向集合中添加元素；而，ListIteror可以向集合添加元素。</li>\n<li>修改元素。Iterator无法修改集合中的元素；而，ListIterator可以使用set()修改集合中的元素。</li>\n<li>索引。Iterator无法获取集合中元素的索引；而，使用ListIterator，可以获取集合中元素的索引。</li>\n</ul>\n","categories":["八股"]},{"title":"Mybatis","url":"/2023/06/04/Mybatis/","content":"<h2 id=\"MyBatis是什么？\"><a href=\"#MyBatis是什么？\" class=\"headerlink\" title=\"MyBatis是什么？\"></a>MyBatis是什么？</h2><p>1、Mybatis是一个半ORM（对象关系映射）框架，它内部封装了JDBC，<strong>加载驱动、创建连接、创建statement</strong>等繁杂的过程，开发者开发时只需要关注如何编写SQL语句，可以严格控制sql执行性能，灵活度高<span id=\"more\"></span></p>\n<p>2、作为一个半ORM框架，MyBatis 可以使用 XML 或注解来配置和映射原生信息，将 POJO映射成数据库中的记录，避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。</p>\n<p>3、通过xml 文件或注解的方式将要执行的各种 statement 配置起来，并通过java对象和 statement中sql的动态参数进行映射生成最终执行的sql语句，最后由mybatis框架执行sql并将结果映射为java对象并返回。（从执行sql到返回result的过程）。</p>\n<p>4、由于MyBatis专注于SQL本身，灵活度高，所以比较适合对性能的要求很高，或者需求变化较多的项目，如互联网项目。</p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/image-20230317221724470.png\" alt=\"img\"></p>\n<p>resultMap:反射创建的对象返回数据</p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/image-20230317221905292.png\" alt=\"img\"></p>\n<h2 id=\"Mybaits的优缺点\"><a href=\"#Mybaits的优缺点\" class=\"headerlink\" title=\"Mybaits的优缺点\"></a>Mybaits的优缺点</h2><p>优点：</p>\n<ul>\n<li>基于SQL语句编程，相当灵活，不会对应用程序或者数据库的现有设计造成任何影响，SQL写在XML里，解除sql与程序代码的耦合，便于统一管理；提供XML标签，支持编写动态SQL语句，并可重用。</li>\n<li>与JDBC相比，减少大量代码量，消除了JDBC大量冗余的代码，不需要手动开关连接；</li>\n<li>与各种数据库<strong>兼容</strong>（因为MyBatis使用JDBC来连接数据库，所以只要JDBC支持的数据库MyBatis都支持）。 jdbc相当于接口 mysql类似于实现类</li>\n<li>g很好的集成Spring；</li>\n<li>提供映射标签，支持对象与数据库的ORM字段关系映射；提供对象关系映射标签，支持对象关系组件维护。</li>\n</ul>\n<p>缺点：</p>\n<ul>\n<li>SQL语句的编写工作量较大，尤其当字段多、关联表多时，对开发人员编写SQL语句的功底有一定要求。</li>\n<li>SQL语句依赖于数据库，导致数据库移植性差，不能随意更换数据库。</li>\n</ul>\n<h2 id=\"和-的区别是什么？\"><a href=\"#和-的区别是什么？\" class=\"headerlink\" title=\"#{}和${}的区别是什么？\"></a>#{}和${}的区别是什么？</h2><p>${} 是 Properties ⽂件中的变量占位符 </p>\n<p>#{} 是 sql 的参数占位符 </p>\n<ul>\n<li>#{}是占位符，预编译处理；${}是拼接符，字符串替换，没有预编译处理。</li>\n<li>Mybatis在处理#{}时，#{}传入参数是以字符串传入，会将SQL中的#{}替换为?号，调用PreparedStatement的set方法来赋值。</li>\n<li>变量替换后，#{} 对应的变量自动加上单引号 ‘’；变量替换后，${} 对应的变量不会加上单引号 ‘’</li>\n<li>#{} 可以有效的防止SQL注入，提高系统安全性；${} 不能防止SQL 注入</li>\n<li>#{} 的变量替换是在DBMS 中；${} 的变量替换是在 DBMS 外</li>\n</ul>\n<h2 id=\"通常一个Xml映射文件，都会写一个Dao接口与之对应，那么这个Dao接口的工作原理是什么？Dao接口里的方法、参数不同时，方法能重载吗？\"><a href=\"#通常一个Xml映射文件，都会写一个Dao接口与之对应，那么这个Dao接口的工作原理是什么？Dao接口里的方法、参数不同时，方法能重载吗？\" class=\"headerlink\" title=\"通常一个Xml映射文件，都会写一个Dao接口与之对应，那么这个Dao接口的工作原理是什么？Dao接口里的方法、参数不同时，方法能重载吗？\"></a><a href=\"https://www.javalearn.cn/#/doc/Mybatis/%E9%9D%A2%E8%AF%95%E9%A2%98?id=_11-%E9%80%9A%E5%B8%B8%E4%B8%80%E4%B8%AAxml%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B6%EF%BC%8C%E9%83%BD%E4%BC%9A%E5%86%99%E4%B8%80%E4%B8%AAdao%E6%8E%A5%E5%8F%A3%E4%B8%8E%E4%B9%8B%E5%AF%B9%E5%BA%94%EF%BC%8C%E9%82%A3%E4%B9%88%E8%BF%99%E4%B8%AAdao%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9Fdao%E6%8E%A5%E5%8F%A3%E9%87%8C%E7%9A%84%E6%96%B9%E6%B3%95%E3%80%81%E5%8F%82%E6%95%B0%E4%B8%8D%E5%90%8C%E6%97%B6%EF%BC%8C%E6%96%B9%E6%B3%95%E8%83%BD%E9%87%8D%E8%BD%BD%E5%90%97%EF%BC%9F\">通常一个Xml映射文件，都会写一个Dao接口与之对应，那么这个Dao接口的工作原理是什么？Dao接口里的方法、参数不同时，方法能重载吗？</a></h2><p>Dao接口即Mapper接口。接口的全限名就是映射文件中的namespace的值；接口的方法名，就是映射文件中Mapper的Statement的id值；接口方法内的参数，就是传递给sql的参数。Mapper接口是没有实现类的，当调用接口方法时，接口全限名+方法名的拼接字符串作为key值，可唯一定位一个MapperStatement。</p>\n<p>Dao接口里的方法，是不能重载的，因为是全限名+方法名的保存和寻找策略。</p>\n<p>Dao接口的工作原理是JDK动态代理，Mybatis运行时会使用JDK动态代理为Dao接口生成代理proxy对象，代理对象proxy会拦截接口方法，转而执行MappedStatement所代表的sql，然后将sql执行结果返回。</p>\n<h2 id=\"Xml-映射⽂件中有哪些标签？\"><a href=\"#Xml-映射⽂件中有哪些标签？\" class=\"headerlink\" title=\"Xml 映射⽂件中有哪些标签？\"></a>Xml 映射⽂件中有哪些标签？</h2><p><resultMap> 、 <parameterMap> 、 <sql> 、 <include> 、 <selectKey> 、<select>、<insert>、<update>、<delete></delete></update></insert></select></selectKey></include></sql></parameterMap></resultMap></p>\n<h2 id=\"Mapper接⼝的⼯作原理是什么？\"><a href=\"#Mapper接⼝的⼯作原理是什么？\" class=\"headerlink\" title=\"Mapper接⼝的⼯作原理是什么？\"></a>Mapper接⼝的⼯作原理是什么？</h2><p>例： com.mybatis3.mappers.StudentDao.findStudentById ，可以唯⼀找到 namespace(接口全限定名)为 com.mybatis3.mappers.StudentDao 下⾯ id &#x3D; findStudentById 的 MappedStatement （接⼝⽅法内的参数，就是传递给 sql 的参数。 ）</p>\n<p>在 Mybatis中，每⼀个 <select> 、 <insert> 、 <update> 、 <delete> 标签，都会被解析为⼀个 MappedStatement 对象 </delete></update></insert></select></p>\n<p>Dao 接⼝的⼯作原理是 JDK 动态代理， <strong>Mybatis 运⾏时会使⽤ JDK 动态代理为 Dao 接⼝⽣成代****理 proxy 对象</strong>，<strong>代理对象 proxy 会<strong><strong>拦截接⼝⽅法</strong></strong>，转⽽<strong><strong>执⾏ MappedStatement 所代表的 sql</strong></strong>，然后****将 sql 执⾏结果返回。</strong></p>\n<h2 id=\"在Mapper中如何传递多个参数？\"><a href=\"#在Mapper中如何传递多个参数？\" class=\"headerlink\" title=\"在Mapper中如何传递多个参数？\"></a><a href=\"https://www.javalearn.cn/#/doc/Mybatis/%E9%9D%A2%E8%AF%95%E9%A2%98?id=_12-%E5%9C%A8mapper%E4%B8%AD%E5%A6%82%E4%BD%95%E4%BC%A0%E9%80%92%E5%A4%9A%E4%B8%AA%E5%8F%82%E6%95%B0%EF%BC%9F\">在Mapper中如何传递多个参数？</a></h2><p>1、若Dao层函数有多个参数，那么其对应的xml中，#{0}代表接收的是Dao层中的第一个参数，#{1}代表Dao中的第二个参数，以此类推。</p>\n<p>2、使用@Param注解：在Dao层的参数中前加@Param注解,注解内的参数名为传递到Mapper中的参数名。</p>\n<p>3、多个参数封装成Map，以HashMap的形式传递到Mapper中。</p>\n<h2 id=\"Dao-（Mapper）接⼝⾥的⽅法，参数不同时，⽅法能重载吗？\"><a href=\"#Dao-（Mapper）接⼝⾥的⽅法，参数不同时，⽅法能重载吗？\" class=\"headerlink\" title=\"Dao （Mapper）接⼝⾥的⽅法，参数不同时，⽅法能重载吗？\"></a>Dao （Mapper）接⼝⾥的⽅法，参数不同时，⽅法能重载吗？</h2><p>Dao 接⼝⾥的⽅法，是不能重载的，因为是全限名+⽅法名的保存和寻找策略 </p>\n<h2 id=\"Mybatisplus-是如何进⾏分⻚的？分⻚插件的原理是什么？\"><a href=\"#Mybatisplus-是如何进⾏分⻚的？分⻚插件的原理是什么？\" class=\"headerlink\" title=\"Mybatisplus 是如何进⾏分⻚的？分⻚插件的原理是什么？\"></a>Mybatisplus 是如何进⾏分⻚的？分⻚插件的原理是什么？</h2><h2 id=\"简述-Mybatis-的插件运⾏原理，以及如何编写⼀个插件\"><a href=\"#简述-Mybatis-的插件运⾏原理，以及如何编写⼀个插件\" class=\"headerlink\" title=\"简述 Mybatis 的插件运⾏原理，以及如何编写⼀个插件\"></a>简述 Mybatis 的插件运⾏原理，以及如何编写⼀个插件</h2><p>使用基于jdk的动态代理，为需要拦截的接口生成代理对象以实现接口方法拦截功能，</p>\n<p>当执行这4种接口方法时，会进入拦截方法，invoke()方法</p>\n<p>如何编写？</p>\n<p>实现 Mybatis 的 Interceptor 接⼝并复写 intercept() ⽅法，然后在给插件编写注解，指定要拦截哪⼀个接⼝的哪些⽅法即可，记住，别忘了在配置⽂件中配置你编写的插件。 </p>\n<h2 id=\"Mybatis-执⾏批量插⼊，能返回数据库主键列表吗？\"><a href=\"#Mybatis-执⾏批量插⼊，能返回数据库主键列表吗？\" class=\"headerlink\" title=\"Mybatis 执⾏批量插⼊，能返回数据库主键列表吗？\"></a>Mybatis 执⾏批量插⼊，能返回数据库主键列表吗？</h2><p>可以</p>\n<h2 id=\"Mybatis-动态-sql-是做什么的？都有哪些动态-sql？能简述⼀下动态-sql-的执⾏原理不？\"><a href=\"#Mybatis-动态-sql-是做什么的？都有哪些动态-sql？能简述⼀下动态-sql-的执⾏原理不？\" class=\"headerlink\" title=\"Mybatis 动态 sql 是做什么的？都有哪些动态 sql？能简述⼀下动态 sql 的执⾏原理不？\"></a>Mybatis 动态 sql 是做什么的？都有哪些动态 sql？能简述⼀下动态 sql 的执⾏原理不？</h2><p>Mybatis 动态 sql 可以让我们在 Xml 映射⽂件内，以标签的形式编写动态 sql，完成逻辑判断和动态拼接 sql 的功能， Mybatis 提供了 9 种动态 sql 标签trim|where|set|foreach|if|choose|when|otherwise|bind 。其执⾏原理为，使⽤ <strong>OGNL</strong> 从 sql 参数对象中计算表达式的值，根据表达式的值动态拼接 sql，以此来完成动态 sql 的功能。 </p>\n<p><strong>执行原理</strong>：是根据表达式的值完成逻辑判断，并动态拼接sql的功能。</p>\n<h2 id=\"Mybatis-是如何将-sql-执⾏结果封装为⽬标对象并返回的？都有哪些映射形式？\"><a href=\"#Mybatis-是如何将-sql-执⾏结果封装为⽬标对象并返回的？都有哪些映射形式？\" class=\"headerlink\" title=\"Mybatis 是如何将 sql 执⾏结果封装为⽬标对象并返回的？都有哪些映射形式？\"></a>Mybatis 是如何将 sql 执⾏结果封装为⽬标对象并返回的？都有哪些映射形式？</h2><p>第⼀种：是使⽤ <resultMap> 标签，逐⼀定义列名和对象属性名之间的映射关系。 </resultMap></p>\n<p>第⼆种：使⽤ sql 列的别名功能，将列别名书写为对象属性名，⽐如 T_NAME AS NAME， </p>\n<p>有了列名与属性名的映射关系后， Mybatis 通过反射创建对象，同时使⽤反射给对象的属性逐⼀赋值并返回，那些找不到映射关系的属性，是⽆法完成赋值的 </p>\n<h2 id=\"Mybatis-能执⾏⼀对⼀、⼀对多的关联查询吗？都有哪些实现⽅式，以及它们之间的区别。\"><a href=\"#Mybatis-能执⾏⼀对⼀、⼀对多的关联查询吗？都有哪些实现⽅式，以及它们之间的区别。\" class=\"headerlink\" title=\"Mybatis 能执⾏⼀对⼀、⼀对多的关联查询吗？都有哪些实现⽅式，以及它们之间的区别。\"></a>Mybatis 能执⾏⼀对⼀、⼀对多的关联查询吗？都有哪些实现⽅式，以及它们之间的区别。</h2><p>可以，把 selectOne() 修改为 selectList() 即可 </p>\n<p>关联对象查询，有两种实现⽅式，一种是两条sql 一种是嵌套（join） 具体如下：</p>\n<pre><code class=\"plain\">有联合查询和嵌套查询两种方式。\n联合查询是几个表联合查询，通过在resultMap里面配置association节点配置一对一的类就可以完成；\n嵌套查询是先查一个表，根据这个表里面的结果的外键id，再去另外一个表里面查询数据，也是通过association配置，但另外一个表的查询是通过select配置的。\n</code></pre>\n<p>去重复的原理是 <resultMap> 标签内的 <id> ⼦标签 </id></resultMap></p>\n<h2 id=\"Mybatis的一级、二级缓存（？）\"><a href=\"#Mybatis的一级、二级缓存（？）\" class=\"headerlink\" title=\"Mybatis的一级、二级缓存（？）\"></a><a href=\"https://www.javalearn.cn/#/doc/Mybatis/%E9%9D%A2%E8%AF%95%E9%A2%98?id=_17-mybatis%E7%9A%84%E4%B8%80%E7%BA%A7%E3%80%81%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98\">Mybatis的一级、二级缓存</a>（？）</h2><p>1、 一级缓存：基于PerpetualCache的HashMap本地缓存，其存储作用域为Session，当Session flush或close之后，该Session中的所有Cache就将清空，默认打开一级缓存。</p>\n<p>2、 二级缓存与一级缓存机制相同，默认也是采用PerpetualCache，HashMap存储，不同在于其存储作用域为Mapper（namespace），并且可自定义存储源，如Ehcache。默认打不开二级缓存，要开启二级缓存，使用二级缓存属性类需要实现Serializable序列化接口（可用来保存对象的状态），可在它的映射文件中配置。</p>\n<p>对于缓存数据更新机制，当某一个作用域（一级缓存Session&#x2F;二级缓存Namespace）进行了增&#x2F;删&#x2F;改操作后，默认该作用域下所有select中的缓存将被clear。</p>\n<h2 id=\"使用MyBatis的Mapper接口调用时有哪些要求？\"><a href=\"#使用MyBatis的Mapper接口调用时有哪些要求？\" class=\"headerlink\" title=\"使用MyBatis的Mapper接口调用时有哪些要求？\"></a><a href=\"https://www.javalearn.cn/#/doc/Mybatis/%E9%9D%A2%E8%AF%95%E9%A2%98?id=_18-%E4%BD%BF%E7%94%A8mybatis%E7%9A%84mapper%E6%8E%A5%E5%8F%A3%E8%B0%83%E7%94%A8%E6%97%B6%E6%9C%89%E5%93%AA%E4%BA%9B%E8%A6%81%E6%B1%82%EF%BC%9F\">使用MyBatis的Mapper接口调用时有哪些要求？</a></h2><p>1、Mapper接口方法名和mapper.xml中定义的每个sql的id相同； </p>\n<p>2、Mapper接口方法的输入参数类型和mapper.xml中定义的每个sql的parameterType类型相同；</p>\n<p>3、Mapper接口方法的输出参数类型和mapper.xml中定义的每个sql的resultType的类型相同；</p>\n<p>4、Mapper.xml文件中的namespace即是mapper接口的类路径。</p>\n<h2 id=\"Mybatis-是否⽀持延迟加载（懒加载）？如果⽀持，它的实现原理是什么？\"><a href=\"#Mybatis-是否⽀持延迟加载（懒加载）？如果⽀持，它的实现原理是什么？\" class=\"headerlink\" title=\"Mybatis 是否⽀持延迟加载（懒加载）？如果⽀持，它的实现原理是什么？\"></a>Mybatis 是否⽀持延迟加载（懒加载）？如果⽀持，它的实现原理是什么？</h2><p>使⽤ CGLIB 创建⽬标对象的代理对象，当调⽤⽬标⽅法时，进⼊拦截器⽅法，⽐如调⽤ a.getB().getName() ，拦截器 invoke() ⽅法发现 a.getB() 是 null 值，那么就会单独发送事先保存好的查询关联 B 对象的 sql，把 B 查询上来，然后调⽤ a.setB(b)，于是 a 的对象 b 属性就有值了，接着完成 a.getB().getName() ⽅法的调⽤。这就是延迟加载的基本原理。 </p>\n<p>意思就是set我先不做，等你get的时候我再带调用set 然后再get，比较懒</p>\n<h2 id=\"Mybatis-的-Xml-映射⽂件中，不同的-Xml-映射⽂件，-id-是否可以重复？\"><a href=\"#Mybatis-的-Xml-映射⽂件中，不同的-Xml-映射⽂件，-id-是否可以重复？\" class=\"headerlink\" title=\"Mybatis 的 Xml 映射⽂件中，不同的 Xml 映射⽂件， id 是否可以重复？\"></a>Mybatis 的 Xml 映射⽂件中，不同的 Xml 映射⽂件， id 是否可以重复？</h2><p>如果配置了 namespace，那么 id 可以重复；如果没有配置namespace，那么 id 不能重复； </p>\n<p>原因就是 namespace+id 是作为 Map&lt;String, MappedStatement&gt; 的 key 使⽤的 </p>\n<h2 id=\"Mybatis-中如何执⾏批处理？\"><a href=\"#Mybatis-中如何执⾏批处理？\" class=\"headerlink\" title=\"Mybatis 中如何执⾏批处理？\"></a>Mybatis 中如何执⾏批处理？</h2><p>BatchExecutor 完成批处理。 </p>\n<h2 id=\"Mybatis-都有哪些-Executor-执⾏器？它们之间的区别是什么？-如何指定使⽤哪⼀种-Executor-执⾏器？\"><a href=\"#Mybatis-都有哪些-Executor-执⾏器？它们之间的区别是什么？-如何指定使⽤哪⼀种-Executor-执⾏器？\" class=\"headerlink\" title=\"Mybatis 都有哪些 Executor 执⾏器？它们之间的区别是什么？ 如何指定使⽤哪⼀种 Executor 执⾏器？\"></a>Mybatis 都有哪些 Executor 执⾏器？它们之间的区别是什么？ 如何指定使⽤哪⼀种 Executor 执⾏器？</h2><p>SimpleExecutor ：每执⾏⼀次 update 或 select，就开启⼀个 Statement 对象，⽤完⽴刻关闭（执行一个开一个）</p>\n<p>ReuseExecutor ： 以 sql 作为 key 查找 Statement 对象，存在就使⽤，不存在就创建，⽤完后，不关闭 Statement 对象，⽽是放置于 Map&lt;String, Statement&gt;内，供下⼀次使⽤。简⾔之，就是重复使⽤ Statement 对象。 </p>\n<p>BatchExecutor ：将所有 sql 都添加到批处理中（addBatch()），等待统⼀执⾏（executeBatch()） </p>\n<p>配置⽂件中，可以指定默认的 ExecutorType 执</p>\n<p>⾏器类型 </p>\n<h2 id=\"Mybatis-是否可以映射-Enum-枚举类？\"><a href=\"#Mybatis-是否可以映射-Enum-枚举类？\" class=\"headerlink\" title=\"Mybatis 是否可以映射 Enum 枚举类？\"></a>Mybatis 是否可以映射 Enum 枚举类？</h2><p>Mybatis 可以映射任何对象到表的⼀列上。⾃定义⼀个 TypeHandler ，实现 TypeHandler 的 setParameter() 和 getResult()接⼝⽅法。 TypeHandler 有两个作⽤， javaType –&gt; jdbcType (setParameter())–&gt;设置sql 问号占位符参数</p>\n<p>jdbcType –&gt; javaType(getResult())-&gt;获取列查询结果</p>\n<h2 id=\"Mybatis-映射⽂件中，如果-A-标签通过-include-引⽤了-B-标签的内容，请问，-B-标签能否定义在-A-标签的后⾯，还是说必须定义在-A-标签的前⾯？\"><a href=\"#Mybatis-映射⽂件中，如果-A-标签通过-include-引⽤了-B-标签的内容，请问，-B-标签能否定义在-A-标签的后⾯，还是说必须定义在-A-标签的前⾯？\" class=\"headerlink\" title=\"Mybatis 映射⽂件中，如果 A 标签通过 include 引⽤了 B 标签的内容，请问， B 标签能否定义在 A 标签的后⾯，还是说必须定义在 A 标签的前⾯？\"></a>Mybatis 映射⽂件中，如果 A 标签通过 include 引⽤了 B 标签的内容，请问， B 标签能否定义在 A 标签的后⾯，还是说必须定义在 A 标签的前⾯？</h2><p>都行， A 标签引⽤了 B 标签，但B在后面，会把A 标签标记为未解析状态，后面有个B，然后 Mybatis 会重新解析那些被标记为未解析的标签，此时再解析 A 标签时， B标签已经存在， OK！</p>\n<h2 id=\"简述-Mybatis-的-Xml-映射⽂件和-Mybatis-内部数据结构之间的映射关系？\"><a href=\"#简述-Mybatis-的-Xml-映射⽂件和-Mybatis-内部数据结构之间的映射关系？\" class=\"headerlink\" title=\"简述 Mybatis 的 Xml 映射⽂件和 Mybatis 内部数据结构之间的映射关系？\"></a>简述 Mybatis 的 Xml 映射⽂件和 Mybatis 内部数据结构之间的映射关系？</h2><p>​       —&gt;MappedStatement     标签会被解析为 ParameterMap   参数</p>\n<p><resultMap> 标签会被解析为 ResultMap 结果</resultMap></p>\n<h2 id=\"为什么说-Mybatis-是半⾃动-ORM-映射⼯具？它与全⾃动的区别在哪⾥？\"><a href=\"#为什么说-Mybatis-是半⾃动-ORM-映射⼯具？它与全⾃动的区别在哪⾥？\" class=\"headerlink\" title=\"为什么说 Mybatis 是半⾃动 ORM 映射⼯具？它与全⾃动的区别在哪⾥？\"></a>为什么说 Mybatis 是半⾃动 ORM 映射⼯具？它与全⾃动的区别在哪⾥？</h2><p>Hibernate属于全自动ORM映射工具，使用Hibernate查询关联对象或者关联集合对象时，可以根据对象关系模型直接获取，所以它是全自动的。</p>\n<p>Mybatis在查询关联对象或关联集合对象时，Mybatis 需要⼿动编写 sql 来完成 </p>\n<h2 id=\"Hibernate-和-MyBatis-的区别\"><a href=\"#Hibernate-和-MyBatis-的区别\" class=\"headerlink\" title=\"Hibernate 和 MyBatis 的区别\"></a>Hibernate 和 MyBatis 的区别</h2><p><strong>相同点</strong>：都是对jdbc的封装，都是持久层的框架，都用于dao层的开发。</p>\n<p><strong>不同点</strong></p>\n<p>1、映射关系</p>\n<p>MyBatis 是一个半自动映射的框架，配置Java对象与sql语句执行结果的对应关系，多表关联关系配置简单。</p>\n<p>Hibernate 是一个全表映射的框架，配置Java对象与数据库表的对应关系，多表关联关系配置复杂。</p>\n<p>2、 SQL优化和移植性</p>\n<p>Hibernate 对SQL语句封装，提供了日志、缓存、级联（级联比 MyBatis 强大）等特性，此外还提供 HQL（Hibernate Query Language）操作数据库，数据库无关性支持好，但会多消耗性能。如果项目需要支持多种数据库，代码开发量少，但SQL语句优化困难。 </p>\n<p>MyBatis 需要手动编写 SQL，支持动态 SQL、处理列表、动态生成表名、支持存储过程。开发工作量相对大些。直接使用SQL语句操作数据库，不支持数据库无关性，但sql语句优化容易。</p>\n<p>3、开发难易程度和学习成本</p>\n<p>Hibernate 是重量级框架，学习使用门槛高，适合于需求相对稳定，中小型的项目，比如：办公自动化系统</p>\n<p>MyBatis 是轻量级框架，学习使用门槛低，适合于需求变化频繁，大型的项目，比如：互联网电子商务系统</p>\n<p><strong>总结</strong></p>\n<p>MyBatis 是一个小巧、方便、高效、简单、直接、半自动化的持久层框架，</p>\n<p>Hibernate 是一个强大、方便、高效、复杂、间接、全自动化的持久层框架</p>\n<h2 id=\"JDBC编程有哪些不足之处，MyBatis是如何解决这些问题的？\"><a href=\"#JDBC编程有哪些不足之处，MyBatis是如何解决这些问题的？\" class=\"headerlink\" title=\"JDBC编程有哪些不足之处，MyBatis是如何解决这些问题的？\"></a>JDBC编程有哪些不足之处，MyBatis是如何解决这些问题的？</h2><p>1、【资源浪费】数据库链接创建、释放频繁造成系统资源浪费从而影响系统性能，如果使用数据库链接池可解决此问题。</p>\n<p><strong>解决：在SqlMapConfig.xml中配置数据链接池，使用连接池管理数据库链接。</strong></p>\n<p>2、【耦合严重】Jdbc的Sql语句写在代码中造成代码不易维护，实际应用sql变化的可能较大，sql变动需要改变java代码。</p>\n<p><strong>解决：将Sql语句配置在XXXXmapper.xml文件中与java代码分离。</strong></p>\n<p>3、 【手动传参】向sql语句传参数麻烦（手动传参），因为sql语句的where条件不一定，可能多也可能少，占位符需要和参数一一对应。</p>\n<p><strong>解决： Mybatis自动将java对象映射至sql语句。</strong></p>\n<p>4、 【解析结果麻烦】对结果集解析麻烦，sql变化导致解析代码变化，且解析前需要遍历，如果能将数据库记录封装成pojo对象解析比较方便。</p>\n<p><strong>解决：Mybatis自动将sql执行结果映射至java对象。</strong></p>\n<h2 id=\"MyBatis编程步骤是什么样的？\"><a href=\"#MyBatis编程步骤是什么样的？\" class=\"headerlink\" title=\"MyBatis编程步骤是什么样的？\"></a>MyBatis编程步骤是什么样的？</h2><p>1、 创建SqlSessionFactory </p>\n<p>2、 通过SqlSessionFactory创建SqlSession</p>\n<p>3、 通过sqlsession执行数据库操作 </p>\n<p>4、 调用session.commit()提交事务 </p>\n<p>5、 调用session.close()关闭会话</p>\n","categories":["八股"]},{"title":"RPC","url":"/2023/06/04/RPC/","content":"<img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/202306041805677.png\" alt=\"image-20230604180538472\" style=\"zoom:50%;\">\n\n<span id=\"more\"></span>\n\n<h1 id=\"资料\"><a href=\"#资料\" class=\"headerlink\" title=\"资料\"></a>资料</h1><p>总结</p>\n<p><a href=\"https://www.jianshu.com/p/28e48e5f9c73\">https://www.jianshu.com/p/28e48e5f9c73</a></p>\n<p><a href=\"https://www.cnblogs.com/javaguide/p/rpc.html\">https://www.cnblogs.com/javaguide/p/rpc.html</a></p>\n<p><a href=\"https://ac.nowcoder.com/discuss/965487?type=2&amp;order=1&amp;pos=423&amp;page=1&amp;channel=-1&amp;source_id=discuss_center_2_nctrack\">https://ac.nowcoder.com/discuss/965487?type=2&amp;order=1&amp;pos=423&amp;page=1&amp;channel=-1&amp;source_id=discuss_center_2_nctrack</a></p>\n<p>具体讲解</p>\n<p><a href=\"https://blog.csdn.net/qq_40856284/category_10138756.html\">https://blog.csdn.net/qq_40856284/category_10138756.html</a></p>\n<p>面试教程</p>\n<p><a href=\"https://blog.csdn.net/wwxy1995/article/details/113781493\">https://blog.csdn.net/wwxy1995/article/details/113781493</a></p>\n<p>面试问题</p>\n<p><a href=\"https://blog.csdn.net/m0_37787662/article/details/124626953?spm=1001.2101.3001.6650.2&amp;utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-2-124626953-blog-113781493.235%5Ev29%5Epc_relevant_default_base3&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-2-124626953-blog-113781493.235%5Ev29%5Epc_relevant_default_base3&amp;utm_relevant_index=3\">https://blog.csdn.net/m0_37787662/article/details/124626953?spm=1001.2101.3001.6650.2&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-2-124626953-blog-113781493.235%5Ev29%5Epc_relevant_default_base3&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-2-124626953-blog-113781493.235%5Ev29%5Epc_relevant_default_base3&amp;utm_relevant_index=3</a></p>\n<h1 id=\"简历\"><a href=\"#简历\" class=\"headerlink\" title=\"简历\"></a>简历</h1><p>1、基于选择器和虚拟节点，实现一致性哈希算法进行负载均衡，降低节点的数据迁移</p>\n<p>2、使用 Zookeeper 作为注册中心，实现持久化节点的创建、子节点列表的获取、节点变化时的自动更新<br>3、采用Netty简化网络传输过程，实现了Channel的缓存化和消息的发送、接收与动态响应等<br>4、使用Kyro进行序列化与反序列化，用ThreadLocal存储Kyro实例解决了线程不安全的问题<br>5、通过JDK动态代理调用远程方法，使用 CompletableFuture 包装接受服务端返回结果  </p>\n<h1 id=\"整体\"><a href=\"#整体\" class=\"headerlink\" title=\"整体\"></a>整体</h1><h2 id=\"整体服务调用链路是怎样的？\"><a href=\"#整体服务调用链路是怎样的？\" class=\"headerlink\" title=\"整体服务调用链路是怎样的？\"></a>整体服务调用链路是怎样的？</h2><p><strong>客户端</strong> （Client）:服务调用方（服务消费者）</p>\n<p><strong>客户端存根</strong> （Client Stub）:存放服务端地址信息，将客户端的请求参数数据信息打包成网络消息，再通过网络传输发送给服务端</p>\n<p><strong>服务端存根</strong> （Server Stub）:接收客户端发送过来的请求消息并进行解包，然后再调用本地服务进行处理</p>\n<p><strong>服务端</strong> （Server）:服务的真正提供者</p>\n<p>服务消费者（client客户端）通过调用本地服务的方式调用需要消费的服务；</p>\n<p>客户端存根（client stub）接收到调用请求后负责将方法、入参等信息序列化（组装）成能够进行网络传输的消息体；</p>\n<p>客户端存根（client stub）找到远程的服务地址，并且将消息通过网络发送给服务端；</p>\n<p>服务端存根（server stub）收到消息后进行解码（反序列化操作）；</p>\n<p>服务端存根（server stub）根据解码结果调用本地的服务进行相关处理；</p>\n<p>本地服务执行具体业务逻辑并将处理结果返回给服务端存根（server stub）；</p>\n<p>服务端存根（server stub）将返回结果重新打包成消息（序列化）并通过网络发送至消费方；</p>\n<p>客户端存根（client stub）接收到消息，并进行解码（反序列化）；</p>\n<p>服务消费方得到最终结果</p>\n<h1 id=\"我的\"><a href=\"#我的\" class=\"headerlink\" title=\"我的\"></a>我的</h1><p>RpcRequest</p>\n<pre><code>public class RpcRequest implements Serializable &#123;\n    private static final long serialVersionUID = 1905122041950251207L;//序列化版本\n    private String requestId;//请求Id\n    private String interfaceName;//接口名\n    private String methodName;//方法名\n    private Object[] parameters;//参数\n    private Class&lt;?&gt;[] paramTypes;//参数类型\n    private String version;//版本号\n    private String group;//一个接口多个实现类的问他\n</code></pre>\n<p>上面是data</p>\n<p>根据负载均衡算法从zookeeper里面找到对应服务名称的一个服务地址，构造rpcMessage对象，data属性就是上面的rpcRequest，然后是序列化方式、压缩方式、消息类型，发送这个对象，添加一个监听器</p>\n<p>用completableFuture接收channel的返回值</p>\n<p>服务端启动的时候就会把自己注册到zookeeper，同时getData(),拿到rpcRequest（rpcRequest.getRpcServiceName()是接口、组、版本号）,获取具体实现类名，方法名，调用方法得到结果，封装到RPCMessage,</p>\n<h2 id=\"总体流程（待丰富）\"><a href=\"#总体流程（待丰富）\" class=\"headerlink\" title=\"总体流程（待丰富）\"></a>总体流程（待丰富）</h2><p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/image-20230416164720582.png\" alt=\"image-20230416164720582\"></p>\n<p>自己画画</p>\n<p>1、client以本地调用方式调用远程服务（）</p>\n<p>2、客户端stub接受到调用将类、方法、参数组装为能进行网络传输的消息体：RPCRequest</p>\n<p>3、客户端Stub (client stub)找到远程服务的地址，并将消息发送到服务提供端;</p>\n<p>4．服务端Stub (桩)收到消息将消息反序列化为Java对象:RpcRequest ;</p>\n<p>5．服务端Stub(桩)根据RpcRequest 中的类、方法、方法参数等信息调用本地的方法;</p>\n<p>6．服务端Stub(桩）得到方法执行结果并将组装成能够进行网络传输的消息体:RpcResponse(序列化)发送至消费方;<br>7．客户端Stub (client stub）接收到消息并将消息反序列化为Java对象:RpcResponse，这样也就得到了最终结果。over!</p>\n<h1 id=\"RPC相关\"><a href=\"#RPC相关\" class=\"headerlink\" title=\"RPC相关\"></a>RPC相关</h1><h2 id=\"RPC框架有哪些\"><a href=\"#RPC框架有哪些\" class=\"headerlink\" title=\"RPC框架有哪些\"></a>RPC框架有哪些</h2><p>Dubbo：Java Golang等语言；提供了从服务定义、服务发现、服务通信到流量管控等几乎所有的服务治理能力，支持Triple 协议(基于HTTP&#x2F;2之上定义的下一代 RPC通信协议)、应用级服务发现、Dubbo <strong>Mesh</strong>(Dubbo3赋予了很多云原生友好的新特性）等特性。</p>\n<p>Motan:精简版Dubbo </p>\n<p>gRPC:面向移动应用，改进了通信层设计（protoBuf，灵活高效的数据格式），但没有服务治理功能，需要依赖腾讯北极星、</p>\n<p>总结：</p>\n<p>1、跨语言调用的话还是grpc 如果是java的话就dubbo</p>\n<p>2、gRPC和Thrift只提供了最基本的RPC框架功能，缺乏一系列配套的服务化组件和服务治理功能的支撑。<br>Dubbo 不论是从功能完善程度、生态系统还是社区活跃度来说都是最优秀的。</p>\n<h2 id=\"为什么要有RPC\"><a href=\"#为什么要有RPC\" class=\"headerlink\" title=\"为什么要有RPC\"></a>为什么要有RPC</h2><p>1、http接口是在接口不多、系统与系统交互较少的情况下，解决信息孤岛初期常使用的一种通信手段；优点就是简单、直接、开发方便。利用现成的http协议进行传输。但是如果是一个大型的网站，内部子系统较多、接口非常多的情况下，RPC框架的好处就显示出来了，首先就是长链接，不必每次通信都要像http一样去3次握手什么的，减少了网络开销；其次就是RPC框架一般都有注册中心，有丰富的监控管理；发布、下线接口、动态扩展等，对调用方来说是无感知、统一化的操作。第三个来说就是安全性。最后就是最近流行的服务化架构、服务化治理，RPC框架是一个强力的支撑。</p>\n<p>2、socket只是一个简单的网络通信方式，只是创建通信双方的通信通道，而要实现rpc的功能，还需要对其进行封装，以实现更多的功能。</p>\n<p>3、RPC一般配合netty框架、spring自定义注解来编写轻量级框架，其实netty内部是封装了socket的，较新的jdk的IO一般是NIO，即非阻塞IO，在高并发网站中，RPC的优势会很明显</p>\n<h2 id=\"什么是RPC\"><a href=\"#什么是RPC\" class=\"headerlink\" title=\"什么是RPC\"></a>什么是RPC</h2><p>RPC（Remote Procedure Call Protocol）远程过程调用协议，它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。简言之，RPC使得程序能够像访问本地系统资源一样，去访问远端系统资源。比较关键的一些方面包括：通讯协议、序列化、资源（接口）描述、服务框架、性能、语言支持等</p>\n<h2 id=\"RPC组件和调用过程\"><a href=\"#RPC组件和调用过程\" class=\"headerlink\" title=\"RPC组件和调用过程\"></a>RPC组件和调用过程</h2><p>一个基本的RPC架构里面应该至少包含以下4个组件： </p>\n<p>1、客户端（Client）:服务调用方（服务消费者）<br> 2、客户端存根（Client Stub）:存放服务端地址信息，将客户端的请求参数数据信息打包成网络消息，再通过网络传输发送给服务端<br> 3、服务端存根（Server Stub）:接收客户端发送过来的请求消息并进行解包，然后再调用本地服务进行处理</p>\n<p>4、服务端（Server）:服务的真正提供者</p>\n<p>具体调用过程：<br> 1、服务消费者（client客户端）通过调用本地服务的方式调用需要消费的服务；（当客户端调用远程服务时，它实际上是通过代理对象来调用的）<br> 2、客户端存根（client stub）接收到调用请求后负责将方法、入参等信息序列化（组装）成能够进行网传输的消息体；（序列化 编码 ）<br> 3、客户端存根（client stub）（通过zookeeper负载均衡 服务端注册 客户端服务发现）找到远程的服务地址，并且将消息通过网络发送给服务端；<br> 4、服务端存根（server stub）收到消息后进行解码（反序列化操作）；<br> 5、服务端存根（server stub）根据解码结果调用本地的服务进行相关处理；<br> 6、本地服务执行具体业务逻辑并将处理结果返回给服务端存根（server stub）；<br> 7、服务端存根（server stub）将返回结果重新打包成消息（序列化）并通过网络发送至消费方；<br> 8、客户端存根（client stub）接收到消息，并进行解码（反序列化）；<br> 9、服务消费方得到最终结果；<br> 而RPC框架的实现目标则是将上面的第2-10步完好地封装起来，也就是把调用、编码&#x2F;解码的过程给封装起来，让用户感觉上像调用本地服务一样的调用远程服务。</p>\n<h2 id=\"RPC框架需要解决的问题？\"><a href=\"#RPC框架需要解决的问题？\" class=\"headerlink\" title=\"RPC框架需要解决的问题？\"></a>RPC框架需要解决的问题？</h2><blockquote>\n<p>1、如何确定客户端和服务端之间的通信协议？<br>2、如何更高效地进行网络通信？<br>3、服务端提供的服务如何暴露给客户端？<br>4、客户端如何发现这些暴露的服务？<br>5、如何更高效地对请求对象和响应结果进行序列化和反序列化操作？</p>\n</blockquote>\n<h2 id=\"RPC使用了哪些关键技术？\"><a href=\"#RPC使用了哪些关键技术？\" class=\"headerlink\" title=\"RPC使用了哪些关键技术？\"></a>RPC使用了哪些关键技术？</h2><blockquote>\n<ul>\n<li>1、动态代理 生成Client Stub（客户端存根）和Server Stub（服务端存根）的时候需要用到Java动态代理技术，可以使用JDK提供的原生的动态代理机制，也可以使用开源的：CGLib代理，Javassist字节码生成技术。</li>\n<li>2、序列化和反序列化 在网络中，所有的数据都将会被转化为字节进行传送，所以为了能够使参数对象在网络中进行传输，需要对这些参数进行序列化和反序列化操作。 序列化：把对象转换为字节序列的过程称为对象的序列化，也就是编码的过程。反序列化：把字节序列恢复为对象的过程称为对象的反序列化，也就是解码的过程。 目前比较高效的开源序列化框架：如Kryo、FastJson和Protobuf等。<br>反序列化：把字节序列恢复为对象的过程称为对象的反序列化，也就是解码的过程。 目前比较高效的开源序列化框架：如Kryo、FastJson和Protobuf等。</li>\n<li>3、NIO通信 出于并发性能的考虑，传统的阻塞式 IO 显然不太合适，因此我们需要异步的 IO，即 NIO。Java 提供了 NIO 的解决方案，Java 7 也提供了更优秀的 NIO.2 支持。可以选择Netty或者MINA来解决NIO数据传输的问题。</li>\n<li>4、服务注册中心 可选：Redis、Zookeeper、Consul 、Etcd。一般使用ZooKeeper提供服务注册与发现功能，解决单 点故障以及分布式部署的问题(注册中心)。</li>\n</ul>\n</blockquote>\n<h2 id=\"RPC的实现原理架构图\"><a href=\"#RPC的实现原理架构图\" class=\"headerlink\" title=\"RPC的实现原理架构图\"></a>RPC的实现原理架构图</h2><p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/04e5b3e5f9e14cd689323d3a833e7c12~tplv-k3u1fbpfcp-zoom-in-crop-mark%3A4536%3A0%3A0%3A0.awebp\" alt=\"image.png\"></p>\n<p>也就是说两台服务器A，B，一个应用部署在A服务器上，想要调用B服务器上应用提供的函数&#x2F;方法，由于不在一个内存空间，不能直接调用，需要通过网络来表达调用的语义和传达调用的数据。 比如说，A服务器想调用B服务器上的一个方法：</p>\n<ul>\n<li>1、建立通信 首先要解决通讯的问题：即A机器想要调用B机器，首先得建立起通信连接。主要是通过在客户端和服务器之间建立TCP连接，远程过程调用的所有交换的数据都在这个连接里传输。连接可以是按需连接，调用结束后就断掉，也可以是长连接，多个远程过程调用共享同一个连接。<br>通常这个连接可以是按需连接（需要调用的时候就先建立连接，调用结束后就立马断掉），也可以是长连接（客户端和服务器建立起连接之后保持长期持有，不管此时有无数据包的发送，可以配合心跳检测机制定期检测建立的连接是否存活有效），多个远程过程调用共享同一个连接。</li>\n<li>2、服务寻址 要解决寻址的问题，也就是说，A服务器上的应用怎么告诉底层的RPC框架，如何连接到B服务器（如主机或IP地址）以及特定的端口，方法的名称名称是什么。通常情况下我们需要提供B机器（主机名或IP地址）以及特定的端口，然后指定调用的方法或者函数的名称以及入参出参等信息，这样才能完成服务的一个调用。可靠的寻址方式（主要是提供服务的发现）是RPC的实现基石，比如可以采用Redis或者Zookeeper来注册服务等等。</li>\n<li>2.1、从服务提供者的角度看： 当服务提供者启动的时候，需要将自己提供的服务注册到指定的注册中心，以便服务消费者能够通过服务注册中心进行查找；当服务提供者由于各种原因致使提供的服务停止时，需要向注册中心注销停止的服务；服务的提供者需要定期向服务注册中心发送心跳检测，服务注册中心如果一段时间未收到来自服务提供者的心跳后，认为该服务提供者已经停止服务，则将该服务从注册中心上去掉。</li>\n<li>2.2、从调用者的角度看： 服务的调用者启动的时候根据自己订阅的服务向服务注册中心查找服务提供者的地址等信息；当服务调用者消费的服务上线或者下线的时候，注册中心会告知该服务的调用者；服务调用者下线的时候，则取消订阅。</li>\n<li>3、网络传输</li>\n<li>3.1、序列化 当A机器上的应用发起一个RPC调用时，调用方法和其入参等信息需要通过底层的网络协议如TCP传输到B机器，由于网络协议是基于二进制的，所有我们传输的参数数据都需要先进行序列化（Serialize）或者编组（marshal）成二进制的形式才能在网络中进行传输。然后通过寻址操作和网络传输将序列化或者编组之后的二进制数据发送给B机器。</li>\n<li>3.2、反序列化 当B机器接收到A机器的应用发来的请求之后，又需要对接收到的参数等信息进行反序列化操作（序列化的逆操作），即将二进制信息恢复为内存中的表达方式，然后再找到对应的方法（寻址的一部分）进行本地调用（一般是通过生成代理Proxy去调用, 通常会有JDK动态代理、CGLIB动态代理、Javassist生成字节码技术等），之后得到调用的返回值。</li>\n<li>4、服务调用 B机器进行本地调用（通过代理Proxy和反射调用）之后得到了返回值，此时还需要再把返回值发送回A机器，同样也需要经过序列化操作，然后再经过网络传输将二进制数据发送回A机器，而当A机器接收到这些返回值之后，则再次进行反序列化操作，恢复为内存中的表达方式，最后再交给A机器上的应用进行相关处理（一般是业务逻辑处理操作）。 通常，经过以上四个步骤之后，一次完整的RPC调用算是完成了，另外可能因为网络抖动等原因需要重试等。</li>\n</ul>\n<h2 id=\"微服务之间如何进行通信？\"><a href=\"#微服务之间如何进行通信？\" class=\"headerlink\" title=\"微服务之间如何进行通信？\"></a>微服务之间如何进行通信？</h2><p><strong>参考答案</strong>：</p>\n<ul>\n<li><strong>单体项目</strong>时：<strong>一次服务调用</strong>发生在<strong>同一台机器</strong>上的<strong>同一个进程内部</strong>，也就是说调用发生在本机内部，因此也被叫作本地方法调用。</li>\n<li><strong>微服务项目</strong>时：<strong>服务提供者</strong>和<strong>服务消费者</strong>运行在<strong>两台不同物理机上的不同进程内</strong>，它们之间的调用相比于本地方法调用，可称之为远程方法调用，简称 RPC</li>\n</ul>\n<h2 id=\"RPC了解多少？都有哪些？\"><a href=\"#RPC了解多少？都有哪些？\" class=\"headerlink\" title=\"RPC了解多少？都有哪些？\"></a><strong>RPC了解多少？都有哪些？</strong></h2><p><strong>参考答案</strong>：RPC全称称： Remote Procedure Calls 远程服务调用，是进行服务之间相互调用的。</p>\n<p><strong>受限语言</strong>的开源 RPC 框架</p>\n<ul>\n<li><strong>Dubbo</strong>：<strong>阿里</strong>2011年开源，仅支持 Java 语言。(<strong>官方文档</strong>：<a href=\"https://hd.nowcoder.com/link.html?target=https://dubbo.apache.org/zh/docs/\">https://dubbo.apache.org/zh/docs/</a>)</li>\n<li><strong>Motan</strong>：<strong>微博</strong>2016 年开源，仅支持 Java 语言。(<strong>Github地址</strong>：<a href=\"https://hd.nowcoder.com/link.html?target=https://github.com/weibocom/motan\">https://github.com/weibocom/motan</a>)</li>\n<li><strong>Tars</strong>：<strong>腾讯</strong>2017 年开源，仅支持 C++ 语言。(<strong>官方文档</strong>：<a href=\"https://hd.nowcoder.com/link.html?target=https://tarscloud.github.io/TarsDocs/installation/source.html\">https://tarscloud.github.io/TarsDocs/installation/source.html</a>)</li>\n<li><strong>Spring Cloud Feigh</strong>：国外 Pivotal 公司 2014 年对外开源的 RPC 框架，仅支持 Java 语言(Github:<a href=\"https://hd.nowcoder.com/link.html?target=https://github.com/OpenFeign/feign\">https://github.com/OpenFeign/feign)【后面又出现了SpringCloud</a>【后面又出现了SpringCloud) Alibaba， Spring-Cloud-Alibaba 项目由阿里巴巴的开源组件和多个阿里云产品组成，旨在实现和公开众所周知的 Spring 框架模式和抽象，为使用阿里巴巴产品的 Java 开发者带来 Spring-Boot 和 Spring-Cloud 的好处。 】</li>\n</ul>\n<p><strong>跨语言平台</strong>的开源 RPC 框架主要有以下几种。</p>\n<ul>\n<li><strong>GRPC</strong>：<strong>Google</strong> 2015 年开源，支持多种语言。(官方文档：<a href=\"https://hd.nowcoder.com/link.html?target=https://grpc.io/docs/\">https://grpc.io/docs/</a>)</li>\n<li><strong>Thrift</strong>：最初<strong>Facebook</strong> 开发的内部框架，2007 年贡献给了 Apache 基金，成为 Apache 开源项目之一，支持多种语言。<br><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/d6e935a5-fd5b-4cc8-8674-0441d04f8a27.png\" alt=\"Dubbo架构\"></li>\n</ul>\n<h2 id=\"RPC包含哪些部分？\"><a href=\"#RPC包含哪些部分？\" class=\"headerlink\" title=\"RPC包含哪些部分？\"></a><strong>RPC包含哪些部分？</strong></h2><p><strong>参考答案</strong>：一个RPC框架要包含</p>\n<ul>\n<li>客户端和服务端建立网络连接模块( <strong>server</strong>模块、<strong>client</strong>模块 )</li>\n<li>服务端<strong>处理请求模块</strong></li>\n<li><strong>协议</strong>模块</li>\n<li><strong>序列化</strong>和<strong>反序列</strong>模块。</li>\n</ul>\n<h2 id=\"设计一个RPC会考虑哪些问题？\"><a href=\"#设计一个RPC会考虑哪些问题？\" class=\"headerlink\" title=\"设计一个RPC会考虑哪些问题？\"></a><strong>设计一个RPC会考虑哪些问题？</strong></h2><p><strong>参考答案</strong>：设计一个RPC框架，可以从PRC包含的几个模块去考虑，对每一个模块分别进行设计。</p>\n<ul>\n<li><strong>客户端</strong>和<strong>服务端如何建立网络连接</strong>？</li>\n<li><strong>服务端</strong>如何<strong>处理请求</strong>？</li>\n<li><strong>数据传输</strong>采用什么<strong>协议</strong>？</li>\n<li><strong>数据</strong>该如何<strong>序列化</strong>和<strong>反序列化</strong>？</li>\n</ul>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/202306041807280.png\" alt=\"gRPC架构\"></p>\n<h1 id=\"序列化与反序列化\"><a href=\"#序列化与反序列化\" class=\"headerlink\" title=\"序列化与反序列化\"></a>序列化与反序列化</h1><h2 id=\"Kryo原理\"><a href=\"#Kryo原理\" class=\"headerlink\" title=\"Kryo原理\"></a>Kryo原理</h2><p>序列化是指将对象转换为字节流的过程，以便在网络上传输或存储。Kryo是一个高效的Java序列化框架，它能够将Java对象快速且高效地序列化为二进制数据，并能够将这些二进制数据快速地反序列化为Java对象。</p>\n<p>Kryo的序列化过程分为两个阶段：注册阶段和序列化阶段。在注册阶段，Kryo会扫描整个Java类路径，将所有需要序列化的类注册到Kryo的注册中心中，以便在序列化时快速地查找类信息。在序列化阶段，Kryo会将Java对象序列化为二进制数据，其中包含了对象的类型、属性名和属性值等信息。在反序列化时，Kryo会根据二进制数据中包含的类型信息，将二进制数据快速地反序列化为Java对象。</p>\n<p>Kryo序列化的原理主要包括以下几个方面：</p>\n<ol>\n<li>注册机制：Kryo通过注册机制将Java类的信息保存在注册中心中，以便在序列化和反序列化时快速地查找类信息。Kryo的注册机制采用了类似于Java序列化中的 serialVersionUID的机制来保证序列化和反序列化的兼容性。</li>\n<li>缓存机制：Kryo在序列化和反序列化时会使用缓存来提高性能。在序列化时，Kryo会将序列化过的对象保存在缓存中，以便在序列化其他对象时能够快速地查找已经序列化过的对象。在反序列化时，Kryo会使用缓存来避免反复创建Java对象，从而提高性能。</li>\n<li>指令集：Kryo使用一套指令集来实现序列化和反序列化。这套指令集包括了对象类型、字段名和字段值等信息，以便在序列化和反序列化时能够准确地还原Java对象。</li>\n</ol>\n<p>总的来说，Kryo序列化的原理主要包括了注册机制、缓存机制和指令集等方面，这些机制和原理都为Kryo的高效性能提供了保障。</p>\n<h2 id=\"netty-bytebuf工作原理\"><a href=\"#netty-bytebuf工作原理\" class=\"headerlink\" title=\"netty bytebuf工作原理\"></a>netty bytebuf工作原理</h2><p><code>ByteBuf</code>是Netty中提供的一个字节缓冲区实现，它的工作原理与Java NIO中的<code>Buffer</code>类有些不同，具体来说，<code>ByteBuf</code>有以下几个特点：</p>\n<ol>\n<li>引用计数：<code>ByteBuf</code>采用了引用计数机制来管理内存，当一个<code>ByteBuf</code>对象被创建时，它会在堆内存或者直接内存中分配一段连续的内存空间，并将它的引用计数初始化为1。当<code>ByteBuf</code>被传递给其他对象时，其引用计数会增加；当<code>ByteBuf</code>不再被使用时，其引用计数会减少，当引用计数为0时，<code>ByteBuf</code>会被释放掉。这种机制可以避免内存泄漏和重复释放的问题。</li>\n<li>可扩展：<code>ByteBuf</code>的大小是可以动态扩展的，当写入的数据超过了缓冲区的容量时，<code>ByteBuf</code>会自动扩展容量，并将原有的数据复制到新的内存空间中，这种机制可以避免缓冲区溢出的问题。</li>\n<li>零拷贝：<code>ByteBuf</code>支持零拷贝，即在传输数据时可以避免数据的复制，减少内存的开销和提高性能。</li>\n</ol>\n<p>与Java NIO中的<code>Buffer</code>类相比，<code>ByteBuf</code>的主要区别如下：</p>\n<ol>\n<li><code>ByteBuf</code>采用了引用计数机制，避免了内存泄漏和重复释放的问题，而<code>Buffer</code>则没有引用计数机制。</li>\n<li><code>ByteBuf</code>的容量是可以动态扩展的，而<code>Buffer</code>的容量是固定的。</li>\n<li><code>ByteBuf</code>支持零拷贝，可以避免数据的复制，而<code>Buffer</code>则需要通过复制将数据从内核空间复制到用户空间。</li>\n</ol>\n<p>综上所述，<code>ByteBuf</code>相比于<code>Buffer</code>具有更多的优势，能够更好地支持高性能网络应用程序的开发。</p>\n<h2 id=\"序列化与反序列的方式有哪些？\"><a href=\"#序列化与反序列的方式有哪些？\" class=\"headerlink\" title=\"序列化与反序列的方式有哪些？\"></a><strong>序列化与反序列的方式有哪些？</strong></h2><p><strong>参考答案</strong>： 常用的序列化方式分为两类</p>\n<ul>\n<li>文本类如 XML&#x2F;JSON 等</li>\n<li>二进制类如 PB&#x2F;Thrift 等</li>\n</ul>\n<h2 id=\"有哪些序列化协议？\"><a href=\"#有哪些序列化协议？\" class=\"headerlink\" title=\"有哪些序列化协议？\"></a><strong>有哪些序列化协议？</strong></h2><p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/018310a6-6f6d-40db-b0dc-13487d4e6c6f.png\" alt=\"参考答案\"></p>\n<h2 id=\"为什么要进行序列化和反序列化？\"><a href=\"#为什么要进行序列化和反序列化？\" class=\"headerlink\" title=\"为什么要进行序列化和反序列化？\"></a><strong>为什么要进行序列化和反序列化？</strong></h2><p><strong>参考答案</strong>：为什么需要序列化和反序列化，有下面几点原因。</p>\n<ul>\n<li>解决内存中<strong>数据结构</strong>到<strong>字节序列的映射过程中</strong>，如何保留各个结构和字段间的关系而生的技术 。</li>\n<li>解决<strong>异构系统的数据传输</strong>，比如大小端、远端的持久存储；</li>\n<li><strong>压缩数据，加快网络传输</strong>。【 网络传输耗时一方面取决于网络带宽大小，另一方面取决于数据传输量。想加快网络传输，要么提高带宽，要么减小数据传输量，而对数据进行编码的主要目的就是减小数据传输量。比如一部高清电影原始大小为 30GB，如果经过特殊编码格式处理，可以减小到 3GB，同样是 100MB&#x2F;s 的网速，下载时间可以从 300s 减小到 30s。 】</li>\n</ul>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/d0580b98-2bf5-4340-ad24-4ade48707cc2.png\" alt=\"Thrift架构\"></p>\n<h2 id=\"为什么选用Kyro\"><a href=\"#为什么选用Kyro\" class=\"headerlink\" title=\"为什么选用Kyro\"></a>为什么选用Kyro</h2><p>变长存储特性，字节码生成机制，运行速度快，占用较少的字节码体积，专门针对java</p>\n<h2 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h2><p>这是一个使用 Kryo 序列化和反序列化 Java 对象的类，为了解决 Kryo 线程不安全的问题，使用 ThreadLocal 为每个线程创建一个独立的 Kryo 实例，保证了线程安全性。</p>\n<p><strong>初始化</strong></p>\n<p>KryoSerializer 类实现了Serializer 接口</p>\n<p>为了解决 Kryo 线程不安全的问题，使用 ThreadLocal 为每个线程创建一个独立的 Kryo 实例，保证了线程安全性。withInitial（）用lamba表达式new了一个kyro实例并注册了RpcResponse 和 RpcRequest 两个类。</p>\n<p>ByteArrayOutputStream :用于存储序列化后的字节数组</p>\n<p>Output : Kryo 序列化库的 Output 对象，将其构造函数中传入的 ByteArrayOutputStream 对象作为参数，以便将序列化后的数据写入 ByteArrayOutputStream 中。</p>\n<p><strong>serialize</strong></p>\n<ol>\n<li>创建一个 ByteArrayOutputStream 和 Output 实例，Output 用于将序列化的对象写入 ByteArrayOutputStream 中。</li>\n<li>获取当前线程的kyro实例</li>\n<li>kryo 将 obj 对象（传入的rpcrequest）序列化成字节数组并写入 Output 中。</li>\n<li>remove清除当前线程的 Kryo 实例</li>\n<li>将 ByteArrayOutputStream 中的数据转换为字节数组并返回。</li>\n</ol>\n<p><strong>deserialize</strong></p>\n<ol>\n<li>创建一个 ByteArrayInputStream 和 Input 实例，Input 从 ByteArrayInputStream 中读取反序列化的对象。</li>\n<li>获取当前线程的 Kryo 实例</li>\n<li>从 Input 中读取字节数组并反序列化成对象。</li>\n<li>清除当前线程的 Kryo 实例。</li>\n<li>将反序列化后的对象强制类型转换为指定的类型并返回。</li>\n</ol>\n<p><strong>为什么用kyro？</strong></p>\n<p>变长存储特性，字节码生成机制，运行速度快，占用较少的字节码体积，专门针对java</p>\n<p><strong>为什么用ThreadLocal？</strong></p>\n<p>key是当前线程，value是kryo实例，防止多个服务调用之间会造成kyro线程不安全的问题，每个线程存一份kyro，多个线程互不影响  </p>\n<pre><code class=\"java\">@Slf4j\npublic class KryoSerializer implements Serializer &#123;\n\n    /**\n     * Because Kryo is not thread safe. So, use ThreadLocal to store Kryo objects\n     * 这是一个使用 Kryo 序列化和反序列化 Java 对象的类，为了解决 Kryo 线程不安全的问题，使用 ThreadLocal 为每个线程创建一个独立的 Kryo 实例，保证了线程安全性。\n     */\n    private final ThreadLocal&lt;Kryo&gt; kryoThreadLocal = ThreadLocal.withInitial(() -&gt; &#123;\n        Kryo kryo = new Kryo();\n//        注册了 RpcResponse 和 RpcRequest 两个类。\n        kryo.register(RpcResponse.class);\n        kryo.register(RpcRequest.class);\n        return kryo;\n    &#125;);\n\n    @Override\n    public byte[] serialize(Object obj) &#123;\n        try (ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();\n//             创建一个 ByteArrayOutputStream 和 Output 实例，Output 将序列化的对象写入 ByteArrayOutputStream 中。\n             Output output = new Output(byteArrayOutputStream)) &#123;\n//            获取当前线程的 Kryo 实例\n            Kryo kryo = kryoThreadLocal.get();\n            //   kryo 将 obj 对象序列化成字节数组并写入 Output 中。\n            kryo.writeObject(output, obj);\n            kryoThreadLocal.remove();//清除当前线程的 Kryo 实例\n//            将 ByteArrayOutputStream 中的数据转换为字节数组并返回。\n            return output.toBytes();\n        &#125; catch (Exception e) &#123;\n            throw new SerializeException(&quot;Serialization failed&quot;);\n        &#125;\n    &#125;\n\n    @Override\n    public &lt;T&gt; T deserialize(byte[] bytes, Class&lt;T&gt; clazz) &#123;\n//        创建一个 ByteArrayInputStream 和 Input 实例，Input 从 ByteArrayInputStream 中读取反序列化的对象。\n        try (ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(bytes);\n             Input input = new Input(byteArrayInputStream)) &#123;\n            Kryo kryo = kryoThreadLocal.get();//获取当前线程的 Kryo 实例。\n            // byte-&gt;Object:从byte数组中反序列化出对对象\n            Object o = kryo.readObject(input, clazz);\n            kryoThreadLocal.remove();//清除当前线程的 Kryo 实例\n            return clazz.cast(o);//将反序列化后的对象强制类型转换为指定的类型并返回。\n        &#125; catch (Exception e) &#123;\n            throw new SerializeException(&quot;Deserialization failed&quot;);\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<pre><code class=\"java\">//具体理解下这段代码：\nByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();\nOutput output = new Output(byteArrayOutputStream)\n</code></pre>\n<p>ByteArrayOutputStream :用于存储序列化后的字节数组</p>\n<p>Output : Kryo 序列化库的 Output 对象，将其构造函数中传入的 ByteArrayOutputStream 对象作为参数，以便将序列化后的数据写入 ByteArrayOutputStream 中。</p>\n<p>这样，通过 Output 对象，可以将需要序列化的对象写入到 ByteArrayOutputStream 缓冲区中。具体来说，通过调用 Output 对象的 writeObject() 方法，将需要序列化的对象写入 ByteArrayOutputStream 缓冲区中。</p>\n<p>在这段代码中，由于 Output 对象是通过 ByteArrayOutputStream 对象构造而来的，因此 Output 对象将序列化后的数据写入了 ByteArrayOutputStream 缓冲区中，而非其他输出流。同时，由于 ByteArrayOutputStream 对象是一个字节数组输出流，因此序列化后的数据会被存储在内存中的字节数组中。这个字节数组可以通过调用 ByteArrayOutputStream 的 toBytes() 方法获取。</p>\n<p>需要注意的是，在使用完 Output 对象后，需要调用其 close() 方法关闭，以释放底层资源。在这里，由于使用了 try-with-resources 语句块，因此 Output 对象会在使用完毕后自动关闭，无需手动调用 close() 方法。</p>\n<h1 id=\"负载均衡\"><a href=\"#负载均衡\" class=\"headerlink\" title=\"负载均衡\"></a>负载均衡</h1><h2 id=\"负载均衡了解哪些-dubbo的四种策略\"><a href=\"#负载均衡了解哪些-dubbo的四种策略\" class=\"headerlink\" title=\"负载均衡了解哪些(dubbo的四种策略)\"></a>负载均衡了解哪些(dubbo的四种策略)</h2><ol>\n<li>随机负载均衡(Random Load Balance)：随机选择一个可用的服务提供者进行调用。实现简单，适合轻度负载情况下使用。</li>\n<li>轮询负载均衡(Round Robin Load Balance)：将请求轮流分配给每个可用的服务提供者，保证每个服务提供者都能被调用到。适合负载均衡比较均衡的情况下使用。</li>\n<li>最少活跃调用数负载均衡(Least Active Load Balance)：统计每个服务提供者的活跃调用数，将请求分发到活跃调用数最小的服务提供者。适合并发量较大、负载不均衡的情况下使用。</li>\n<li><strong>一致性哈希负载均衡</strong>(Consistent Hash Load Balance)：将每个服务提供者映射到哈希环上，将请求根据哈希值映射到环上的某个服务提供者，从而实现负载均衡。适合服务提供者数量变化较大的情况下使用。</li>\n</ol>\n<h2 id=\"Dubbo为什么推荐基于随机的负载均衡？\"><a href=\"#Dubbo为什么推荐基于随机的负载均衡？\" class=\"headerlink\" title=\"Dubbo为什么推荐基于随机的负载均衡？\"></a>Dubbo为什么推荐基于随机的负载均衡？</h2><p>Dubbo是一种高性能的分布式服务框架，提供了负载均衡的功能来平衡分布式系统中的负载。Dubbo推荐基于随机的负载均衡算法，原因如下：</p>\n<ol>\n<li>随机的负载均衡算法可以避免单点故障。与基于权重的负载均衡算法相比，基于随机的负载均衡算法不依赖于权重，因此不会因为权重调整不当而导致单点故障。</li>\n<li>随机的负载均衡算法可以避免负载集中。基于随机的负载均衡算法会在所有服务提供者之间随机分配请求，从而避免某些服务提供者因为负载过高而导致系统不稳定的情况。</li>\n<li>随机的负载均衡算法可以提高系统的吞吐量。基于随机的负载均衡算法可以在所有服务提供者之间随机分配请求，从而使系统能够更好地利用资源，提高系统的吞吐量。</li>\n</ol>\n<p>总的来说，Dubbo推荐基于随机的负载均衡算法，因为它可以避免单点故障、避免负载集中、提高系统的吞吐量等优点。当然，在特定的场景下，基于权重的负载均衡算法或其他负载均衡算法也可能更适合，需要根据具体情况进行选择。</p>\n<p><strong>我用一致性Hash主要是</strong></p>\n<p>一致性hash算法可以保证当机器增加或者减少时，节点之间的数据迁移只限于两个节点之间，不会造成全局的网络问题。</p>\n<h2 id=\"一致性哈希在某节点宕机时怎么保证一致性的\"><a href=\"#一致性哈希在某节点宕机时怎么保证一致性的\" class=\"headerlink\" title=\"一致性哈希在某节点宕机时怎么保证一致性的\"></a>一致性哈希在某节点宕机时怎么保证一致性的</h2><p>具体来说，当某个节点宕机时，一致性哈希算法会将该节点上的所有数据重新映射到其他节点上，从而保证数据的一致性。这个过程可以分为以下几个步骤：</p>\n<ol>\n<li>确定宕机节点：当某个节点宕机时，需要先确定它所在的节点。</li>\n<li>删除节点：将宕机节点从哈希环上删除。</li>\n<li>重新映射数据：将宕机节点上的所有数据重新映射到离它最近的节点上。</li>\n</ol>\n<p>需要注意的是，在一致性哈希算法中，节点的加入和退出都会影响数据的分布，因此在节点加入或退出时，需要重新计算数据的映射关系。</p>\n<p>为了提高一致性哈希算法的可靠性，可以采取以下措施：</p>\n<ol>\n<li>虚拟节点：通过增加虚拟节点的方式来提高节点的数量，从而减小节点宕机对数据分布的影响。</li>\n<li>备份节点：在节点加入时，可以将数据复制到其他节点上，从而提高数据的冗余度，增加系统的可靠性。</li>\n</ol>\n<p>综上所述，一致性哈希算法在某节点宕机时会将它上面的数据重新映射到其他节点上，从而保证数据的一致性。为了提高算法的可靠性，可以采取虚拟节点和备份节点等措施。</p>\n<h2 id=\"一致性哈希算法\"><a href=\"#一致性哈希算法\" class=\"headerlink\" title=\"一致性哈希算法\"></a>一致性哈希算法</h2><ul>\n<li>如果Redis被当做缓存使用，使用一致性哈希实现动态扩容缩容。</li>\n</ul>\n<p><a href=\"https://juejin.cn/post/6844903750860013576\">https://juejin.cn/post/6844903750860013576</a></p>\n<p>一致性hash算法可以保证当机器增加或者减少时，节点之间的数据迁移只限于两个节点之间，不会造成全局的网络问题。</p>\n<ol>\n<li>传统hash算法增减服务器会导致大量key重定向到其他服务器</li>\n<li>一致性hash算法有一个0-2^31的圆环(哈希值是32位无符号整形）值为Key的数据隶属于顺时针方向第一个服务器</li>\n</ol>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/1545973609449.png\" alt=\"RedisServicee4\"></p>\n<ol start=\"3\">\n<li>当宕机和扩展服务器只会影响一部分数据</li>\n</ol>\n<img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/1545977832954.png\" alt=\"哈希环\" style=\"zoom:33%;\">\n\n<img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/1545978062568.png\" alt=\"虚拟节点\" style=\"zoom: 33%;\">\n\n<ol start=\"3\">\n<li>如果节点太少,会导致数据倾斜,也就是hash范围差距大 那么可以引入了<strong>虚拟节点机制</strong>，即对每个节点计算多个哈希值，每个计算结果位置都放置在对应节点中，这些节点<strong>称为虚拟节点</strong>。</li>\n</ol>\n<ul>\n<li>如果Redis被当做一个持久化存储使用，必须使用固定的keys-to-nodes映射关系，节点的数量一旦确定不能变化。否则的话(即Redis节点需要动态变化的情况），必须使用可以在运行时进行数据再平衡的一套系统，而当前只有Redis集群可以做到这样。</li>\n</ul>\n<h2 id=\"代码实现-1\"><a href=\"#代码实现-1\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h2><p>代码具体怎么实现的？</p>\n<p>维护了一个ConcurrentHashMap类型的选择器集合，键为服务名称 rpcServiceName，值为选择器selector</p>\n<p>接收一个服务地址列表 serviceAddresses 和一个 RpcRequest 对象 rpcRequest，计算 serviceAddresses 的身份哈希码，通过 rpcRequest 中的服务名称构造出 rpcServiceName。然后从 selectors 中获取与 rpcServiceName 对应的一致性哈希选择器 ConsistentHashSelector（每个一致性哈希选择器对应一个服务），如果该选择器不存在或者哈希码不匹配，则创建一个新的一致性哈希选择器（），并将key为serviceName，value为selector放入 selectors（缓存） 中。最后，调用一致性哈希选择器的 select 方法选择一个服务地址。</p>\n<p><strong>选择器实现</strong>：</p>\n<p>再说下这个选择器的内部实现 ，维护了一个存储虚拟节点的 TreeMap （保证有序），key是hash值，value 是一个服务地址；（为什么？如果节点太少,会导致数据倾斜,也就是hash范围差距大，那么此时可以引入了<strong>虚拟节点机制</strong>，即对每个节点计算多个哈希值，每个计算结果位置都放置在对应节点中，这些节点<strong>称为虚拟节点</strong>。）</p>\n<p><strong>选择器初始化</strong>：</p>\n<p>遍历所有服务地址，为每个服务地址创建多个虚拟节点，使用 md5 算法出当前服务地址字符串的摘要数组，从 md5摘要中取出 4 个子段，并计算子段的哈希值，然后将虚拟节点的哈希值和服务地址的映射关系存储到 TreeMap 中</p>\n<p>针对每一个ip地址创建（replicaNumber &#x2F; 4）个重复节点，针对每个一个重复节点将其等间隔的分布在环形hash空间上（4个） 将虚拟节点的哈希值和服务地址的映射关系存储到 TreeMap 中 </p>\n<p>同时缓存了之前计算的 serviceAddresses 的身份哈希码</p>\n<p><strong>select方法</strong>：</p>\n<p>计算 RPC 服务名的 MD5 摘要数组，计算md5摘要哈希值并在TreeMap里面选择一个服务地址，找到虚拟节点中第一个哈希值大于等于指定哈希值的节点，如果不存在该节点，则选择环上的第一个节点，返回该节点对应的服务地址；</p>\n<h1 id=\"动态代理\"><a href=\"#动态代理\" class=\"headerlink\" title=\"动态代理\"></a>动态代理</h1><h2 id=\"JDK动态代理机制是怎么实现的（反射，再底层原理不太清楚）\"><a href=\"#JDK动态代理机制是怎么实现的（反射，再底层原理不太清楚）\" class=\"headerlink\" title=\"JDK动态代理机制是怎么实现的（反射，再底层原理不太清楚）\"></a>JDK动态代理机制是怎么实现的（反射，再底层原理不太清楚）</h2><p>在RPC中，JDK动态代理机制通常用于实现远程方法调用。具体来说，当客户端调用远程服务时，它实际上是通过代理对象来调用的。代理对象在本地接收方法调用，并将其转发到远程服务器。服务器上的远程对象处理请求，并将结果返回给代理对象，代理对象将结果传递回客户端。</p>\n<p>JDK动态代理机制是通过Java反射机制来实现的。它可以在运行时动态地创建代理类和代理对象，而无需在编译时指定代理类。代理类实现了与委托类相同的接口，并在方法调用时将请求转发到委托对象。</p>\n<p>具体来说，JDK动态代理机制是通过以下步骤实现的：</p>\n<p>​\t1.定义一个接口及其实现类;<br>​\t2.自定义InvocationHandler并重写invoke方法，在invoke 方法中我们会调用原生方法(被代理类的方法) 并自定义一些处理逻辑;<br>​\t3.通过Proxy . newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces ，InvocationHandler h)方法创建代理对象;（这是一个代理对象的工厂类，构造参数包括目标类的类加载器；代理需要实现的接口，可有多个；代理对象对应自定义的InvocationHandler）,然后调用原生方法，这里Handler起作用，实际上调用的是invoke方法，然后Invoke前后都可以对方法进行增强</p>\n<p>总的来说，JDK动态代理机制是一种灵活的方式来实现RPC，它可以根据需要创建代理对象，而无需在编译时指定代理类。同时，它还可以将远程方法调用与本地方法调用结合起来，从而提高了系统的性能和可扩展性。</p>\n<p><strong>网络传输细节都被封装在了invoke( )方法中。</strong></p>\n<h2 id=\"静态代理\"><a href=\"#静态代理\" class=\"headerlink\" title=\"静态代理\"></a>静态代理</h2><p>静态代理中，我们对目标对象的每个方法的增强都是手动完成的<br>(比如接口，一旦新增加方法，目标对象和代理对象都要进行修改)，要对每个目标类都单独写一个代理类)。<br>静态代理实现步骤:<br>1.定义一个接口及其实现类;<br>2.创建一个代理类同样实现这个接口<br>3.将目标对象注入进代理类,然后在代理类的对应方法调用目标类中的对应方法。这样的话，我们就可以通过代理类屏蔽对目标对象的访问，并且可以在目标方法执行前后做一些自己想做的事情。</p>\n<h2 id=\"动态代理-1\"><a href=\"#动态代理-1\" class=\"headerlink\" title=\"动态代理\"></a>动态代理</h2><p>动态代理更加灵活。不需要针对每个目标类都单独创建一个代理类 ，并且也不需要我们必须实现接口，我们可以直接代理实现类( CGLIB动态代理机制）。<br>从JVM角度来说，动态代理是在运行时动态生成类字节码，并加载到JVM中的。<br>说到动态代理，Spring AOP、RPC 框架应该是两个不得不的提的，它们的实现都依赖了动态代理。</p>\n<h3 id=\"JDK动态代理使用步骤\"><a href=\"#JDK动态代理使用步骤\" class=\"headerlink\" title=\"JDK动态代理使用步骤\"></a>JDK动态代理使用步骤</h3><p>1.定义一个接口及其实现类;<br>2.自定义InvocationHandler并重写invoke方法，在invoke 方法中我们会调用原生方法(被代理类的方法) 并自定义一些处理辑;<br>3.通过Proxy . newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces ，InvocationHandler h)方法创建代理对象;（这是一个代理对象的工厂类，构造参数包括目标类的类加载器；代理需要实现的接口，可有多个；代理对象对应自定义的InvocationHandler）,然后调用原生方法，这里Handler起作用，实际上调用的是invoke方法，然后Invoke前后都可以对方法进行增强</p>\n<p>invoke方法处理逻辑：</p>\n<pre><code>1、创建远程方法请求对象，调用rpcRequestTransport.sendRpcRequest(rpcRequest)\n拿到响应结果。\n2、检查响应结果是否正确，如果响应结果为null，抛出调用失败的异常，如果请求ID与响应ID不匹配，抛出请求与响应不匹配的异常， 如果响应结果状态码为null或者不是成功状态，抛出调用失败的异常\n3、返回远程方法调用的结果\n</code></pre>\n<h3 id=\"CGLIB\"><a href=\"#CGLIB\" class=\"headerlink\" title=\"CGLIB\"></a>CGLIB</h3><p>JDK动态代理有个问题，只能代理实现了接口的类。可以用CGLIB动态代理机制来避免。</p>\n<p>Spring中的AOP模块中:如果目标对象实现了接口，则默认采用JDK动态代理，否则采用CGLIB动态代理。<br>在CGLIB动态代理机制中MethodInterceptor 接口和Enhancer<br>类是核心。<br>需要自定义MethodInterceptor 并重写intercept方法，intercept 用于拦截增强被代理类的方法。</p>\n<pre><code class=\"java\">public interface MethodInterceptor\nextends Callback&#123;\n//拦截被代理类中的方法\npublic object intercept(object obj, java.lang. reflect. Method method, 0bject[] args,MethodProxy proxy) throws Throwable;\n&#125;\n</code></pre>\n<ol>\n<li><p>obj :被代理的对象( 需要增强的对象)</p>\n</li>\n<li><p>method :被拦截的方法( 需要增强的方法)</p>\n</li>\n<li><p>args:方法入参</p>\n</li>\n<li><p>methodProxy :用于调用原始方法</p>\n</li>\n</ol>\n<p>可以通过Enhancer 类来动态获取被代理类，当代理类调用方法的时候，实际调用的是MethodInterceptor中的intercept 方法。</p>\n<p>CGLIB动态代理类使用步骤<br>1.定义一个类（导入依赖）;<br>2.自定义MethodInterceptor 并写intercept 方法，intercept 用于拦截增强被代理类的方法,和JDK动态代理中的invoke 方法类似;同样的在调用原始方法（methodProxy）之前之后可以增强<br>3.通过Enhancer类的create() 创建代理类;（包括设置类加载器、设置被代理类、方法拦截器）</p>\n<p>4.最后获取代理类并调用原生方法</p>\n<h3 id=\"JDK动态代理和CGLIB动态代理对比\"><a href=\"#JDK动态代理和CGLIB动态代理对比\" class=\"headerlink\" title=\"JDK动态代理和CGLIB动态代理对比\"></a>JDK动态代理和CGLIB动态代理对比</h3><ol>\n<li><p>JDK动态代理只能只能代理实现了接口的类,而CGLIB可以代理未实现任何接口的类。另外,CGLIB动态代理是通过生成一个被代理类的子类来拦截被代理类的方法调用，因此不能代理声明为final类型的类和方法。</p>\n</li>\n<li><p>就二者的效率来说，大部分情况都是JDK动态代理更优秀,随着JDK版本的升级,这个优势更加明显</p>\n</li>\n</ol>\n<h3 id=\"静态代理和动态代理的对比\"><a href=\"#静态代理和动态代理的对比\" class=\"headerlink\" title=\"静态代理和动态代理的对比\"></a>静态代理和动态代理的对比</h3><p>1、灵活性:动态代理更加灵活,不需要必须实现接口，可以直接代理实现类,并且可以不需要针对每个目标类都创建一个代理类。 另外，静态代理中，接口一旦新增加方法，目标对象和代理对象都要进行修改，这是非常麻烦的! </p>\n<p>2、JVM层面:静态代理在编译时就将接口、实现类、代理类这些都变成了一个个实际的class文件。而动态代理是在运行时动态生成类字节码，并加载到JVM中的。</p>\n<h2 id=\"反射可以访问private方法和属性吗？如何访问？\"><a href=\"#反射可以访问private方法和属性吗？如何访问？\" class=\"headerlink\" title=\"反射可以访问private方法和属性吗？如何访问？\"></a>反射可以访问private方法和属性吗？如何访问？</h2><p>通过 setAccessible(true)</p>\n<h2 id=\"代码实现-2\"><a href=\"#代码实现-2\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h2><h3 id=\"JDK动态代理使用步骤-1\"><a href=\"#JDK动态代理使用步骤-1\" class=\"headerlink\" title=\"JDK动态代理使用步骤\"></a>JDK动态代理使用步骤</h3><p>1.定义一个接口及其实现类;<br>2.自定义InvocationHandler并重写invoke方法，在invoke 方法中我们会调用原生方法(被代理类的方法) 并自定义一些处理逻辑;</p>\n<p>invoke方法处理逻辑：</p>\n<pre><code>1、创建远程方法请求对象，调用rpcRequestTransport.sendRpcRequest(rpcRequest)\n拿到响应结果。\n2、根据传输方式发送远程方法请求，并获取响应结果\n3、检查响应结果是否正确，如果响应结果为null，抛出调用失败的异常，如果请求ID与响应ID不匹配，抛出请求与响应不匹配的异常， 如果响应结果状态码为null或者不是成功状态，抛出调用失败的异常\n4、返回远程方法调用的结果\n</code></pre>\n<p>3.通过Proxy . newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces ，InvocationHandler h)方法创建代理对象;（这是一个代理对象的工厂类，构造参数包括目标类的类加载器；代理需要实现的接口，可有多个；代理对象对应自定义的InvocationHandler）,然后调用原生方法，这里Handler起作用，实际上调用的是invoke方法，然后Invoke前后都可以对方法进行增强</p>\n<h1 id=\"注册中心\"><a href=\"#注册中心\" class=\"headerlink\" title=\"注册中心\"></a>注册中心</h1><h2 id=\"介绍一下服务注册中心怎么做的？\"><a href=\"#介绍一下服务注册中心怎么做的？\" class=\"headerlink\" title=\"介绍一下服务注册中心怎么做的？\"></a>介绍一下服务注册中心怎么做的？</h2><p>Zookeeper是一个分布式的开源服务注册中心，它提供了一个高可用的协调服务，用于协调和管理分布式系统中的各种服务和节点。Zookeeper提供了一个统一的命名空间，用于存储和管理分布式系统中的各种服务和节点，同时还提供了一个高可用的集群环境，以保证系统的可靠性和稳定性。</p>\n<p>Zookeeper的主要功能之一是服务注册和发现。在分布式系统中，通常需要注册服务和节点，并使其他节点能够发现它们。Zookeeper提供了一个统一的命名空间，用于存储和管理分布式系统中的各种服务和节点。在Zookeeper中，每个服务或节点都被表示为一个节点，节点可以具有子节点。每个节点都有一个唯一的路径和数据，其中路径用于标识节点，数据用于存储有关节点的信息。</p>\n<p>当一个节点或服务启动时，它可以将自己注册到Zookeeper中，并在节点下创建一个临时节点。这个节点将包含有关服务或节点的信息。其他节点可以查询Zookeeper以查找特定服务或节点的信息。在这种方式下，节点和服务可以动态地加入和退出系统，而不需要人工干预。</p>\n<p>Zookeeper还提供了watch机制，用于监视节点和数据的变化。当节点或数据发生变化时，Zookeeper会通知所有相关的节点。这使得系统可以动态地响应变化，同时避免了轮询的开销。</p>\n<p>总之，服务注册中心（Zookeeper）通过提供统一的命名空间和watch机制，使得分布式系统中的节点和服务可以动态地加入和退出系统，并且可以动态地响应变化，从而提高了系统的可靠性和灵活性。</p>\n<h2 id=\"为什么选zookeeper？\"><a href=\"#为什么选zookeeper？\" class=\"headerlink\" title=\"为什么选zookeeper？\"></a>为什么选zookeeper？</h2><h2 id=\"如果你节点宕机，zookeeper如何感知？\"><a href=\"#如果你节点宕机，zookeeper如何感知？\" class=\"headerlink\" title=\"如果你节点宕机，zookeeper如何感知？\"></a>如果你节点宕机，zookeeper如何感知？</h2><p>zookee提供了“心跳检测”功能，它会定时间各个服务提供者发送一个请求 (实际上建立的是一个socket长连接) . 如果长期没有响应，服务中心就认为该服务提供者已经“挂了”。并将其删除。</p>\n<p>默认的是服务提供者和zookeeper不会断开连接(创建的是永久节点) .否则应该将服务创建成临时节点，客户端和zookper建立会话后，他们之间的连接有个过期时间限制，客户端也就是服务提供者会定时向zookeeper发送心跳请求来延缓过期时间(crud操作也会延缓过期时间)，同时zookeeper会定期扫描哪些连接已经过期,如果发现这个session过期会删除这个连接中创建的临时节点</p>\n<h2 id=\"代码实现-3\"><a href=\"#代码实现-3\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h2><p>ZK_REGISTER_ROOT_PATH（根路径） + “&#x2F;“ + rpcServiceName（服务名称） + inetSocketAddress.toString()（服务地址）;</p>\n<p>我们定义了两个接口ServiceDiscovery.java 和ServiceRegistry.java ，这两个接口分别定义了服务发现和服务注册行为。</p>\n<p>接下来，我们使用zookeeper作为注册中心的实现方式，并实现了这两个接口。</p>\n<p>当我们的服务被注册进zookeeper的时候，我们将完整的服务名称rpcServiceName (classname+group+version)作为根节点（一个根节点(rpcServiceName) 可能会对应多个服务地址(相同服务被部署多份的情况)），子节点是对应的服务地址(ip+端口号)。</p>\n<p>class name :服务接口名也就是类名比如: github. javaguide . HelloService 。<br>version : 服务版本。主要是为后续不兼容升级提供可能<br>group :服务所在的组。主要用于处理一个接口有多 个类实现的情况。</p>\n<p>如果我们要获得某个服务对应的地址的话，就直接根据完整的服务名称来获取到其下的所有子节点，然后通过具体的负载均衡策略取出一个就可以了。相关代码如下在ZkServiceDiscovery. java中已经给出。</p>\n<p>CuratorUtils:</p>\n<p>一些属性</p>\n<pre><code class=\"java\">    private static final int BASE_SLEEP_TIME = 1000; //定义基本等待时间为1000毫秒\n    private static final int MAX_RETRIES = 3; //定义最大重试次数为3次\n    public static final String ZK_REGISTER_ROOT_PATH = &quot;/my-rpc&quot;; //定义服务注册的根路径为/my-rpc\n    private static final Map&lt;String, List&lt;String&gt;&gt; SERVICE_ADDRESS_MAP = new ConcurrentHashMap&lt;&gt;(); //定义一个线程安全的Map用于存储每个服务的地址列表\n    private static final Set&lt;String&gt; REGISTERED_PATH_SET = ConcurrentHashMap.newKeySet(); //定义一个线程安全的Set用于存储已经注册过的路径\n    private static CuratorFramework zkClient; //定义一个CuratorFramework类型的客户端对象\n    private static final String DEFAULT_ZOOKEEPER_ADDRESS = &quot;127.0.0.1:2181&quot;; //定义默认的Zookeeper服务器地址为127.0.0.1:2181\n</code></pre>\n<p>createPersistentNode:用于创建持久化节点</p>\n<pre><code>判断节点是否已经存在，如果存在则直接返回,如果节点不存在，则使用指定的路径(传入的)创建一个持久化节点,将已注册的路径加入到REGISTERED_PATH_SET中，以便后续检查\n</code></pre>\n<p>getChildrenNodes:用于获取指定节点下的所有子节点</p>\n<pre><code>根据SERVICE_ADDRESS_MAP判断是否已经获取过该节点的子节点列表,如果已经获取过，直接返回之前获取到的子节点列表，没有的话，声明一个空列表，用于存放获取到的子节点列表，拼接出目标节点的完整路径，获取指定节点下的所有子节点列表，将获取到的子节点列表缓存起来，便于下次快速获取，给该节点注册一个监听器(registerWatcher)，用于在节点发生变化时自动更新子节点列表，返回获取到的子节点列表\n</code></pre>\n<p>clearRegistry：清空注册表的数据</p>\n<pre><code>并行处理已注册路径的流,for each循环遍历路径，如果路径以传入的服务端的IP地址和端口号结尾，则删除该路径\n</code></pre>\n<p>getZkClient：获取ZooKeeper客户端</p>\n<pre><code>1、检查用户是否设置了 ZooKeeper 地址，如果 zkClient 已经启动，则直接返回。\n2、设置重试策略。最多重试 3 次，并会增加重试之间的休眠时间。\n3、 创建 zkClient 实例，启动 zkClient，等待 30 秒直到连接到 ZooKeeper\n</code></pre>\n<p>registerWatcher：在节点发生变化时自动更新子节点列表</p>\n<pre><code>通过拼接ZooKeeper注册根路径和服务名称得到服务路径，然后创建了一个PathChildrenCache对象，用于监听服务路径下的子节点变化，并将其添加到服务路径的监听器列表中。当服务路径下的子节点发生变化时，PathChildrenCacheListener对象会被回调，获取服务路径下所有子节点的路径（List&lt;String&gt;），将服务名称与服务地址的映射关系存入服务地址映射表中。最终通过启动PathChildrenCache对象实现监听服务地址的更新。\n</code></pre>\n<pre><code>//注册\npublic void registerService(String rpcServiceName, InetSocketAddress inetSocketAddress) &#123;\n    // 创建服务节点路径\n    String servicePath = CuratorUtils.ZK_REGISTER_ROOT_PATH（根路径） + &quot;/&quot; + rpcServiceName（服务名称） + inetSocketAddress.toString()（服务地址）;\n    // 获取Zookeeper客户端\n    CuratorFramework zkClient = CuratorUtils.getZkClient();\n    // 创建持久化节点\n    CuratorUtils.createPersistentNode(zkClient, servicePath);\n&#125;\n</code></pre>\n<pre><code>//发现\npublic InetSocketAddress lookupService(RpcRequest rpcRequest) &#123;\n    String rpcServiceName = rpcRequest.getRpcServiceName();\n    CuratorFramework zkClient = CuratorUtils.getZkClient();\n    // 获取服务的地址列表\n    List&lt;String&gt; serviceUrlList = CuratorUtils.getChildrenNodes(zkClient, rpcServiceName);\n    if (CollectionUtil.isEmpty(serviceUrlList)) &#123;\n        // 若地址列表为空，则服务未找到，抛出异常\n        throw new RpcException(RpcErrorMessageEnum.SERVICE_CAN_NOT_BE_FOUND, rpcServiceName);\n    &#125;\n    // 使用负载均衡算法，从地址列表中选取一个服务地址\n    String targetServiceUrl = loadBalance.selectServiceAddress(serviceUrlList, rpcRequest);\n    log.info(&quot;Successfully found the service address:[&#123;&#125;]&quot;, targetServiceUrl);\n    //分隔符 Ip  port\n    String[] socketAddressArray = targetServiceUrl.split(&quot;:&quot;);//host:port\n    String host = socketAddressArray[0];\n    int port = Integer.parseInt(socketAddressArray[1]);\n    // 返回服务的 InetSocketAddress 对象\n    return new InetSocketAddress(host, port);\n&#125;\n</code></pre>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p><strong>注册思路：</strong></p>\n<p>首先创建服务节点路径（根路径+服务名称+服务地址（ip端口）），获取Zookeeper客户端，创建持久化节点</p>\n<p><strong>创建持久化节点部分</strong>：</p>\n<p>根据REGISTERED_PATH_SET（ConcurrentHashMap.newKeySet(); 定义一个线程安全的Set用于存储已经注册过的路径）判断节点是否已经存在，如果存在则直接返回,如果节点不存在，则使用指定的路径(传入的)创建一个持久化节点,将已注册的路径加入到REGISTERED_PATH_SET中，以便后续检查</p>\n<p><strong>发现部分：</strong></p>\n<p>根据zookeeper客户端和服务名称，调用getChildrenNodes获取指定结点下（该服务名称下的）所有子节点</p>\n<p><strong>getChildrenNodes部分</strong>：</p>\n<p>根据SERVICE_ADDRESS_MAP（currentHashMap  线程安全的Map用于存储每个服务的地址列表 ）的Containskey方法判断是否已经获取过该节点的子节点列表,如果已经获取过，直接返回之前获取到的子节点列表，没有的话，声明一个空列表，用于存放获取到的子节点列表，拼接出目标节点的完整路径，获取指定节点下的所有子节点列表，将获取到的子节点列表缓存起来，便于下次快速获取，同时给该节点注册一个监听器(registerWatcher)，用于在节点发生变化时自动更新子节点列表，返回获取到的子节点列表</p>\n<p><strong>registerWatcher部分</strong>：（在节点发生变化时自动更新子节点列表）</p>\n<p>getChildrenNodes部分，给serviceName结点注册了一个监听器，传入了serviceName参数，通过拼接ZooKeeper注册根路径和服务名称得到服务路径，创建了一个PathChildrenCache对象，用于监听服务路径下的子节点变化，并将其添加到服务路径的监听器列表中。与此同时，创建了一个PathChildrenCacheListener对象，当服务路径下的子节点发生变化时，PathChildrenCacheListener对象会被回调，获取服务路径下所有子节点的路径（List<String>），将服务名称与服务地址的映射关系存入服务地址映射表SERVICE_ADDRESS_MAP中。最终通过启动PathChildrenCache对象实现监听服务地址的更新。</String></p>\n<h2 id=\"Zookeeper有几种角色？\"><a href=\"#Zookeeper有几种角色？\" class=\"headerlink\" title=\"Zookeeper有几种角色？\"></a>Zoo<a href=\"https://blog.csdn.net/jump/super-jump/word?word=keep\">keep</a>er有几种角色？</h2><ol>\n<li>Leader（领导者）：ZooKeeper集群中的一个节点被选举为Leader，它负责处理所有客户端请求的响应，并且负责管理集群中所有的数据副本，包括数据的读取、写入和删除等操作。</li>\n<li>Follower（跟随者）：ZooKeeper集群中的节点可以是Follower，它们负责接收客户端请求并将请求转发给Leader进行处理，同时也负责同步Leader上的数据副本。</li>\n<li>Observer（观察者）：ZooKeeper集群中的节点可以是Observer，它们与Follower的角色类似，但是Observer不参与Leader选举过程，也不参与数据同步，只接收客户端请求并将请求转发给Leader进行处理。</li>\n<li>Client（客户端）：ZooKeeper的客户端可以是任何需要协调的分布式系统，客户端向ZooKeeper发送请求来进行数据操作，例如创建、读取、写入和删除等操作。</li>\n</ol>\n<p>在ZooKeeper中，Leader和Follower的角色是比较重要的，因为它们共同组成了ZooKeeper集群的核心。Leader负责处理所有客户端请求并管理所有数据副本，Follower则负责接收客户端请求并同步Leader上的数据副本。Observer的角色则比较轻量级，它可以帮助扩展集群的读取性能，而不会对集群的写入性能造成影响。</p>\n<h2 id=\"Zookeeper集群节点宕机了怎么发现剔除的？\"><a href=\"#Zookeeper集群节点宕机了怎么发现剔除的？\" class=\"headerlink\" title=\"Zookeeper集群节点宕机了怎么发现剔除的？\"></a>Zoo<a href=\"https://blog.csdn.net/jump/super-jump/word?word=keep\">keep</a>er集群节点宕机了怎么发现剔除的？</h2><p>当ZooKeeper集群中的节点宕机时，需要通过一定的机制来发现并剔除宕机的节点，以保证集群的正常运行。ZooKeeper使用了心跳机制来检测节点的存活状态，具体操作如下：</p>\n<ol>\n<li>每个节点定时向集群中的其他节点发送心跳请求，并在心跳请求中包含自己的状态信息，例如节点的ID、版本号等。</li>\n<li>如果某个节点长时间未收到其他节点的心跳请求，则会将该节点标记为失效状态，并开始进行选举以选出新的Leader节点。</li>\n<li>在Leader节点宕机的情况下，其他节点将会发起选举，选举出新的Leader节点，并重新分配所有数据副本。</li>\n<li>如果某个节点在集群中被剔除，其他节点将会收到该节点失效的通知，并在自己的数据结构中将该节点剔除。</li>\n</ol>\n<p>在ZooKeeper中，集群中的每个节点都会维护一个与其他节点的连接，并定期进行心跳检测，以确保节点的存活状态。如果某个节点失效，则其他节点将会通过检测到该节点长时间未发送心跳请求来判断节点的状态，并进行相应的处理。同时，ZooKeeper还提供了一些工具和API，可以用来查看集群中节点的状态信息，以及手动进行节点的管理和剔除操作。</p>\n<h2 id=\"dubbo不足，以及优化方向？（语言支持）\"><a href=\"#dubbo不足，以及优化方向？（语言支持）\" class=\"headerlink\" title=\"dubbo不足，以及优化方向？（语言支持）\"></a>dubbo不足，以及优化方向？（语言支持）</h2><ol>\n<li>配置复杂：Dubbo的配置相对比较复杂，需要开发者对Dubbo的各个组件及其配置参数有一定的了解，这对于初学者来说可能会造成一定的困难。</li>\n<li>集成难度较大：Dubbo的集成需要开发者在应用程序中添加一定的代码和依赖，这会增加代码量和部署难度。</li>\n<li>性能瓶颈：在高并发场景下，Dubbo可能会存在性能瓶颈。例如，Dubbo的默认通信协议是基于TCP的，这在连接数较高的情况下可能会导致网络负载过大，从而影响性能。</li>\n</ol>\n<p>为了优化Dubbo的性能和使用体验，可以从以下方面入手：</p>\n<ol>\n<li>配置简化：Dubbo可以通过使用注解、配置文件等方式来简化配置，让开发者更方便地使用Dubbo。例如，使用Spring Boot集成Dubbo可以通过自动配置来简化配置。</li>\n<li>集成便捷性：可以考虑将Dubbo的集成与应用程序的构建和部署过程整合在一起，例如使用容器化技术来部署Dubbo服务。</li>\n<li>性能优化：可以通过更换通信协议、使用线程池等方式来优化Dubbo的性能。例如，使用Netty替代Dubbo默认的通信协议可以提高性能，同时使用线程池来处理请求可以减少线程切换带来的开销。</li>\n<li>容错机制：Dubbo提供了多种容错机制，可以在服务调用失败时自动切换到备用服务节点，从而提高系统的可用性。可以针对具体的业务需求选择合适的容错机制来保证系统的可靠性。</li>\n</ol>\n<p>总之，Dubbo作为一个成熟的分布式服务框架，已经具备了很多优秀的特性和功能。为了提高Dubbo的使用体验和性能，我们需要根据具体的业务需求来选择合适的优化方向。</p>\n<h2 id=\"netty高性能主要依赖了哪些特性？\"><a href=\"#netty高性能主要依赖了哪些特性？\" class=\"headerlink\" title=\"netty高性能主要依赖了哪些特性？\"></a>netty高性能主要依赖了哪些特性？</h2><p>Netty高性能主要依赖以下几个特性：</p>\n<ol>\n<li>异步非阻塞I&#x2F;O：Netty采用了基于NIO的异步非阻塞I&#x2F;O模型，可以有效地利用系统资源，提高程序的并发处理能力。</li>\n<li>Reactor模式：Netty采用了Reactor模式，通过一个主线程来监听所有的I&#x2F;O事件，并通过多个工作线程来处理这些事件，从而充分利用多核CPU，并减少线程上下文切换的开销。</li>\n<li>零拷贝技术：Netty支持零拷贝技术，可以避免在进行数据传输时将数据从内核空间复制到用户空间，从而提高数据传输的效率。</li>\n<li>内存池：Netty采用了内存池技术，可以减少内存的分配和回收次数，从而降低内存管理的开销，提高程序的性能。</li>\n<li>可插拔的编解码器：Netty提供了可插拔的编解码器，可以根据不同的业务需求选择不同的编解码器来实现数据的序列化和反序列化，从而提高数据传输的效率。</li>\n</ol>\n<p>综上所述，Netty高性能主要依赖于异步非阻塞I&#x2F;O、Reactor模式、零拷贝技术、内存池和可插拔的编解码器等特性，这些特性可以有效地提高程序的性能和可扩展性，使得Netty成为一个高性能的通信框架。</p>\n<h2 id=\"CGLib-底层\"><a href=\"#CGLib-底层\" class=\"headerlink\" title=\"CGLib 底层\"></a>CGLib 底层</h2><h3 id=\"一个类有方法a和方法b，两个方法都被代理，方法a中调用了方法b，被代理后调用a方法，a方法中调用的是被代理的方法b还是普通方法b？（求大神解答）\"><a href=\"#一个类有方法a和方法b，两个方法都被代理，方法a中调用了方法b，被代理后调用a方法，a方法中调用的是被代理的方法b还是普通方法b？（求大神解答）\" class=\"headerlink\" title=\"一个类有方法a和方法b，两个方法都被代理，方法a中调用了方法b，被代理后调用a方法，a方法中调用的是被代理的方法b还是普通方法b？（求大神解答）\"></a>一个类有方法a和方法b，两个方法都被代理，方法a中调用了方法b，被代理后调用a方法，a方法中调用的是被代理的方法b还是普通方法b？（求大神解答）</h3><p>如果一个类有方法a和方法b，两个方法都被代理，而且被代理的方法中调用了另一个方法b，那么在被代理后调用a方法时，a方法中调用的是被代理的方法b，而不是普通方法b。</p>\n<p>这是因为代理会把原始对象的所有方法都代理一遍，包括方法a和方法b，代理的实现通常是在原始对象方法的基础上增加一些额外的操作或逻辑。所以，当方法a中调用方法b时，代理会拦截这个调用，并转发给被代理的方法b，从而保证被代理的方法b能够正常执行代理增加的逻辑或操作。</p>\n<p>JDK动态代理有个问题，只能代理实现了接口的类。可以用CGLIB动态代理机制来避免。</p>\n<p>Spring中的AOP模块中:如果目标对象实现了接口，则默认采用JDK动态代理，否则采用CGLIB动态代理。<br>在CGLIB动态代理机制中MethodInterceptor 接口和Enhancer<br>类是核心。<br>需要自定义MethodInterceptor 并重写intercept方法，intercept 用于拦截增强被代理类的方法。</p>\n<pre><code class=\"java\">public interface MethodInterceptor\nextends Callback&#123;\n//拦截被代理类中的方法\npublic object intercept(object obj, java.lang. reflect. Method method, 0bject[] args,MethodProxy proxy) throws Throwable;\n&#125;\n</code></pre>\n<ol>\n<li><p>obj :被代理的对象( 需要增强的对象)</p>\n</li>\n<li><p>method :被拦截的方法( 需要增强的方法)</p>\n</li>\n<li><p>args:方法入参</p>\n</li>\n<li><p>methodProxy :用于调用原始方法</p>\n</li>\n</ol>\n<p>可以通过Enhancer 类来动态获取被代理类，当代理类调用方法的时候，实际调用的是MethodInterceptor中的intercept 方法。</p>\n<p>CGLIB动态代理类使用步骤<br>1.定义一个类（导入依赖）;<br>2.自定义MethodInterceptor 并写intercept 方法，intercept 用于拦截增强被代理类的方法,和JDK动态代理中的invoke 方法类似;同样的在调用原始方法（methodProxy）之前之后可以增强<br>3.通过Enhancer类的create() 创建代理类;（包括设置类加载器、设置被代理类、方法拦截器）</p>\n<p>4.最后获取代理类并调用原生方法</p>\n<h1 id=\"Socket\"><a href=\"#Socket\" class=\"headerlink\" title=\"Socket\"></a>Socket</h1><p>套接字socket&#x3D;ip+port</p>\n<p>进行通信，至少需要一对套接字，Socket:客户端    ServerSocket：用于服务端</p>\n<p>通信过程：</p>\n<p>1．建立服务端并且监听客户端请求<br>2．客户端请求，服务端和客户端建立连接</p>\n<p>3．两端之间可以传递数据<br>4．关闭资源</p>\n<p>服务器端:<br>1．创建ServerSocket对象并且绑定地址（ip）和端口号(port): server.bind(new InetSocketAddress(host，port))<br>2．通过accept()方法监听客户端请求<br>3．连接建立后，通过输入流读取客户端发送的请求信息</p>\n<p>4．通过输出流向客户端发送响应信息<br>5．关闭相关资源</p>\n<p>客户端:<br>1.创建 Socket对象并且连接指定的服务器的地址（ip）和端口号(port): socket.connect(inetSocketAddress)<br>2．连接建立后，通过输出流向服务器端发送请求信息</p>\n<p>3．通过输入流获取服务器响应的信息<br>4．关闭相关资源</p>\n<p>问题：</p>\n<p>accept方法是阻塞的，一次只能处理一个客户端</p>\n<p>可以用线程池解决 但是本质还是BIO（同步阻塞）</p>\n<h1 id=\"Netty传输\"><a href=\"#Netty传输\" class=\"headerlink\" title=\"Netty传输\"></a>Netty传输</h1><h2 id=\"select、poll-和-epoll-之间的区别\"><a href=\"#select、poll-和-epoll-之间的区别\" class=\"headerlink\" title=\"select、poll 和 epoll 之间的区别?\"></a>select、poll 和 epoll 之间的区别?</h2><p>（1）select：时间复杂度 O(n)</p>\n<p>select 仅仅知道有 I&#x2F;O 事件发生，但并不知道是哪几个流，所以只能<strong>无差别轮询所有流</strong>，找出能读出数据或者写入数据的流，并对其进行操作。所以 select 具有 O(n) 的无差别轮询复杂度，同时处理的流越多，无差别轮询时间就越长。</p>\n<p>（2）poll：时间复杂度 O(n)</p>\n<p>poll 本质上和 select 没有区别，它将用户传入的数组拷贝到内核空间，然后查询每个 fd 对应的设备状态， 但是它<strong>没有最大连接数的限制</strong>，原因是它是基于<strong>链表</strong>来存储的。</p>\n<p>（3）epoll：时间复杂度 O(1)</p>\n<p>epoll 可以理解为 event poll，不同于忙轮询和无差别轮询，epoll 会把哪个流发生了怎样的 I&#x2F;O 事件通知我们。所以说 epoll 实际上是事件驱动（每个事件关联上 fd）的。</p>\n<blockquote>\n<p>select，poll，epoll 都是 IO 多路复用的机制。I&#x2F;O 多路复用就是通过一种机制监视多个描述符，&#x3D;&#x3D;<strong>一旦某个描述符就绪（一般是读就绪或者写就绪）</strong>&#x3D;&#x3D;，就通知程序进行相应的读写操作。但 select，poll，epoll 本质上都是同步 I&#x2F;O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的，而异步 I&#x2F;O 则无需自己负责进行读写，异步 I&#x2F;O 的实现会负责把数据从内核拷贝到用户空间。</p>\n</blockquote>\n<h2 id=\"为什么选用Netty来做通信框架？\"><a href=\"#为什么选用Netty来做通信框架？\" class=\"headerlink\" title=\"为什么选用Netty来做通信框架？\"></a>为什么选用<a href=\"https://blog.csdn.net/jump/super-jump/word?word=Netty\">Netty</a>来做通信框架？</h2><ol>\n<li>高性能：Netty是一个基于NIO的框架，相比于传统的BIO，在处理高并发连接时能够更好地利用系统资源，提高程序的性能。Netty的线程模型采用的是事件驱动的方式，可以充分利用多核CPU，同时减少线程上下文切换的开销。</li>\n<li>易扩展：Netty提供了许多现成的组件和模块，可以轻松构建各种类型的应用程序。同时，Netty的架构设计非常灵活，可以根据不同的业务需求进行定制化开发。</li>\n<li>协议支持：Netty支持各种主流的网络协议，包括TCP、UDP、HTTP、WebSocket等。同时，Netty也提供了很多针对特定协议的编解码器和处理器，可以帮助开发者快速实现业务逻辑。</li>\n<li>社区活跃：Netty是一个开源的框架，拥有庞大的社区支持，开发者可以从社区中获得各种类型的帮助和支持。同时，Netty也在不断地更新和升级，保证了框架的可靠性和稳定性。</li>\n</ol>\n<p>综上所述，Netty是一个高性能、易扩展、协议支持丰富、社区活跃的通信框架，非常适合在分布式系统中作为RPC通信框架使用。</p>\n<h2 id=\"还知道其他网络通信框架？\"><a href=\"#还知道其他网络通信框架？\" class=\"headerlink\" title=\"还知道其他网络通信框架？\"></a>还知道其他网络通信框架？</h2><p>Dubbo：Java Golang等语言；提供了从服务定义、服务发现、服务通信到流量管控等几乎所有的服务治理能力，支持Triple 协议(基于HTTP&#x2F;2之上定义的下一代 RPC通信协议)、应用级服务发现、Dubbo <strong>Mesh</strong>(Dubbo3赋予了很多云原生友好的新特性）等特性。</p>\n<p>Motan:精简版Dubbo </p>\n<p>gRPC:面向移动应用，改进了通信层设计（protoBuf，灵活高效的数据格式），但没有服务治理功能，需要依赖腾讯北极星、</p>\n<p>总结：</p>\n<p>1、跨语言调用的话还是grpc 如果是java的话就dubbo</p>\n<p>2、gRPC和Thrift只提供了最基本的RPC框架功能，缺乏一系列配套的服务化组件和服务治理功能的支撑。<br>Dubbo 不论是从功能完善程度、生态系统还是社区活跃度来说都是最优秀的。</p>\n<h2 id=\"客户端\"><a href=\"#客户端\" class=\"headerlink\" title=\"客户端\"></a>客户端</h2><pre><code>NettyClient. java\n</code></pre>\n<p>1、初始化一些资源</p>\n<pre><code class=\"java\">//    ServiceDiscovery实例，用于服务发现\n    private final ServiceDiscovery serviceDiscovery;\n    // UnprocessedRequests实例，用于存放未处理的请求  建议限制map容器大小,避免未处理请求过多ooM\n    private final UnprocessedRequests unprocessedRequests;\n    // ChannelProvider实例，用于缓存已经建立连接的Channel  key：服务地址  value:channel\n    private final ChannelProvider channelProvider;\n    // Bootstrap实例，用于客户端的引导\n    private final Bootstrap bootstrap;\n    // EventLoopGroup实例，用于处理I/O操作的线程池\n    private final EventLoopGroup eventLoopGroup;\n</code></pre>\n<p>2、连接服务端</p>\n<p><strong>doConnect</strong>() :用于连接服务端 ( 目标方法所在的服务器)并返回对应的Channel </p>\n<p>创建一个completableFuture接受结果，bootstrap连接服务端的地址，（ChannelFuture的作用是用来保存Channel异步操作的结果）（当做了一个I&#x2F;O操作并有后续任务的时候用addListener(ChannelFutureListener)的方式来获得通知，结果是成功<code>、</code>失败这两种状态）</p>\n<p>如果成功的话，completableFuture调用complete把channel的数据当作返回值，调用get()获取返回值</p>\n<pre><code>bootstrap.connect(inetSocketAddress).addListener((ChannelFutureListener) future\n</code></pre>\n<p><strong>sendRpcRequest</strong>() : 传输rpc请求( RpcRequest ) 到服务端</p>\n<p>根据服务端地址获取服务，getChannel方法获取地址相关channel，判断是否处于活跃状态，不活跃的话，抛出一个非法状态异常；活跃的话，将当前请求的RequestId和结果resultFuture放入一个未处理请求的Map中；创建一个RpcMessage对象，用于存储当前请求的相关信息，包括请求的数据和序列化方式；向服务器发送当前请求的RpcMessage对象，同样，用addListener((ChannelFutureListener)添加一个监听器，在请求发送成功记录日志，失败的话关闭客户端的channel，并使用异常信息将结果resultFuture标记为已完成但是发生异常。</p>\n<p><strong>getChannel</strong>：  获取channel</p>\n<p>从channelProvider里面找缓存，找到的话直接返回，找不到的话通过doConnect获取channel，然后存到channelProvider缓存里面</p>\n<pre><code>UnprocessedRequests .java\n</code></pre>\n<p><strong>NettyRpcClientHandler</strong>：读取从服务端返回消息；Netty心跳机制相关。保证客户端和服务端的连接不被断掉,避免重连。</p>\n<p><strong>ChannelProvider</strong></p>\n<p>维护了一个channelMap，底层是ConcurrentHashMap做的</p>\n<p>get从Map里面拿，如果不空且channel活跃，返回chanel，否则删除（remove）key</p>\n<p>set调用put方法</p>\n<p>使用ConcurrentHashMap对channel进行缓存化，</p>\n<h2 id=\"总结：\"><a href=\"#总结：\" class=\"headerlink\" title=\"总结：\"></a>总结：</h2><p><strong>channal缓存</strong></p>\n<p>通过负载均衡找到服务端地址，调用doconnet方法连接服务端，返回对应的channel，后续发送rpc请求消息就是通过channel传输，考虑到后面可能有相同服务调用，对channel做了缓存，底层是ConcurrentHashMap，key是服务地址，value是channel，get的时候为空的话调用doconnect获得channel并存进去</p>\n<p><strong>消息的发送：</strong></p>\n<p>负载均衡获取服务地址，getChannel方法获取地址相关channel，判断是否处于活跃状态，不活跃的话，抛出一个非法状态异常；活跃的话，将当前请求的RequestId和结果resultFuture放入一个未处理请求的Map中；创建一个RpcMessage对象，用于存储当前请求的相关信息，包括请求的数据和序列化方式；向服务器发送当前请求的RpcMessage对象，同样，用addListener((ChannelFutureListener)添加一个监听器，在请求发送成功记录日志，失败的话关闭客户端的channel，并使用异常信息将结果resultFuture标记为已完成但是发生异常。</p>\n<p><strong>消息的接受与动态响应：</strong></p>\n<p>1、检查接收到的消息是否是RpcMessage类型的，是的话，打印接收到的消息日志信息，并构造RpcMessage<br>2、获取消息类型，判断是心跳请求消息还是RPC请求消息，如果是心跳请求消息，构造心跳响应消息，并设置数据为PONG，如果是RPC请求消息，获取RPC请求并处理，返回处理结果；</p>\n<p>3、同时构造RPC响应消息，如果连接可写，构造成功的RPC响应消息，如果连接不可写，构造失败的RPC响应消息，发送RPC响应消息，并在发送失败时关闭连接，最后确保ByteBuf被释放，否则可能会出现内存泄漏；</p>\n<p>4、如果连接处于空闲状态（即没有数据传输）或者当捕获到异常时，关闭连接</p>\n<h2 id=\"服务端\"><a href=\"#服务端\" class=\"headerlink\" title=\"服务端\"></a>服务端</h2><p><strong>NettyRpcServer</strong></p>\n<p>注册服务（通过RpcServiceConfig里面的version group service进行注册）</p>\n<ol>\n<li><p>启动服务时</p>\n<p>1.1  创建一个Boss线程组和一个Worker线程组（主从），Boss线程组用于监听端口，Worker线程组用于处理请求</p>\n<p>1.2  此外还创建了一个服务处理线程组，用于处理RPC请求。</p>\n<p>1.2 设置服务器的通道类型为 NIO。</p>\n<p>1.3 通过设置TCP_NODE LAY（开启了 Nagle 算法，该算法的作用是尽可能的发送大数据快，减少网络传输，控制是否启用 Nagle 算法）</p>\n<p>1.4 SO_KEEPALIVE（开启 TCP 底层心跳机制 服务端与zookeeper）</p>\n<p>1.5 SO_BACKLOG（表示系统用于临时存放已完成三次握手的请求的队列的最大长度,如果连接建立频繁，服务器处理创建新连接较慢，可以适当调大这个参数1.6 当客户端第一次进行请求时才会进行初始化，然后将处理器添加到管道（30 秒之内没有收到客户端请求的话就关闭连接）中，对消息进行编解码和处理。</p>\n</li>\n<li><p>然后绑定端口，同步等待绑定成功，等待服务端监听端口关闭。</p>\n</li>\n<li><p>关闭服务：当服务端关闭时，通过调用shutdownGracefully()方法关闭线程组。</p>\n</li>\n</ol>\n<p><strong>NettyRpcServerHandler</strong></p>\n<p>1、检查接收到的消息是否是RpcMessage类型的，是的话，打印接收到的消息日志信息，并构造RpcMessage<br>2、获取消息类型，判断是心跳请求消息还是RPC请求消息，如果是心跳请求消息，构造心跳响应消息，并设置数据为PONG，如果是RPC请求消息，获取RPC请求并处理，返回处理结果；</p>\n<p>3、同时构造RPC响应消息，如果连接可写，构造成功的RPC响应消息，如果连接不可写，构造失败的RPC响应消息，发送RPC响应消息，并在发送失败时关闭连接，最后确保ByteBuf被释放，否则可能会出现内存泄漏；</p>\n<p>4、如果连接处于空闲状态（即没有数据传输）或者当捕获到异常时，关闭连接</p>\n<h2 id=\"服务端处理请求些方式？NIO-BIO-AIO\"><a href=\"#服务端处理请求些方式？NIO-BIO-AIO\" class=\"headerlink\" title=\"服务端处理请求些方式？NIO BIO AIO\"></a><strong>服务端处理请求些方式？NIO BIO AIO</strong></h2><p><strong>参考答案</strong>：服务端接收到客户端的请求后，常见的处理方式有三种，分别是BIO、NIO和AIO。</p>\n<ul>\n<li><strong>同步阻塞方式</strong>（BIO）：客户端发一次请求，服务端生成一个对应线程去处理。当客户端同时发起的请求很多时，服务端需要创建多个线程去处理每一个请求，当达到了系统最大的线程数时，新来的请求就无法处理了。</li>\n<li><strong>同步非阻塞方式</strong> (NIO)：客户端发一次请求，服务端并不是每次都创建一个新线程来处理，而是通过 I&#x2F;O 多路复用技术进行处理。就是把多个 I&#x2F;O 的阻塞复用到同一个 select 的阻塞上，从而使系统在单线程的情况下可以同时处理多个客户端请求。这种方式的优势是开销小，不用为每个请求创建一个线程，可以节省系统开销。</li>\n<li><strong>异步非阻塞方式</strong>（AIO）：客户端发起一个 I&#x2F;O 操作然后立即返回，等 I&#x2F;O 操作真正完成以后，客户端会得到 I&#x2F;O 操作完成的通知，此时客户端只需要对数据进行处理就好了，不需要进行实际的 I&#x2F;O 读写操作，因为真正的 I&#x2F;O 读取或者写入操作已经由内核完成了。这种方式的优势是客户端无需等待，不存在阻塞等待问题。</li>\n</ul>\n<blockquote>\n<p><strong>使用场景</strong><br>BIO 适用于连接数比较小的业务场景，这样的话不至于系统中没有可用线程去处理请求。这种方式写的程序也比较简单直观，易于理解。</p>\n<p>NIO 适用于连接数比较多并且请求消耗比较轻的业务场景，比如聊天服务器。这种方式相比 BIO，相对来说编程比较复杂。</p>\n<p>AIO 适用于连接数比较多而且请求消耗比较重的业务场景，比如涉及 I&#x2F;O 操作的相册服务器。这种方式相比另外两种，编程难度最大，程序也不易于理解。 【<strong>来自网络</strong>】</p>\n</blockquote>\n<h2 id=\"传输协议\"><a href=\"#传输协议\" class=\"headerlink\" title=\"传输协议\"></a>传输协议</h2><p><strong>RpcMessageEncoder</strong></p>\n<p>该方法的输入参数有三个：ChannelHandlerContext、RpcMessage 和 ByteBuf，分别表示上下文信息、待编码的消息和编码后的消息。</p>\n<p>1、向ByteBuf对象写入魔数、写入版本号、留出空间写入全长（out.writerIndex(out.writerIndex() + 4)）、写入消息类型、写入序列化方式、写入压缩方式、写入请求编号（AtomicInteger进行自增操作，保证线程安全）AtomicInteger进行自增操作getAndIncrement、这些信息可以从 RpcMessage 中获取。<br>2、之后，代码计算消息体的字节数组长度，如果是心跳消息则不需要对消息体进行序列化和压缩，否则需要使用序列化方式和压缩方式对消息体进行序列化和压缩。序列化和压缩方式均可以从 RpcMessage 中获取。最终，将压缩后的消息体写入 ByteBuf 对象中。<br>3、接下来，将 ByteBuf 的写指针移到全长字段位置，写入计算得到的全长，最后将写指针复位到最后的位置。</p>\n<p><strong>RpcMessageDecoder.decode</strong></p>\n<p><strong>RpcMessageDecoder.decodeFrame</strong></p>\n<p>该方法是一个解码器，用于将ByteBuf解码为RpcMessage对象。方法具体实现如下：</p>\n<ol>\n<li>检查魔数是否正确：调用checkMagicNumber方法检查接收到的消息的魔数是否和定义的魔数一致。</li>\n<li>检查协议版本是否正确：调用checkVersion方法检查接收到的消息的协议版本是否和定义的版本一致。</li>\n<li>读取消息总长度：从ByteBuf中读取4个字节来获取消息的总长度。</li>\n<li>构建RpcMessage对象：从ByteBuf中读取5个字节，分别为消息类型、编解码类型、压缩类型、请求ID，然后构建RpcMessage对象并返回。</li>\n<li>如果是心跳请求消息类型，设置消息数据为Ping，并返回RpcMessage对象。</li>\n<li>如果是心跳响应消息类型，设置消息数据为Pong，并返回RpcMessage对象。</li>\n<li>计算消息体长度：从消息总长度中减去消息头的长度，得到消息体的长度。</li>\n<li>如果消息体长度大于0，读取消息体内容：从ByteBuf中读取消息体的字节数组，并根据压缩类型解压缩字节数组。</li>\n<li>反序列化消息体：根据编解码类型和消息类型，使用ExtensionLoader获取相应的序列化器和反序列化出RpcRequest或RpcResponse对象。</li>\n<li>将反序列化得到的RpcRequest或RpcResponse对象设置为RpcMessage的data属性。</li>\n<li>返回RpcMessage对象。</li>\n</ol>\n<p>注意：该方法的实现中，必须按照指定的顺序依次读取ByteBuf中的字节，并且要保证字节的正确性。</p>\n<h1 id=\"通过注解注册-x2F-消费服务\"><a href=\"#通过注解注册-x2F-消费服务\" class=\"headerlink\" title=\"通过注解注册&#x2F;消费服务\"></a>通过注解注册&#x2F;消费服务</h1><p>定义两个注解:<br>RcpService : 注册服务<br>RpcReference：消费服务</p>\n<p>我们的实现需要BeanPostProcessor接口并重写 postProcessBeforeInitialization()方法和postProcessAfterInitialization()方法。<br>Spring bean在实例化之前会调用postProcessBeforeInitialization() 方法，在Spring bean实例化之后会调用postProcessAfterInitialization()方法。</p>\n<p>被我们使用RpcService 和RpcReference注解的类都算是Spring Bean。<br>我们可以在postProcessBeforeInitialization() 方法中去判断类上是否有RpcService注解。<br>如果有的话，就取出group 和version的值。然后，再调用ServiceProvider 的publishService()方法发布服务即可!<br>我们可以在postProcessAfterInitialization() 方法中遍历类的属性上是否有RpcReference注解。如果有的话,我们就通过反射将这个属性赋值即可!</p>\n<h1 id=\"CompletableFuture\"><a href=\"#CompletableFuture\" class=\"headerlink\" title=\"CompletableFuture\"></a><code>CompletableFuture</code></h1><p>在RPC中使用<code>CompletableFuture</code>包装接受服务端返回结果有以下几个好处：</p>\n<ol>\n<li>异步处理：<code>CompletableFuture</code>可以<strong>帮助我们异步处理服务端返回结果</strong>，避免在客户端等待服务端响应时阻塞线程，提高应用的并发性能。</li>\n<li>可组合：<code>CompletableFuture</code><strong>支持链式调用和组合</strong>，可以方便地将多个异步任务组合在一起，实现复杂的异步业务逻辑。</li>\n<li>异常处理：<code>CompletableFuture</code><strong>可以捕获异步任务中的异常</strong>，便于我们进行异常处理，提高代码的健壮性。</li>\n<li>超时控制：<code>CompletableFuture</code><strong>支持设置超时时间</strong>，可以在服务端响应超时时及时进行处理，避免因服务端响应慢而导致客户端请求超时。</li>\n</ol>\n<p>综上所述，使用<code>CompletableFuture</code>包装接受服务端返回结果可以帮助我们更好地实现异步处理、异常处理、超时控制等功能，提高应用的性能和健壮性。</p>\n<h1 id=\"SPI\"><a href=\"#SPI\" class=\"headerlink\" title=\"SPI\"></a>SPI</h1><h2 id=\"javaspi\"><a href=\"#javaspi\" class=\"headerlink\" title=\"javaspi\"></a>javaspi</h2><p>Java内置的SPI通过java.util.ServiceLoader类解析classPath和jar包的META-INF&#x2F;services&#x2F;目录 下的以接口全限定名命名的文件，并加载该文件中指定的接口实现类，以此完成调用。</p>\n<h2 id=\"springspi\"><a href=\"#springspi\" class=\"headerlink\" title=\"springspi\"></a>springspi</h2><p>Java SPI是一个服务提供接口对应一个配置文件，配置文件中存放当前接口的所有实现类，多个服务提供接口对应多个配置文件，所有配置都在services目录下；</p>\n<p>Spring factories SPI是一个spring.factories配置文件存放多个接口及对应的实现类，以接口全限定名作为key，实现类作为value来配置，多个实现类用逗号隔开，仅spring.factories一个配置文件。</p>\n<h2 id=\"dubbo\"><a href=\"#dubbo\" class=\"headerlink\" title=\"dubbo\"></a>dubbo</h2><p>比如说我们想要实现自己的负载均衡策略，我们创建对应的实现类 <code>XxxLoadBalance</code> 实现 <code>LoadBalance</code> 接口或者 <code>AbstractLoadBalance</code> 类。</p>\n<p>我们将这个实现类的路径写入到<code>resources</code> 目录下的 <code>META-INF/dubbo/org.apache.dubbo.rpc.cluster.LoadBalance</code>文件中即可。</p>\n<h1 id=\"负载均衡-1\"><a href=\"#负载均衡-1\" class=\"headerlink\" title=\"负载均衡\"></a>负载均衡</h1><p>在 Dubbo 中，所有负载均衡实现类均继承自 <code>AbstractLoadBalance</code>，该类实现了 <code>LoadBalance</code> 接口，并封装了一些公共的逻辑。</p>\n<h4 id=\"RandomLoadBalance\"><a href=\"#RandomLoadBalance\" class=\"headerlink\" title=\"RandomLoadBalance\"></a>RandomLoadBalance</h4><p>根据权重随机选择（对加权随机算法的实现）。这是Dubbo默认采用的一种负载均衡策略。</p>\n<p><code> RandomLoadBalance</code> 具体的实现原理非常简单，假如有两个提供相同服务的服务器 S1,S2，S1的权重为7，S2的权重为3。</p>\n<p>我们把这些权重值分布在坐标区间会得到：S1-&gt;[0, 7) ，S2-&gt;[7, 10)。我们生成[0, 10) 之间的随机数，随机数落到对应的区间，我们就选择对应的服务器来处理请求。</p>\n<h4 id=\"LeastActiveLoadBalance\"><a href=\"#LeastActiveLoadBalance\" class=\"headerlink\" title=\"LeastActiveLoadBalance\"></a>LeastActiveLoadBalance</h4><p><code>LeastActiveLoadBalance</code> 直译过来就是<strong>最小活跃数负载均衡</strong>。</p>\n<p>这个名字起得有点不直观，不仔细看官方对活跃数的定义，你压根不知道这玩意是干嘛的。</p>\n<p>我这么说吧！初始状态下所有服务提供者的活跃数均为 0（每个服务提供者的中特定方法都对应一个活跃数，我在后面的源码中会提到），每收到一个请求后，对应的服务提供者的活跃数 +1，当这个请求处理完之后，活跃数 -1。</p>\n<p>因此，<strong>Dubbo 就认为谁的活跃数越少，谁的处理速度就越快，性能也越好，这样的话，我就优先把请求给活跃数少的服务提供者处理。</strong></p>\n<p><strong>如果有多个服务提供者的活跃数相等怎么办？</strong></p>\n<p>很简单，那就再走一遍 <code>RandomLoadBalance</code> 。</p>\n<h3 id=\"ConsistentHashLoadBalance\"><a href=\"#ConsistentHashLoadBalance\" class=\"headerlink\" title=\"ConsistentHashLoadBalance\"></a>ConsistentHashLoadBalance</h3><p> <code>ConsistentHashLoadBalance</code> 中没有权重的概念，具体是哪个服务提供者处理请求是由你的请求的参数决定的，也就是说相同参数的请求总是发到同一个服务提供者。</p>\n<p>另外，Dubbo 为了避免数据倾斜问题（节点不够分散，大量请求落到同一节点），还引入了虚拟节点的概念。通过虚拟节点可以让节点更加分散，有效均衡各个节点的请求量</p>\n<h4 id=\"RoundRobinLoadBalance\"><a href=\"#RoundRobinLoadBalance\" class=\"headerlink\" title=\"RoundRobinLoadBalance\"></a>RoundRobinLoadBalance</h4><p>加权轮询负载均衡。比较精确吧 权重比值就是处理请求比值，但是随机负载均衡的话可能权重大的请求会很多</p>\n<h1 id=\"为什么不用Jdk自带序列化\"><a href=\"#为什么不用Jdk自带序列化\" class=\"headerlink\" title=\"为什么不用Jdk自带序列化\"></a>为什么不用Jdk自带序列化</h1><p>一般我们不会直接使用 JDK 自带的序列化方式。主要原因有两个：</p>\n<ol>\n<li><strong>不支持跨语言调用</strong> : 如果调用的是其他语言开发的服务的时候就不支持了。</li>\n<li><strong>性能差</strong> ：相比于其他序列化框架性能更低，主要原因是序列化之后的字节数组体积较大，导致传输成本加大。</li>\n</ol>\n<h1 id=\"zookeeper\"><a href=\"#zookeeper\" class=\"headerlink\" title=\"zookeeper\"></a>zookeeper</h1><h3 id=\"ZooKeeper-特点\"><a href=\"#ZooKeeper-特点\" class=\"headerlink\" title=\"ZooKeeper 特点\"></a>ZooKeeper 特点</h3><ul>\n<li><strong>顺序一致性：</strong> 从同一客户端发起的事务请求，最终将会严格地按照顺序被应用到 ZooKeeper 中去。</li>\n<li><strong>原子性：</strong> 所有事务请求的处理结果在整个集群中所有机器上的应用情况是一致的，也就是说，要么整个集群中所有的机器都成功应用了某一个事务，要么都没有应用。</li>\n<li><strong>单一系统映像 ：</strong> 无论客户端连到哪一个 ZooKeeper 服务器上，其看到的服务端数据模型都是一致的。</li>\n<li><strong>可靠性：</strong> 一旦一次更改请求被应用，更改的结果就会被持久化，直到被下一次更改覆盖</li>\n</ul>\n<h3 id=\"ZooKeeper-应用场景\"><a href=\"#ZooKeeper-应用场景\" class=\"headerlink\" title=\"ZooKeeper 应用场景\"></a>ZooKeeper 应用场景</h3><p>ZooKeeper 概览中，我们介绍到使用其通常被用于实现诸如数据发布&#x2F;订阅、负载均衡、命名服务、分布式协调&#x2F;通知、集群管理、Master 选举、分布式锁和分布式队列等功能。</p>\n<p>下面选 3 个典型的应用场景来专门说说：</p>\n<ol>\n<li><strong>命名服务</strong> ：可以通过 ZooKeeper 的顺序节点生成全局唯一 ID。</li>\n<li><strong>数据发布&#x2F;订阅</strong> ：通过 <strong>Watcher 机制</strong> 可以很方便地实现数据发布&#x2F;订阅。当你将数据发布到 ZooKeeper 被监听的节点上，其他机器可通过监听 ZooKeeper 上节点的变化来实现配置的动态更新。</li>\n<li><strong>分布式锁</strong> ： 通过创建唯一节点获得分布式锁，当获得锁的一方执行完相关代码或者是挂掉之后就释放锁。分布式锁的实现也需要用到 <strong>Watcher 机制</strong> ，我在 <a href=\"https://javaguide.cn/distributed-system/distributed-lock.html\">分布式锁详解open in new window</a> 这篇文章中有详细介绍到如何基于 ZooKeeper 实现分布式锁</li>\n</ol>\n<h3 id=\"会话（Session）\"><a href=\"#会话（Session）\" class=\"headerlink\" title=\"会话（Session）\"></a>会话（Session）</h3><p>Session 可以看作是 ZooKeeper 服务器与客户端的之间的一个 TCP 长连接，通过这个连接，客户端能够通过心跳检测与服务器保持有效的会话，也能够向 ZooKeeper 服务器发送请求并接受响应，同时还能够通过该连接接收来自服务器的 Watcher 事件通知。</p>\n<p>Session 有一个属性叫做：<code>sessionTimeout</code> ，<code>sessionTimeout</code> 代表会话的超时时间。当由于服务器压力太大、网络故障或是客户端主动断开连接等各种原因导致客户端连接断开时，只要在<code>sessionTimeout</code>规定的时间内能够重新连接上集群中任意一台服务器，那么之前创建的会话仍然有效。</p>\n<p>另外，在为客户端创建会话之前，服务端首先会为每个客户端都分配一个 <code>sessionID</code>。由于 <code>sessionID</code>是 ZooKeeper 会话的一个重要标识，许多与会话相关的运行机制都是基于这个 <code>sessionID</code> 的，因此，无论是哪台服务器为客户端分配的 <code>sessionID</code>，都务必保证全局唯一。</p>\n<hr>\n<h3 id=\"两阶段提交\"><a href=\"#两阶段提交\" class=\"headerlink\" title=\"两阶段提交\"></a>两阶段提交</h3><p>第一阶段：当要执行一个分布式事务的时候，事务发起者首先向协调者发起事务请求，然后协调者会给所有参与者发送 <code>prepare</code> 请求（其中包括事务内容）告诉参与者你们需要执行事务了，如果能执行我发的事务内容那么就先执行但不提交，执行后请给我回复。然后参与者收到 <code>prepare</code> 消息后，他们会开始执行事务（但不提交），并将 <code>Undo</code> 和 <code>Redo</code> 信息记入事务日志中，之后参与者就向协调者反馈是否准备好了。</p>\n<p>第二阶段：第二阶段主要是协调者根据参与者反馈的情况来决定接下来是否可以进行事务的提交操作，即提交事务或者回滚事务。</p>\n<p>比如这个时候 <strong>所有的参与者</strong> 都返回了准备好了的消息，这个时候就进行事务的提交，协调者此时会给所有的参与者发送 <strong><code>Commit</code> 请求</strong> ，当参与者收到 <code>Commit</code> 请求的时候会执行前面执行的事务的 <strong>提交操作</strong> ，提交完毕之后将给协调者发送提交成功的响应。</p>\n<p>而如果在第一阶段并不是所有参与者都返回了准备好了的消息，那么此时协调者将会给所有参与者发送 <strong>回滚事务的 <code>rollback</code> 请求</strong>，参与者收到之后将会 <strong>回滚它在第一阶段所做的事务处理</strong> ，然后再将处理情况返回给协调者，最终协调者收到响应后便给事务发起者返回处理失败的结果。</p>\n<h3 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h3><ul>\n<li><strong>单点故障问题</strong>，如果协调者挂了那么整个系统都处于不可用的状态了。</li>\n<li><strong>阻塞问题</strong>，即当协调者发送 <code>prepare</code> 请求，参与者收到之后如果能处理那么它将会进行事务的处理但并不提交，这个时候会一直占用着资源不释放，如果此时协调者挂了，那么这些资源都不会再释放了，这会极大影响性能。</li>\n<li><strong>数据不一致问题</strong>，比如当第二阶段，协调者只发送了一部分的 <code>commit</code> 请求就挂了，那么也就意味着，收到消息的参与者会进行事务的提交，而后面没收到的则不会进行事务提交，那么这时候就会产生数据不一致性问题。</li>\n</ul>\n<h3 id=\"3PC（三阶段提交）\"><a href=\"#3PC（三阶段提交）\" class=\"headerlink\" title=\"3PC（三阶段提交）\"></a>3PC（三阶段提交）</h3><hr>\n<h1 id=\"待删除\"><a href=\"#待删除\" class=\"headerlink\" title=\"待删除\"></a>待删除</h1><h2 id=\"Netty使用kyro序列化传输对象实战\"><a href=\"#Netty使用kyro序列化传输对象实战\" class=\"headerlink\" title=\"Netty使用kyro序列化传输对象实战\"></a>Netty使用kyro序列化传输对象实战</h2><h2 id=\"传输实体类\"><a href=\"#传输实体类\" class=\"headerlink\" title=\"传输实体类\"></a>传输实体类</h2><p>客户端请求实体类（String interfaceName  String methodName）</p>\n<p>服务端响应实体类(String message)</p>\n<h2 id=\"客户端-1\"><a href=\"#客户端-1\" class=\"headerlink\" title=\"客户端\"></a>客户端</h2><h3 id=\"初始化客户端\"><a href=\"#初始化客户端\" class=\"headerlink\" title=\"初始化客户端\"></a>初始化客户端</h3><p>初始化相关资源，eventLoopGroup(线程池，包含一组eventLoop实例，每个实例负责处理一个或多个IO操作) 和bootstrap（负责启动和配置Netty客户端的各种参数，如协议、编码、解码、I&#x2F;O模型）等，bootstrap指定实例使用的eventLoopGroup、channel类型、日志处理器、编码器解码器等</p>\n<p>然后对之前创建的<code>Bootstrap</code>实例进行了一系列配置，包括设置事件循环组（.group(eventLoopGroup)）、指定通道类型(.channel(NioSocketChannel))、添加日志处理器、设置连接超时时间(超过一定时间断掉)、添加空闲状态处理器（如果15秒之内没有发送数据给服务端的话，就发送一次心跳请求）、编解码器（添加编码器，用于将RPC请求编码为二进制数据；添加解码器，用于将二进制数据解码为RPC响应）和自定义的<code>ChannelHandler</code>（添加自定义的ChannelHandler）。</p>\n<h3 id=\"客户端-2\"><a href=\"#客户端-2\" class=\"headerlink\" title=\"客户端\"></a>客户端</h3><p>sendMessage()方法</p>\n<p>1.首先初始化了一个Bootstrap<br>2.通过 Bootstrap 对象连接服务端<br>3.通过 Channel 向服务端发送消息RpcRequest<br>4.发送成功后，阻塞等待，直到Channel关闭<br>5.拿到服务端返回的结果RpcResponse</p>\n<h2 id=\"定义ChannelHandler处理服务端消息\"><a href=\"#定义ChannelHandler处理服务端消息\" class=\"headerlink\" title=\"定义ChannelHandler处理服务端消息\"></a>定义ChannelHandler处理服务端消息</h2><p>NettyClientHandler用于读取服务端发送过来的RpcResponse 消息对象，并将 RpcResponse 消息对象保存到AttributeMap 上，AttributeMap 可以看作是一 个Channel 的共享数据源。<br>这样的话，我们就能通过channel和key将数据读取出来。</p>\n<p>AttributeMap的key是AttributeKey（“rpcResponse”）, value是Attribute(response)</p>\n<p>Channel实现了AttributeMap 接口(AttributeMap是一个接口，类似于Map数据结构)。每个Channel上的AttributeMap 属于共享数据。 AttributeMap 的结构，和Map很像，我们可以把key看作是AttributeKey, value 看作是Attribute，我们可以根据 AttributeKey 找到对应的Attribute</p>\n<pre><code class=\"java\">public interface AttributeMap &#123;\n    &lt;T&gt; Attribute&lt;T&gt; attr(AttributeKey&lt;T&gt; key);//可以理解为map的get\n    &lt;T&gt; boolean hasAttr(AttributeKey&lt;T&gt; key);//containsKey\n&#125;\n</code></pre>\n<h2 id=\"服务端-1\"><a href=\"#服务端-1\" class=\"headerlink\" title=\"服务端\"></a>服务端</h2><h3 id=\"初始化服务端\"><a href=\"#初始化服务端\" class=\"headerlink\" title=\"初始化服务端\"></a>初始化服务端</h3><p>NettyServer主要作用就是开启了一个服务端用于接受客户端的请求并处理。</p>\n<ol>\n<li>启动服务：启动服务时，创建一个Boss线程组和一个Worker线程组（主从），Boss线程组用于监听端口，Worker线程组用于处理请求，此外还创建了一个服务处理线程组，用于处理RPC请求。通过设置TCP_NODELAY（开启了 Nagle 算法，该算法的作用是尽可能的发送大数据快，减少网络传输）、SO_KEEPALIVE（开启 TCP 底层心跳机制）和SO_BACKLOG（表示系统用于临时存放已完成三次握手的请求的队列的最大长度,如果连接建立频繁，服务器处理创建新连接较慢，可以适当调大这个参数）等参数，优化了服务端的网络性能。当客户端第一次进行请求时才会进行初始化，然后将处理器添加到管道（30 秒之内没有收到客户端请求的话就关闭连接）中，对消息进行编解码和处理。</li>\n<li>关闭服务：当服务端关闭时，通过调用shutdownGracefully()方法关闭线程组。</li>\n</ol>\n<p>总体来说，这段代码实现了一个简单的RPC框架，提供了服务的注册和远程调用功能，可以方便地进行分布式开发。</p>\n<h2 id=\"能聊聊gRPC和dubbo这两类框架区别？\"><a href=\"#能聊聊gRPC和dubbo这两类框架区别？\" class=\"headerlink\" title=\"能聊聊gRPC和dubbo这两类框架区别？\"></a>能聊聊gRPC和dubbo这两类框架区别？</h2><h2 id=\"有没有考虑过服务治理相关的事情吗（还没有）\"><a href=\"#有没有考虑过服务治理相关的事情吗（还没有）\" class=\"headerlink\" title=\"有没有考虑过服务治理相关的事情吗（还没有）\"></a>有没有考虑过服务治理相关的事情吗（还没有）</h2><h2 id=\"RPC项目中有做单元测试吗？（没有）\"><a href=\"#RPC项目中有做单元测试吗？（没有）\" class=\"headerlink\" title=\"RPC项目中有做单元测试吗？（没有）\"></a>RPC<a href=\"https://blog.csdn.net/jump/super-jump/word?word=%E9%A1%B9%E7%9B%AE\">项目</a>中有做单元测试吗？（没有）</h2><h1 id=\"模拟面试\"><a href=\"#模拟面试\" class=\"headerlink\" title=\"模拟面试\"></a>模拟面试</h1><h2 id=\"一致性哈希\"><a href=\"#一致性哈希\" class=\"headerlink\" title=\"一致性哈希\"></a>一致性哈希</h2><p>代码具体怎么实现的？</p>\n<p>维护了一个ConcurrentHashMap类型的选择器集合，键为服务名称 rpcServiceName，值为选择器selector</p>\n<p>接收一个服务地址列表 serviceAddresses 和一个 RpcRequest 对象 rpcRequest，计算 serviceAddresses 的身份哈希码，通过 rpcRequest 中的服务名称构造出 rpcServiceName。然后从 selectors 中获取与 rpcServiceName 对应的一致性哈希选择器 ConsistentHashSelector（每个一致性哈希选择器对应一个服务），如果该选择器不存在或者哈希码不匹配，则创建一个新的一致性哈希选择器（），并将key为serviceName，value为selector放入 selectors（缓存） 中。最后，调用一致性哈希选择器的 select 方法选择一个服务地址。</p>\n<p><strong>选择器实现</strong>：</p>\n<p>再说下这个选择器的内部实现 ，维护了一个存储虚拟节点的 TreeMap （保证有序），key是hash值，value 是一个服务地址；（为什么？如果节点太少,会导致数据倾斜,也就是hash范围差距大，那么此时可以引入了<strong>虚拟节点机制</strong>，即对每个节点计算多个哈希值，每个计算结果位置都放置在对应节点中，这些节点<strong>称为虚拟节点</strong>。）</p>\n<p><strong>选择器初始化</strong>：</p>\n<p>遍历所有服务地址，为每个服务地址创建多个虚拟节点，使用 md5 算法出当前服务地址字符串的摘要数组，从 md5摘要中取出 4 个子段，并计算子段的哈希值，然后将虚拟节点的哈希值和服务地址的映射关系存储到 TreeMap 中</p>\n<p>针对每一个ip地址创建（replicaNumber &#x2F; 4）个重复节点，针对每个一个重复节点将其等间隔的分布在环形hash空间上（4个） 将虚拟节点的哈希值和服务地址的映射关系存储到 TreeMap 中 </p>\n<p>同时缓存了之前计算的 serviceAddresses 的身份哈希码</p>\n<p><strong>select方法</strong>：</p>\n<p>计算 RPC 服务名的 MD5 摘要数组，计算md5摘要哈希值并在TreeMap里面选择一个服务地址，找到虚拟节点中第一个哈希值大于等于指定哈希值的节点，如果不存在该节点，则选择环上的第一个节点，返回该节点对应的服务地址；</p>\n<h2 id=\"Zookeeper\"><a href=\"#Zookeeper\" class=\"headerlink\" title=\"Zookeeper\"></a>Zookeeper</h2><p><strong>注册思路：</strong></p>\n<p>首先创建服务节点路径（根路径+服务名称+服务地址（ip端口）），获取Zookeeper客户端，创建持久化节点</p>\n<p><strong>创建持久化节点部分</strong>：</p>\n<p>根据REGISTERED_PATH_SET（ConcurrentHashMap.newKeySet(); 定义一个线程安全的Set用于存储已经注册过的路径）判断节点是否已经存在，如果存在则直接返回,如果节点不存在，则使用指定的路径(传入的)创建一个持久化节点,将已注册的路径加入到REGISTERED_PATH_SET中，以便后续检查</p>\n<p><strong>发现部分：</strong></p>\n<p>根据zookeeper客户端和服务名称，调用getChildrenNodes获取指定结点下（该服务名称下的）所有子节点</p>\n<p><strong>getChildrenNodes部分</strong>：</p>\n<p>根据SERVICE_ADDRESS_MAP（currentHashMap 线程安全的Map用于存储每个服务的地址列表 ）的Containskey方法判断是否已经获取过该节点的子节点列表,如果已经获取过，直接返回之前获取到的子节点列表，没有的话，声明一个空列表，用于存放获取到的子节点列表，拼接出目标节点的完整路径，获取指定节点下的所有子节点列表，将获取到的子节点列表缓存起来，便于下次快速获取，同时给该节点注册一个监听器(registerWatcher)，用于在节点发生变化时自动更新子节点列表，返回获取到的子节点列表</p>\n<p><strong>registerWatcher部分</strong>：（在节点发生变化时自动更新子节点列表）</p>\n<p>getChildrenNodes部分，给serviceName结点注册了一个监听器，传入了serviceName参数，通过拼接ZooKeeper注册根路径和服务名称得到服务路径，创建了一个PathChildrenCache对象，用于监听服务路径下的子节点变化，并将其添加到服务路径的监听器列表中。与此同时，创建了一个PathChildrenCacheListener对象，当服务路径下的子节点发生变化时，PathChildrenCacheListener对象会被回调，获取服务路径下所有子节点的路径（List<String>），将服务名称与服务地址的映射关系存入服务地址映射表SERVICE_ADDRESS_MAP中。最终通过启动PathChildrenCache对象实现监听服务地址的更新。</String></p>\n<h2 id=\"Netty\"><a href=\"#Netty\" class=\"headerlink\" title=\"Netty\"></a>Netty</h2><p><strong>channal缓存</strong></p>\n<p>通过负载均衡找到服务端地址，调用doconnet方法连接服务端，返回对应的channel，后续发送rpc请求消息就是通过channel传输，考虑到后面可能有相同服务调用，对channel做了缓存，底层是ConcurrentHashMap，key是服务地址，value是channel，get的时候为空的话调用doconnect获得channel并存进去</p>\n<p><strong>消息的发送：</strong></p>\n<p>负载均衡获取服务地址，getChannel方法获取地址相关channel，判断是否处于活跃状态，不活跃的话，抛出一个非法状态异常；活跃的话，将当前请求的RequestId和结果resultFuture放入一个未处理请求的Map中；创建一个RpcMessage对象，用于存储当前请求的相关信息，包括请求的数据和序列化方式；向服务器发送当前请求的RpcMessage对象，同样，用addListener((ChannelFutureListener)添加一个监听器，在请求发送成功记录日志，失败的话关闭客户端的channel，并使用异常信息将结果resultFuture标记为已完成但是发生异常。</p>\n<p><strong>消息的接受与动态响应：</strong></p>\n<p>1、检查接收到的消息是否是RpcMessage类型的，是的话，打印接收到的消息日志信息，并构造RpcMessage2、获取消息类型，判断是心跳请求消息还是RPC请求消息，如果是心跳请求消息，构造心跳响应消息，并设置数据为PONG，如果是RPC请求消息，获取RPC请求并处理，返回处理结果；</p>\n<p>3、同时构造RPC响应消息，如果连接可写，构造成功的RPC响应消息，如果连接不可写，构造失败的RPC响应消息，发送RPC响应消息，并在发送失败时关闭连接，最后确保ByteBuf被释放，否则可能会出现内存泄漏；</p>\n<p>4、如果连接处于空闲状态（即没有数据传输）或者当捕获到异常时，关闭连接</p>\n<h2 id=\"kyro\"><a href=\"#kyro\" class=\"headerlink\" title=\"kyro\"></a>kyro</h2><p>这是一个使用 Kryo 序列化和反序列化 Java 对象的类，为了解决 Kryo 线程不安全的问题，使用 ThreadLocal 为每个线程创建一个独立的 Kryo 实例，保证了线程安全性。</p>\n<p><strong>初始化</strong></p>\n<p>KryoSerializer 类实现了Serializer 接口</p>\n<p>为了解决 Kryo 线程不安全的问题，使用 ThreadLocal 为每个线程创建一个独立的 Kryo 实例，保证了线程安全性。withInitial（）用lamba表达式new了一个kyro实例并注册了RpcResponse 和 RpcRequest 两个类。</p>\n<p>ByteArrayOutputStream :用于存储序列化后的字节数组</p>\n<p>Output : Kryo 序列化库的 Output 对象，将其构造函数中传入的 ByteArrayOutputStream 对象作为参数，以便将序列化后的数据写入 ByteArrayOutputStream 中。</p>\n<p><strong>serialize</strong></p>\n<ol>\n<li>创建一个 ByteArrayOutputStream 和 Output 实例，Output 用于将序列化的对象写入 ByteArrayOutputStream 中。</li>\n<li>获取当前线程的kyro实例</li>\n<li>kryo 将 obj 对象（传入的rpcrequest）序列化成字节数组并写入 Output 中。</li>\n<li>remove清除当前线程的 Kryo 实例</li>\n<li>将 ByteArrayOutputStream 中的数据转换为字节数组并返回。</li>\n</ol>\n<p><strong>deserialize</strong></p>\n<ol>\n<li>创建一个 ByteArrayInputStream 和 Input 实例，Input 从 ByteArrayInputStream 中读取反序列化的对象。</li>\n<li>获取当前线程的 Kryo 实例</li>\n<li>从 Input 中读取字节数组并反序列化成对象。</li>\n<li>清除当前线程的 Kryo 实例。</li>\n<li>将反序列化后的对象强制类型转换为指定的类型并返回。</li>\n</ol>\n<p><strong>为什么用kyro？</strong></p>\n<p>变长存储特性，字节码生成机制，运行速度快，占用较少的字节码体积，专门针对java</p>\n<p><strong>为什么用ThreadLocal？</strong></p>\n<p>key是当前线程，value是kryo实例，防止多个服务调用之间会造成kyro线程不安全的问题，每个线程存一份kyro，多个线程互不影响 </p>\n<h2 id=\"动态代理-2\"><a href=\"#动态代理-2\" class=\"headerlink\" title=\"动态代理\"></a>动态代理</h2><p>1.定义一个接口及其实现类;2.自定义InvocationHandler并重写invoke方法，在invoke 方法中我们会调用原生方法(被代理类的方法) 并自定义一些处理逻辑;</p>\n<p>invoke方法处理逻辑：</p>\n<pre><code class=\"plain\">1、创建远程方法请求对象，调用rpcRequestTransport.sendRpcRequest(rpcRequest)\n拿到响应结果。\n2、根据传输方式发送远程方法请求，并获取响应结果\n3、检查响应结果是否正确，如果响应结果为null，抛出调用失败的异常，如果请求ID与响应ID不匹配，抛出请求与响应不匹配的异常， 如果响应结果状态码为null或者不是成功状态，抛出调用失败的异常\n4、返回远程方法调用的结果\n</code></pre>\n<p>3.通过Proxy . newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces ，InvocationHandler h)方法创建代理对象;（这是一个代理对象的工厂类，构造参数包括目标类的类加载器；代理需要实现的接口，可有多个；代理对象对应自定义的InvocationHandler）,然后调用原生方法，这里Handler起作用，实际上调用的是invoke方法，然后Invoke前后都可以对方法进行增强</p>\n<h2 id=\"CompletableFuture-1\"><a href=\"#CompletableFuture-1\" class=\"headerlink\" title=\"CompletableFuture\"></a>CompletableFuture</h2><p>在RPC中使用CompletableFuture包装接受服务端返回结果有以下几个好处：</p>\n<ol>\n<li>异步处理：CompletableFuture可以<strong>帮助我们异步处理服务端返回结果</strong>，避免在客户端等待服务端响应时阻塞线程，提高应用的并发性能。</li>\n<li>可组合：CompletableFuture<strong>支持链式调用和组合</strong>，可以方便地将多个异步任务组合在一起，实现复杂的异步业务逻辑。</li>\n<li>异常处理：CompletableFuture<strong>可以捕获异步任务中的异常</strong>，便于我们进行异常处理，提高代码的健壮性。</li>\n<li>超时控制：CompletableFuture<strong>支持设置超时时间</strong>，可以在服务端响应超时时及时进行处理，避免因服务端响应慢而导致客户端请求超时。</li>\n</ol>\n<p>综上所述，使用CompletableFuture包装接受服务端返回结果可以帮助我们更好地实现异步处理、异常处理、超时控制等功能，提高应用的性能和健壮性。</p>\n","categories":["项目"]},{"title":"SQL","url":"/2023/06/04/SQL/","content":"<h1 id=\"1\"><a href=\"#1\" class=\"headerlink\" title=\"1\"></a>1</h1><p>1、题目：现在运营想要筛选出所有<strong>北京大学</strong>的学生进行用户调研，请你从用户信息表中取出满足条件的数据，结果返回<strong>设备id</strong>和<strong>学校</strong>。<span id=\"more\"></span></p>\n<p>SELECT device_id,university FROM user_profile WHERE university&#x3D; ‘北京大学</p>\n<p>注意 返回数据用逗号隔开</p>\n<h1 id=\"2\"><a href=\"#2\" class=\"headerlink\" title=\"2\"></a>2</h1><p>2、查询考试成绩有不及格的学生的学号</p>\n<p>SELECT DISTINCT 学号 FROM 成绩表 WHERE 成绩&lt; 60</p>\n<p>DISTINCT用来去重</p>\n<h1 id=\"3\"><a href=\"#3\" class=\"headerlink\" title=\"3\"></a>3</h1><p>3、查找年龄大于24岁的用户信息</p>\n<p>SELECT device_id, gender, age, university FROM user_profile WHERE age is not null and age &gt; 24</p>\n<p>null 是大于所有数值型还是小于所有数值型是由 DBMS 决定的，严谨起见，还是加上 age is not null 的条件</p>\n<h1 id=\"4\"><a href=\"#4\" class=\"headerlink\" title=\"4\"></a>4</h1><p>4、查询所有系号在2和3之间的班号和班名。</p>\n<p>SELECT 班号,班名 FROM 班级表 WHERE 系号 BETWEEN <code>2` `AND </code>3</p>\n<h1 id=\"5\"><a href=\"#5\" class=\"headerlink\" title=\"5\"></a>5</h1><p>5、查询所有系号不在2和3之间的班号和班名。</p>\n<p>SELECT 班号,班名 FROM 班级表 WHERE 系号 NOT BETWEEN <code>2` `AND </code>3</p>\n<h1 id=\"6\"><a href=\"#6\" class=\"headerlink\" title=\"6\"></a>6</h1><p>6、现在运营想要查看除复旦大学以外的所有用户明细，请你取出相应数据</p>\n<p>SELECT<code> </code>device_id,gender,age,university <code>FROM` `user_profile</code>WHERE<code> </code>university <code>NOT` `IN` `(</code>‘复旦大学’&#96;&#96;)或者select device_id,gender,age,university from user_profile where university!&#x3D;”复旦大学”</p>\n<p>where 字段 in（not in） 一个范围</p>\n<h1 id=\"7\"><a href=\"#7\" class=\"headerlink\" title=\"7\"></a>7</h1><p>7、现在运营想要找到<strong>男性且GPA在3.5以上</strong>的用户进行调研，请你取出相关数据。</p>\n<p>select device_id,gender,age ,university,gpa from user_profile where gender&#x3D;”male” and gpa&gt;3.5</p>\n<h1 id=\"8\"><a href=\"#8\" class=\"headerlink\" title=\"8\"></a>8</h1><p>8、查询所有系号大于1且班名以“电子 ” 开头的班号和班名。</p>\n<p>SELECT<code> </code>班号,班名 <code>FROM` `班级表</code>WHERE<code> </code>系号&gt;1 <code>AND` `班名 </code>LIKE<code> </code>‘电子%’</p>\n<h1 id=\"9\"><a href=\"#9\" class=\"headerlink\" title=\"9\"></a>9</h1><p>9、现在运营想要找到<strong>学校为北大或GPA在3.7以上</strong>的用户进行调研，请你取出相关数据</p>\n<p>SELECT<code> </code>device_id,gender,age,university,gpa <code>FROM` `user_profile</code>WHERE<code> </code>university&#x3D;&#96;&#96;’北京大学’<code> </code>OR<code> </code>gpa &gt; 3.7</p>\n<h1 id=\"10\"><a href=\"#10\" class=\"headerlink\" title=\"10\"></a>10</h1><p>10、现在运营想要找到<strong>学校为北大、复旦和山大</strong>的同学进行调研，请你取出相关数据。</p>\n<p>SELECT<code> </code>device_id,gender,age,university,gpa <code>FROM` `user_profile</code>WHERE<code> </code>university <code>IN` `(</code>‘北京大学’<code> </code>, <code>&#39;复旦大学&#39;</code>, <code>&#39;山东大学&#39;</code>)</p>\n<h1 id=\"11\"><a href=\"#11\" class=\"headerlink\" title=\"11\"></a>11</h1><p>11、现在运营想要找到gpa在3.5以上的山东大学用户 或 gpa在3.8以上的复旦大学同学进行用户调研，请你取出相应数据</p>\n<p>SELECT<code> </code>device_id,gender,age,university,gpa <code>FROM` `user_profile</code>WHERE<code> </code>(university&#x3D;<code>&#39;山东大学&#39;</code>AND<code> </code>gpa &gt; 3.5) <code>OR` `(university=</code>‘复旦大学’<code> </code>AND<code> </code>gpa &gt; 3.8)</p>\n<h1 id=\"12\"><a href=\"#12\" class=\"headerlink\" title=\"12\"></a>12</h1><p>12、现在运营想查看所有大学中带有北京的用户的信息，请你取出相应数据。</p>\n<p>SELECT device_id,age,university  FROM user_profile WHERE university  LIKE ‘%北京%’</p>\n<p><strong>拓展：</strong></p>\n<p>这道题主要考察的是模糊查询 字段名 like ‘匹配内容’</p>\n<ol>\n<li>_ ：下划线 代表匹配任意一个字符；</li>\n<li>% ：百分号 代表匹配0个或多个字符；</li>\n<li>[]: 中括号 代表匹配其中的任意一个字符；</li>\n<li>[^]: ^尖冒号 代表 非，取反的意思；不匹配中的任意一个字符。</li>\n</ol>\n<p>tips：面试常问的一个问题：你了解哪些数据库优化技术？ SQL语句优化也属于数据库优化一部分，而我们的like模糊查询会引起全表扫描，速度比较慢，应该尽量避免使用like关键字进行模糊查询。</p>\n<h1 id=\"13\"><a href=\"#13\" class=\"headerlink\" title=\"13\"></a>13</h1><p>13 复旦大学学生gpa最高值</p>\n<p>方法一：</p>\n<p><strong>desc倒排</strong></p>\n<p>select gpa from user_profile where university &#x3D;’复旦大学’ order by  gpa desc limit 1</p>\n<p>方法二：</p>\n<p>聚合函数必须放在前面 不可在where里面</p>\n<p>SELECT MAX(gpa)gpa FROM user_profile WHERE university &#x3D; ‘复旦大学’</p>\n<p><strong>拓展</strong></p>\n<h2 id=\"使用聚合函数汇总数据\"><a href=\"#使用聚合函数汇总数据\" class=\"headerlink\" title=\"使用聚合函数汇总数据\"></a>使用聚合函数汇总数据</h2><p>SQL提供的统计函数有：COUNT(【Shift+8】)：统计表中元组个数；COUNT([DISTINCT] &lt;列名&gt;)：统计本列列值个数；SUM( &lt;列名&gt; )：计算列值总和；AVG( &lt;列名&gt; )：计算列值平均值；MAX( &lt;列名&gt; )：求列值最大值；MIN( &lt;列名&gt; )： 求列值最小值。上述函数中除COUNT(【Shift+8】)外，其他函数在计算过程中均忽略NULL值。</p>\n<p><strong>统计函数不能出现在WHERE子句中。</strong>例如，查询成绩最高的学生的学号，如下写法是错误的：SELECT 学号 FROM 成绩表WHERE 成绩 &#x3D; MX(成绩</p>\n<h1 id=\"14\"><a href=\"#14\" class=\"headerlink\" title=\"14\"></a>14</h1><p>14、题目：现在运营想要看一下男性用户有多少人以及他们的平均gpa是多少，用以辅助设计相关活动，请你取出相应数据。</p>\n<p>问题分解：</p>\n<ol>\n<li>限定条件为 男性用户；</li>\n<li>有多少人，明显是计数，count函数；</li>\n<li>平均gpa，求平均值用avg函数；</li>\n</ol>\n<hr>\n<p>细节问题：根据输出示例，有两个问题需要注意：</p>\n<ol>\n<li>表头重命名，用as语法</li>\n<li>浮点数的平均值可能小数点位数很多，按照示例保存一位小数，用round函数</li>\n</ol>\n<p>使用ROUND()函数，ROUND返回一个数值，舍入到指定的长度或精度</p>\n<p>select count(gender) as male_num,round(avg(gpa),1) as avg_gpa from user_profile where gender&#x3D;’male’ </p>\n<h1 id=\"15\"><a href=\"#15\" class=\"headerlink\" title=\"15\"></a>15</h1><p>15、现在运营想要对每个学校不同性别的用户活跃情况和发帖数量进行分析，请分别计算出每个学校每种性别的用户数、30天内平均活跃天数和平均发帖数量。</p>\n<p>结果：这里最好用下round(x,1)</p>\n<p>select      gender, university,     count(device_id) as user_num,     avg(active_days_within_30) as avg_active_days,     avg(question_cnt) as avg_question_cnt from user_profile group by gender, university</p>\n<p><strong>在面试某上海上市金融科技公司中曾被问到的一个问题是：</strong></p>\n<ol>\n<li>你在项目中你用过分组函数吗？</li>\n</ol>\n<p>我：用过（必须展现实力）</p>\n<ol>\n<li>那你听清楚我下面这个问题，分组SQL语句中，select和from和where和group by 和 having 这几部分的执行顺序是怎么样的？</li>\n</ol>\n<p>我：先是from，再到 where ，再到select，再到group by ，最后having。</p>\n<ol>\n<li>你能说说为什么是这样子的吗？</li>\n</ol>\n<p>我：因为首先肯定是要确定数据从哪张表来，然后按where条件查询出结果，再然后才能进行group by分组（分组条件可以有多个，按字段顺序依次分组），最后是由having对分组后的结果集进行过滤</p>\n<p>我的理解： 先看他是根据什么分组的 然后看需要啥字段 给他就行了</p>\n<h1 id=\"16\"><a href=\"#16\" class=\"headerlink\" title=\"16\"></a>16</h1><p>16、题目：现在运营想查看每个学校用户的平均发贴和回帖情况，寻找低活跃度学校进行重点运营，请取出平均发贴数低于5的学校或平均回帖数小于20的学校。</p>\n<p>select     university,     round(avg(question_cnt), 1) as avg_question_cnt,     round(avg(answer_cnt), 1) as avg_answer_cnt from user_profile group by university having avg_question_cnt&lt;5 or avg_answer_cnt&lt;20 </p>\n<h2 id=\"使用HAVING\"><a href=\"#使用HAVING\" class=\"headerlink\" title=\"使用HAVING\"></a>使用HAVING</h2><p>HAVING子句用于对分组后的结果再进行过滤，它的功能有点像WHERE子句，但它用于组而不是单个记录。<strong>在HAVING子句中可以使用统计函数，但在WHERE子句中则不能。****HAVING通常与GROUP BY子句一起使用。</strong></p>\n<p>我的理解：</p>\n<h1 id=\"17\"><a href=\"#17\" class=\"headerlink\" title=\"17\"></a>17</h1><p>17、having 最后规律分组的数据 可以用select后面的as 字段</p>\n<p>题目：现在运营想要查看不同大学的用户平均发帖情况，并期望结果按照平均发帖情况进行升序排列，请你取出相应数据。</p>\n<p>select university,     avg(question_cnt) as avg_question_cnt from user_profile group by university order by avg_question_cnt</p>\n<p>同样的 order by 放在最后面就好了</p>\n<ol>\n<li>tips：在排序中order by 字段 asc –其中升序为asc(可以不写，默认就是按照升序排列),降序为desc（必须写）</li>\n</ol>\n<p>round最好也加一下</p>\n<h1 id=\"18\"><a href=\"#18\" class=\"headerlink\" title=\"18\"></a>18</h1><p>题目：现在运营想要查看所有来自浙江大学的用户题目回答明细情况，请你取出相应数据</p>\n<ul>\n<li>限定条件：来自浙江大学的用户，学校信息在用户画像表，答题情况在用户练习明细表，因此需要通过device_id关联两个表的数据； </li>\n<li>方法1：join两个表，用inner join，条件是on up.device_id&#x3D;qpd.device_id and up.university&#x3D;’浙江大学’</li>\n<li>方法2：先从画像表找到浙江大学的所有学生id列表where university&#x3D;’浙江大学’，再去练习明细表筛选出id在这个列表的记录，用where in</li>\n</ul>\n<p>select qpd.device_id, qpd.question_id, qpd.result from question_practice_detail as qpd inner join user_profile as up on up.device_id&#x3D;qpd.device_id and up.university&#x3D;’浙江大学’ order by question_idselect device_id, question_id, result from question_practice_detail where device_id in (     select device_id from user_profile     where university&#x3D;’浙江大学’ ) order by question_id</p>\n<p>子查询效率低一点 但是我写起来舒服</p>\n<p>xx表 inner join xx表 On 条件 order by XX</p>\n<p>还是用join吧 !!!! 用子查询好像不太行</p>\n<p>这里注意，一旦我们join了之后，select qpd.device_id, qpd.question_id, qpd.result后面跟的一定要是具体表的表名 不然查不出来！</p>\n<p>而且中间有条件的话别用where 条件直接在On里面写就行</p>\n<h1 id=\"19\"><a href=\"#19\" class=\"headerlink\" title=\"19\"></a>19</h1><p>运营想要了解每个学校答过题的用户平均答题数量情况，请你取出数据。</p>\n<ul>\n<li>每个学校：按学校分组，group by university</li>\n<li>平均答题数量：在每个学校的分组内，用总答题数量除以总人数即可得到平均答题数量count(question_id) &#x2F; count(distinct device_id)</li>\n<li>表连接：学校和答题信息在不同的表，需要做连接</li>\n</ul>\n<p>select university,     count(question_id) &#x2F; count(distinct qpd.device_id) as avg_answer_cnt from question_practice_detail as qpd inner join user_profile as up on qpd.device_id&#x3D;up.device_id group by university</p>\n<h1 id=\"20\"><a href=\"#20\" class=\"headerlink\" title=\"20\"></a>20</h1><h3 id=\"左连接，右连接，内连接，全连接的区别及使用\"><a href=\"#左连接，右连接，内连接，全连接的区别及使用\" class=\"headerlink\" title=\"左连接，右连接，内连接，全连接的区别及使用\"></a>左连接，右连接，内连接，全连接的区别及使用</h3><p>左连接 （left join）：返回包括左表的所有记录和右表中连接字段相等的记录右连接（right join）：返回包括右表的所有记录和左表中连接字段相等的记录等值连接或者叫内连接（inner join）：只返回两表相连相等的行全外连接（full join）：返回左右表中所有的记录和左右表中连接字段相等的记录。</p>\n<ul>\n<li>限定条件：无；</li>\n<li>每个学校：按学校分组group by university</li>\n<li>不同难度：按难度分组group by difficult_level</li>\n<li>平均答题数：总答题数除以总人数count(qpd.question_id) &#x2F; count(distinct qpd.device_id)</li>\n<li>来自上面信息三个表，需要联表，up与qpd用device_id连接，qd与qpd用question_id连接。</li>\n</ul>\n<p>select      university,     difficult_level,     round(count(qpd.question_id) &#x2F; count(distinct qpd.device_id), 4) as avg_answer_cnt from question_practice_detail as qpd left join user_profile as up on up.device_id&#x3D;qpd.device_id left join question_detail as qd on qd.question_id&#x3D;qpd.question_id group by university, difficult_level</p>\n<h1 id=\"21\"><a href=\"#21\" class=\"headerlink\" title=\"21\"></a>21</h1><p>运营想要查看<strong>参加了答题</strong>的山东大学的用户在不同难度下的平均答题题目数，请取出相应数据</p>\n<p>目前用inner比较稳妥</p>\n<p>20题用inner就可</p>\n<h1 id=\"22\"><a href=\"#22\" class=\"headerlink\" title=\"22\"></a>22</h1><p>分别查看学校为山东大学或者性别为男性的用户的device_id、gender、age和gpa数据，结果不去重</p>\n<ul>\n<li>限定条件：学校为山东大学或者性别为男性的用户：university&#x3D;’山东大学’, gender&#x3D;’male’；</li>\n<li>分别查看&amp;结果不去重：所以直接使用两个条件的or是不行的，直接用union也不行，要用union all，分别去查满足条件1的和满足条件2的，然后合在一起不去重</li>\n</ul>\n<p>SELECT device_id,gender,age,gpa FROM user_profile WHERE university&#x3D;’山东大学’  UNION ALL SELECT device_id,gender,age,gpa FROM user_profile WHERE gender&#x3D;’male’</p>\n<p>结果不去重 就加ALL</p>\n<h1 id=\"23\"><a href=\"#23\" class=\"headerlink\" title=\"23\"></a>23</h1><p>题目：现在运营想要将用户划分为25岁以下和25岁及以上两个年龄段，分别查看这两个年龄段用户数量</p>\n<p><strong>本题注意：age为null 也记为 25岁以下</strong></p>\n<h3 id=\"CASE函数\"><a href=\"#CASE函数\" class=\"headerlink\" title=\"CASE函数\"></a>CASE函数</h3><p>是一种多分支的函数，可以根据条件列表的值返回多个可能的结果表达式中的一个。可用在任何允许使用表达式的地方，但不能单独作为一个语句执行。</p>\n<p>case 条件表达式 when 条件表达式值 then 字段值 end as 字段</p>\n<p>SELECT CASE WHEN age &lt; 25 OR age IS NULL THEN ‘25岁以下’              WHEN age &gt;&#x3D; 25 THEN ‘25岁及以上’             END age_cut,COUNT(*) as number FROM user_profile GROUP BY age_cut</p>\n<h1 id=\"24\"><a href=\"#24\" class=\"headerlink\" title=\"24\"></a>24</h1><p>题目：现在运营想要将用户划分为<strong>20岁以下，20-24岁，25岁及以上</strong>三个年龄段，分别查看不同年龄段用户的明细情况，请取出相应数据。（注：若<strong>年龄为空</strong>请返回<strong>其他</strong>。）</p>\n<p>select     device_id,     gender,     case         when age&gt;&#x3D;25 then ‘25岁及以上’         when age&gt;&#x3D;20 then ‘20-24岁’         when age&lt;20 then ‘20岁以下’         else ‘其他’     end as age_cut from user_profile </p>\n<h1 id=\"25\"><a href=\"#25\" class=\"headerlink\" title=\"25\"></a>25</h1><p>题目：现在运营想要计算出<strong>2021年8月每天用户练习题目的数量</strong>，请取出相应数据。</p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/image-20230424160950126.png\" alt=\"img\"></p>\n<p><strong>知识点</strong>：</p>\n<p>对于2021-05-03，用year month day函数直接取得想要的</p>\n<pre><code class=\"plain\">select\n    day(date) as day,\n    count(question_id) as question_cnt\nfrom question_practice_detail\nwhere month(date)=8 and year(date)=2021\ngroup by date\n</code></pre>\n<h1 id=\"26\"><a href=\"#26\" class=\"headerlink\" title=\"26\"></a>26</h1><p>题目：现在运营想要查看用户在某天刷题后第二天还会再来刷题的平均概率。请你取出相应数据。<img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/image-20230424161313268.png\" alt=\"img\"></p>\n<ul>\n<li><p>限定条件：第二天再来。</p>\n</li>\n<li><ul>\n<li>解法1：表里的数据可以看作是全部第一天来刷题了的，那么我们需要构造出第二天来了的字段，因此可以考虑用left join把第二天来了的拼起来，限定第二天来了的可以用date_add(date1, interval 1 day)&#x3D;date2筛选，并用device_id限定是同一个用户。</li>\n</ul>\n</li>\n<li><p>平均概率：</p>\n</li>\n<li><ul>\n<li>解法1：可以count(date1)得到左表全部的date记录数作为分母，count(date2)得到右表关联上了的date记录数作为分子，相除即可得到平均概率</li>\n</ul>\n</li>\n</ul>\n<pre><code class=\"plain\">select count(date2) / count(date1) as avg_ret\nfrom (\n    select\n        distinct qpd.device_id,\n        qpd.date as date1,\n        uniq_id_date.date as date2\n    from question_practice_detail as qpd\n    left join(\n        select distinct device_id, date\n        from question_practice_detail\n    ) as uniq_id_date\n    on qpd.device_id=uniq_id_date.device_id\n        and date_add(qpd.date, interval 1 day)=uniq_id_date.date\n) as id_last_next_date\n</code></pre>\n<h1 id=\"27\"><a href=\"#27\" class=\"headerlink\" title=\"27\"></a>27</h1><p>题目：现在运营举办了一场比赛，收到了一些参赛申请，表数据记录形式如下所示，现在运营想要统计每个性别的用户分别有多少参赛者，请取出相应结果</p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/image-20230424162133044.png\" alt=\"img\"></p>\n<p><strong>字符串截取函数</strong></p>\n<p>substring_index(FIELD, sep, n)可以将字段FIELD按照sep分隔：</p>\n<p>(1).当n大于0时取第n个分隔符(n从1开始)左边的全部内容；</p>\n<p>(2).当n小于0时取倒数第n个分隔符(n从-1开始)右边的全部内容；</p>\n<pre><code class=\"plain\">select\n    substring_index(profile, &#39;,&#39;, -1) as gender,\n    count(device_id) as number\nfrom user_submit\ngroup by gender\n</code></pre>\n<p>同理，对blog_url进行处理</p>\n<p>select device_id,substring_index(blog_url,’&#x2F;‘,-1) as user_name from user_submit;</p>\n<p>如果要找年龄呢？</p>\n<p>双层嵌套</p>\n<p>select substring_index(substring_index(profile,’,’,-2) ,’,’,1) as age,count(device_id) as number from user_submit group by age;</p>\n<h1 id=\"28\"><a href=\"#28\" class=\"headerlink\" title=\"28\"></a>28</h1><p>现在运营想要找到每个学校gpa最低的同学来做调研，请你取出每个学校的最低gpa。</p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/image-20230424163904655.png\" alt=\"img\"></p>\n<pre><code class=\"plain\">select device_id,university,gpa\nfrom user_profile\nwhere (university,gpa) in (select university,min(gpa) from user_profile group by university)\norder by university;\n</code></pre>\n<p>子查询：去重的university 以及min gpa</p>\n<p>然后用In判断符合条件的就行</p>\n","categories":["SQL"]},{"title":"Redis","url":"/2023/06/04/Redis/","content":"<h2 id=\"Redis是什么以及优缺点\"><a href=\"#Redis是什么以及优缺点\" class=\"headerlink\" title=\"Redis是什么以及优缺点\"></a>Redis是什么以及优缺点</h2><p>整个数据库加载在内存当中操作，定期通过异步操作把数据库中的数据flush到硬盘上进行保存，每秒10w次读写操作<span id=\"more\"></span></p>\n<p><strong>优点：</strong></p>\n<p>读写性能高 Redis能读的速度是110000次&#x2F;s，写的速度是81000次&#x2F;s。</p>\n<p>支持数据持久化 AOF RDB</p>\n<p>支持事务</p>\n<p>数据结构丰富：hash set zset list string</p>\n<p>支持主从复制和读写分离 主机会自动将数据同步到从机，可以进行读写分离。</p>\n<p>支持发布订阅 pub-sub，通知，key过期等特性</p>\n<p><strong>缺点：</strong></p>\n<ul>\n<li>数据库容量受到物理内存的限制，不能用作海量数据的高性能读写，因此Redis适合的场景主要局限在较小数据量的高性能操作和运算上。</li>\n<li>主机宕机，宕机前有部分数据未能及时同步到从机，切换IP后还会引入数据不一致的问题，降低了系统的可用性。</li>\n</ul>\n<h2 id=\"Redis为什么快\"><a href=\"#Redis为什么快\" class=\"headerlink\" title=\"Redis为什么快\"></a>Redis为什么快</h2><p>1、内存存储：没有磁盘IO的开销 。数据存在内存中，类似于 HashMap，HashMap 的优势就是查找和操作的时间复杂度都是O(1)。</p>\n<p>2、单线程：避免了多个线程之间线程切换和锁资源争用的开销。注意：单线程是指的是在核心网络模型中，网络请求模块使用一个线程来处理，即一个线程处理所有网络请求。</p>\n<p>3、非阻塞IO：Redis使用多路复用IO技术，将epoll作为I&#x2F;O多路复用技术的实现，再加上Redis自身的事件处理模型将epoll中的连接、读写、关闭都转换为事件，不在网络I&#x2F;O上浪费过多的时间。</p>\n<p>4、优化的数据结构，提升性能：Redis有诸多可以直接应用的优化数据结构的实现，应用层可以直接使用原生的数据结构提升性能。</p>\n<p>5、使用底层模型不同：Redis直接自己构建了 VM (虚拟内存)机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求。</p>\n<p>内存数据库，读写速度快 分布式锁，甚⾄是消息队列。 </p>\n<hr>\n<p>Redis的VM(虚拟内存)机制就是暂时把不经常访问的数据(冷数据)从内存交换到磁盘中，从而腾出宝贵的内存空间用于其它需要访问的数据(热数据)。通过VM功能可以实现冷热数据分离，使热数据仍在内存中、冷数据保存到磁盘。这样就可以避免因为内存不足而造成访问速度下降的问题。</p>\n<p>Redis提高数据库容量的办法有两种：一种是可以将数据分割到多个RedisServer上；另一种是使用虚拟内存把那些不经常访问的数据交换到磁盘上。<strong>需要特别注意的是Redis并没有使用OS提供的Swap，而是自己实现。</strong></p>\n<hr>\n<h2 id=\"分布式缓存常⻅的技术选型⽅案有哪些？\"><a href=\"#分布式缓存常⻅的技术选型⽅案有哪些？\" class=\"headerlink\" title=\"分布式缓存常⻅的技术选型⽅案有哪些？\"></a>分布式缓存常⻅的技术选型⽅案有哪些？</h2><h2 id=\"说⼀下-Redis-和-Memcached-的区别和共同点\"><a href=\"#说⼀下-Redis-和-Memcached-的区别和共同点\" class=\"headerlink\" title=\"说⼀下 Redis 和 Memcached 的区别和共同点\"></a>说⼀下 Redis 和 Memcached 的区别和共同点</h2><p>共同点 ：基于内存 过期策略 性能</p>\n<p>区别 ：</p>\n<ol>\n<li>数据类型丰富 list set hash zset</li>\n<li>数据的持久化 </li>\n<li>灾难恢复机制。 把缓存中的数据持久化到磁盘上。</li>\n<li>Redis ⽬前是⽀持 cluster 模式</li>\n<li>Memcached 多线程，⾮阻塞 IO 复⽤的⽹络模型； Redis 使⽤单线程的多路 IO 复⽤模型。 </li>\n<li>Memcached过期数据的删除策略只⽤了惰性删除，⽽ Redis 同时使⽤了惰性删除与定期删除。</li>\n</ol>\n<h2 id=\"Redis相比Memcached有哪些优势？\"><a href=\"#Redis相比Memcached有哪些优势？\" class=\"headerlink\" title=\"Redis相比Memcached有哪些优势？\"></a><a href=\"https://www.javalearn.cn/#/doc/Redis/%E9%9D%A2%E8%AF%95%E9%A2%98?id=_3-redis%E7%9B%B8%E6%AF%94memcached%E6%9C%89%E5%93%AA%E4%BA%9B%E4%BC%98%E5%8A%BF%EF%BC%9F\">Redis相比Memcached有哪些优势？</a></h2><ul>\n<li>数据类型：Memcached所有的值均是简单的字符串，Redis支持更为丰富的数据类型，支持string(字符串)，list(列表)，Set(集合)、Sorted Set(有序集合)、Hash(哈希)等。</li>\n<li>持久化：Redis支持数据落地持久化存储，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用。 memcache不支持数据持久存储 。</li>\n<li>集群模式：Redis提供主从同步机制，以及 Cluster集群部署能力，能够提供高可用服务。Memcached没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据</li>\n<li>性能对比：Redis的速度比Memcached快很多。</li>\n<li>网络IO模型：Redis使用单线程的多路 IO 复用模型，Memcached使用多线程的非阻塞IO模式。</li>\n<li>Redis支持服务器端的数据操作：Redis相比Memcached来说，拥有更多的数据结构和并支持更丰富的数据操作，通常在Memcached里，你需要将数据拿到客户端来进行类似的修改再set回去。这大大增加了网络IO的次数和数据体积。在Redis中，这些复杂的操作通常和一般的GET&#x2F;SET一样高效。所以，如果需要缓存能够支持更复杂的结构和操作，那么Redis会是不错的选择。</li>\n</ul>\n<h2 id=\"缓存数据的处理流程是怎样的？\"><a href=\"#缓存数据的处理流程是怎样的？\" class=\"headerlink\" title=\"缓存数据的处理流程是怎样的？\"></a>缓存数据的处理流程是怎样的？</h2><p>用户请求数据在缓存直接范围，不在，查数据库，数据库在，更新缓存，不在，返回空</p>\n<h2 id=\"为什么要⽤-Redis-x2F-为什么要⽤缓存？\"><a href=\"#为什么要⽤-Redis-x2F-为什么要⽤缓存？\" class=\"headerlink\" title=\"为什么要⽤ Redis&#x2F;为什么要⽤缓存？\"></a>为什么要⽤ Redis&#x2F;为什么要⽤缓存？</h2><p><strong>从高并发上来说：</strong></p>\n<ul>\n<li>直接操作缓存能够承受的请求是远远大于直接访问数据库的，所以我们可以考虑把数据库中的部分数据转移到缓存中去，这样用户的一部分请求会直接到缓存这里而不用经过数据库。缓存能够承受的数据库请求数量是远远⼤于直接访问数据库的，也就提⾼的系统整体的并发。</li>\n</ul>\n<p><strong>从高性能上来说：</strong></p>\n<ul>\n<li>用户第一次访问数据库中的某些数据。 因为是从硬盘上读取的所以这个过程会比较慢。将该用户访问的数据存在缓存中，下一次再访问这些数据的时候就可以直接从缓存中获取了。操作缓存就是直接操作内存，所以速度相当快。如果数据库中的对应数据改变的之后，同步改变缓存中相应的数据。</li>\n</ul>\n<p>总结：</p>\n<p>提升⽤户体验以及应对更多的⽤户。——》 ⾼性能”和“⾼并发 </p>\n<p>高性能：从硬盘取太慢 从缓存快</p>\n<p>⾼并发： MySQL QPS （服务器每秒可以执⾏的查询次数 ）⼤概都在 1w 左右（4 核 8g） ，但是使⽤ Redis 缓存之后单机 10w- 30w， redis 集群的话会更⾼。 </p>\n<h2 id=\"为什么用redis而不是map-x2F-guava做缓存\"><a href=\"#为什么用redis而不是map-x2F-guava做缓存\" class=\"headerlink\" title=\"为什么用redis而不是map&#x2F;guava做缓存\"></a>为什么用redis而不是map&#x2F;guava做缓存</h2><p>缓存分为本地缓存和分布式缓存。以java为例，使用自带的map或者guava实现的是<strong>本地缓存</strong>，最主要的特点是轻量以及快速，生命周期随着jvm的销毁而结束，并且在多实例的情况下，每个实例都需要各自保存一份缓存，缓存不具有一致性。</p>\n<p>使用Redis或memcached之类的称为<strong>分布式缓存</strong>，在多实例的情况下，<strong>各实例共用一份缓存数据，缓存具有一致性</strong>。缺点是需要保持Redis或memcached服务的高可用，整个程序架构上较为复杂。</p>\n<ul>\n<li>（缓存容量大）Redis 可以用几十 G 内存来做缓存，Map 不行，一般 JVM 也就分几个 G 数据就够大了；</li>\n<li>（持久化）Redis 的缓存可以持久化，Map 是内存对象，程序一重启数据就没了；</li>\n<li>（分布式缓存）Redis 可以实现分布式的缓存，Map 只能存在创建它的程序里；</li>\n<li>（高并发）Redis 可以处理每秒百万级的并发，是专业的缓存服务，Map 只是一个普通的对象；</li>\n<li>（缓存过期+丰富API）Redis 缓存有过期机制，Map 本身无此功能；Redis 有丰富的 API，Map 就简单太多了；</li>\n<li>（分布式共享数据）Redis可单独部署，多个项目之间可以共享，本地内存无法共享；</li>\n<li>（单独管理工具）Redis有专门的管理工具可以查看缓存数据。</li>\n</ul>\n<h2 id=\"Redis-常⻅数据结构以及使⽤场景分析\"><a href=\"#Redis-常⻅数据结构以及使⽤场景分析\" class=\"headerlink\" title=\"Redis 常⻅数据结构以及使⽤场景分析\"></a>Redis 常⻅数据结构以及使⽤场景分析</h2><p><strong>1、缓存</strong></p>\n<p>缓存现在几乎是所有中大型网站都在用的必杀技，合理的利用缓存不仅能够提升网站访问速度，还能大大降低数据库的压力。Redis提供了键过期功能，也提供了灵活的键淘汰策略，所以，现在Redis用在缓存的场合非常多。</p>\n<p><strong>2、排行榜</strong></p>\n<p>很多网站都有排行榜应用的，如京东的月度销量榜单、商品按时间的上新排行榜等。Redis提供的有序集合数据类构能实现各种复杂的排行榜应用。</p>\n<p><strong>3、计数器</strong></p>\n<p>什么是计数器，如电商网站商品的浏览量、视频网站视频的播放数等。为了保证数据实时效，每次浏览都得给+1，并发量高时如果每次都请求数据库操作无疑是种挑战和压力。Redis提供的incr命令来实现计数器功能，内存操作，性能非常好，非常适用于这些计数场景。</p>\n<p><strong>4、分布式会话</strong></p>\n<p>集群模式下，在应用不多的情况下一般使用容器自带的session复制功能就能满足，当应用增多相对复杂的系统中，一般都会搭建以Redis等内存数据库为中心的session服务，session不再由容器管理，而是由session服务及内存数据库管理。</p>\n<p><strong>5、分布式锁</strong></p>\n<p>在很多互联网公司中都使用了分布式技术，分布式技术带来的技术挑战是对同一个资源的并发访问，如全局ID、减库存、秒杀等场景，并发量不大的场景可以使用数据库的悲观锁、乐观锁来实现，但在并发量高的场合中，利用数据库锁来控制资源的并发访问是不太理想的，大大影响了数据库的性能。可以利用Redis的setnx功能来编写分布式的锁，如果设置返回1说明获取锁成功，否则获取锁失败，实际应用中要考虑的细节要更多。</p>\n<p><strong>6、 社交网络</strong></p>\n<p>点赞、踩、关注&#x2F;被关注、共同好友等是社交网站的基本功能，社交网站的访问量通常来说比较大，而且传统的关系数据库类型不适合存储这种类型的数据，Redis提供的哈希、集合等数据结构能很方便的的实现这些功能。如在微博中的共同好友，通过Redis的set能够很方便得出。</p>\n<p><strong>7、最新列表</strong></p>\n<p>Redis列表结构，LPUSH可以在列表头部插入一个内容ID作为关键字，LTRIM可用来限制列表的数量，这样列表永远为N个ID，无需查询最新的列表，直接根据ID去到对应的内容页即可。</p>\n<p><strong>8、消息系统</strong></p>\n<p>消息队列是大型网站必用中间件，如ActiveMQ、RabbitMQ、Kafka等流行的消息队列中间件，主要用于业务解耦、流量削峰及异步处理实时性低的业务。Redis提供了发布&#x2F;订阅及阻塞队列功能，能实现一个简单的消息队列系统。另外，这个不能和专业的消息中间件相比。</p>\n<p>string:计数器 过期</p>\n<p>List:消息队列</p>\n<p>incr命令：计数器</p>\n<p>hash:存储对象数据 ⽤户信息，商品信息 </p>\n<p>set ：获取多个数据源交集和并集 ，共同关注、共同粉丝、共同喜好 </p>\n<p>sorted set （zset） ：礼物排⾏榜，弹幕消息 </p>\n<h2 id=\"Redis的数据类型有哪些？\"><a href=\"#Redis的数据类型有哪些？\" class=\"headerlink\" title=\"Redis的数据类型有哪些？\"></a>Redis的数据类型有哪些？</h2><p>有五种常用数据类型：String、Hash、Set、List、SortedSet。以及三种特殊的数据类型：Bitmap、HyperLogLog、Geospatial ，其中HyperLogLog、Bitmap的底层都是 String 数据类型，Geospatial 的底层是 Sorted Set 数据类型。</p>\n<p><strong>五种常用的数据类型</strong>：</p>\n<p>1、String：String是最常用的一种数据类型，普通的<strong>key- value</strong> 存储都可以归为此类。<strong>其中Value既可以是数字也可以是字符串</strong>。使用场景：常规key-value缓存应用。常规计数: 微<strong>博数， 粉丝数。</strong></p>\n<p>2、Hash：Hash 是一个键值(key &#x3D;&gt; value)对集合。Redishash 是一个 string 类型的 field 和 value 的映射表，hash 特别适合用于<strong>存储对象</strong>，并且可以像数据库中update一个属性一样只修改某一项属性值。</p>\n<p>3、Set：Set是一个无序的天然去重的集合，即Key-Set。此外还提供了<strong>交集、并集</strong>等一系列直接操作集合的方法，对于<strong>求共同好友、共同关注</strong>什么的功能实现特别方便。</p>\n<p>4、List：List是一个有序可重复的集合，其遵循<strong>FIFO</strong>的原则，底层是依赖双向链表实现的，因此支持正向、反向双重查找。通过List，我们可以很方面的获得类似于<strong>最新回复</strong>这类的功能实现。</p>\n<p>5、SortedSet：类似于java中的TreeSet，是Set的可排序版。此外还支持优先级排序，维护了一个score的参数来实现。适用于<strong>排行榜和带权重的消息队列</strong>等场景。</p>\n<p><strong>三种特殊的数据类型</strong>：</p>\n<p>1、Bitmap：位图，Bitmap想象成一个以位为单位数组，数组中的每个单元只能存0或者1，数组的下标在Bitmap中叫做偏移量。使用Bitmap实现统计功能，更省空间。<strong>如果只需要统计数据的二值状态，例如商品有没有、用户在不在等</strong>，就可以使用 Bitmap，因为它只用一个 bit 位就能表示 0 或 1。</p>\n<p>2、Hyperloglog。HyperLogLog 是一种<strong>用于统计基数的数据集合类型</strong>，HyperLogLog 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定 的、并且是很小的。每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基 数。场景：<strong>统计网页的UV（即Unique Visitor，不重复访客，一个人访问某个网站多次，但是还是只计算为一次）。</strong></p>\n<p>要注意，HyperLogLog 的统计规则是基于<strong>概率</strong>完成的，所以它给出的统计结果是有一定误差的，标准误算率是 0.81%。</p>\n<p>3、Geospatial ：主要用于存储地理位置信息，并对存储的信息进行操作，适用场景如<strong>朋友的定位、附近的人、打车距离计算等。</strong></p>\n<h2 id=\"持久化\"><a href=\"#持久化\" class=\"headerlink\" title=\"持久化\"></a>持久化</h2><h3 id=\"Redis-持久化机制-怎么保证-Redis-挂掉之后再重启数据可以进⾏恢复\"><a href=\"#Redis-持久化机制-怎么保证-Redis-挂掉之后再重启数据可以进⾏恢复\" class=\"headerlink\" title=\"Redis 持久化机制(怎么保证 Redis 挂掉之后再重启数据可以进⾏恢复)\"></a>Redis 持久化机制(怎么保证 Redis 挂掉之后再重启数据可以进⾏恢复)</h3><p>为了能够重用Redis数据，或者防止系统故障，我们需要将Redis中的数据写入到磁盘空间中，即持久化。</p>\n<h4 id=\"快照（snapshotting）持久化（RDB）-（默认）\"><a href=\"#快照（snapshotting）持久化（RDB）-（默认）\" class=\"headerlink\" title=\"快照（snapshotting）持久化（RDB） （默认）\"></a><strong>快照（snapshotting）持久化（RDB</strong>） <strong>（默认）</strong></h4><p>在<strong>指定的时间间隔内</strong>将内存中的数据集快照写入磁盘(Snapshot)，它恢复时是将快照文件直接读到内存里。</p>\n<p><strong>优势</strong>：适合大规模的数据恢复；对数据完整性和一致性要求不高</p>\n<p><strong>劣势</strong>：在一定间隔时间做一次备份，所以如果Redis意外down掉的话，就会<strong>丢失最后一次快照后的所有修改</strong>。（Redis 主从结构，主要⽤来提⾼ Redis 性能），还可以将快照留在原地以便重启服务器的时候使⽤ </p>\n<h4 id=\"AOF（append-only-file）持久化\"><a href=\"#AOF（append-only-file）持久化\" class=\"headerlink\" title=\"AOF（append-only file）持久化\"></a><strong>AOF（append-only file）持久化</strong></h4><p>每执⾏⼀条会更改 Redis 中的数据的命令， Redis 就会将该命令写⼊硬盘中的 AOF ⽂件。 Redis启动之初会读取该文件重新构建数据</p>\n<p>AOF采用文件追加方式，文件会越来越大，为避免出现此种情况，新增了重写机制，当AOF文件的大小超过所设定的阈值时， Redis就会启动AOF文件的内容压缩，只保留可以恢复数据的最小指令集(比如两条数据取最新的那条就行了).。</p>\n<p><strong>优势</strong></p>\n<ul>\n<li>每修改同步：appendfsync always 同步持久化，每次发生数据变更会被立即记录到磁盘，性能较差但数据完整性比较好</li>\n<li>每秒同步：appendfsync everysec异步操作，每秒记录，如果一秒内宕机，有数据丢失</li>\n<li>不同步：appendfsync no 从不同步</li>\n</ul>\n<p><strong>具体地:</strong></p>\n<ul>\n<li><strong>Always</strong>，这个单词的意思是「总是」，所以它的意思是每次写操作命令执行完后，同步将 AOF 日志数据写回硬盘；</li>\n<li><strong>Everysec</strong>，这个单词的意思是「每秒」，所以它的意思是每次写操作命令执行完后，先将命令写入到 AOF 文件的内核缓冲区，然后每隔一秒将缓冲区里的内容写回到硬盘；</li>\n<li><strong>No</strong>，意味着不由 Redis 控制写回硬盘的时机，转交给操作系统控制写回的时机，也就是每次写操作命令执行完后，先将命令写入到 AOF 文件的内核缓冲区，再由操作系统决定何时将缓冲区内容写回硬盘。</li>\n</ul>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/98987d9417b2bab43087f45fc959d32a-20230309232253633.png\" alt=\"img\"></p>\n<p><strong>劣势</strong></p>\n<ul>\n<li>相同数据集的数据而言aof文件要远大于rdb文件，恢复速度慢于rdb</li>\n<li>aof运行效率要慢于rdb，每秒同步策略效率较好，不同步效率和rdb相同</li>\n</ul>\n<h3 id=\"如何选择合适的持久化方式\"><a href=\"#如何选择合适的持久化方式\" class=\"headerlink\" title=\"如何选择合适的持久化方式\"></a><a href=\"https://www.javalearn.cn/#/doc/Redis/%E9%9D%A2%E8%AF%95%E9%A2%98?id=_9-%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%E5%90%88%E9%80%82%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96%E6%96%B9%E5%BC%8F\">如何选择合适的持久化方式</a></h3><ul>\n<li>如果是数据不那么敏感，且可以从其他地方重新生成补回的，那么可以关闭持久化。</li>\n<li>如果是数据比较重要，不想再从其他地方获取，且可以承受数分钟的数据丢失，比如缓存等，那么可以只使用RDB。</li>\n<li>如果是用做内存数据库，要使用Redis的持久化，建议是RDB和AOF都开启，或者定期执行bgsave做快照备份，RDB方式更适合做数据的备份，AOF可以保证数据的不丢失。</li>\n</ul>\n<h2 id=\"Redis持久化数据和缓存怎么做扩容？\"><a href=\"#Redis持久化数据和缓存怎么做扩容？\" class=\"headerlink\" title=\"Redis持久化数据和缓存怎么做扩容？\"></a>Redis持久化数据和缓存怎么做扩容？</h2><ul>\n<li>如果Redis被当做缓存使用，使用一致性哈希实现动态扩容缩容。</li>\n</ul>\n<p><a href=\"https://juejin.cn/post/6844903750860013576\">https://juejin.cn/post/6844903750860013576</a></p>\n<p>一致性hash算法可以保证当机器增加或者减少时，节点之间的数据迁移只限于两个节点之间，不会造成全局的网络问题。</p>\n<ol>\n<li>传统hash算法增减服务器会导致大量key重定向到其他服务器</li>\n<li>一致性hash算法有一个0-2^31的圆环(哈希值是32位无符号整形）值为Key的数据隶属于顺时针方向第一个服务器</li>\n</ol>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/1545973609449.png\" alt=\"img\"></p>\n<ol>\n<li>当宕机和扩展服务器只会影响一部分数据</li>\n</ol>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/1545977832954.png\" alt=\"img\"></p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/1545978062568.png\" alt=\"img\"></p>\n<ol>\n<li>如果节点太少,会导致数据倾斜,也就是hash范围差距大 那么可以引入了<strong>虚拟节点机制</strong>，即对每个节点计算多个哈希值，每个计算结果位置都放置在对应节点中，这些节点<strong>称为虚拟节点</strong>。</li>\n</ol>\n<ul>\n<li>如果Redis被当做一个持久化存储使用，必须使用固定的keys-to-nodes映射关系，节点的数量一旦确定不能变化。否则的话(即Redis节点需要动态变化的情况），必须使用可以在运行时进行数据再平衡的一套系统，而当前只有Redis集群可以做到这样。</li>\n</ul>\n<h2 id=\"过期键的删除策略、淘汰策略\"><a href=\"#过期键的删除策略、淘汰策略\" class=\"headerlink\" title=\"过期键的删除策略、淘汰策略\"></a>过期键的删除策略、淘汰策略</h2><ol>\n<li>惰性删除 ：只会在取出key的时候才对数据进⾏过期检查。这样对CPU最友好，但是可能会造成太多过期 key 没有被删除。</li>\n<li>定期删除 ： 每隔⼀段时间抽取⼀批 key 执⾏删除过期key操作。并且， Redis 底层会通过限制删除操作执⾏的时⻓和频率来减少删除操作对CPU时间的影响。</li>\n</ol>\n<p>删除key常见的三种处理方式:</p>\n<p><strong>1、定时删除</strong></p>\n<p>在设置某个key 的过期时间同时，我们创建一个定时器，让定时器在该过期时间到来时，立即执行对其进行删除的操作。</p>\n<p>优点：定时删除对内存是最友好的，能够保存内存的key一旦过期就能立即从内存中删除。</p>\n<p>缺点：对CPU最不友好，在过期键比较多的时候，删除过期键会占用一部分 CPU 时间，对服务器的响应时间和吞吐量造成影响。</p>\n<p><strong>2、惰性删除</strong></p>\n<p>设置该key 过期时间后，我们不去管它，当需要该key时，我们在检查其是否过期，如果过期，我们就删掉它，反之返回该key。(代码层面)</p>\n<p>优点：对 CPU友好，我们只会在使用该键时才会进行过期检查，对于很多用不到的key不用浪费时间进行过期检查。</p>\n<p>缺点：对内存不友好，如果一个键已经过期，但是一直没有使用，那么该键就会一直存在内存中，如果数据库中有很多这种使用不到的过期键，这些键便永远不会被删除，内存永远不会释放。从而造成内存泄漏。(不用但存在)</p>\n<p><strong>3、定期删除</strong></p>\n<p>每隔一段时间，我们就对一些key进行检查，删除里面过期的key。</p>\n<p>优点：可以通过限制删除操作执行的时长和频率来减少删除操作对 CPU 的影响。另外定期删除，也能有效释放过期键占用的内存。</p>\n<p>缺点：难以确定删除操作执行的时长和频率。如果执行的太频繁，定期删除策略变得和定时删除策略一样，对CPU不友好。如果执行的太少，那又和惰性删除一样了，过期键占用的内存不会及时得到释放。</p>\n<p>另外最重要的是，在获取某个键时，如果某个键的过期时间已经到了，但是还没执行定期删除，那么就会返回这个键的值，这是业务不能忍受的错误。</p>\n<h2 id=\"Redis-key的过期时间和永久有效分别怎么设置？\"><a href=\"#Redis-key的过期时间和永久有效分别怎么设置？\" class=\"headerlink\" title=\"Redis key的过期时间和永久有效分别怎么设置？\"></a><a href=\"https://www.javalearn.cn/#/doc/Redis/%E9%9D%A2%E8%AF%95%E9%A2%98?id=_12-redis-key%E7%9A%84%E8%BF%87%E6%9C%9F%E6%97%B6%E9%97%B4%E5%92%8C%E6%B0%B8%E4%B9%85%E6%9C%89%E6%95%88%E5%88%86%E5%88%AB%E6%80%8E%E4%B9%88%E8%AE%BE%E7%BD%AE%EF%BC%9F\">Redis key的过期时间和永久有效分别怎么设置？</a></h2><p>通过expire或pexpire命令，客户端可以以秒或毫秒的精度为数据库中的某个键设置生存时间。</p>\n<p>与expire和pexpire命令类似，客户端可以通过expireat和pexpireat命令，以秒或毫秒精度给数据库中的某个键设置过期时间，可以理解为：让某个键在某个时间点过期。</p>\n<h3 id=\"Redis-给缓存数据设置过期时间有啥⽤？\"><a href=\"#Redis-给缓存数据设置过期时间有啥⽤？\" class=\"headerlink\" title=\"Redis 给缓存数据设置过期时间有啥⽤？\"></a>Redis 给缓存数据设置过期时间有啥⽤？</h3><p>命令：字符串：setex 其他 expire </p>\n<p>有助于缓解内存的消耗 </p>\n<p>业务场景就是需要某个数据只在某⼀时间段内存在 ⽐如我们的短信验证码可能只在1分钟内有效，⽤户登录的 token 可能只在 1 天内有效。 </p>\n<p>如果使⽤传统的数据库来处理的话，⼀般都是⾃⼰判断过期，这样更麻烦并且性能要差很多。 </p>\n<h3 id=\"Redis是如何判断数据是否过期的呢？\"><a href=\"#Redis是如何判断数据是否过期的呢？\" class=\"headerlink\" title=\"Redis是如何判断数据是否过期的呢？\"></a>Redis是如何判断数据是否过期的呢？</h3><p>过期字典 (hash表）键指向Redis数据库中的某个key(键)，值是⼀个long long类型的整数(数据库键的过期时间)</p>\n<h3 id=\"Redis-内存淘汰机制了解么？\"><a href=\"#Redis-内存淘汰机制了解么？\" class=\"headerlink\" title=\"Redis 内存淘汰机制了解么？\"></a>Redis 内存淘汰机制了解么？</h3><p>仅仅通过给 key 设置过期时间不太够，还是有很多key没删掉，报oom，因此要用内存淘汰机制</p>\n<ol>\n<li>volatile-lru（least recently used） ：从已设置过期时间的数据 中移除最近最少使⽤数据</li>\n<li>allkeys-lru（least recently used） ：在键空间中，移除最近最少使⽤的 key（最常⽤）</li>\n<li>volatile-lfu 从已设置过期时间的数据 中移除最不经常使⽤数据</li>\n<li>allkeys-lfu（least recently used） ：在键空间中，移除最近最不经常用的 key（最常⽤）</li>\n<li>volatile-random：从已设置过期时间的数据任意选择数据淘汰</li>\n<li>allkeys-random：从数据集中任意选择数据淘汰</li>\n<li>volatile-ttl：从已设置过期时间的数据挑选要过期的数据淘汰</li>\n<li>no-eviction：禁止驱逐数据，也就是说当内存不足以容纳新写入数据时，新写入操作会报错。这个应该没人使用吧！</li>\n</ol>\n<p>内存淘汰策略可以通过配置文件来修改，Redis.conf对应的配置项是maxmemory-policy 修改对应的值就行，默认是noeviction。</p>\n<h2 id=\"事务\"><a href=\"#事务\" class=\"headerlink\" title=\"事务\"></a>事务</h2><p>Redis事务提供了⼀种将多个命令请求打包的功能。然后，再按顺序执⾏打包的所有命令，并且不会被中途打断。 </p>\n<p>Redis 是不⽀持 roll back 的，因⽽不满⾜原⼦性的（⽽且不满⾜持久性）。 </p>\n<p><strong>为啥不支持回滚？</strong></p>\n<p>更简单便捷并且性能更好。 即使命令执⾏错误也应该在开发过程中就被发现⽽不是⽣产过程中。 </p>\n<h2 id=\"缓存异常\"><a href=\"#缓存异常\" class=\"headerlink\" title=\"缓存异常\"></a>缓存异常</h2><p>缓存异常有四种类型，分别是缓存和数据库的数据不一致、缓存雪崩、缓存击穿和缓存穿透。</p>\n<hr>\n<h3 id=\"如何保证缓存与数据库双写时的数据一致性？\"><a href=\"#如何保证缓存与数据库双写时的数据一致性？\" class=\"headerlink\" title=\"如何保证缓存与数据库双写时的数据一致性？\"></a>如何保证缓存与数据库双写时的数据一致性？</h3><p>背景：使用到缓存，无论是本地内存做缓存还是使用 Redis 做缓存，那么就会存在数据同步的问题，因为配置信息缓存在内存中，而内存时无法感知到数据在数据库的修改。这样就会造成数据库中的数据与缓存中数据不一致的问题。</p>\n<p>共有四种方案：</p>\n<ol>\n<li>先更新数据库，后更新缓存</li>\n<li>先更新缓存，后更新数据库</li>\n<li>先删除缓存，后更新数据库</li>\n<li>先更新数据库，后删除缓存</li>\n</ol>\n<p>第一种和第二种方案，没有人使用的，因为第一种方案存在问题是：并发更新数据库场景下，会将脏数据刷到缓存。</p>\n<p>第二种方案存在的问题是：如果先更新缓存成功，但是数据库更新失败，则肯定会造成数据不一致。</p>\n<p>目前主要用第三和第四种方案。</p>\n<h3 id=\"先删除缓存，后更新数据库\"><a href=\"#先删除缓存，后更新数据库\" class=\"headerlink\" title=\"先删除缓存，后更新数据库\"></a>先删除缓存，后更新数据库</h3><p>该方案也会出问题，此时来了两个请求，请求 A（更新操作） 和请求 B（查询操作）</p>\n<ol>\n<li>请求A进行写操作，删除缓存</li>\n<li>请求B查询发现缓存不存在</li>\n<li>请求B去数据库查询得到旧值(此时)</li>\n<li>请求B将旧值写入缓存</li>\n<li>请求A将新值写入数据库</li>\n</ol>\n<p>上述情况就会导致不一致的情形出现。而且，如果不采用给缓存设置过期时间策略，该数据永远都是脏数据。</p>\n<h5 id=\"答案一：延时双删\"><a href=\"#答案一：延时双删\" class=\"headerlink\" title=\"答案一：延时双删\"></a>答案一：延时双删</h5><p>（1）先淘汰缓存 </p>\n<p>（2）再写数据库（这两步和原来一样） </p>\n<p>（3）休眠1秒，再次淘汰缓存，这么做，可以将1秒内所造成的缓存脏数据，再次删除。<strong>确保读请求结束，写请求可以删除读请求造成的缓存脏数据</strong>。自行评估自己的项目的读数据业务逻辑的耗时，<strong>写数据的休眠时间则在读数据业务逻辑的耗时基础上，加几百ms即可。</strong></p>\n<p>（我的理解：请求A先删缓存再往DB写数据，就算这时B来查数据库，缓存没数据，然后查DB，此时查到的是旧数据，写到缓存，A等待B写完之和再删缓存，这样就缓存一致）</p>\n<p>如果使用的是 Mysql 的<strong>读写分离的架构的话</strong>，那么其实主从同步之间也会有时间差。</p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/1735bb5881bbb1d4~tplv-t2oaga2asx-watermark.awebp\" alt=\"img\"></p>\n<p>此时来了两个请求，请求 A（更新操作） 和请求 B（查询操作）</p>\n<ol>\n<li>请求 A 更新操作，删除了 Redis</li>\n<li>请求主库进行更新操作，主库与从库进行同步数据的操作</li>\n<li>请 B 查询操作，发现 Redis 中没有数据</li>\n<li>去从库中拿去数据</li>\n<li>此时同步数据(binlog没写完)还未完成，拿到的数据是旧数据</li>\n</ol>\n<p>此时的解决办法就是如果是对 Redis 进行填充数据的查询数据库操作，那么就强制将其指向主库进行查询。</p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/1735bb5881a19fec~tplv-t2oaga2asx-watermark.awebp\" alt=\"img\"></p>\n<h5 id=\"答案二：-更新与读取操作进行异步串行化\"><a href=\"#答案二：-更新与读取操作进行异步串行化\" class=\"headerlink\" title=\"答案二： 更新与读取操作进行异步串行化\"></a>答案二： 更新与读取操作进行异步串行化</h5><p>采用<strong>更新与读取操作进行异步串行化</strong></p>\n<p><strong>异步串行化</strong></p>\n<p>我在系统内部维护n个内存队列，更新数据的时候，根据数据的唯一标识，将该操作路由之后，发送到其中一个jvm内部的内存队列中（对同一数据的请求发送到同一个队列）。读取数据的时候，如果发现数据不在缓存中，并且此时队列里有更新库存的操作，那么将重新读取数据+更新缓存的操作，根据唯一标识路由之后，也将发送到同一个jvm内部的内存队列中。然后每个队列对应一个工作线程，每个工作线程串行地拿到对应的操作，然后一条一条的执行。</p>\n<p>这样的话，<strong>一个数据变更的操作，先执行删除缓存，然后再去更新数据库，但是还没完成更新的时候，如果此时一个读请求过来，读到了空的缓存，那么可以先将缓存更新的请求发送到队列中，此时会在队列中积压，排在刚才更新库的操作之后，然后同步等待缓存更新完成，再读库。</strong></p>\n<p><strong>读操作去重</strong></p>\n<p>多个读库更新缓存的请求串在同一个队列中是没意义的，因此可以做过滤，如果发现队列中已经有了该数据的更新缓存的请求了，那么就不用再放进去了，直接等待前面的更新操作请求完成即可，待那个队列对应的工作线程完成了上一个操作（数据库的修改）之后，才会去执行下一个操作（读库更新缓存），此时会从数据库中读取最新的值，然后写入缓存中。</p>\n<p>如果请求还在等待时间范围内，不断轮询发现可以取到值了，那么就直接返回；如果请求等待的时间超过一定时长，那么这一次直接从数据库中读取当前的旧值。（返回旧值不是又导致缓存和数据库不一致了么？那至少可以减少这个情况发生，因为等待超时也不是每次都是，几率很小吧。这里我想的是，如果超时了就直接读旧值，这时候仅仅是读库后返回而不放缓存）</p>\n<h3 id=\"先更新数据库，后删除缓存\"><a href=\"#先更新数据库，后删除缓存\" class=\"headerlink\" title=\"先更新数据库，后删除缓存\"></a>先更新数据库，后删除缓存</h3><p>这一种情况也会出现问题，比如更新数据库成功了，但是在删除缓存的阶段出错了没有删除成功，那么此时再读取缓存的时候每次都是错误的数据了。</p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/1735bb5881fb4a1b~tplv-t2oaga2asx-watermark.awebp\" alt=\"img\"></p>\n<p>此时解决方案就是利用消息队列进行<strong>删除的补偿</strong>。具体的业务逻辑用语言描述如下：</p>\n<ol>\n<li>请求 A 先对数据库进行更新操作</li>\n<li>在对 Redis 进行删除操作的时候发现报错，删除失败</li>\n<li>此时将Redis 的 key 作为消息体发送到消息队列中</li>\n<li>系统接收到消息队列发送的消息后再次对 Redis 进行删除操作</li>\n</ol>\n<p>但是这个方案会有一个缺点就是会对业务代码造成大量的侵入，深深的耦合在一起，所以这时会有一个优化的方案，我们知道对 Mysql 数据库更新操作后在binlog 日志中我们都能够找到相应的操作，那么我们可以订阅 Mysql 数据库的 binlog 日志对缓存进行操作。</p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/1735bb588215b298~tplv-t2oaga2asx-watermark.awebp\" alt=\"img\"></p>\n<h3 id=\"什么是缓存击穿\"><a href=\"#什么是缓存击穿\" class=\"headerlink\" title=\"什么是缓存击穿?\"></a>什么是缓存击穿?</h3><p>(热点key失效)</p>\n<p>缓存击穿跟缓存雪崩有点类似，缓存雪崩是大规模的key失效，而缓存击穿是某个热点的key失效(及你太美)，大并发集中对其进行请求，就会造成大量请求读缓存没读到数据，从而导致高并发访问数据库，引起数据库压力剧增。这种现象就叫做缓存击穿。</p>\n<p>从两个方面解决，第一是否可以考虑热点key不设置过期时间，第二是否可以考虑降低打在数据库上的请求数量。</p>\n<p>解决方案：</p>\n<ul>\n<li><p>在缓存失效后，通过互斥锁或者队列来控制读数据写缓存的线程数量&#x3D;&#x3D;，比如某个key只允许一个线程查询数据和写缓存，其他线程等待。这种方式会阻塞其他的线程，此时系统的吞吐量会下降</p>\n</li>\n<li><p>热点数据缓存永远不过期。永不过期实际包含两层意思：</p>\n</li>\n<li><ul>\n<li>物理不过期，针对热点key不设置过期时间</li>\n<li>逻辑过期，把过期时间存在key对应的value里，如果发现要过期了，通过一个后台的异步线程进行缓存的构建</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"什么是缓存穿透\"><a href=\"#什么是缓存穿透\" class=\"headerlink\" title=\"什么是缓存穿透?\"></a>什么是缓存穿透?</h3><p>(缓存数据库都无)</p>\n<p>缓存穿透是指用户请求的数据在缓存中不存在即没有命中，同时在数据库中也不存在，导致用户每次请求该数据都要去数据库中查询一遍。如果有恶意攻击者不断请求系统中不存在的数据，会导致短时间大量请求落在数据库上，造成数据库压力过大，甚至导致数据库承受不住而宕机崩溃。</p>\n<p>缓存穿透的关键在于在Redis中查不到key值，它和缓存击穿的根本区别在于传进来的key在Redis中是不存在的。假如有黑客传进大量的不存在的key，那么大量的请求打在数据库上是很致命的问题，所以在日常开发中要对参数做好校验，一些非法的参数，不可能存在的key就直接返回错误提示。</p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/2021013117512340.png\" alt=\"img\"></p>\n<p>解决方法：</p>\n<ul>\n<li>将无效的key存放进Redis中：</li>\n</ul>\n<p>当出现Redis查不到数据，数据库也查不到数据的情况，我们就把这个key保存到Redis中，设置value&#x3D;”null”，并设置其过期时间极短，后面再出现查询这个key的请求的时候，直接返回null，就不需要再查询数据库了。但这种处理方式是有问题的，假如传进来的这个不存在的Key值每次都是随机的，那存进Redis也没有意义。</p>\n<ul>\n<li>使用布隆过滤器：</li>\n</ul>\n<p>(准确度换空间?)</p>\n<p>如果布隆过滤器判定某个 key 不存在布隆过滤器中，那么就一定不存在，如果判定某个 key 存在，那么很大可能是存在(存在一定的误判率)。于是我们可以在缓存之前再加一个布隆过滤器，将数据库中的所有key都存储在布隆过滤器中，在查询Redis前先去布隆过滤器查询 key 是否存在，如果不存在就直接返回请求参数错误信息给客户端，不让其访问数据库，从而避免了对底层存储系统的查询压力。</p>\n<p>如何选择：针对一些恶意攻击，攻击带过来的大量key是随机，那么我们采用第一种方案就会缓存大量不存在key的数据。那么这种方案就不合适了，我们可以先对使用布隆过滤器方案进行过滤掉这些key。所以，针对这种key异常多、请求重复率比较低的数据，优先使用第二种方案直接过滤掉。而对于空数据的key有限的，重复率比较高的，则可优先采用第一种方式进行缓存。</p>\n<h3 id=\"缓存雪崩\"><a href=\"#缓存雪崩\" class=\"headerlink\" title=\"缓存雪崩\"></a><strong>缓存雪崩</strong></h3><p>(大规模的key失效)</p>\n<p>如果缓在某一个时刻出现<strong>大规模的key失效，</strong>那么就会导致大量的请求打在了数据库上面，导致数据库压力巨大，如果在高并发的情况下，可能瞬间就会导致数据库宕机。这时候<strong>如果运维马上又重启数据库，马上又会有新的流量把数据库打死</strong>。这就是缓存雪崩。</p>\n<p>造成缓存雪崩的关键在于同一时间的大规模的key失效，主要有两种可能：</p>\n<ul>\n<li>第一种是Redis宕机</li>\n<li>第二种可能就是采用了相同的过期时间。</li>\n</ul>\n<p>例子：秒杀开始 12 个⼩时之前，我们统⼀存放了⼀批商品到 Redis 中，设置的缓存过期时间也是 12 个⼩时，那么秒杀开始的时候，这些秒杀的商品的访问直接就失效了。导致的情况就是，相应的请求直接就落到了数据库上，就像雪崩⼀样可怕。 </p>\n<h3 id=\"有哪些解决办法？\"><a href=\"#有哪些解决办法？\" class=\"headerlink\" title=\"有哪些解决办法？\"></a>有哪些解决办法？</h3><p>解决方案：</p>\n<p>1、事前：</p>\n<ul>\n<li><p>均匀过期：设置不同的过期时间，让缓存失效的时间尽量均匀，避免相同的过期时间导致缓存雪崩，造成大量数据库的访问。如把每个Key的失效时间都加个随机值，setRedis（Key，value，time + Math.random() * 10000）；，保证数据不会在同一时间大面积失效。</p>\n</li>\n<li><p>分级缓存：第一级缓存失效的基础上，访问二级缓存，每一级缓存的失效时间都不同。</p>\n</li>\n<li><p>热点数据缓存永远不过期。永不过期实际包含两层意思：</p>\n</li>\n<li><ul>\n<li>物理不过期，针对热点key不设置过期时间</li>\n<li>逻辑过期，把过期时间存在key对应的value里，如果发现要过期了，通过一个后台的异步线程进行缓存的构建(定时任务)</li>\n</ul>\n</li>\n<li><p>保证Redis缓存的高可用，防止Redis宕机导致缓存雪崩的问题。可以使用 主从+ 哨兵，Redis集群来避免 Redis 全盘崩溃的情况。</p>\n</li>\n</ul>\n<p>2、事中：</p>\n<ul>\n<li>互斥锁：在缓存失效后，通过互斥锁或者队列来控制读数据写缓存的线程数量，比如某个key只允许一个线程查询数据和写缓存，其他线程等待。这种方式会阻塞其他的线程，此时系统的吞吐量会下降</li>\n<li>使用熔断机制，限流降级。当流量达到一定的阈值，直接返回“系统拥挤”之类的提示，<strong>防止过多的请求打在数据库上将数据库击垮，至少能保证一部分用户是可以正常使用，其他用户多刷新几次也能得到结果。</strong></li>\n</ul>\n<p>3、事后：</p>\n<p>开启Redis持久化机制，尽快恢复缓存数据，一旦重启，就能从磁盘上自动加载数据恢复内存中的数据。 </p>\n<h3 id=\"什么是缓存预热\"><a href=\"#什么是缓存预热\" class=\"headerlink\" title=\"什么是缓存预热?\"></a>什么是缓存预热?</h3><p>缓存预热是指系统上线后，提前将相关的缓存数据加载到缓存系统。避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题，用户直接查询事先被预热的缓存数据。</p>\n<p>如果不进行预热，那么Redis初始状态数据为空，系统上线初期，对于高并发的流量，都会访问到数据库中， 对数据库造成流量的压力。</p>\n<p>缓存预热解决方案：</p>\n<ul>\n<li>数据量不大的时候，工程启动的时候进行加载缓存动作；</li>\n<li>数据量大的时候，设置一个定时任务脚本，进行缓存的刷新；(防止启动太慢)</li>\n<li>数据量太大的时候，优先保证热点数据进行提前加载到缓存。</li>\n</ul>\n<h3 id=\"什么是缓存降级？\"><a href=\"#什么是缓存降级？\" class=\"headerlink\" title=\"什么是缓存降级？\"></a>什么是缓存降级？</h3><p>缓存降级是指缓存失效或缓存服务器挂掉的情况下，不去访问数据库，直接返回默认数据或访问服务的内存数据。降级一般是有损的操作，所以尽量减少降级对于业务的影响程度。</p>\n<p>在进行降级之前要对系统进行梳理，看看系统是不是可以丢卒保帅；从而梳理出哪些必须誓死保护，哪些可降级；比如可以参考日志级别设置预案：</p>\n<ul>\n<li>一般：比如有些服务偶尔因为网络抖动或者服务正在上线而超时，可以自动降级；</li>\n<li>警告：有些服务在一段时间内成功率有波动（如在95~100%之间），可以自动降级或人工降级，并发送告警；</li>\n<li>错误：比如可用率低于90%，或者数据库连接池被打爆了，或者访问量突然猛增到系统能承受的最大阀值，此时可以根据情况自动降级或者人工降级；</li>\n<li>严重错误：比如因为特殊原因数据错误了，此时需要紧急人工降级。</li>\n</ul>\n<h2 id=\"如何保证缓存和数据库数据的⼀致性？\"><a href=\"#如何保证缓存和数据库数据的⼀致性？\" class=\"headerlink\" title=\"如何保证缓存和数据库数据的⼀致性？\"></a>如何保证缓存和数据库数据的⼀致性？</h2><p>缓存失效时间变短（不推荐，治标不治本）：我们让缓存数据的过期时间变短，这样的话缓存就会从数据库中加载数据。另外，这种解决办法对于先操作缓存后操作数据库的场景不适⽤ </p>\n<p>增加cache更新重试机制（常⽤） ： 如果 cache 服务当前不可⽤导致缓存删除失败的话，我们就隔⼀段时间进⾏重试，重试次数可以⾃⼰定。如果多次重试还是失败的话，我们可以把当前更新失败的 key 存⼊队列中，等缓存服务可⽤之后，再将 缓存中对应的 key 删除即可 </p>\n<h2 id=\"线程模型\"><a href=\"#线程模型\" class=\"headerlink\" title=\"线程模型\"></a>线程模型</h2><h3 id=\"Redis为何选择单线程？\"><a href=\"#Redis为何选择单线程？\" class=\"headerlink\" title=\"Redis为何选择单线程？\"></a>Redis为何选择单线程？</h3><p>在<strong>Redis 6.0以前，Redis的核心网络模型选择用单线程</strong>来实现。先来看下官方的回答：</p>\n<p>核心意思就是，对于一个 DB 来说，CPU 通常不会是瓶颈，因为大多数请求不会是 CPU 密集型的，而是 I&#x2F;O 密集型。具体到 Redis的话，如果不考虑 RDB&#x2F;AOF 等持久化方案，Redis是完全的纯内存操作，执行速度是非常快的，因此这部分操作通常不会是性能瓶颈，Redis真正的性能瓶颈在于网络 I&#x2F;O，也就是客户端和服务端之间的网络传输延迟，因此 Redis选择了单线程的 I&#x2F;O 多路复用来实现它的核心网络模型。</p>\n<p>实际上更加具体的选择单线程的原因如下：</p>\n<ul>\n<li>避免过多的<strong>上下文切换开销</strong>：如果是单线程则可以规避进程内频繁的线程切换开销，因为程序始终运行在进程中单个线程内，没有多线程切换的场景。</li>\n<li><strong>避免同步机制的开销</strong>：如果 Redis选择多线程模型，又因为 Redis是一个数据库，那么势必涉及到底层数据同步的问题，则必然会引入某些同步机制，比如锁，而我们知道 Redis不仅仅提供了简单的 key-value 数据结构，还有 list、set 和 hash 等等其他丰富的数据结构，而<strong>不同的数据结构对同步访问的加锁粒度又不尽相同</strong>，可能会导致在操作数据过程中带来很多<strong>加锁解锁的开销</strong>，增加程序复杂度的同时还会降低性能。</li>\n<li>简单可维护：如果 Redis使用多线程模式，<strong>那么所有的底层数据结构都必须实现成线程安全的</strong>，这无疑又使得 Redis的实现变得更加复杂。</li>\n</ul>\n<p>总而言之，Redis选择单线程可以说是<strong>多方博弈</strong>之后的一种权衡：在保证足够的性能表现之下，使用单线程保持代码的简单和可维护性。</p>\n<h3 id=\"Redis真的是单线程？\"><a href=\"#Redis真的是单线程？\" class=\"headerlink\" title=\"Redis真的是单线程？\"></a>Redis真的是单线程？</h3><p>讨论 这个问题前，先看下 Redis的版本中两个重要的节点：</p>\n<ol>\n<li>Redisv4.0（引入多线程处理异步任务）</li>\n<li>Redis 6.0（在网络模型中实现多线程 I&#x2F;O ）</li>\n</ol>\n<p>所以，网络上说的Redis是单线程，通常是指在Redis 6.0之前，其核心网络模型使用的是单线程。</p>\n<p>且Redis6.0引入<strong>多线程I&#x2F;O</strong>，只是用来<strong>处理网络数据的读写和协议的解析</strong>，而<strong>执行命令依旧是单线程</strong>。</p>\n<p>Redis在 v4.0 版本的时候就已经引入了的多线程来做一些异步操作，此举主要针对的是那些非常耗时的命令，通过将这些命令的执行进行异步化，避免阻塞单线程的事件循环。</p>\n<p>在 Redisv4.0 之后增加了一些的非阻塞命令如 UNLINK、FLUSHALL ASYNC、FLUSHDB ASYNC。</p>\n<h3 id=\"Redis-6-0为何引入多线程？\"><a href=\"#Redis-6-0为何引入多线程？\" class=\"headerlink\" title=\"Redis 6.0为何引入多线程？\"></a>Redis 6.0为何引入多线程？</h3><p>很简单，就是 Redis的网络 I&#x2F;O 瓶颈已经越来越明显了。</p>\n<p>随着互联网的飞速发展，互联网业务系统所要处理的线上流量越来越大，Redis的单线程模式会导致系统消耗很多 CPU 时间在网络 I&#x2F;O 上从而降低吞吐量，要提升 Redis的性能有两个方向：</p>\n<ul>\n<li>优化网络 I&#x2F;O 模块</li>\n<li>提高机器内存读写的速度</li>\n</ul>\n<p>后者依赖于硬件的发展，暂时无解。所以只能从前者下手，网络 I&#x2F;O 的优化又可以分为两个方向：</p>\n<ul>\n<li>零拷贝技术或者 DPDK 技术</li>\n<li>利用多核优势</li>\n</ul>\n<p>零拷贝技术有其局限性，无法完全适配 Redis这一类复杂的网络 I&#x2F;O 场景，更多网络 I&#x2F;O 对 CPU 时间的消耗和 Linux 零拷贝技术。而 DPDK 技术通过旁路网卡 I&#x2F;O 绕过内核协议栈的方式又太过于复杂以及需要内核甚至是硬件的支持。</p>\n<p>总结起来，Redis支持多线程主要就是两个原因：</p>\n<ul>\n<li><strong>可以充分利用服务器 CPU 资源，目前主线程只能利用一个核</strong></li>\n<li><strong>多线程任务可以****分摊 Redis 同步 IO 读写负荷</strong></li>\n</ul>\n<h3 id=\"Redis-6-0-采用多线程后，性能的提升效果如何？\"><a href=\"#Redis-6-0-采用多线程后，性能的提升效果如何？\" class=\"headerlink\" title=\"Redis 6.0 采用多线程后，性能的提升效果如何？\"></a>Redis 6.0 采用多线程后，性能的提升效果如何？</h3><p>Redis 作者 antirez 在 RedisConf 2019 分享时曾提到：Redis 6 引入的多线程 IO 特性对性能提升至少是<strong>一倍以上</strong>。</p>\n<p>国内也有大牛曾使用 unstable 版本在阿里云 esc 进行过测试，GET&#x2F;SET 命令在 4 线程 IO 时性能相比单线程是几乎是翻倍了。</p>\n<h3 id=\"介绍下Redis的线程模型\"><a href=\"#介绍下Redis的线程模型\" class=\"headerlink\" title=\"介绍下Redis的线程模型\"></a>介绍下Redis的线程模型</h3><p>Redis的线程模型包括Redis 6.0之前和Redis 6.0。</p>\n<p>下面介绍的是Redis 6.0之前。</p>\n<p>Redis 是基于 <strong>reactor</strong> 模式开发了网络事件处理器，这个处理器叫做文件事件处理器（file event handler）。由于这个文件事件处理器是单线程的，所以 Redis 才叫做单线程的模型。采用 IO 多路复用机制同时监听多个 Socket，根据 socket 上的事件来选择对应的事件处理器来处理这个事件。</p>\n<p>IO多路复用是 IO 模型的一种，有时也称为异步阻塞 IO，是基于经典的 Reactor 设计模式设计的。多路指的是多个 Socket 连接，复用指的是复用一个线程。多路复用主要有三种技术：Select，Poll，Epoll。</p>\n<p>Epoll 是最新的也是目前最好的多路复用技术。</p>\n<p>模型如下图：</p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/202105092153018231.png\" alt=\"img\"></p>\n<p>文件事件处理器的结构包含了四个部分：</p>\n<ul>\n<li><p>多个 Socket。Socket 会产生 AE_READABLE(读) 和 AE_WRITABLE (写)事件：</p>\n</li>\n<li><ul>\n<li>当 socket 变得可读时或者有新的可以应答的 socket 出现时，socket 就会产生一个 AE_READABLE 事件</li>\n<li>当 socket 变得可写时，socket 就会产生一个 AE_WRITABLE(可写) 事件。</li>\n</ul>\n</li>\n<li><p>IO 多路复用程序</p>\n</li>\n<li><p>文件事件分派器</p>\n</li>\n<li><p>事件处理器。事件处理器包括：连接应答处理器、命令请求处理器、命令回复处理器，每个处理器对应不同的 socket 事件：</p>\n</li>\n<li><ul>\n<li>如果是客户端要连接 Redis，那么会为 socket 关联连接<strong>应答处理器</strong></li>\n<li>如果是客户端要写数据到 Redis（读、写请求命令），那么会为 socket 关联<strong>命令请求处理器</strong></li>\n<li>如果是客户端要从 Redis 读数据，那么会为 socket 关联<strong>命令回复处理器</strong></li>\n</ul>\n</li>\n</ul>\n<p>多个 socket 会产生不同的事件，不同的事件对应着不同的操作，IO 多路复用程序监听着这些 Socket，当这些 Socket 产生了事件，IO 多路复用程序会将这些事件放到一个<strong>队列</strong>中，通过这个队列，以有序、同步、每次一个事件的方式向文件时间分派器中传送。当事件处理器处理完一个事件后，IO 多路复用程序才会继续向文件分派器传送下一个事件。</p>\n<p>下图是客户端与 Redis 通信的一次完整的流程：</p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/202105092153019692.png\" alt=\"img\"></p>\n<ol>\n<li>Redis 启动初始化的时候，Redis 会将连接应答处理器与 AE_READABLE 事件关联起来。</li>\n<li>如果一个客户端跟 Redis 发起连接，此时 Redis 会产生一个 AE_READABLE 事件，由于开始之初 AE_READABLE 是与连接应答处理器关联，所以由连接应答处理器来处理该事件，这时连接应答处理器会与客户端建立连接，<strong>创建客户端响应的 socket</strong>，<strong>同时将这个 socket 的 AE_READABLE 事件与命令请求处理器关联起来。</strong></li>\n<li>如果这个时间客户端向 Redis 发送一个命令（set k1 v1），这时 socket 会产生一个 AE_READABLE 事件，IO 多路复用程序会将该事件压入队列中，此时事件分派器从队列中取得该事件，由于该 socket 的 AE_READABLE 事件已经和命令请求处理器关联了，因此事件分派器会将该事件交给命令请求处理器处理，命令请求处理器读取事件中的命令并完成。<strong>操作完成后，Redis 会将该 socket 的 AE_WRITABLE 事件与命令回复处理器关联。</strong></li>\n<li>如果客户端已经准备好接受数据后，Redis 中的该 socket 会产生一个 AE_WRITABLE 事件，同样会压入队列然后被事件派发器取出交给相对应的命令回复处理器，由该命令回复处理器将准备好的响应数据写入 socket 中，供客户端读取。</li>\n<li>命令回复处理器写完后，就会删除该 socket 的 AE_WRITABLE 事件与命令回复处理器的关联关系。</li>\n</ol>\n<h3 id=\"Redis-6-0-多线程的实现机制？\"><a href=\"#Redis-6-0-多线程的实现机制？\" class=\"headerlink\" title=\"Redis 6.0 多线程的实现机制？\"></a>Redis 6.0 多线程的实现机制？</h3><p><strong>流程简述如下</strong>：</p>\n<ul>\n<li>主线程负责接收建立连接请求，获取 Socket 放入全局等待读处理队列。</li>\n<li>主线程处理完读事件之后，通过 RR（Round Robin）将这些连接分配给这些 IO 线程。</li>\n<li>主线程阻塞等待 IO 线程读取 Socket 完毕。</li>\n<li>主线程通过单线程的方式执行请求命令，请求数据读取并解析完成，但并不执行。</li>\n<li>主线程阻塞等待 IO 线程将数据回写 Socket 完毕。</li>\n</ul>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/image-20210828175543973.png\" alt=\"img\"></p>\n<h3 id=\"Redis-6-0开启多线程后，是否会存在线程并发安全问题？\"><a href=\"#Redis-6-0开启多线程后，是否会存在线程并发安全问题？\" class=\"headerlink\" title=\"Redis 6.0开启多线程后，是否会存在线程并发安全问题？\"></a>Redis 6.0开启多线程后，是否会存在线程并发安全问题？</h3><p>从实现机制可以看出，Redis 的多线程部分只是用来处理网络数据的读写和协议解析，执行命令仍然是单线程顺序执行。</p>\n<p>所以我们不需要去考虑控制 Key、Lua、事务，LPUSH&#x2F;LPOP 等等的并发及线程安全问题。</p>\n<h3 id=\"Redis-6-0-与-Memcached-多线程模型的对比\"><a href=\"#Redis-6-0-与-Memcached-多线程模型的对比\" class=\"headerlink\" title=\"Redis 6.0 与 Memcached 多线程模型的对比\"></a>Redis 6.0 与 Memcached 多线程模型的对比</h3><ul>\n<li><strong>相同点：</strong>都采用了 Master 线程 -Worker 线程的模型。</li>\n<li><strong>不同点</strong>：Memcached 执行主逻辑也是在 Worker 线程里，模型更加简单，实现了真正的线程隔离，符合我们对线程隔离的常规理解。而 Redis 把处理逻辑交还给 Master 线程，虽然一定程度上增加了模型复杂度，但也解决了线程并发安全等问题。</li>\n</ul>\n<h3 id=\"Redis-单线程模型详解\"><a href=\"#Redis-单线程模型详解\" class=\"headerlink\" title=\"Redis 单线程模型详解\"></a>Redis 单线程模型详解</h3><p>单线程如何监听来⾃客户端的⼤量连接？</p>\n<p>答：Redis 通过IO 多路复⽤程序 来监听来⾃客户端的⼤量连接 </p>\n<p>好处：I&#x2F;O 多路复⽤技术的使⽤让 Redis 不需要额外创建多余的线程来监听客户端的⼤量连接，降低了资源的消耗</p>\n<h3 id=\"Redis-没有使⽤多线程？为什么不使⽤多线程？\"><a href=\"#Redis-没有使⽤多线程？为什么不使⽤多线程？\" class=\"headerlink\" title=\"Redis 没有使⽤多线程？为什么不使⽤多线程？\"></a>Redis 没有使⽤多线程？为什么不使⽤多线程？</h3><ol>\n<li>编程容易 容易维护；</li>\n<li>Redis 的性能瓶颈不在 CPU ，主要在内存和⽹络，没必要多线程；</li>\n<li>多线程就会存在死锁、线程上下⽂切换等问题，甚⾄会影响性能。</li>\n</ol>\n<h3 id=\"Redis6-0-之后为何引⼊了多线程\"><a href=\"#Redis6-0-之后为何引⼊了多线程\" class=\"headerlink\" title=\"Redis6.0 之后为何引⼊了多线程\"></a>Redis6.0 之后为何引⼊了多线程</h3><p>为了提⾼⽹络 IO 读写性能 但也只是在⽹络数据的读写这类耗时操作上使⽤了， 执⾏命令仍然是单线程顺序执⾏ </p>\n<p>默认禁用，修改 redis 配置⽂件 redis.conf 开启</p>\n<h2 id=\"事务-1\"><a href=\"#事务-1\" class=\"headerlink\" title=\"事务\"></a>事务</h2><h3 id=\"Redis事务的概念\"><a href=\"#Redis事务的概念\" class=\"headerlink\" title=\"Redis事务的概念\"></a>Redis事务的概念</h3><p>Redis的事务并不是我们传统意义上理解的事务，我们都知道 单个 Redis 命令的执行是原子性的，但 Redis 没有在事务上增加任何维持原子性的机制，所以 Redis <strong>事务的执行并不是原子性的</strong>。</p>\n<p>事务可以理解为一个<strong>打包的批量执行脚本</strong>，但<strong>批量指令并非原子化</strong>的操作，<strong>中间某条指令的失败不会导致前面已做指令的回滚，也不会造成后续的指令不做。</strong>(没回滚)</p>\n<p><strong>总结：</strong></p>\n<ol>\n<li>Redis事务中如果有某一条命令执行失败，之前的命令不会回滚，其后的命令仍然会被继续执行。<strong>鉴于这个原因，所以说Redis的事务严格意义上来说是不具备原子性的</strong>。</li>\n<li>Redis事务中所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。</li>\n<li>在事务开启之前，如果客户端与服务器之间出现通讯故障并导致网络断开，其后所有待执行的语句都将不会被服务器执行。<strong>然而如果网络中断事件是发生在客户端执行EXEC命令之后，那么该事务中的所有命令都会被服务器执行。</strong></li>\n</ol>\n<p>当使用Append-Only模式时，Redis会通过调用系统函数write将该事务内的所有写操作在本次调用中全部写入磁盘。然而如果在写入的过程中出现系统崩溃，如电源故障导致的宕机，那么此时也许只有部分数据被写入到磁盘，而另外一部分数据却已经丢失。Redis服务器会在重新启动时执行一系列必要的一致性检测，一旦发现类似问题，就会立即退出并给出相应的错误提示。此时，我们就要充分利用Redis工具包中提供的Redis-check-aof工具，<strong>该工具可以帮助我们定位到数据不一致的错误，并将已经写入的部分数据进行回滚。</strong>修复之后我们就可以再次重新启动Redis服务器了。</p>\n<h3 id=\"Redis事务的三个阶段\"><a href=\"#Redis事务的三个阶段\" class=\"headerlink\" title=\"Redis事务的三个阶段\"></a>Redis事务的三个阶段</h3><ol>\n<li>multi 开启事务</li>\n<li>大量指令入队</li>\n<li>exec执行事务块内命令，<strong>截止此处一个事务已经结束。</strong></li>\n<li>discard 取消事务</li>\n<li>watch 监视一个或多个key，如果事务执行前key被改动，事务将打断。unwatch 取消监视。</li>\n</ol>\n<p>事务执行过程中，如果服务端收到有EXEC、DISCARD、WATCH、MULTI之外的请求，将会把请求放入队列中排队.</p>\n<h3 id=\"Redis事务相关命令\"><a href=\"#Redis事务相关命令\" class=\"headerlink\" title=\"Redis事务相关命令\"></a>Redis事务相关命令</h3><p>Redis事务功能是通过MULTI、EXEC、DISCARD和WATCH 四个原语实现的</p>\n<ul>\n<li>WATCH 命令是一个乐观锁，可以为 Redis 事务提供 check-and-set （CAS）行为。 可以监控一个或多个键，一旦其中有一个键被修改（或删除），之后的事务就不会执行，监控一直持续到EXEC命令。</li>\n<li>MULTI命令用于开启一个事务，它总是返回OK。 MULTI执行之后，客户端可以继续向服务器发送任意多条命令，这些命令不会立即被执行，而是被放到一个队列中，当EXEC命令被调用时，所有队列中的命令才会被执行。</li>\n<li>EXEC：执行所有事务块内的命令。返回事务块内所有命令的返回值，按命令执行的先后顺序排列。 当操作被打断时，返回空值 nil 。 通过调用DISCARD，客户端可以清空事务队列，并放弃执行事务， 并且客户端会从事务状态中退出。</li>\n<li>UNWATCH命令可以取消watch对所有key的监控。</li>\n</ul>\n<h3 id=\"Redis事务支持隔离性吗\"><a href=\"#Redis事务支持隔离性吗\" class=\"headerlink\" title=\"Redis事务支持隔离性吗?\"></a>Redis事务支持隔离性吗?</h3><p>Redis 是单进程程序，并且它保证在执行事-务时，不会对事务进行中断，事务可以运行直到执行完所有事务队列中的命令为止。因此，<strong>Redis 的事务是总是带有隔离性的</strong>。</p>\n<h3 id=\"Redis为什么不支持事务回滚？\"><a href=\"#Redis为什么不支持事务回滚？\" class=\"headerlink\" title=\"Redis为什么不支持事务回滚？\"></a><a href=\"https://www.javalearn.cn/#/doc/Redis/%E9%9D%A2%E8%AF%95%E9%A2%98?id=_34-redis%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E6%94%AF%E6%8C%81%E4%BA%8B%E5%8A%A1%E5%9B%9E%E6%BB%9A%EF%BC%9F\">Redis为什么不支持事务回滚？</a></h3><ul>\n<li>Redis 命令只会因为错误的语法而失败，或是命令用在了错误类型的键上面，这些问题不能在入队时发现，这也就是说，从实用性的角度来说，失败的命令是由编程错误造成的，而这些错误应该在开发的过程中被发现，而不应该出现在生产环境中.</li>\n<li>因为不需要对回滚进行支持，所以 Redis 的内部可以保持简单且快速。</li>\n</ul>\n<h3 id=\"Redis事务其他实现\"><a href=\"#Redis事务其他实现\" class=\"headerlink\" title=\"Redis事务其他实现(?)\"></a><a href=\"https://www.javalearn.cn/#/doc/Redis/%E9%9D%A2%E8%AF%95%E9%A2%98?id=_35-redis%E4%BA%8B%E5%8A%A1%E5%85%B6%E4%BB%96%E5%AE%9E%E7%8E%B0\">Redis事务其他实现</a>(?)</h3><ul>\n<li>基于Lua脚本，Redis可以保证脚本内的命令一次性、按顺序地执行， 其同时也不提供事务运行错误的回滚，执行过程中如果部分命令运行错误，剩下的命令还是会继续运行完。</li>\n<li>基于中间标记变量，通过另外的标记变量来标识事务是否执行完成，读取数据时先读取该标记变量判断是否事务执行完成。但这样会需要额外写代码实现，比较繁琐。</li>\n</ul>\n<h2 id=\"主从、哨兵、集群\"><a href=\"#主从、哨兵、集群\" class=\"headerlink\" title=\"主从、哨兵、集群\"></a>主从、哨兵、集群</h2><h3 id=\"36-Redis常见使用方式有哪些？\"><a href=\"#36-Redis常见使用方式有哪些？\" class=\"headerlink\" title=\"36. Redis常见使用方式有哪些？\"></a><a href=\"https://www.javalearn.cn/#/doc/Redis/%E9%9D%A2%E8%AF%95%E9%A2%98?id=_36-redis%E5%B8%B8%E8%A7%81%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F\">36. Redis常见使用方式有哪些？</a></h3><p>Redis的几种常见使用方式包括：</p>\n<ul>\n<li>Redis单副本；</li>\n<li>Redis多副本（主从）；</li>\n<li>Redis Sentinel（哨兵）；</li>\n<li>Redis Cluster；</li>\n<li>Redis自研。</li>\n</ul>\n<p>使用场景：</p>\n<p>如果数据量很少，主要是承载高并发高性能的场景，比如缓存一般就几个G的话，单机足够了。</p>\n<p>主从模式：master 节点挂掉后，需要<strong>手动</strong>指定新的 master，可用性不高，基本不用。</p>\n<p>哨兵模式：master 节点挂掉后，哨兵进程会主动选举新的 master，可用性高，但是每个节点存储的数据是一样的，浪费内存空间。数据量不是很多，集群规模不是很大，需要自动容错容灾的时候使用。</p>\n<p>Redis cluster 主要是针对海量数据+高并发+高可用的场景，如果是海量数据，如果你的数据量很大，那么建议就用Redis cluster，所有master的容量总和就是Redis cluster可缓存的数据容量。</p>\n<h3 id=\"介绍下Redis单副本\"><a href=\"#介绍下Redis单副本\" class=\"headerlink\" title=\"介绍下Redis单副本\"></a>介绍下Redis单副本</h3><p>Redis单副本，采用单个Redis节点部署架构，没有备用节点实时同步数据，不提供数据持久化和备份策略，适用于数据可靠性要求不高的纯缓存业务场景。</p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/image-20210829103307048.png\" alt=\"img\"></p>\n<p><strong>优点：</strong></p>\n<ul>\n<li>架构简单，部署方便；</li>\n<li>高性价比：缓存使用时无需备用节点（单实例可用性可以用supervisor或crontab保证），当然为了满足业务的高可用性，也可以牺牲一个备用节点，但同时刻只有一个实例对外提供服务；</li>\n<li>高性能。</li>\n</ul>\n<p><strong>缺点：</strong></p>\n<ul>\n<li>不保证数据的可靠性；</li>\n<li>在缓存使用，进程重启后，数据丢失，即使有备用的节点解决高可用性，但是仍然不能解决缓存预热问题，因此不适用于数据可靠性要求高的业务；</li>\n<li>高性能受限于单核CPU的处理能力（Redis是单线程机制），CPU为主要瓶颈，所以适合操作命令简单，排序、计算较少的场景。也可以考虑用Memcached替代。</li>\n</ul>\n","categories":["八股"]},{"title":"基于hexo的Quiet主题搭建博客教程","url":"/2023/05/01/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/","content":"<h1 id=\"1、参考的文章\"><a href=\"#1、参考的文章\" class=\"headerlink\" title=\"1、参考的文章\"></a>1、参考的文章</h1><p>搭建博客</p>\n<p><a href=\"https://www.bilibili.com/read/cv12633102\">https://www.bilibili.com/read/cv12633102</a></p>\n<p>域名绑定</p>\n<p><a href=\"https://blog.csdn.net/Mancuojie/article/details/119906071\">https://blog.csdn.net/Mancuojie/article/details/119906071</a><span id=\"more\"></span></p>\n<p>主题修改</p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/618864711\">https://zhuanlan.zhihu.com/p/618864711</a></p>\n<h1 id=\"2、遇到的报错信息\"><a href=\"#2、遇到的报错信息\" class=\"headerlink\" title=\"2、遇到的报错信息\"></a>2、遇到的报错信息</h1><h2 id=\"2-1-遇到转义问题\"><a href=\"#2-1-遇到转义问题\" class=\"headerlink\" title=\"2.1 遇到转义问题\"></a>2.1 遇到转义问题</h2><pre><code>git config --global core.autocrlf false\n</code></pre>\n<h2 id=\"2-2-打开viacheung-github-io跳转绑定域名但显示空白\"><a href=\"#2-2-打开viacheung-github-io跳转绑定域名但显示空白\" class=\"headerlink\" title=\"2.2 打开viacheung.github.io跳转绑定域名但显示空白\"></a>2.2 打开viacheung.github.io跳转绑定域名但显示空白</h2><p>原因是我们没有在阿里云服务器配置好</p>\n<p>具体配置：<a href=\"https://blog.csdn.net/Mancuojie/article/details/119906071\">https://blog.csdn.net/Mancuojie/article/details/119906071</a></p>\n<p>然后你需要在博客的根目录的<code>source</code>文件夹下新建一个<code>CNAME</code>文件（不要有任何后缀），在里面写入自己的域名</p>\n<p>最后在你博客的Github仓库里找到设置，下拉到Pages填入你的域名保存。大功告成！</p>\n<p>踩坑小tip：按照教程完成一件事情最好全做完，不要想当然分模块，有可能这一步出问题就是因为没把全部事情做完，比如这个打开空白的事情一直以为是之前设置有误，结果是阿里云服务器于域名没有配好。</p>\n<h1 id=\"3、需要的github操作\"><a href=\"#3、需要的github操作\" class=\"headerlink\" title=\"3、需要的github操作\"></a>3、需要的github操作</h1><p>1、我们访问的域名需要是github的用户名.github.io这种形式，github用户名修改在account里面。</p>\n<p>2、同时在博客的根目录下的_config.yml里应该是这种形式:</p>\n<pre><code> deploy:\n  type: git\n  repository: git@github.com:viacheung/viacheung.github.io.git\n  branch: master\n</code></pre>\n<p> respository里面直接在我们的博客代码里面进行如下复制操作</p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/image-20230424170302215.png\" alt=\"image-20230424170302215\"></p>\n<h1 id=\"4、更换主题\"><a href=\"#4、更换主题\" class=\"headerlink\" title=\"4、更换主题\"></a>4、更换主题</h1><p>下载相应主题放到 theme 文件夹下。</p>\n<p>打开博客目录下的_config.yml文件，在里面设置为theme: blinkfox   （blinkfox为我们要使用的主题名）,然后重新执行hexo g来重新生成。</p>\n<p>如果出现一些莫名其妙的问题，可以先执行hexo clean来清理一下public的内容，然后再执行hexo g 和 hexo s 重新生成和发布。</p>\n<h1 id=\"5、增加评论功能\"><a href=\"#5、增加评论功能\" class=\"headerlink\" title=\"5、增加评论功能\"></a>5、增加评论功能</h1><p>这里采用的是 <code>gitalk</code> 一个基于 Github Issue 和 Preact 开发的评论插件</p>\n<p>我们只需要在 <code>Quiet </code>主题文件里面的<code>_config.yml</code>配置文件的 <code>gitalk</code> 进行配置</p>\n<p>首先，您需要选择一个公共github存储库（已存在或创建一个新的github存储库）用于存储评论，</p>\n<p>然后需要创建 <strong>GitHub Application</strong>，如果没有 <a href=\"https://github.com/settings/applications/new\">点击这里申请</a>，<code>Authorization callback URL</code> 填写当前使用插件页面的域名。</p>\n<img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/image-20230501002945716.png\" alt=\"image-20230501002945716\" style=\"zoom: 67%;\">\n\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/2020-02-02-17-34-57.png\" alt=\"img\"></p>\n<pre><code class=\"yaml\">gitalk:\n  clientID: 43557dd07d33bd0ebcdd # （需要替换）GitHub Application Client ID.\n  clientSecret: 4f8841de720cb270e38dea5ff52818c9eb744c36 #（需要替换）GitHub Application Client Secret.\n  repo: blog_commets #（需要替换）GitHub仓库名\n  owner: viacheung #（需要替换）GitHub repository 所有者，可以是个人或者组织。\n  admin: [&#39;viacheung&#39;] #（需要替换）GitHub repository 的所有者和合作者 (对这个 repository 有写权限的用户)。\n</code></pre>\n<p>然后发布的时候题头需要comments: true</p>\n<h2 id=\"Error-Validation-Failed\"><a href=\"#Error-Validation-Failed\" class=\"headerlink\" title=\"Error: Validation Failed\"></a>Error: Validation Failed</h2><p>可能会出现Error: Validation Failed的问题，我的解决办法是添加了一句 <strong>id: decodeURI(location.pathname)</strong> ，使用了JS的解码函数decodeURI()</p>\n<p>在bloh&#x2F;themes&#x2F;Quiet&#x2F;layout&#x2F;_widget&#x2F;commet.ejs里面配置如下：</p>\n<pre><code class=\"ejs\">&lt;% if(theme.gitalk.clientID &amp;&amp; theme.gitalk.clientSecret) &#123; %&gt;\n    &lt;!-- Gitalk --&gt;\n    &lt;script&gt;\n        const data = &#39;&#123;&quot;clientID&quot;:&quot;&lt;%= theme.gitalk.clientID %&gt;&quot;,&quot;clientSecret&quot;:&quot;&lt;%= theme.gitalk.clientSecret %&gt;&quot;,&quot;repo&quot;:&quot;&lt;%= theme.gitalk.repo %&gt;&quot;,&quot;owner&quot;:&quot;&lt;%= theme.gitalk.owner %&gt;&quot;,&quot;admin&quot;:&quot;&lt;%= theme.gitalk.admin %&gt;&quot;&#125;&#39;\n        const gitalk = new Gitalk(&#123;\n            ...JSON.parse( data),\n            id:decodeURI(location.pathname),\n            distractionFreeMode:false\n        &#125;)\n        \n        if(Boolean(&#39;&lt;%= page.comments %&gt;&#39;))&#123;\n            gitalk.render(&#39;gitalk-container&#39;)\n        &#125;\n    &lt;/script&gt;\n&lt;% &#125; %&gt;\n</code></pre>\n<h1 id=\"6-、插入图像\"><a href=\"#6-、插入图像\" class=\"headerlink\" title=\"6 、插入图像\"></a>6 、插入图像</h1><p>修改博客根目录中<code>_config.yml</code>文件的配置项<code>post_asset_folder</code>为<code>true</code>：</p>\n<p>npm install hexo-asset-image –save</p>\n<p>当文章需要添加图片时，将需要添加的图片放入同名的文件夹中，同时通过相对路径索引到该图片。</p>\n<p>右键引入图像</p>\n<p>有待改进</p>\n<p><strong>Typora文件名为中文保存时，插入图片的路径的中文部分是字符串乱码的，怎么解决？</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/image-20230424170226645.png\" alt=\"image-20230424170226645\"></p>\n<h1 id=\"7、写博客\"><a href=\"#7、写博客\" class=\"headerlink\" title=\"7、写博客\"></a>7、写博客</h1><p>我们的文章（F:\\programFiles\\blog\\source_posts在此处）前面需要加这个</p>\n<p>在C:\\Users\\50537\\OneDrive\\blog\\scaffolds\\post.md里面可以配格式</p>\n<hr>\n<pre><code>title: 基于hexo的Quiet主题搭建博客教程\ncomments: true\ncategories:\n  - 教程\naubot: viacheung\ntags:\n  - Hexo\n  - Quiet\ntoc: true\ndate: 2023-5-1 0:55\n</code></pre>\n<hr>\n<pre><code>笔记前面都加上这个 然后hexo clean   g   d\n</code></pre>\n<h1 id=\"8、换主题\"><a href=\"#8、换主题\" class=\"headerlink\" title=\"8、换主题\"></a>8、换主题</h1><p>找了一个还不错的主题，quiet</p>\n<p><a href=\"https://github.com/79E/hexo-theme-quiet\">https://github.com/79E/hexo-theme-quiet</a></p>\n<p>下载下来，放在F:\\programFiles\\blog的themes</p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/202306032304160.png\" alt=\"image-20230603230455013\"></p>\n<p>此处执行 </p>\n<pre><code>hexo clean \nhexo g \nhexo d\n</code></pre>\n<hr>\n<h2 id=\"8-1关于github里面提到的问题\"><a href=\"#8-1关于github里面提到的问题\" class=\"headerlink\" title=\"8.1关于github里面提到的问题\"></a>8.1关于github里面提到的问题</h2><p><strong>css 样式没有加载出来</strong></p>\n<p>需要管理员打开cmd 切换到博客根路径</p>\n<pre><code>C:\\WINDOWS\\system32&gt;F:\n\nF:\\&gt;cd programFiles\n\nF:\\programFiles&gt;cd blog\n</code></pre>\n<p>然后执行</p>\n<pre><code>npm i hexo-renderer-less\nnpm i hexo-renderer-ejs\n</code></pre>\n<p>反正成功了</p>\n<p>不知道是不是这个起作用了</p>\n<p><a href=\"https://www.cnblogs.com/xrblog/p/11587356.html\">https://www.cnblogs.com/xrblog/p/11587356.html</a></p>\n<h1 id=\"9、对于Hexo的理解\"><a href=\"#9、对于Hexo的理解\" class=\"headerlink\" title=\"9、对于Hexo的理解\"></a>9、对于Hexo的理解</h1><p>F:\\programFiles\\blog\\source里面的文件名对应theme里面配置文件的导航名称</p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/image-20230424170212169.png\" alt=\"image-20230424170212169\"></p>\n<h1 id=\"10-、绑定域名\"><a href=\"#10-、绑定域名\" class=\"headerlink\" title=\"10 、绑定域名\"></a>10 、绑定域名</h1><p>source下面有个CNAME 里面写zhangweiyang.xyz</p>\n<p>github里面有个CNAME 里面写zhangweiyang.xyz</p>\n<h1 id=\"11、操作命令\"><a href=\"#11、操作命令\" class=\"headerlink\" title=\"11、操作命令\"></a>11、操作命令</h1><h2 id=\"11-1-新建文章\"><a href=\"#11-1-新建文章\" class=\"headerlink\" title=\"11. 1 新建文章\"></a>11. 1 新建文章</h2><pre><code>blog根目录下：\n\nhexo new &quot;xxx&quot;\n</code></pre>\n<h1 id=\"12、文章截断\"><a href=\"#12、文章截断\" class=\"headerlink\" title=\"12、文章截断\"></a>12、文章截断</h1><p>在需要截断的地方加入：</p>\n<!--more-->\n\n<p>首页就会显示这条以上的所有内容，隐藏接下来的所有内容。<br>例如本文会显示到修改配置上面。</p>\n<p>这个明显就方便很多，但当然有利有弊，比如开头都是废话首页看着就不是很好看，因此我一般会先选择方法二，如果感觉文章前面的写的不太好再用方法一。</p>\n","categories":["教程"]},{"title":"二分","url":"/2023/06/04/%E4%BA%8C%E5%88%86/","content":"<h1 id=\"二分排序\"><a href=\"#二分排序\" class=\"headerlink\" title=\"二分排序\"></a>二分排序</h1><p>部分有序也可以二分</p>\n<h2 id=\"模板\"><a href=\"#模板\" class=\"headerlink\" title=\"模板\"></a>模板</h2><p>1、记录答案法（推荐这个）<span id=\"more\"></span>：</p>\n<p>要保证左右断点都能取到</p>\n<pre><code class=\"plain\">while (l&lt;=r)\n&#123;\n    int mid=l+(r-l)/2;\n    if (check(mid))\n    &#123;\n        r=mid-1;\n    &#125;\n    else l=mid+1;\n&#125;\n//reurn的时候要注意，现在的l是多的一个\n</code></pre>\n<p>2、不记录法</p>\n<pre><code class=\"plain\">bool check(int x) &#123;/* ... */&#125; // 检查x是否满足某种性质\n\n// 寻找满足条件的左边界      \nint bsearch_1(int l, int r)\n&#123;\n    while (l &lt; r)\n    &#123;\n        int mid = l + r &gt;&gt; 1;\n        //对应l+(r-l)/2\n        if (check(mid)) r = mid;    // check()判断mid是否满足性质\n        else l = mid + 1;\n    &#125;\n    return l;\n&#125;\n// 寻找满足条件的右边界(222完全二叉树的节点个数的题解就是这个思路)   \nint bsearch_2(int l, int r)\n&#123;\n    while (l &lt; r)\n    &#123;\n        //对应l+(r-l+1)/2\n        int mid = l + r + 1 &gt;&gt; 1;\n        if (check(mid)) l = mid;\n        else r = mid - 1;\n    &#125;\n    return l;\n&#125;\n//要记住  满足条件，需要保留的就mid，不满足条件就是mid+1 mid-1\n</code></pre>\n<h2 id=\"旋转数组\"><a href=\"#旋转数组\" class=\"headerlink\" title=\"旋转数组\"></a>旋转数组</h2><p>将数组一分为二，其中一定有一个是有序的，另一个可能是有序，也能是部分有序。此时有序部分用二分法查找。无序部分再一分为二，其中一个一定有序，另一个可能有序，可能无序。就这样循环. </p>\n<h2 id=\"二分查找\"><a href=\"#二分查找\" class=\"headerlink\" title=\"二分查找\"></a>二分查找</h2><p>给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。</p>\n<pre><code class=\"plain\">class Solution &#123;\n    public int search(int[] nums, int target) &#123;\n        int left=0,right=nums.length-1;\n        while(left&lt;=right)&#123;\n            //取下标中点  &gt;&gt;1表示除以2\n            int mid=(left+right)&gt;&gt;1;\n            if(nums[mid]==target)&#123;\n                return mid;\n            &#125;else if(nums[mid]&lt;target)&#123;\n                left=mid+1;\n            &#125;else&#123;\n                right=mid-1;\n            &#125;\n        &#125;\n        return -1;\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"二维数组中的查找\"><a href=\"#二维数组中的查找\" class=\"headerlink\" title=\"二维数组中的查找\"></a><strong>二维数组中的查找</strong></h2><ul>\n<li>step 1：首先获取矩阵的两个边长，判断特殊情况。</li>\n<li>step 2：首先以左下角为起点，若是它小于目标元素，则往右移动去找大的，若是他大于目标元素，则往上移动去找小的。</li>\n<li>step 3：若是移动到了矩阵边界也没找到，说明矩阵中不存在目标值。</li>\n</ul>\n<pre><code class=\"plain\">public class Solution &#123;\n    public boolean Find(int target, int [][] array) &#123;\n        // 从左下角开始搜索：  列最大 行最小\n        int row=array.length;\n        int col=array[0].length;\n        for(int i=row-1,j=0;i&gt;=0&amp;j&lt;col;)&#123;\n            if(array[i][j]==target) return true;\n            else if(array[i][j]&gt;target) i--;\n            else j++;\n        &#125;\n        return false;\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"寻找峰值\"><a href=\"#寻找峰值\" class=\"headerlink\" title=\"寻找峰值\"></a><strong>寻找峰值</strong></h2><p>1、求最大值</p>\n<pre><code class=\"plain\">public int findPeakElement(int[] nums) &#123;\n        int idx = 0;\n        for (int i = 1; i &lt; nums.length; ++i) &#123;\n            if (nums[i] &gt; nums[idx]) &#123;\n                idx = i;\n            &#125;\n        &#125;\n        return idx;\n    &#125;\n</code></pre>\n<p>2、二分</p>\n<pre><code class=\"plain\">import java.util.*;\n\n\npublic class Solution &#123;\n    /**\n     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可\n     *\n     * \n     * @param nums int整型一维数组 \n     * @return int整型\n     */\n    public int findPeakElement (int[] nums) &#123;\n        // write code here\n   //关键思想：下坡的时候可能找到波峰，但是可能找不到，一直向下走的\n  //上坡的时候一定能找到波峰，因为题目给出的是nums[-1] = nums[n] = -∞\n        int left = 0;\n        int right = nums.length-1;\n        while(left&lt;right)&#123;\n            int mid = left+(right-left)/2;\n            //证明右边的路是下坡路，不一定有坡峰\n            if(nums[mid]&gt;nums[mid+1])&#123;\n                right = mid;\n            &#125;\n            else&#123;\n                //这里是右边的路是上坡路\n                left=mid+1;\n            &#125;\n        &#125;\n        return right;\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"旋转数组的最小数字\"><a href=\"#旋转数组的最小数字\" class=\"headerlink\" title=\"旋转数组的最小数字\"></a><strong>旋转数组的最小数字</strong></h2><p><strong>思路：</strong></p>\n<p>旋转数组将原本有序的数组分成了两部分有序的数组，因为在原始有序数组中，最小的元素一定是在首位，旋转后无序的点就是最小的数字。我们可以将旋转前的前半段命名为A，旋转后的前半段命名为B，旋转数组即将AB变成了BA，我们想知道最小的元素到底在哪里。</p>\n<p>因为A部分和B部分都是各自有序的，所以我们还是想用分治来试试，每次比较中间值，确认目标值（最小元素）所在的区间。</p>\n<p><strong>具体做法：</strong></p>\n<ul>\n<li>step 1：双指针指向旋转后数组的首尾，作为区间端点。</li>\n<li>step 2：若是区间中点值大于区间右界值，则最小的数字一定在中点右边。(left&#x3D;mid+1)</li>\n<li>step 3：若是区间中点值等于区间右界值，则是不容易分辨最小数字在哪半个区间，比如[1,1,1,0,1]，应该逐个缩减右界。 (right–)</li>\n<li>step 4：若是区间中点值小于区间右界值，则最小的数字一定在中点左边。(right&#x3D;mid)</li>\n<li>step 5：通过调整区间最后即可锁定最小值所在。</li>\n</ul>\n<pre><code class=\"plain\">import java.util.ArrayList;\npublic class Solution &#123;\n    public int minNumberInRotateArray(int [] array) &#123;\n        int left=0,right=array.length-1;\n        while(left&lt;=right)&#123;\n            int mid=(left+right)/2;\n            if(array[mid]&gt;array[right])&#123;\n                left=mid+1;\n            &#125;else if(array[mid]==array[right])&#123;\n                right--;\n            &#125;else &#123;\n                // 最小数字要么在左边要么是mid\n                right=mid;\n            &#125;\n        &#125;\n        return array[left];\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"比较版本号\"><a href=\"#比较版本号\" class=\"headerlink\" title=\"比较版本号\"></a><strong>比较版本号</strong></h2><p>比较规则：</p>\n<p>一. 比较版本号时，请按从左到右的顺序依次比较它们的修订号。比较修订号时，只需比较忽略任何前导零后的整数值。比如”0.1”和”0.01”的版本号是相等的</p>\n<p>二. 如果版本号没有指定某个下标处的修订号，则该修订号视为0。例如，”1.1”的版本号小于”1.1.1”。因为”1.1”的版本号相当于”1.1.0”，第3位修订号的下标为0，小于1</p>\n<p>三. version1 &gt; version2 返回1，如果 version1 &lt; version2 返回-1，不然返回0.</p>\n<p>思路:</p>\n<ol>\n<li><strong>每次比较.前的数字大小即可</strong></li>\n</ol>\n<pre><code class=\"plain\">import java.util.*;\npublic class Solution &#123;\n    public int compare (String version1, String version2) &#123;\n        int n1 = version1.length();\n        int n2 = version2.length();\n        int i = 0, j = 0;\n        //直到某个字符串结束\n        while(i &lt; n1 || j &lt; n2)&#123;\n            long num1 = 0;\n            //从下一个点前截取数字\n            while(i &lt; n1 &amp;&amp; version1.charAt(i) != &#39;.&#39;)&#123; \n                num1 = num1 * 10 + (version1.charAt(i) - &#39;0&#39;);\n                i++;\n            &#125;\n            //跳过点\n            i++; \n            long num2 = 0;\n            //从下一个点前截取数字\n            while(j &lt; n2 &amp;&amp; version2.charAt(j) != &#39;.&#39;)&#123; \n                num2 = num2 * 10 + (version2.charAt(j) - &#39;0&#39;);\n                j++;\n            &#125;\n            //跳过点\n            j++; \n            //比较数字大小\n            if(num1 &gt; num2) \n                return 1;\n            if(num1 &lt; num2)\n                return -1;\n        &#125;\n        //版本号相同\n        return 0; \n    &#125;\n&#125;\n</code></pre>\n","categories":["算法"]},{"title":"Spring","url":"/2023/06/04/Spring/","content":"<h2 id=\"使用Spring框架的好处是什么？\"><a href=\"#使用Spring框架的好处是什么？\" class=\"headerlink\" title=\"使用Spring框架的好处是什么？\"></a>使用Spring框架的好处是什么？</h2><ul>\n<li><strong>轻量：</strong>Spring 是轻量的，基本的版本大约2MB<span id=\"more\"></span></li>\n<li><strong>控制反转：</strong>Spring通过控制反转实现了松散耦合，对象们给出它们的依赖，而不是创建或查找依赖的对象们</li>\n<li><strong>面向切面的编程(AOP)：</strong>Spring支持面向切面的编程，并且把应用业务逻辑和系统服务分开</li>\n<li><strong>容器：</strong>Spring 包含并管理应用中对象的生命周期和配置</li>\n<li><strong>MVC框架：</strong>Spring的WEB框架是个精心设计的框架，是Web框架的一个很好的替代品</li>\n<li><strong>事务管理：</strong>Spring 提供一个持续的事务管理接口，可以扩展到上至本地事务下至全局事务（JTA）</li>\n<li><strong>异常处理：</strong>Spring 提供方便的API把具体技术相关的异常（比如由JDBC，Hibernate or JDO抛出的）转化为一致的unchecked 异常。</li>\n</ul>\n<h2 id=\"spring开发步骤\"><a href=\"#spring开发步骤\" class=\"headerlink\" title=\"spring开发步骤\"></a>spring开发步骤</h2><p>Spring的开发步骤① 导入坐标（context ）② 创建Bean（编写Dao接口和实现类 ）③ 创建applicationContext.xml（类路径下（resources） ）④ 在配置文件中进行配置（&lt;bean id&#x3D;”userDao” class&#x3D;”com.itheima.dao.impl.UserDaoImp ）⑤ 创建ApplicationContext对象getBean </p>\n<pre><code class=\"plain\">ApplicationContext applicationContext = new   ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);\nUserDao userDao = (UserDao) applicationContext.getBean(&quot;userDao&quot;);\nuserDao.save();\n</code></pre>\n<h2 id=\"Bean\"><a href=\"#Bean\" class=\"headerlink\" title=\"Bean\"></a>Bean</h2><p>用于配置对象交由Spring 来创建。默认情况下它调用的是类中的无参构造函数，如果没有无参构造函数则不能创建成功。 </p>\n<p>id： Bean实例在Spring容器中class： Bean的全限定名称 </p>\n<p>默认值，单例的</p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/image-20230317204511492.png\" alt=\"img\"></p>\n<p>init-method：指定类中的初始化方法名称</p>\n<p>destroy-method：指定类中销毁方法名称 </p>\n<h3 id=\"Bean实例化三种方式\"><a href=\"#Bean实例化三种方式\" class=\"headerlink\" title=\"Bean实例化三种方式\"></a>Bean实例化三种方式</h3><p>无参构造方法实例化工厂静态方法实例化工厂实例方法实例化 </p>\n<h3 id=\"Bean的依赖注入\"><a href=\"#Bean的依赖注入\" class=\"headerlink\" title=\"Bean的依赖注入\"></a>Bean的依赖注入</h3><p>通过控制反转，把对象的创建交给了 Spring，但IOC 解耦只是降低他们的依赖关系，但不会消除。例如：业务层仍会调用持久层的方法。那这种业务层和持久层的依赖关系，在使用 Spring 之后，就让 Spring 来维护了。简单的说，就是坐等框架把持久层对象传入业务层，而不用我们自己去获取 </p>\n<p>对象注入哪几种方式？</p>\n<p>1、<strong>构造函数注入</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/image-20230410165353388.png\" alt=\"img\"></p>\n<p>好处：</p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/image-20230410165421975.png\" alt=\"img\"></p>\n<p>2、<strong>setter 注入</strong>（在XML中写入，然后在set方法中注入。</p>\n<p><bean id=\"userService\" class=\"com.lyu.spring.service.impl.UserService\"><!-- 写法一 --><!-- <property name=\"UserDao\" ref=\"userDaoMyBatis\"></property> --></bean></p>\n<pre><code class=\"plain\">private IUserDao userDao1;\n \npublic void setUserDao(IUserDao userDao1) &#123;//这里注意，name方法与类中成员变量名和方法的参数名都无关，只与set方法名有关\n    this.userDao1 = userDao1;\n&#125;\n</code></pre>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/image-20230410165552733.png\" alt=\"img\"></p>\n<p>3、接口注入（<strong>注解注入</strong>）</p>\n<p>前面两种都可以检测出循环依赖</p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/image-20230410165617392.png\" alt=\"img\"></p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/image-20230410165642347.png\" alt=\"img\"></p>\n<h3 id=\"构造注入vs-setter注入\"><a href=\"#构造注入vs-setter注入\" class=\"headerlink\" title=\"构造注入vs setter注入\"></a>构造注入vs setter注入</h3><table>\n<thead>\n<tr>\n<th><strong>构造函数注入</strong></th>\n<th><strong>setter 注入</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>没有部分注入</td>\n<td>有部分注入</td>\n</tr>\n<tr>\n<td>不会覆盖 setter 属性</td>\n<td>会覆盖 setter 属性</td>\n</tr>\n<tr>\n<td>任意修改都会创建一个新实例</td>\n<td>任意修改不会创建一个新实例</td>\n</tr>\n<tr>\n<td>适用于设置很多属性</td>\n<td>适用于设置少量属性</td>\n</tr>\n</tbody></table>\n<p>普通属性呢？</p>\n<p> 普通数据类型 引用数据类型 集合数据类型</p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/image-20230317210715447.png\" alt=\"img\"></p>\n<p>一样 也是 set方法 this.age&#x3D;age,然后直接输出age</p>\n<h3 id=\"getBean\"><a href=\"#getBean\" class=\"headerlink\" title=\"getBean\"></a>getBean</h3><p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/image-20230317211005500.png\" alt=\"img\"></p>\n<p>容器中某一类型的Bean有多个–用id</p>\n<p>有一个–用class</p>\n<h3 id=\"区分-BeanFactory-和-ApplicationContext？\"><a href=\"#区分-BeanFactory-和-ApplicationContext？\" class=\"headerlink\" title=\"区分 BeanFactory 和 ApplicationContext？\"></a>区分 BeanFactory 和 ApplicationContext？</h3><table>\n<thead>\n<tr>\n<th><strong>BeanFactory</strong></th>\n<th><strong>ApplicationContext</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>它使用懒加载</td>\n<td>它使用即时加载</td>\n</tr>\n<tr>\n<td>它使用语法显式提供资源对象</td>\n<td>它自己创建和管理资源对象</td>\n</tr>\n<tr>\n<td>不支持国际化</td>\n<td>支持国际化</td>\n</tr>\n<tr>\n<td>不支持基于依赖的注解</td>\n<td>支持基于依赖的注解</td>\n</tr>\n</tbody></table>\n<p>BeanFactory和ApplicationContext的优缺点分析：</p>\n<p>BeanFactory的优缺点：</p>\n<ul>\n<li>优点：应用启动的时候占用资源很少，对资源要求较高的应用，比较有优势；</li>\n<li>缺点：运行速度会相对来说慢一些。而且有可能会出现空指针异常的错误，而且通过Bean工厂创建的Bean生命周期会简单一些。</li>\n</ul>\n<p>ApplicationContext的优缺点：</p>\n<ul>\n<li>优点</li>\n<li>1、启动即加载所有Bean</li>\n<li>2、系统运行的速度快</li>\n<li>3、在系统启动的时候，可以发现系统中的配置问题</li>\n<li>缺点</li>\n<li>1、所有的对象都预加载，缺点就是内存占用较大。</li>\n</ul>\n<h3 id=\"spring提供了哪些配置方式\"><a href=\"#spring提供了哪些配置方式\" class=\"headerlink\" title=\"spring提供了哪些配置方式\"></a>spring提供了哪些配置方式</h3><ul>\n<li>基于 xml 配置</li>\n</ul>\n<p>bean 所需的依赖项和服务在 XML 格式的配置文件中指定。这些配置文件通常包含许多 bean 定义和特定于应用程序的配置选项。它们通常以 bean 标签开头。</p>\n<pre><code class=\"plain\">&lt;bean id=&quot;studentbean&quot; class=&quot;org.edureka.firstSpring.StudentBean&quot;&gt;\n &lt;property name=&quot;name&quot; value=&quot;Edureka&quot;&gt;&lt;/property&gt;\n&lt;/bean&gt;\n</code></pre>\n<ul>\n<li>基于注解配置</li>\n</ul>\n<p>通过在相关的类，方法或字段声明上使用注解，将 bean 配置为组件类本身，而不是使用 XML 来描述 bean 装配。默认情况下，Spring 容器中未打开注解装配。因此需要在使用它之前在 Spring 配置文件中启用它。例如：</p>\n<pre><code class=\"plain\">&lt;beans&gt; \n    &lt;context:annotation-config/&gt; \n    &lt;!-- bean definitions go here --&gt; \n&lt;/beans&gt;\n</code></pre>\n<ul>\n<li>基于 Java API 配置</li>\n</ul>\n<p>Spring 的 Java 配置是通过使用 @Bean 和 @Configuration 来实现。</p>\n<ol>\n<li>@Bean 注解扮演与 <bean> 元素相同的角色。</bean></li>\n<li>@Configuration 类允许通过简单地调用同一个类中的其他 @Bean 方法来定义 bean 间依赖关系。</li>\n</ol>\n<pre><code class=\"plain\">@Configuration\npublic class StudentConfig &#123;\n    @Bean\n    public StudentBean myStudent() &#123;\n        return new StudentBean();\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"AOP工作流程\"><a href=\"#AOP工作流程\" class=\"headerlink\" title=\"AOP工作流程\"></a>AOP工作流程</h2><ol>\n<li>Spring容器启动</li>\n<li>读取切面的所有切入点（没使用的切入点不会形成切面）</li>\n<li>Spring初始化bean，会判断bean对应的类中方法是否匹配到任意切入点，若匹配成功，说明与AOP无关，创建对象；若匹配失败，创建原始对象的代理对象</li>\n<li>获取bean执行方法，若不是代理对象，则与AOP无关，调用方法并执行，完成操作；若是代理对象，则根据代理对象的运行模式运行原始方法与增强的内容，完成操作</li>\n</ol>\n<p>AOP 的底层是通过 Spring 提供的的动态代理技术实现的。在运行期间， Spring通过动态代理技术动态的生成代理对象，代理对象方法执行时进行增强功能的介入，在去调用目标对象的方法，从而完成功能的增强 </p>\n<p>在 spring 中，框架会根据目标类是否实现了接口来决定采用哪种动态代理的方式 </p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/image-20230317214126458.png\" alt=\"img\"></p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/image-20230317214459819.png\" alt=\"img\"></p>\n<p>对切入点Pointcut进行通知也就形成了一个切面</p>\n<p>面向切面编程，将公共的代码逻辑抽象出来变成一个切面，然后注入到目标对象（具体业务）中去，通过动态代理的方式，将需要注入切面的对象进行代理，在进行调用的时候，将公共的逻辑直接添加进去，而不需要修改原有业务的逻辑代码，只需要在原来的业务逻辑基础之上做一些增强功能即可。</p>\n<p>Spring AOP就是基于动态代理的， </p>\n<p>如果要代理的对象，实现了某个接⼝，那么Spring AOP会使（基于代理对象的接口）⽤JDK Proxy，去创建代理对象，⽽对于没有实现接⼝的对象， 会使⽤ Cglib ⽣成⼀个被代理对象的⼦类来作为代理，如下图所示： （基于代理对象的子类）</p>\n<h3 id=\"基于注解的aop开发步骤：\"><a href=\"#基于注解的aop开发步骤：\" class=\"headerlink\" title=\"基于注解的aop开发步骤：\"></a>基于注解的aop开发步骤：</h3><p>① 创建目标接口和目标类（内部有切点）(一个接口 一个实现类)② 创建切面类（内部有增强方法）③ 将目标类和切面类的对象创建权交给 spring（xml 或者 注解）④ 在切面类中使用注解配置织入关系（定义是哪个切面 目标类的方法用的切面类的哪个增强方法）⑤ 在配置文件中开启组件扫描和 AOP 的自动代理⑥ 测试 </p>\n<h3 id=\"AOP-有哪些实现方式？\"><a href=\"#AOP-有哪些实现方式？\" class=\"headerlink\" title=\"AOP 有哪些实现方式？\"></a>AOP 有哪些实现方式？</h3><p>主要分为两大类：</p>\n<ul>\n<li><p>静态代理 - 指使用 AOP 框架提供的命令进行编译，从而在编译阶段就可生成 AOP 代理类，因此也称为编译时增强；</p>\n</li>\n<li><ul>\n<li>编译时编织（特殊编译器实现）</li>\n<li>类加载时编织（特殊的类加载器实现）。</li>\n</ul>\n</li>\n<li><p>动态代理 - 在运行时在内存中“临时”生成 AOP 动态代理类，因此也被称为运行时增强。</p>\n</li>\n<li><ul>\n<li>JDK 动态代理：通过反射来接收被代理的类，并且要求被代理的类必须实现一个接口 。JDK 动态代理的核心是 InvocationHandler 接口和 Proxy 类 。</li>\n<li>CGLIB动态代理： 如果目标类没有实现接口，那么 Spring AOP 会选择使用 CGLIB 来动态代理目标类 。CGLIB （ Code Generation Library ），是一个代码生成的类库，可以在运行时动态的生成某个类的子类，注意， CGLIB 是通过继承的方式做的动态代理，因此如果某个类被标记为 final ，那么它是无法使用 CGLIB 做动态代理的。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Spring-AOP-和-AspectJ-AOP-有什么区别？\"><a href=\"#Spring-AOP-和-AspectJ-AOP-有什么区别？\" class=\"headerlink\" title=\"Spring AOP 和 AspectJ AOP 有什么区别？\"></a>Spring AOP 和 AspectJ AOP 有什么区别？</h3><p>Spring AOP 属于运⾏时增强，⽽ AspectJ 是编译时增强。 </p>\n<h2 id=\"IOC工作流程\"><a href=\"#IOC工作流程\" class=\"headerlink\" title=\"IOC工作流程\"></a>IOC工作流程</h2><p>设计思想 ：原本在程序中⼿动创建对象的控制权，交由Spring框架来管理 </p>\n<p><strong>IoC 容器实际上就是个Map</strong>（key， value） ,Map 中存放的是各种对象。 IoC 容器类似⼯⼚，当需要创建⼀个对象的时候，只需要配置好配置⽂件&#x2F;注解即可</p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/image-20230314005000935.png\" alt=\"img\"></p>\n<p>解析xml注册到beanFactory</p>\n<p>IoC，即控制反转，的核心思想是把对象的管理权限交给容器，应用程序如果需要使用某个对象的实例，直接从IOC容器里获取就可以了。这种设计的好处在于，降低了程序中对象之间的耦合性。</p>\n<p>Spring提供了很多方式声明bean，比如xml、注解等方式去声明。Spring启动时会解析这些bean并保存到IOC容器里</p>\n<ul>\n<li>第一阶段：IOC容器的初始化，这个阶段主要是根据xml或者注解声明的bean，通过解析和加载后生成beanDefinition，包含一些bean的定义属性等，然后把beanDefinition保存到一个map集合里，注册到IOC容器里，从而完成IOC的初始化</li>\n<li>第二阶段：完成bean的初始化和依赖注入。主要有两个操作，一个是通过反射去针对没有设置lazy-init属性的单例bean进行初始化，另一个是完成bean的依赖注入</li>\n<li>第三阶段：使用。通常我们通过@Autowired或者BeanFactory.getBean从IOC获得bean的实例，另外，设置了lazy-init属性，或者非单例bean的实例化，是在每一次获取bean对象的时候，调用bean的初始化方法完成实例化的，IOC不会管理这些bean</li>\n</ul>\n<h2 id=\"bean注入的方式\"><a href=\"#bean注入的方式\" class=\"headerlink\" title=\"bean注入的方式\"></a>bean注入的方式</h2><ol>\n<li>xml方式，Spring容器启动时会加载并解析xml，把bean加载到IOC容器</li>\n<li>@CompontScan注解扫描声明了@Controller、@Service、@Repository、@Component的类</li>\n<li>@Configuration+@Bean</li>\n<li>@Import导入配置类或者普通的bean</li>\n<li>FactoryBean构造bean实例</li>\n<li>ImportBeanDefinition-Registrar接口，可以动态注入bean，这个在Springboot启动类注解里用到了</li>\n<li>ImportSelector接口，动态批量注入配置类、bean对象，在SpringBoot的自动装配机制里用到</li>\n<li>@AutoWired @Qualifier @Resource @Inject</li>\n</ol>\n<h2 id=\"Spring三级缓存解决循环依赖\"><a href=\"#Spring三级缓存解决循环依赖\" class=\"headerlink\" title=\"Spring三级缓存解决循环依赖\"></a>Spring三级缓存解决循环依赖</h2><p>Spring设计了三级缓存来解决循环依赖问题</p>\n<p>第一级缓存里面存储完整的bean实例，这些实例是可以直接被使用的</p>\n<p>第二级缓存里存储的是实例化以后，但是还没有设置属性值的bean实例，也就是依赖注入还没有做</p>\n<p>第三季缓存是用来存放bean工厂，它主要用来生成原始bean对象，并放入二级缓存</p>\n<p>三级缓存的核心思想就是把bean的实例化和bean里面的依赖注入进行分离，采用一级缓存储存完整的bean实例，采用二级缓存存储不完整的bean实例，通过不完整的bean实例作为突破口，解决循环依赖问题，至于第三级缓存，主要解决代理对象的循环依赖问题</p>\n<h2 id=\"如何理解IoC和DI？\"><a href=\"#如何理解IoC和DI？\" class=\"headerlink\" title=\"如何理解IoC和DI？\"></a>如何理解IoC和DI？</h2><p><strong>IOC</strong></p>\n<p>就是控制反转，通俗的说就是我们不用自己创建实例对象，这些都交给Spring的bean工厂帮我们创建管理。</p>\n<p>这也是Spring的核心思想，通过面向接口编程的方式来是实现对业务组件的动态依赖。这就意味着IOC是Spring针对解决程序耦合而存在的。在实际应用中，Spring通过配置文件（xml或者properties）指定需要实例化的java类（类名的完整字符串），包括这些java类的一组初始化值，通过加载读取配置文件，用Spring提供的方法（getBean()）就可以获取到我们想要的根据指定配置进行初始化的实例对象。</p>\n<ul>\n<li>优点：IOC或依赖注入减少了应用程序的代码量。它使得应用程序的测试很简单，因为在单元测试中不再需要单例或JNDI查找机制。简单的实现以及较少的干扰机制使得松耦合得以实现。IOC容器支持勤性单例及延迟加载服务。</li>\n</ul>\n<p><strong>DI：DI—Dependency</strong> Injection，即“依赖注入”：组件之间依赖关系由容器在运行期决定，形象的说，即由容器动态的将某个依赖关系注入到组件之中。依赖注入的目的并非为软件系统带来更多功能，而是为了提升组件重用的频率，并为系统搭建一个灵活、可扩展的平台。通过依赖注入机制，我们只需要通过简单的配置，而无需任何代码就可指定目标需要的资源，完成自身的业务逻辑，而不需要关心具体的资源来自何处，由谁实现。</p>\n<h2 id=\"spring特征\"><a href=\"#spring特征\" class=\"headerlink\" title=\"spring特征\"></a>spring特征</h2><p>核⼼技术 ：依赖注⼊(DI)， AOP，事件(events)，资源， 验证，数据绑定，测试 ： Spring MVC 测试， 数据访问 ：事务， DAO⽀持， JDBC， ORM，XML。Web⽀持 : Spring MVC和Spring WebFlux Web框架。集成 ：远程处理， 电⼦邮件，任务，调度，缓存。</p>\n<h2 id=\"列举⼀些重要的Spring模块？\"><a href=\"#列举⼀些重要的Spring模块？\" class=\"headerlink\" title=\"列举⼀些重要的Spring模块？\"></a>列举⼀些重要的Spring模块？</h2><p>Spring Core： 基础,可以说 Spring 其他所有的功能都需要依赖于该类库。主要提供 IoC 依赖注⼊功能。Spring Aspects ： 该模块为与AspectJ的集成提供⽀持。Spring AOP ：提供了⾯向切⾯的编程实现。Spring JDBC : Java数据库连接。Spring JMS ： Java消息服务。Spring ORM : ⽤于⽀持Hibernate等ORM⼯具。Spring Web : 为创建Web应⽤程序提供⽀持。Spring Test : 提供了对 JUnit 和 TestNG 测试的⽀持。 </p>\n<h2 id=\"Spring-中的-bean-的作⽤域有哪些\"><a href=\"#Spring-中的-bean-的作⽤域有哪些\" class=\"headerlink\" title=\"Spring 中的 bean 的作⽤域有哪些?\"></a>Spring 中的 bean 的作⽤域有哪些?</h2><p>singleton : 唯⼀ bean 实例， Spring 中的 bean 默认都是单例的。prototype : 每次请求都会创建⼀个新的 bean 实例。request : 每⼀次HTTP请求都会产⽣⼀个新的bean，该bean仅在当前HTTP request内有效。session : 每⼀次HTTP请求都会产⽣⼀个新的 bean，该bean仅在当前 HTTP session 内有效。</p>\n<h2 id=\"Spring-中的单例-bean-的线程安全问题了解吗（Threadlocal）？\"><a href=\"#Spring-中的单例-bean-的线程安全问题了解吗（Threadlocal）？\" class=\"headerlink\" title=\"Spring 中的单例 bean 的线程安全问题了解吗（Threadlocal）？\"></a>Spring 中的单例 bean 的线程安全问题了解吗（Threadlocal）？</h2><p>主要是因为当多个线程操作同⼀个对象的时候，对这个对象的⾮静态成员变量的写操作会存在线程安全问题。<strong>常⻅的有两种解决办法：</strong></p>\n<p>在类中定义⼀个ThreadLocal成员变量，将⾮静态成员变量保存在 ThreadLocal 中（推荐的⼀种⽅式）。 作线程隔离</p>\n<h2 id=\"Component-和-Bean-的区别是什么？\"><a href=\"#Component-和-Bean-的区别是什么？\" class=\"headerlink\" title=\"@Component 和 @Bean 的区别是什么？\"></a>@Component 和 @Bean 的区别是什么？</h2><p>@Component 注解作⽤于类，⽽ @Bean 注解作⽤于⽅法。</p>\n<p>@Component 通常是通过类路径扫描⾃动装配到Spring容器中（ @ComponentScan 注解定义要扫描的路径)Spring 的 bean 容器中） </p>\n<p>引⽤第三⽅库中的类需要装配到 Spring 容器时，则只能通过@Bean 来实现 </p>\n<h2 id=\"自动注入\"><a href=\"#自动注入\" class=\"headerlink\" title=\"自动注入\"></a>自动注入</h2><p>resource 按name</p>\n<p>autowired 按类型 +quirfy 按name</p>\n<h2 id=\"将⼀个类声明为Spring的-bean-的注解有哪些\"><a href=\"#将⼀个类声明为Spring的-bean-的注解有哪些\" class=\"headerlink\" title=\"将⼀个类声明为Spring的 bean 的注解有哪些?\"></a>将⼀个类声明为Spring的 bean 的注解有哪些?</h2><p>我们一般使用 @Autowired 注解自动装配 bean，要想把类标识成可用于 @Autowired 注解自动装配的 bean 的类,采用以下注解可实现：</p>\n<ul>\n<li>@Component ：通用的注解，可标注任意类为 Spring 组件。如果一个Bean不知道属于哪个层，可以使用@Component 注解标注。 8 @Repository : 对应持久层即 Dao 层，主要用于数据库相关操作。</li>\n<li>@Service : 对应服务层，主要涉及一些复杂的逻辑，需要用到 Dao层。</li>\n<li>@Controller : 对应 Spring MVC 控制层，主要用户接受用户请求并调用 Service 层返回数据给前端页面。</li>\n</ul>\n<h2 id=\"Spring-中的-bean-⽣命周期\"><a href=\"#Spring-中的-bean-⽣命周期\" class=\"headerlink\" title=\"Spring 中的 bean ⽣命周期?\"></a>Spring 中的 bean ⽣命周期?</h2><p>实例化—-设置属性–前置处理 -init–后置处理–destory方法</p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/image-20230314112152047.png\" alt=\"img\"></p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/image-20230314112157474.png\" alt=\"img\"></p>\n<h4 id=\"创建过程\"><a href=\"#创建过程\" class=\"headerlink\" title=\"创建过程\"></a>创建过程</h4><ul>\n<li><p>1、实例化 Instantiation</p>\n</li>\n<li><ul>\n<li>对于BeanFactory容器，当客户向容器请求一个尚未初始化的bean时，或初始化bean的时候需要注入另一尚未初始化的依赖时，容器会调用createBean进行实例化。</li>\n<li><font color=\"red\">对于ApplicationContext容器，当容器启动结束后，通过获取BeanDefinition对象中的信息，实例化所有的bean。</font></li>\n</ul>\n</li>\n<li><p>2、属性赋值（依赖注入）</p>\n</li>\n<li><ul>\n<li>实例化后的对象被封装在BeanWrapper对象中，Spring根据BeanDefinition中的信息以及通过BeanWrapper提供的设置属性的接口完成属性设置与依赖注入。</li>\n</ul>\n</li>\n<li><p>3、处理Aware接口：可以让我们拿到Spring容器的一些资源：</p>\n</li>\n<li><ul>\n<li>Spring会检测该对象是否实现了xxxAware接口，通过Aware类型的接口，</li>\n<li>① 如果这个Bean实现了BeanNameAware接口，会调用它实现的setBeanName（String beanid）方法，传入Bean的名字；</li>\n<li>② 如果这个Bean实现了BeanClassLoaderAware接口，调用setBeanClassLoader（）方法，传入ClassLoader对象的实例。</li>\n<li>③ 如果这个Bean实现了BeanFactoryAware接口，会调用它是实现的setBeanFactory（）方法，传递的是Spring工厂自身。</li>\n<li>④ 如果这个Bean实现了ApplicationContextAware接口，会调用 setApplicationContext（ApplicationContext）方法，传入Spring上下文；</li>\n</ul>\n</li>\n<li><p>初始化</p>\n</li>\n<li><ul>\n<li>4、调用Aware接口相关的方法：invokeAwareMethod(完成beanName, beanClassLoader, beanFactory对象的属性设置)</li>\n<li>5、调用beanPostProcessor中的前置处理方法postProcessBeforeInitializ（Object obj，String s）</li>\n<li>6、判断是否实现了initializingBean接口，如果有，调用afterPropertiesSet方法，没有就不调用</li>\n<li>6.调用InitMethod方法：invokeInitMethod()</li>\n</ul>\n</li>\n<li><ul>\n<li><ul>\n<li>如果Bean在Spring配置文件中配置了init-method属性，则会自动调用其配置的初始化方法，调用了别的一些方法，也就是回调</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><ul>\n<li>7、调用BeanPostProcessor后置处理方法 。postProcessAfterInitiazation（Object obj，String s）</li>\n</ul>\n</li>\n<li><ul>\n<li><ul>\n<li>Spring 的Aop就是在此处实现的</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>销毁</p>\n</li>\n<li><ul>\n<li>8、DisposableBean当Bean不再需要时，会经过清理阶段，如果Bean实现了DisposableBean这个接口，会调用其实现的destroy（）方法</li>\n<li>9、destory-method如果这个Bean的Spring配置中配置了destroy-method属性，会自动调用其配置的销毁方法，也就是回调</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Spring-MVC-⼯作原理了解吗\"><a href=\"#Spring-MVC-⼯作原理了解吗\" class=\"headerlink\" title=\"Spring MVC ⼯作原理了解吗?\"></a>Spring MVC ⼯作原理了解吗?</h2><p>客户端–request—disoatcherservelt–Handler–HandlerAdapter—由处理器适配器处理业务 返回一个modelandview对象，model返回数据 view视图渲染 返回浏览器</p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/image-20230314112406771.png\" alt=\"img\"></p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/image-20230314112250270.png\" alt=\"img\"></p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/image-20230317212450925.png\" alt=\"img\"></p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/image-20230317212500883.png\" alt=\"img\"></p>\n<p>HandlerMapping负责根据用户请求找到Handler即处理器，</p>\n<p>SpringMVC基于Spring容器，所以在进行SpringMVC操作时，需要将Controller存储到Spring容器中</p>\n<h3 id=\"简单介绍-Spring-MVC-的核心组件\"><a href=\"#简单介绍-Spring-MVC-的核心组件\" class=\"headerlink\" title=\"简单介绍 Spring MVC 的核心组件\"></a>简单介绍 Spring MVC 的核心组件</h3><table>\n<thead>\n<tr>\n<th><strong>组件</strong></th>\n<th><strong>说明</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>DispatcherServlet</td>\n<td>Spring MVC 的核心组件，是请求的入口，负责协调各个组件工作</td>\n</tr>\n<tr>\n<td>MultipartResolver</td>\n<td>内容类型( Content-Type )为 multipart&#x2F;* 的请求的解析器，例如解析处理文件上传的请求，便于获取参数信息以及上传的文件</td>\n</tr>\n<tr>\n<td>HandlerMapping</td>\n<td>请求的处理器匹配器，负责为请求找到合适的 HandlerExecutionChain 处理器执行链，包含处理器（handler）和拦截器们（interceptors）</td>\n</tr>\n<tr>\n<td>HandlerAdapter</td>\n<td>处理器的适配器。因为处理器 handler 的类型是 Object 类型，需要有一个调用者来实现 handler 是怎么被执行。Spring 中的处理器的实现多变，比如用户处理器可以实现 Controller 接口、HttpRequestHandler 接口，也可以用 @RequestMapping 注解将方法作为一个处理器等，这就导致 Spring MVC 无法直接执行这个处理器。所以这里需要一个处理器适配器，由它去执行处理器</td>\n</tr>\n<tr>\n<td>HandlerExceptionResolver</td>\n<td>处理器异常解析器，将处理器（ handler ）执行时发生的异常，解析( 转换 )成对应的 ModelAndView 结果</td>\n</tr>\n<tr>\n<td>RequestToViewNameTranslator</td>\n<td>视图名称转换器，用于解析出请求的默认视图名</td>\n</tr>\n<tr>\n<td>LocaleResolver</td>\n<td>本地化（国际化）解析器，提供国际化支持</td>\n</tr>\n<tr>\n<td>ThemeResolver</td>\n<td>主题解析器，提供可设置应用整体样式风格的支持</td>\n</tr>\n<tr>\n<td>ViewResolver</td>\n<td>视图解析器，根据视图名和国际化，获得最终的视图 View 对象</td>\n</tr>\n<tr>\n<td>FlashMapManager</td>\n<td>FlashMap 管理器，负责重定向时，保存参数至临时存储（默认 Session）</td>\n</tr>\n</tbody></table>\n<p>Spring MVC 对各个组件的职责划分的比较清晰。DispatcherServlet 负责协调，其他组件则各自做分内之事，互不干扰。</p>\n<h2 id=\"什么是-spring-的内部-bean？\"><a href=\"#什么是-spring-的内部-bean？\" class=\"headerlink\" title=\"什么是 spring 的内部 bean？\"></a>什么是 spring 的内部 bean？</h2><p>将 bean 用作另一个 bean 的属性时，才能将 bean 声明为内部 bean，假设我们有一个 Student 类，其中引用了 Person 类，就可以这样。</p>\n<h2 id=\"什么是-spring-装配？\"><a href=\"#什么是-spring-装配？\" class=\"headerlink\" title=\"什么是 spring 装配？\"></a>什么是 spring 装配？</h2><p>当 bean 在 Spring 容器中组合在一起时，它被称为装配或 bean 装配。 Spring 容器需要知道需要什么 bean 以及容器应该如何使用依赖注入来将 bean 绑定在一起，同时装配 bean。</p>\n<p>Spring 容器能够自动装配 bean。也就是说，可以通过检查 BeanFactory 的内容让 Spring 自动解析 bean 的协作者。</p>\n<p>自动装配的不同模式：</p>\n<ul>\n<li><strong>no</strong> - 这是默认设置，表示没有自动装配。应使用显式 bean 引用进行装配。</li>\n<li><strong>byName</strong> - 它根据 bean 的名称注入对象依赖项。它匹配并装配其属性与 XML 文件中由相同名称定义的 bean。</li>\n<li><strong>byType</strong> - 它根据类型注入对象依赖项。如果属性的类型与 XML 文件中的一个 bean 名称匹配，则匹配并装配属性。</li>\n<li><strong>构造函数</strong> - 它通过调用类的构造函数来注入依赖项。它有大量的参数。</li>\n<li><strong>autodetect</strong> - 首先容器尝试通过构造函数使用 autowire 装配，如果不能，则尝试通过 byType 自动装配。</li>\n</ul>\n<h2 id=\"自动装配有什么局限？\"><a href=\"#自动装配有什么局限？\" class=\"headerlink\" title=\"自动装配有什么局限？\"></a>自动装配有什么局限？</h2><ul>\n<li>覆盖的可能性 - 您始终可以使用 <constructor-arg> 和 <property> 设置指定依赖项，这将覆盖自动装配。</property></constructor-arg></li>\n<li>基本元数据类型 - 简单属性（如原数据类型，字符串和类）无法自动装配。</li>\n<li>令人困惑的性质 - 总是喜欢使用明确的装配，因为自动装配不太精确。</li>\n</ul>\n<h2 id=\"Spring中出现同名bean怎么办？\"><a href=\"#Spring中出现同名bean怎么办？\" class=\"headerlink\" title=\"Spring中出现同名bean怎么办？\"></a>Spring中出现同名bean怎么办？</h2><ul>\n<li>同一个配置文件内同名的Bean，以最上面定义的为准</li>\n<li>不同配置文件中存在同名Bean，后解析的配置文件会覆盖先解析的配置文件</li>\n<li>同文件中ComponentScan和@Bean出现同名Bean。同文件下@Bean的会生效，@ComponentScan扫描进来不会生效。通过@ComponentScan扫描进来的优先级是最低的，原因就是它扫描进来的Bean定义是最先被注册的~</li>\n</ul>\n<h2 id=\"Spring-怎么解决循环依赖问题？\"><a href=\"#Spring-怎么解决循环依赖问题？\" class=\"headerlink\" title=\"Spring 怎么解决循环依赖问题？\"></a>Spring 怎么解决循环依赖问题？</h2><p>spring对循环依赖的处理有三种情况： </p>\n<p>①构造器的循环依赖：这种依赖spring是处理不了的，直 接抛出BeanCurrentlylnCreationException异常。</p>\n<p>②单例模式下的setter循环依赖：通过“三级缓存”处理循环依赖。 </p>\n<p>③非单例循环依赖：无法处理。</p>\n<p><strong>所以只针对2</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/image-20230318003242035.png\" alt=\"img\"></p>\n<p>spring对象实例三步</p>\n<p>（1）createBeanInstance：实例化，其实也就是调用对象的构造方法实例化对象</p>\n<p>（2）populateBean：填充属性，这一步主要是多bean的依赖属性进行填充</p>\n<p>（3）initializeBean：调用spring xml中的init 方法。</p>\n<p>三级缓存（对应上面进行哪一步了）</p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/image-20230318003344460.png\" alt=\"img\"></p>\n<p>A的某个field或者setter依赖了B的实例对象，同时B的某个field或者setter依赖了A的实例对象”这种循环依赖的情况。</p>\n<ol>\n<li>A首先完成了初始化的第一步（createBeanINstance实例化），并且将自己提前曝光到singletonFactories（三级缓存）中。</li>\n<li>此时进行初始化的第二步，发现自己依赖对象B，此时就尝试去get(B)，发现B还没有被create，所以走create流程，B在初始化第一步的时候发现自己依赖了对象A，于是尝试get(A)，尝试一级缓存singletonObjects(肯定没有，因为A还没初始化完全)，尝试二级缓存earlySingletonObjects（也没有），尝试三级缓存singletonFactories，由于A通过ObjectFactory将自己提前曝光了，所以B能够通过ObjectFactory.getObject拿到A对象(虽然A还没有初始化完全，但是总比没有好呀)，B拿到A对象后顺利完成了初始化阶段1、2、3，完全初始化之后将自己放入到一级缓存singletonObjects中。</li>\n<li>此时返回A中，A此时能拿到B的对象顺利完成自己的初始化阶段2、3，最终A也完成了初始化，进去了一级缓存singletonObjects中，而且更加幸运的是，由于B拿到了A的对象引用，所以B现在hold住的A对象完成了初始化。</li>\n</ol>\n<h2 id=\"Spring-中的单例-bean-的线程安全问题？\"><a href=\"#Spring-中的单例-bean-的线程安全问题？\" class=\"headerlink\" title=\"Spring 中的单例 bean 的线程安全问题？\"></a>Spring 中的单例 bean 的线程安全问题？</h2><p>当多个用户同时请求一个服务时，容器会给每一个请求分配一个线程，这时多个线程会并发执行该请求对应的业务逻辑（成员方法），此时就要注意了，如果该处理逻辑中有对单例状态的修改（体现为该单例的成员属性），则必须考虑线程同步问题。 <strong>线程安全问题都是由全局变量及静态变量引起的。</strong> 若每个线程中对全局变量、静态变量只有读操作，而无写操作，一般来说，这个全局变量是线程安全的；若有多个线程同时执行写操作，一般都需要考虑线程同步，否则就可能影响线程安全.</p>\n<p><strong>无状态bean和有状态bean</strong></p>\n<ul>\n<li>有状态就是有数据存储功能。有状态对象(Stateful Bean)，就是有实例变量的对象，可以保存数据，是非线程安全的。在不同方法调用间不保留任何状态。</li>\n<li>无状态就是一次操作，不能保存数据。无状态对象(Stateless Bean)，就是没有实例变量的对象 .不能保存数据，是不变类，是线程安全的。</li>\n</ul>\n<p>在spring中无状态的Bean适合用不变模式，就是单例模式，这样可以共享实例提高性能。有状态的Bean在多线程环境下不安全，适合用Prototype原型模式。 Spring使用ThreadLocal解决线程安全问题。如果你的Bean有多种状态的话（比如 View Model 对象），就需要自行保证线程安全 。</p>\n<h2 id=\"Spring-框架中⽤到了哪些设计模式？\"><a href=\"#Spring-框架中⽤到了哪些设计模式？\" class=\"headerlink\" title=\"Spring 框架中⽤到了哪些设计模式？\"></a>Spring 框架中⽤到了哪些设计模式？</h2><p>⼯⼚设计模式 : Spring使⽤⼯⼚模式通过 <strong>BeanFactory</strong> 、 <strong>ApplicationContext</strong>(应用上下文) 创建 bean 对象。代理设计模式 : Spring AOP 功能（动态代理）的实现。单例设计模式 : Spring 中的 Bean 默认都是单例的。包装器设计模式 : 我们的项⽬需要连接多个数据库，⽽且不同的客户在每次访问中根据需要会去访问不同的数据库。这种模式让我们可以根据客户的需求能够动态切换不同的数据源。观察者模式: Spring 事件驱动模型就是观察者模式很经典的⼀个应⽤。(消息队列的发布订阅)适配器模式 :Spring AOP 的增强或通知(Advice)使⽤到了适配器模式、 spring MVC 中也是⽤到了适配器模式适配 Controller 。 </p>\n<h2 id=\"Spring-事务\"><a href=\"#Spring-事务\" class=\"headerlink\" title=\"Spring 事务\"></a>Spring 事务</h2><p>PlatformTransactionManager ：是 spring 的事务管理器，它里面提供了我们常用的操作事务的方法 getTransaction commit rollback</p>\n<h3 id=\"Spring-管理事务的⽅式有⼏种？\"><a href=\"#Spring-管理事务的⽅式有⼏种？\" class=\"headerlink\" title=\"Spring 管理事务的⽅式有⼏种？\"></a>Spring 管理事务的⽅式有⼏种？</h3><p>编程式事务，在代码中硬编码。 (不推荐使⽤)声明式事务，在配置⽂件中配置（推荐使⽤） （分为基于xml 和基于注解）</p>\n<p>声明式作用：事务管理不侵入开发的组件 事务管理是属于系统层面的服务，而不是业务逻辑的一部分 在不需要事务管理的时候，只要在设定文件上修改一下，即可移去事务管理服务，无需改变代码重新编译，这样维护起来极其方便</p>\n<p>注意： <strong>Spring 声明式事务控制底层就是AOP。</strong></p>\n<p>基于xml</p>\n<p> 平台事务管理器配置 事务通知的配置 事务aop织入的配置 </p>\n<p><strong>基于注解</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/image-20230317221224522.png\" alt=\"img\"></p>\n<p> 平台事务管理器配置（xml方式） 事务通知的配置（@Transactional注解配置） 事务注解驱动的配置 tx:annotation-driven&#x2F;</p>\n<h3 id=\"Spring-事务中的隔离级别有哪⼏种\"><a href=\"#Spring-事务中的隔离级别有哪⼏种\" class=\"headerlink\" title=\"Spring 事务中的隔离级别有哪⼏种?\"></a>Spring 事务中的隔离级别有哪⼏种?</h3><p>1、使⽤后端数据库默认的隔离级别 </p>\n<p>2、读未提交</p>\n<p>3、读已提交</p>\n<p>4、可重复读</p>\n<p>5、串行化（将严重影响程序的性能 ）</p>\n<h3 id=\"Spring框架的事务管理有哪些优点？\"><a href=\"#Spring框架的事务管理有哪些优点？\" class=\"headerlink\" title=\"Spring框架的事务管理有哪些优点？\"></a>Spring框架的事务管理有哪些优点？</h3><ul>\n<li>它提供了跨不同事务api（如JTA、JDBC、Hibernate、JPA和JDO）的一致编程模型。</li>\n<li>它为编程事务管理提供了比JTA等许多复杂事务API更简单的API。</li>\n<li>它支持声明式事务管理。</li>\n<li>它很好地集成了Spring的各种数据访问抽象。</li>\n</ul>\n<h3 id=\"Spring-事务中哪⼏种事务传播⾏为\"><a href=\"#Spring-事务中哪⼏种事务传播⾏为\" class=\"headerlink\" title=\"Spring 事务中哪⼏种事务传播⾏为?\"></a>Spring 事务中哪⼏种事务传播⾏为?</h3><p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/image-20230317220702593.png\" alt=\"img\"></p>\n<p><strong>⽀持当前事务的情况 ：</strong></p>\n<p>如果当前存在事务 加入该事务，否则（1、创建⼀个新的事务 2、以⾮事务的⽅式继续运⾏ 3、抛出异常）</p>\n<p><strong>不⽀持当前事务 ：</strong></p>\n<p>把当前事务挂起 然后：</p>\n<p>1、创建⼀个新的事务 2、以⾮事务的⽅式继续运⾏ 3、抛出异常</p>\n<h3 id=\"Spring-事务传播行为\"><a href=\"#Spring-事务传播行为\" class=\"headerlink\" title=\"Spring 事务传播行为\"></a>Spring 事务传播行为</h3><ul>\n<li>1.TransactionDefinition.PROPAGATION_REQUIRED如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。</li>\n<li>2.TransactionDefinition.PROPAGATION_REQUIRES_NEW创建一个新的事务，如果当前存在事务，则把当前事务挂起。</li>\n<li>3.TransactionDefinition.PROPAGATION_NESTED如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于默认的</li>\n<li>4.TransactionDefinition.PROPAGATION_MANDATORY如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。</li>\n<li>5 TransactionDefinition.PROPAGATION_SUPPORTS: 如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。</li>\n<li>6 TransactionDefinition.PROPAGATION_NOT_SUPPORTED: 以非事务方式运行，如果当前存在事务，则把当前事务挂起。</li>\n<li>7 TransactionDefinition.PROPAGATION_NEVER: 以非事务方式运行，如果当前存在事务，则抛出异常。</li>\n</ul>\n<h3 id=\"spring事务不生效的场景\"><a href=\"#spring事务不生效的场景\" class=\"headerlink\" title=\"spring事务不生效的场景\"></a>spring事务不生效的场景</h3><p><img src=\"https://cdn.nlark.com/yuque/0/2023/webp/226907/1684915047847-3921a115-8de1-4131-acbb-975573911a50.webp\" alt=\"img\"></p>\n<h4 id=\"1、spring框架配置\"><a href=\"#1、spring框架配置\" class=\"headerlink\" title=\"1、spring框架配置\"></a>1、spring框架配置</h4><h5 id=\"你的service类没有被Spring管理\"><a href=\"#你的service类没有被Spring管理\" class=\"headerlink\" title=\"你的service类没有被Spring管理\"></a>你<strong>的service类没有被Spring管理</strong></h5><p>@Service注解注释之后，spring事务（@Transactional）没有生效，因为Spring事务是由AOP机制实现的，也就是说从Spring IOC容器获取bean时，Spring会为目标类创建代理，来支持事务的。但是@Service被注释后，你的service类都不是spring管理的，<strong>那怎么创建代理类来支持事务呢</strong>。</p>\n<h4 id=\"2、AOP代理\"><a href=\"#2、AOP代理\" class=\"headerlink\" title=\"2、AOP代理\"></a>2、AOP代理</h4><h5 id=\"事务方法被final、static关键字修饰\"><a href=\"#事务方法被final、static关键字修饰\" class=\"headerlink\" title=\"事务方法被final、static关键字修饰\"></a><strong>事务方法被final、static关键字修饰</strong></h5><p>如果一个方法被声明为final或者static，则该方法不能被子类重写，也就是说无法在该方法上进行动态代理，这会导致Spring无法生成事务代理对象来管理事务。</p>\n<h5 id=\"同一个类中，方法内部调用\"><a href=\"#同一个类中，方法内部调用\" class=\"headerlink\" title=\"同一个类中，方法内部调用\"></a>同一个类中，方法内部调用</h5><p><strong>事务不生效的原因</strong>: 事务是通过Spring AOP代理来实现的，而在同一个类中，一个方法调用另一个方法时，<strong>调用方法直接调用目标方法的代码，而不是通过代理类进行调用</strong>。即以上代码，调用目标executeAddTianLuo方法不是通过代理类进行的，因此事务不生效。</p>\n<h5 id=\"方法的访问权限不是public\"><a href=\"#方法的访问权限不是public\" class=\"headerlink\" title=\"方法的访问权限不是public\"></a>方法的访问权限不是public</h5><p>spring事务方法addTianLuo的访问权限不是public，所以事务就不生效啦，因为Spring事务是由AOP机制实现的，AOP机制的本质就是动态代理，而代理的事务方法不是public的话，computeTransactionAttribute()就会返回null，也就是这时事务属性不存在了。</p>\n<h4 id=\"3、-数据库的存储引擎不支持事务\"><a href=\"#3、-数据库的存储引擎不支持事务\" class=\"headerlink\" title=\"3、 数据库的存储引擎不支持事务\"></a>3、 数据库的存储引擎不支持事务</h4><p>Spring事务的底层，还是依赖于数据库本身的事务支持。在MySQL中，MyISAM存储引擎是不支持事务的，InnoDB引擎才支持事务。因此开发阶段设计表的时候，<strong>确认你的选择的存储引擎是支持事务的</strong>。</p>\n<h4 id=\"4、Transational配置问题\"><a href=\"#4、Transational配置问题\" class=\"headerlink\" title=\"4、Transational配置问题\"></a>4、Transational配置问题</h4><h5 id=\"4-1-事务超时时间设置过短\"><a href=\"#4-1-事务超时时间设置过短\" class=\"headerlink\" title=\"4.1 事务超时时间设置过短\"></a>4.1 事务超时时间设置过短</h5><pre><code class=\"plain\">@Transactional(timeout = 1)\npublic void doSomething() &#123;\n    //...\n&#125;\n复制代码\n</code></pre>\n<ul>\n<li><strong>事务不生效的原因</strong>：在上面的例子中，timeout属性被设置为1秒，这意味着如果事务在1秒内无法完成，则报事务超时了。</li>\n</ul>\n<h5 id=\"4-2-使用了错误的事务传播机制\"><a href=\"#4-2-使用了错误的事务传播机制\" class=\"headerlink\" title=\"4.2 使用了错误的事务传播机制\"></a>4.2 使用了错误的事务传播机制</h5><pre><code class=\"plain\">@Service\npublic class TianLuoServiceImpl &#123;\n \n    @Autowired\n    private TianLuoMapper tianLuoMapper;\n    @Autowired\n    private TianLuoFlowMapper tianLuoFlowMapper;\n \n    @Transactional(propagation = Propagation.NOT_SUPPORTED)\n    public  void doInsertTianluo(TianLuo tianluo) throws Exception &#123;\n        tianLuoMapper.save(tianluo);\n        tianLuoFlowMapper.saveFlow(buildFlowByTianLuo(tianluo));\n    &#125;\n&#125;\n复制代码\n</code></pre>\n<ul>\n<li><strong>事务不生效的原因</strong>：Propagation.NOT_SUPPORTED传播特性不支持事务。</li>\n<li><strong>解决方案</strong>：选择正确的事务传播机制。</li>\n</ul>\n<h4 id=\"5-事务多线程调用\"><a href=\"#5-事务多线程调用\" class=\"headerlink\" title=\"5 事务多线程调用\"></a>5 事务多线程调用</h4><p><strong>事务失效原因</strong>：这是因为Spring事务是基于线程绑定的，<strong>每个线程都有自己的事务上下文</strong>，而多线程环境下可能会存在多个线程共享同一个事务上下文的情况，导致事务失效。Spring事务管理器通过使用线程本地变量（ThreadLocal）来实现线程安全。大家有兴趣的话，可以去看下源码哈.</p>\n<p>在Spring事务管理器中，通过TransactionSynchronizationManager类来管理事务上下文。TransactionSynchronizationManager内部维护了一个ThreadLocal对象，用来存储当前线程的事务上下文。在事务开始时，TransactionSynchronizationManager会将事务上下文绑定到当前线程的ThreadLocal对象中，当事务结束时，TransactionSynchronizationManager会将事务上下文从ThreadLocal对象中移除。</p>\n<h3 id=\"Controller-注解有什么用？\"><a href=\"#Controller-注解有什么用？\" class=\"headerlink\" title=\"@Controller 注解有什么用？\"></a>@Controller 注解有什么用？</h3><p>标记一个类为 Spring Web MVC <strong>控制器</strong> Controller，springmvc扫描到有该注解的类，然后这个类有@RequestMapping注解的方法，为这个方法生成一个处理器对象</p>\n<h3 id=\"RequestMapping-注解有什么用？\"><a href=\"#RequestMapping-注解有什么用？\" class=\"headerlink\" title=\"@RequestMapping 注解有什么用？\"></a>@RequestMapping 注解有什么用？</h3><p>将请求和方法进行映射，可以作用于类也可以作用于方法，作用于类的话一般就是控制器URI前缀、</p>\n<h3 id=\"RestController-和-Controller-有什么区别？\"><a href=\"#RestController-和-Controller-有什么区别？\" class=\"headerlink\" title=\"@RestController 和 @Controller 有什么区别？\"></a>@RestController 和 @Controller 有什么区别？</h3><p>@RestController &#x3D;@Controller + @ResponseBody ，更加适合目前前后端分离的架构下，提供 Restful API ，返回例如 JSON 数据格式。</p>\n<p>当然，返回什么样的数据格式，根据客户端的 ACCEPT 请求头来决定。</p>\n<h3 id=\"RequestMapping-和-GetMapping-注解的不同之处在哪里？\"><a href=\"#RequestMapping-和-GetMapping-注解的不同之处在哪里？\" class=\"headerlink\" title=\"@RequestMapping 和 @GetMapping 注解的不同之处在哪里？\"></a>@RequestMapping 和 @GetMapping 注解的不同之处在哪里？</h3><ol>\n<li>@RequestMapping：可注解在类和方法上；@GetMapping 仅可注册在方法上</li>\n<li>@RequestMapping： GET、POST、PUT、DELETE 等请求方法都可以用@GetMapping 是 @RequestMapping 的 GET 请求方法的特例，目的是为了提高区分度。</li>\n</ol>\n<h3 id=\"RequestParam-和-PathVariable-两个注解的区别\"><a href=\"#RequestParam-和-PathVariable-两个注解的区别\" class=\"headerlink\" title=\"@RequestParam 和 @PathVariable 两个注解的区别\"></a>@RequestParam 和 @PathVariable 两个注解的区别</h3><p>两个注解都用于方法参数，获取参数值的方式不同，@RequestParam 注解的参数从请求携带的参数中获取（请求头），而 @PathVariable 注解从请求的 URI 中（？后面的参数）</p>\n<p>参数绑定注解@requestParam </p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/image-20230317213825953.png\" alt=\"img\"></p>\n<h3 id=\"RestController-vs-Controller\"><a href=\"#RestController-vs-Controller\" class=\"headerlink\" title=\"@RestController vs @Controller\"></a>@RestController vs @Controller</h3><p>@Controller 返回⼀个⻚⾯ </p>\n<p>只返回视图 属于⽐较传统的Spring MVC 的应⽤，对应于前后端不分离的情况 </p>\n<p>@RestController 返回JSON 或 XML 形式数据 </p>\n<p>只返回对象，以 JSON 或 XML 形式写⼊ Response中，（前后端分离）。 </p>\n<p>@Controller +@ResponseBody &#x3D;@RestController </p>\n<p><strong>@ResponseBody</strong>  ：Controller 的⽅法返回的对象通过适当的转换器转换为指定的格式（json xml）之后，写⼊到HTTP 响应(Response)对象的 body 中， </p>\n<h3 id=\"restful\"><a href=\"#restful\" class=\"headerlink\" title=\"restful\"></a>restful</h3><p> GET：用于获取资源 POST：用于新建资源 PUT：用于更新资源 DELETE：用于删除资源 </p>\n<h3 id=\"返回-JSON-格式使用什么注解？\"><a href=\"#返回-JSON-格式使用什么注解？\" class=\"headerlink\" title=\"返回 JSON 格式使用什么注解？\"></a>返回 JSON 格式使用什么注解？</h3><p><strong>@ResponseBody</strong> 注解，or <strong>@RestController</strong>(ResponseBody+Controller)</p>\n<h3 id=\"Transactional-rollbackFor-x3D-Exception-class-注解了解吗？\"><a href=\"#Transactional-rollbackFor-x3D-Exception-class-注解了解吗？\" class=\"headerlink\" title=\"@Transactional(rollbackFor &#x3D; Exception.class)注解了解吗？\"></a>@Transactional(rollbackFor &#x3D; Exception.class)注解了解吗？</h3><p>当 @Transactional 注解作⽤于类上时，该类的所有 public ⽅法将都具有该类型的事务属性，如果类或者⽅法加了这个注解，那么这个类⾥⾯的⽅法抛出异常，就会回滚，数据库⾥⾯的数据也会回滚。</p>\n<p>如果不配置 rollbackFor 属性,那么事物只会在遇到 RuntimeException 的时候才会回滚,加上 rollbackFor&#x3D;Exception.class ,可以让事物在遇到⾮运⾏时异常时也回滚。</p>\n<h3 id=\"注解开发\"><a href=\"#注解开发\" class=\"headerlink\" title=\"注解开发\"></a>注解开发</h3><p>替代xml里面的配置 xml里面一个个都是容器 然后注入就是拿容器返回的值（getBean）</p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/image-20230317211552909.png\" alt=\"img\"></p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/image-20230317211721760.png\" alt=\"img\"></p>\n<p>获取容器 ——也就是获取上下文</p>\n<pre><code class=\"plain\">ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;bean.xml&quot;);\nIAccountService as = ac.getBean(&quot;accountService&quot;,IAccountService.class);\n</code></pre>\n<h2 id=\"什么是springmvc拦截器以及如何使用它？\"><a href=\"#什么是springmvc拦截器以及如何使用它？\" class=\"headerlink\" title=\"什么是springmvc拦截器以及如何使用它？\"></a>什么是springmvc拦截器以及如何使用它？</h2><p>Spring的处理程序映射机制包括处理程序拦截器，当你希望将特定功能应用于某些请求时，例如，检查用户主题时，这些拦截器非常有用。拦截器必须实现org.springframework.web.servlet包的HandlerInterceptor。此接口定义了三种方法：</p>\n<ul>\n<li>preHandle：在执行实际处理程序之前调用。</li>\n<li>postHandle：在执行完实际程序之后调用。</li>\n<li>afterCompletion：在完成请求后调用。</li>\n</ul>\n<h2 id=\"Spring-MVC-和-Struts2-的异同？\"><a href=\"#Spring-MVC-和-Struts2-的异同？\" class=\"headerlink\" title=\"Spring MVC 和 Struts2 的异同？\"></a>Spring MVC 和 Struts2 的异同？</h2><p><strong>入口</strong>不同</p>\n<ul>\n<li>Spring MVC 的入门是一个 Servlet <strong>控制器</strong>。</li>\n<li>Struts2 入门是一个 Filter <strong>过滤器</strong>。</li>\n</ul>\n<p><strong>配置映射</strong>不同，</p>\n<ul>\n<li>Spring MVC 是基于<strong>方法</strong>开发，传递参数是通过<strong>方法形参</strong>，一般设置为<strong>单例</strong>。</li>\n<li>Struts2 是基于<strong>类</strong>开发，传递参数是通过<strong>类的属性</strong>，只能设计为<strong>多例</strong>。</li>\n</ul>\n<p><strong>视图</strong>不同</p>\n<ul>\n<li>Spring MVC 通过参数解析器是将 Request 对象内容进行解析成方法形参，将响应数据和页面封装成 <strong>ModelAndView</strong> 对象，最后又将模型数据通过 <strong>Request</strong> 对象传输到页面。其中，如果视图使用 JSP 时，默认使用 <strong>JSTL</strong> 。</li>\n<li>Struts2 采用<strong>值栈</strong>存储请求和响应的数据，通过 <strong>OGNL</strong> 存取数据。</li>\n</ul>\n<h2 id=\"REST\"><a href=\"#REST\" class=\"headerlink\" title=\"REST\"></a>REST</h2><h3 id=\"REST-代表着什么\"><a href=\"#REST-代表着什么\" class=\"headerlink\" title=\"REST 代表着什么?\"></a><a href=\"https://www.javalearn.cn/#/doc/Spring/%E9%9D%A2%E8%AF%95%E9%A2%98?id=_35-rest-%E4%BB%A3%E8%A1%A8%E7%9D%80%E4%BB%80%E4%B9%88\">REST 代表着什么?</a></h3><p>REST 代表着抽象状态转移，它是根据 HTTP 协议从客户端发送数据到服务端，例如：服务端的一本书可以以 XML 或 JSON 格式传递到客户端</p>\n<h2 id=\"什么是安全的-REST-操作\"><a href=\"#什么是安全的-REST-操作\" class=\"headerlink\" title=\"什么是安全的 REST 操作?\"></a><a href=\"https://www.javalearn.cn/#/doc/Spring/%E9%9D%A2%E8%AF%95%E9%A2%98?id=_36-%E4%BB%80%E4%B9%88%E6%98%AF%E5%AE%89%E5%85%A8%E7%9A%84-rest-%E6%93%8D%E4%BD%9C\">什么是安全的 REST 操作?</a></h2><p>REST 接口是通过 HTTP 方法完成操作</p>\n<ul>\n<li>GET 和 HEAD 安全，因为它不能在服务端修改资源</li>\n<li>PUT、POST 和 DELETE 是不安全的，因为他们能修改服务端的资源</li>\n</ul>\n<p>所以，是否安全的界限，在于<strong>是否修改</strong>服务端的资源</p>\n<h3 id=\"REST-API-是无状态的吗\"><a href=\"#REST-API-是无状态的吗\" class=\"headerlink\" title=\"REST API 是无状态的吗?\"></a><a href=\"https://www.javalearn.cn/#/doc/Spring/%E9%9D%A2%E8%AF%95%E9%A2%98?id=_37-rest-api-%E6%98%AF%E6%97%A0%E7%8A%B6%E6%80%81%E7%9A%84%E5%90%97\">REST API 是无状态的吗?</a></h3><p><strong>是的</strong>，REST API 应该是无状态的，因为它是基于 HTTP 的，它也是无状态的</p>\n<p>REST API 中的请求应该包含处理它所需的所有细节。它<strong>不应该</strong>依赖于以前或下一个请求或服务器端维护的一些数据，例如会话</p>\n<p><strong>REST 规范为使其无状态设置了一个约束，在设计 REST API 时，你应该记住这一点</strong></p>\n<h3 id=\"REST安全吗-你能做什么来保护它\"><a href=\"#REST安全吗-你能做什么来保护它\" class=\"headerlink\" title=\"REST安全吗? 你能做什么来保护它?\"></a><a href=\"https://www.javalearn.cn/#/doc/Spring/%E9%9D%A2%E8%AF%95%E9%A2%98?id=_38-rest%E5%AE%89%E5%85%A8%E5%90%97-%E4%BD%A0%E8%83%BD%E5%81%9A%E4%BB%80%E4%B9%88%E6%9D%A5%E4%BF%9D%E6%8A%A4%E5%AE%83\">REST安全吗? 你能做什么来保护它?</a></h3><p>安全是一个宽泛的术语。它可能意味着消息的安全性，这是通过认证和授权提供的加密或访问限制提供的</p>\n<p>REST 通常不是安全的，需要开发人员自己实现安全机制</p>\n<h2 id=\"补充\"><a href=\"#补充\" class=\"headerlink\" title=\"补充\"></a>补充</h2><h3 id=\"spring中出现异步调用的方式？\"><a href=\"#spring中出现异步调用的方式？\" class=\"headerlink\" title=\"spring中出现异步调用的方式？\"></a>spring中出现异步调用的方式？</h3><p>1、注解（我项目里面用的）</p>\n<p>配置类上加上@EnableAsync启动异步调用，使用了@Async标记的异步方法，可以带参可以带返回值</p>\n<p>返回值必须以下类型：</p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/image-20230410171205483.png\" alt=\"img\"></p>\n<p>2、内置线程池</p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/image-20230410171626618.png\" alt=\"img\"></p>\n<p>3、自定义线程池</p>\n","categories":["八股"]},{"title":"位运算","url":"/2023/06/04/%E4%BD%8D%E8%BF%90%E7%AE%97/","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>x&gt;&gt;y &#x3D;》 x➗2^y 右移</p>\n<p>x&gt;&gt;y &#x3D;》 x × 2^y 左移 &#x3D;这个地方可以用来做2的幂次运算 比如 1&gt;&gt;x就是 求 2^x的值<span id=\"more\"></span></p>\n<h2 id=\"比特位计数\"><a href=\"#比特位计数\" class=\"headerlink\" title=\"比特位计数\"></a>比特位计数</h2><p>给你一个整数 n ，对于 0 &lt;&#x3D; i &lt;&#x3D; n 中的每个 i ，计算其二进制表示中 <strong>1</strong> <strong>的个数</strong> ，返回一个长度为 n + 1 的数组 ans 作为答案。</p>\n<p>前沿知识：</p>\n<p>1、Brian Kernighan 算法原理：对于任意整数 x，令 x&#x3D;x &amp; (x−1)，该运算将 x 的二进制表示的最后一个 1 变成 0</p>\n<p>2、如果正整数 y是 2 的整数次幂，则 y的二进制表示中只有最高位是 1，其余都是 0，因此 y &amp; (y−1)&#x3D;0 ；</p>\n<p>3、对于正整数 x，将其二进制表示右移一位，等价于将其二进制表示的最低位去掉，得到的数是 ⌊x➗2⌋</p>\n<p><strong>方法四：动态规划——最低设置位</strong></p>\n<p>直接用第一条知识</p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/image-20220930205258719.png\" alt=\"img\"></p>\n<pre><code class=\"plain\">class Solution &#123;\n    public int[] countBits(int n) &#123;\n        int[] bits = new int[n + 1];\n        for (int i = 1; i &lt;= n; i++) &#123;\n            bits[i] = bits[i &amp; (i - 1)] + 1;\n        &#125;\n        return bits;\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"只出现一次数字\"><a href=\"#只出现一次数字\" class=\"headerlink\" title=\"只出现一次数字\"></a>只出现一次数字</h2><p>题目：给定一个<strong>非空</strong>整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/image-20220901155150280.png\" alt=\"img\"></p>\n<p>答案：</p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/image-20220901155229412.png\" alt=\"img\"></p>\n<p><strong>总结：异或运算：不同为1 相同为0</strong></p>\n<p>Leetcode报错 error：＜identifier＞ expected：原因是在定义<strong>方法</strong>的时候，在方法参数列表没有声明参数的类型，或者是方法参数列表写错，比如我就犯了如下错误：</p>\n<p>public boolean check(char[][] board, boolean[][] visited, int i, int, j, String s, int k)</p>\n<p>自己一直没发现，而且Idea的比较文件也没有发现，idea比较文件方法，选中两个文件，右键compare files （ctrl+D）</p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/202306031846302.png\" alt=\"img\"></p>\n<h2 id=\"无额外空间交换两个数\"><a href=\"#无额外空间交换两个数\" class=\"headerlink\" title=\"无额外空间交换两个数\"></a>无额外空间交换两个数</h2><pre><code class=\"plain\">int x = 5;\nint y = 10;\nx = x ^ y;\ny = x ^ y;\nx = x ^ y;\n//其实就是  y = x ^ y ^ y , x = y ^ x ^ x\n</code></pre>\n<p>第二种方法利用了异或运算的性质：</p>\n<ul>\n<li>相同的两个数异或结果为0</li>\n<li>任何数与0异或结果还是其自身</li>\n<li>异或运算满足交换律和结合律</li>\n</ul>\n<h2 id=\"根据数字二进制下-1-的数目排序\"><a href=\"#根据数字二进制下-1-的数目排序\" class=\"headerlink\" title=\"根据数字二进制下 1 的数目排序\"></a>根据数字二进制下 1 的数目排序</h2><p>给你一个整数数组 arr 。请你将数组中的元素按照其二进制表示中数字 <strong>1</strong> 的数目升序排序。</p>\n<p>如果存在多个数字二进制中 <strong>1</strong> 的数目相同，则必须将它们按照数值大小升序排列。</p>\n<p>请你返回排序后的数组。</p>\n<p>题解：</p>\n<p>用到了x&amp;&amp;(x-1)去除x最后一个0（二进制）</p>\n<p>stream流不会写 这个比较器必须会！</p>\n<pre><code class=\"plain\">class Solution &#123;\n    public int[] sortByBits(int[] arr) &#123;\n        Collections.sort(list, new Comparator&lt;Integer&gt;() &#123;\n            public int compare(Integer x, Integer y) &#123;\n                if (cntInt(x) != cntInt(y)) &#123;\n                    return cntInt(x) - cntInt(y);\n                &#125; else &#123;\n                    return x - y;\n                &#125;\n            &#125;\n        &#125;);\n        for (int i = 0; i &lt; arr.length; ++i) &#123;\n            arr[i] = list.get(i);\n        &#125;\n        return arr;\n    &#125;\n    \n    private int cntInt(int val)&#123;\n        int count = 0;\n        while(val &gt; 0) &#123;\n            val = val &amp; (val - 1);\n            count ++;\n        &#125;\n\n        return count;\n    &#125;    \n    //也可以这么写\n    /**\n        public int get(int x) &#123;\n        int res = 0;\n        while (x != 0) &#123;\n            res += x % 2;\n            x /= 2;\n        &#125;\n        return res;\n    &#125;\n    **/\n\n&#125;\n</code></pre>\n","categories":["算法"]},{"title":"二叉树","url":"/2023/06/04/%E4%BA%8C%E5%8F%89%E6%A0%91/","content":"<h2 id=\"相关知识\"><a href=\"#相关知识\" class=\"headerlink\" title=\"相关知识\"></a>相关知识</h2><p>完全二叉树： 从满二叉树最后一个结点往前删除</p>\n<p>二叉搜索树：左小右大 带数值<span id=\"more\"></span></p>\n<p>平衡二叉搜索树：AVL 高度差值小于2</p>\n<p>存储方式：数组 链式 <strong>如果父节点的数组下标是 i，那么它的左孩子就是 i</strong> ***** <strong>2 + 1，右孩子就是 i</strong> ***** <strong>2 + 2。</strong>想012就行</p>\n<p>遍历方式：深度：前中后 迭代 递归 栈</p>\n<p>​\t\t\t\t 广度 层次 迭代 队列</p>\n<p>定义：</p>\n<pre><code class=\"plain\">public class TreeNode &#123;\n     int val;\n     TreeNode left;\n     TreeNode right;\n     TreeNode() &#123;&#125;\n     TreeNode(int val) &#123; this.val = val; &#125;\n     TreeNode(int val, TreeNode left, TreeNode right) &#123;\n             this.val = val;\n             this.left = left;\n             this.right = right;\n     &#125;\n &#125;\n</code></pre>\n<p>二叉排序<a href=\"http://data.biancheng.net/view/313.html\">树</a>（Binary Sort Tree，简称 BST ）又叫二叉查找树和二叉搜索树，是一种实现动态查找表的树形存储结构。</p>\n<ul>\n<li>节点的左子树仅包含键 <strong>小于</strong> 节点键的节点。</li>\n<li>节点的右子树仅包含键 <strong>大于</strong> 节点键的节点。</li>\n<li>左右子树也必须是二叉搜索树。<strong>递归思路：</strong></li>\n</ul>\n<ol>\n<li><strong>确定递归函数的参数和返回值：</strong> 确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数， 并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。</li>\n<li><strong>确定终止条件：</strong> 写完了递归算法, 运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对，操作系统也是用一个栈的结构来保存每一层递归的信息，如果递归没有终止，操作系统的内存栈必然就会溢出。</li>\n<li><strong>确定单层递归的逻辑：</strong> 确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程。</li>\n</ol>\n<h2 id=\"对称二叉树\"><a href=\"#对称二叉树\" class=\"headerlink\" title=\"对称二叉树\"></a>对称二叉树</h2><p>给你一个二叉树的根节点 root ， 检查它是否轴对称。</p>\n<p>我们可以实现这样一个递归函数，通过「同步移动」两个指针的方法来遍历这棵树，p指针和 q 指针一开始都指向这棵树的根，随后 p 右移时，q 左移 p 左移时，q 右移。每次检查当前 p 和 q 节点的值是否相等，如果相等再判断左右子树是否对称。</p>\n<pre><code class=\"plain\">class Solution &#123;\n     public boolean isSymmetric(TreeNode root) &#123;\n         return check(root, root);\n     &#125;\n \n     public boolean check(TreeNode p, TreeNode q) &#123;\n         if (p == null &amp;&amp; q == null) &#123;\n             return true;\n         &#125;\n         if (p == null || q == null) &#123;\n             return false;\n         &#125;\n         return p.val == q.val &amp;&amp; check(p.left, q.right) &amp;&amp; check(p.right, q.left);     \n     &#125;\n &#125;\n</code></pre>\n<h2 id=\"二叉树的最大深度\"><a href=\"#二叉树的最大深度\" class=\"headerlink\" title=\"二叉树的最大深度\"></a>二叉树的最大深度</h2><p>给定一个二叉树，找出其最大深度。 二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p>\n<pre><code class=\"plain\">class Solution &#123;\n     public int maxDepth(TreeNode root) &#123;\n         if (root == null) &#123;\n             return 0;\n         &#125; else &#123;\n             int leftHeight = maxDepth(root.left);\n             int rightHeight = maxDepth(root.right);\n             return Math.max(leftHeight, rightHeight) + 1;\n         &#125;\n     &#125;\n &#125;\n \n //return root == null ? 0 : Math.max(this.maxDepth(root.left), this.maxDepth(root.right)) + 1;\npublic int maxDepth (TreeNode root) &#123;\n         // write code here\n         if(root==null) return 0;\n         return Math.max(maxDepth(root.left),maxDepth(root.right))+1;\n     &#125;\n</code></pre>\n<h2 id=\"二叉树最小深度\"><a href=\"#二叉树最小深度\" class=\"headerlink\" title=\"二叉树最小深度\"></a>二叉树最小深度</h2><p>给定一个二叉树，找出其最小深度。</p>\n<p>最小深度是从根节点到最近叶子节点的最短路径上的节点数量。（注意这里 和求最大深度不一样）</p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/20210203155800503.png\" alt=\"img\"></p>\n<pre><code class=\"plain\">class Solution &#123;\n     public int minDepth(TreeNode root) &#123;\n         if (root == null) return 0;\n         //这两个else if 很重要 就是为了防止出现上图所示情况\n         else if (root.left == null) return minDepth(root.right) + 1;\n         else if (root.right == null) return minDepth(root.left) + 1;\n         else return Math.min(minDepth(root.left), minDepth(root.right)) + 1;\n     &#125;\n &#125;\n</code></pre>\n<h2 id=\"完全二叉树的节点个数-×\"><a href=\"#完全二叉树的节点个数-×\" class=\"headerlink\" title=\"完全二叉树的节点个数(×)\"></a>完全二叉树的节点个数(×)</h2><p>给你一棵 <strong>完全二叉树</strong> 的根节点 root ，求出该树的节点个数。</p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/image-20221029171009163.png\" alt=\"img\"></p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/image-20221031151200655.png\" alt=\"img\"></p>\n<pre><code class=\"plain\">class Solution &#123;\n     public int countNodes(TreeNode root) &#123;\n         if(root == null) &#123;\n             return 0;\n         &#125;\n         int left = countNodes(root.left);\n         int right = countNodes(root.right);\n         \n         return left+right+1;\n         \n     &#125;\n &#125;\n</code></pre>\n<p>遍历树来统计节点是一种时间复杂度为 O(n) 的简单解决方案。你可以设计一个更快的算法吗</p>\n<pre><code class=\"plain\">class Solution &#123;\n     public int countNodes(TreeNode root) &#123;\n         if (root == null) &#123;\n             return 0;\n         &#125;\n         int level = 0;\n         TreeNode node = root;\n         //去最下左结点  记录下结点和层数\n         while (node.left != null) &#123;\n             level++;\n             node = node.left;\n         &#125;\n         //          2^level\n         //当 0≤i&lt;h 时，第 i层包含 2^i 个节点，最底层包含的节点数最少为 1，最多为 2^h。\n         int low = 1 &lt;&lt; level, high = (1 &lt;&lt; (level + 1)) - 1;\n         while (low &lt; high) &#123;\n             // 这一句一用就会超时  原因是防止溢出，可能出现两者相加超过int表示范围\n             int mid = (high - low + 1) / 2 + low;\n             if (exists(root, level, mid)) &#123;\n                 low = mid;\n             &#125; else &#123;\n                 high = mid - 1;\n             &#125;\n         &#125;\n         return low;\n     &#125;\n     bits:1000-&gt; 100&gt; 10 &gt;1\n     k:1100 右 左 左   \n     public boolean exists(TreeNode root, int level, int k) &#123;\n         int bits = 1 &lt;&lt; (level - 1);\n         TreeNode node = root;\n         while (node != null &amp;&amp; bits &gt; 0) &#123;\n             if ((bits &amp; k) == 0) &#123;\n                 node = node.left;\n             &#125; else &#123;\n                 node = node.right;\n             &#125;\n             bits &gt;&gt;= 1;\n         &#125;\n         return node != null;\n     &#125;\n &#125;\n</code></pre>\n<h2 id=\"二叉树的所有路径\"><a href=\"#二叉树的所有路径\" class=\"headerlink\" title=\"二叉树的所有路径\"></a>二叉树的所有路径</h2><p>给你一个二叉树的根节点 root ，按 <strong>任意顺序</strong> ，返回所有从根节点到叶子节点的路径。</p>\n<p><strong>叶子节点</strong> 是指没有子节点的节点。</p>\n<pre><code class=\"plain\">//我写的 那就选这个！\n class Solution &#123;\n     List&lt;String&gt; ans=new ArrayList&lt;&gt;();\n     public List&lt;String&gt; binaryTreePaths(TreeNode root) &#123;\n         StringBuilder sb=new StringBuilder();\n         dfs(root,sb);\n         return ans;\n     &#125;\n     public void dfs(TreeNode root, StringBuilder sb)&#123;\n         if(root==null) return;\n         if(sb.length()==0)&#123;\n             sb.append(root.val);\n         &#125;else&#123;\n             sb.append(&quot;-&gt;&quot;).append(root.val);\n         &#125;\n         if(root.left==null&amp;&amp;root.right==null)&#123;\n             ans.add(sb.toString());\n             return;\n         &#125;\n         //注意这里 一定要new StringBuilder 递归左子树之后再传入右子树的sb已经变成左子树的路径了，因此不能用sb了，而应该把前面sb的值copy来\n         dfs(root.left,new StringBuilder(sb)); \n         dfs(root.right,new StringBuilder(sb));\n \n     &#125;\n &#125;\n//还有一种方法，就是回溯。\n     private void dfs(TreeNode root, StringBuilder cur, List&lt;String&gt; paths) &#123;\n         if (root == null) return;\n         if (root.left == null &amp;&amp; root.right == null) &#123;\n             paths.add(cur.toString() + root.val);\n             return;\n         &#125;\n         int sz = cur.length();\n         cur.append(root.val).append(&quot;-&gt;&quot;);\n         dfs(root.left, cur);\n         dfs(root.right, cur);\n         cur.delete(sz, cur.length());//在这里已经定义了dfs的回溯，因此dfs(root.left, cur);执行完毕就已经是回溯的了，也就不会影响        dfs(root.right, cur);的路径了！ 完美！\n     &#125;\n</code></pre>\n<h2 id=\"平衡二叉树\"><a href=\"#平衡二叉树\" class=\"headerlink\" title=\"平衡二叉树\"></a>平衡二叉树</h2><p>给定一个二叉树，判断它是否是高度平衡的二叉树。</p>\n<p>本题中，一棵高度平衡二叉树定义为：一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1 。</p>\n<p><strong>方法一：自顶向下的递归</strong>（选这个）</p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/image-20221101131731698.png\" alt=\"img\"></p>\n<pre><code class=\"plain\">class Solution &#123;\n     public boolean isBalanced(TreeNode root) &#123;\n         if(root==null) return true;\n         //这个&amp;&amp;开始没想到 根节点高度满足还需要后面节点也都是如此  \n         return Math.abs(getDepth(root.right)-getDepth(root.left))&lt;2&amp;&amp;isBalanced(root.right)&amp;&amp;isBalanced(root.left);\n     &#125;\n     public int getDepth(TreeNode root)&#123;\n         if(root==null) return 0;\n         return Math.max(getDepth(root.left),getDepth(root.right))+1;\n     &#125;\n &#125;\n O(n^2)\n</code></pre>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/image-20221101131921565.png\" alt=\"img\"></p>\n<pre><code class=\"plain\">class Solution &#123;\n     public boolean isBalanced(TreeNode root) &#123;\n         return height(root) &gt;= 0;\n     &#125;\n \n     public int height(TreeNode root) &#123;\n         if (root == null) &#123;\n             return 0;\n         &#125;\n         int leftHeight = height(root.left);\n         int rightHeight = height(root.right);\n         if (leftHeight == -1 || rightHeight == -1 || Math.abs(leftHeight - rightHeight) &gt; 1) &#123;\n             return -1;\n         &#125; else &#123;\n             return Math.max(leftHeight, rightHeight) + 1;\n         &#125;\n     &#125;\n &#125;\n O(n)\n     自底向上的递归就是及时止损 自顶向下的递归就是不管三七二十一先把所有的高度算一遍\n</code></pre>\n<h2 id=\"左叶子之和\"><a href=\"#左叶子之和\" class=\"headerlink\" title=\"左叶子之和\"></a>左叶子之和</h2><p>题目：计算二叉树左叶子的和</p>\n<p>左叶子 是节点的左节点不为空且左节点的左右节点都为空 </p>\n<p>1、出口：节点空或者节点无子节点</p>\n<p>2、判断为左节点 加到ans</p>\n<pre><code class=\"plain\">//我的题解 我选择用自己的\n class Solution &#123;\n     int ans=0;\n     public int sumOfLeftLeaves(TreeNode root) &#123;\n         dfs(root);\n         return ans;\n     &#125;\n     public void dfs(TreeNode root)&#123;\n         //出口\n         if(root==null||(root.left==null&amp;&amp;root.right==null)) return;\n         //左节点存在且为叶节点\n         if(root.left!=null&amp;&amp;root.left.left==null&amp;&amp;root.left.right==null)&#123;\n             ans+=root.left.val;\n         &#125;\n         //递归到左右节点\n         dfs(root.left);\n         dfs(root.right);\n     &#125;\n &#125;\n</code></pre>\n<h2 id=\"找树左下角的值\"><a href=\"#找树左下角的值\" class=\"headerlink\" title=\"找树左下角的值\"></a>找树左下角的值</h2><p>给定一个二叉树的 <strong>根节点</strong>root，请找出该二叉树的 <strong>最底层 最左边</strong> 节点的值。</p>\n<p>假设二叉树中至少有一个节点。</p>\n<pre><code class=\"plain\">class Solution &#123;\n     //维护当前树高度和值\n     int curval=0;\n     int curheight=0;\n     public int findBottomLeftValue(TreeNode root) &#123;\n         dfs(root,0);\n         return curval;\n     &#125;\n     public void dfs(TreeNode root,int height)&#123;\n         if(root==null) return;\n         height++;//向下递归一层加一\n         //也就是说到最深高度且先遍历左边就能保证找到了左下角的节点值\n         if(height&gt;curheight)&#123;\n             curheight=height;\n             curval=root.val;\n         &#125;\n         //因为是先左后右 相同高度左边结点优先遍历到\n         //这个想法没问题 但是int数据表示范围32位有限 出现内存溢出 所以还是Left在前\n         \n         // if(height==curheight)&#123;\n         //     Math.min(curval,root.val);\n         // &#125;\n         dfs(root.left,height);\n         dfs(root.right,height);\n \n     &#125;\n &#125;\n</code></pre>\n<h2 id=\"路径总和\"><a href=\"#路径总和\" class=\"headerlink\" title=\"路径总和\"></a>路径总和</h2><p>给你二叉树的根节点 root 和一个表示目标和的整数 targetSum 。判断该树中是否存在 <strong>根节点到叶子节点</strong> 的路径，这条路径上所有节点值相加等于目标和 targetSum 。如果存在，返回 true ；否则，返回 false 。</p>\n<pre><code class=\"plain\">class Solution &#123;\n    //有待改进 需要剪枝。。。 因为就算找到targetSum==0 递归还在继续\n     boolean ans=false;\n     public boolean hasPathSum(TreeNode root, int targetSum) &#123;\n         dfs(root,targetSum);\n         return ans;\n     &#125;\n     public void dfs(TreeNode root,int targetSum)&#123;\n         if(root==null) return;\n         targetSum=targetSum-root.val;\n         if(root.left==null&amp;&amp;root.right==null)&#123;\n             if(targetSum==0)&#123;\n                 ans=true;\n                 return;\n             &#125;\n         &#125;\n         dfs(root.left,targetSum);\n         dfs(root.right,targetSum);\n     &#125;\n &#125;\n</code></pre>\n<p>官方题解：简洁！</p>\n<pre><code class=\"plain\">class Solution &#123;\n     public boolean hasPathSum(TreeNode root, int sum) &#123;\n         if (root == null) &#123;\n             return false;\n         &#125;\n         //递归到最后一层   最后只需要判断sum==root.val就行\n         if (root.left == null &amp;&amp; root.right == null) &#123;\n             return sum == root.val;\n         &#125;\n         //一直递归到最后一层  sum - root.val（传参到sum）一直在减少\n         return hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val);\n     &#125;\n &#125;\n</code></pre>\n<h2 id=\"从中序与后序遍历序列构造二叉树\"><a href=\"#从中序与后序遍历序列构造二叉树\" class=\"headerlink\" title=\"从中序与后序遍历序列构造二叉树\"></a>从中序与后序遍历序列构造二叉树</h2><p>给定两个整数数组 inorder 和 postorder ，其中 inorder 是二叉树的中序遍历， postorder 是同一棵树的后序遍历，请你构造并返回这颗 <em>二叉树</em> 。</p>\n<pre><code class=\"plain\">class Solution &#123;\n     int post_idx;\n     int[] postorder;\n     int[] inorder;\n     Map&lt;Integer, Integer&gt; idx_map = new HashMap&lt;Integer, Integer&gt;();\n     \n     public TreeNode buildTree(int[] inorder, int[] postorder) &#123;\n         this.postorder = postorder;\n         this.inorder = inorder;\n         // 从后序遍历的最后一个元素开始\n         post_idx = postorder.length - 1;\n \n         // 建立（元素，下标）键值对的哈希表\n         int idx = 0;\n         for (Integer val : inorder) &#123;\n             idx_map.put(val, idx++);\n         &#125;\n         \n         return helper(0, inorder.length - 1);\n     &#125;\n     \n     public TreeNode helper(int in_left, int in_right) &#123;\n         // 如果这里没有节点构造二叉树了，就结束\n         if (in_left &gt; in_right) &#123;\n             return null;\n         &#125;\n \n         // 选择 post_idx 位置的元素作为当前子树根节点\n         int root_val = postorder[post_idx];\n         TreeNode root = new TreeNode(root_val);\n         // 根据 root 所在位置分成左右两棵子树\n         int index = idx_map.get(root_val);\n         // 下标减一\n         post_idx--;\n         // 构造右子树\n         root.right = helper(index + 1, in_right);\n         // 构造左子树\n         root.left = helper(in_left, index - 1);\n         return root;\n     &#125;\n \n &#125;\n</code></pre>\n<h2 id=\"最大二叉树\"><a href=\"#最大二叉树\" class=\"headerlink\" title=\"最大二叉树\"></a>最大二叉树</h2><p>给定一个不重复的整数数组 nums 。 <strong>最大二叉树</strong> 可以用下面的算法从 nums 递归地构建:</p>\n<ol>\n<li>创建一个根节点，其值为 nums 中的最大值。</li>\n<li>递归地在最大值 <strong>左边</strong> 的 <strong>子数组前缀上</strong> 构建左子树。</li>\n<li>递归地在最大值 <strong>右边</strong> 的 <strong>子数组后缀上</strong> 构建右子树。</li>\n</ol>\n<p>返回 <em>nums</em> <em>构建的</em><em><strong>最大二叉树</strong></em>**** 。</p>\n<p><strong>递归</strong></p>\n<pre><code class=\"plain\">//我最初的解法\n class Solution &#123;\n     int[] nums;\n     public TreeNode constructMaximumBinaryTree(int[] nums) &#123;\n         this.nums=nums;\n         return buildTreee(0,nums.length-1);\n     &#125;\n     public TreeNode buildTreee(int left,int right)&#123;\n         if(left&gt;right) return null;\n         int index=getMaxNumIndex(left,right);\n         TreeNode root=new TreeNode(nums[index]);\n         root.left=buildTreee(left,index-1);\n         root.right=buildTreee(index+1,right);\n         return root;\n     &#125;\n     public int getMaxNumIndex(int left,int right)&#123;\n         int max=Integer.MIN_VALUE;\n         int index=0;\n         for(int i=left;i&lt;=right;i++)&#123;\n             if(nums[i]&gt;max)&#123;\n                 max=nums[i];\n                 index=i;\n             &#125;\n         &#125;\n         return index;\n     &#125;\n &#125;\n //优化后\n class Solution &#123;\n     int[] nums;\n     public TreeNode constructMaximumBinaryTree(int[] nums) &#123;\n         this.nums=nums;\n         return buildTreee(0,nums.length-1);\n     &#125;\n     public TreeNode buildTreee(int left,int right)&#123;\n         if(left&gt;right) return null;\n         int best=left;\n         for (int i = left + 1; i &lt;= right; ++i) &#123;\n             if (nums[i] &gt; nums[best]) &#123;\n                 best = i;\n             &#125;\n         &#125;\n         TreeNode root=new TreeNode(nums[best]);\n         root.left=buildTreee(left,best-1);\n         root.right=buildTreee(best+1,right);\n         return root;\n     &#125;\n &#125;\n</code></pre>\n<p><strong>单调栈</strong></p>\n<h2 id=\"验证二叉搜索树\"><a href=\"#验证二叉搜索树\" class=\"headerlink\" title=\"验证二叉搜索树\"></a>验证二叉搜索树</h2><p>给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。</p>\n<p><strong>有效</strong> 二叉搜索树定义如下：</p>\n<ul>\n<li>节点的左子树只包含 <strong>小于</strong> 当前节点的数。</li>\n<li>节点的右子树只包含 <strong>大于</strong> 当前节点的数。</li>\n<li>所有左子树和右子树自身必须也是二叉搜索树。</li>\n</ul>\n<pre><code class=\"plain\">class Solution &#123;\n     public boolean isValidBST(TreeNode root) &#123;\n         return dfs(root,Long.MIN_VALUE,Long.MAX_VALUE);\n     &#125;\n     public boolean dfs(TreeNode root,long l,long r)&#123;\n         if(root==null) return true;\n         if(root.val&lt;=l||root.val&gt;=r) return false;\n         return dfs(root.left,l,root.val)&amp;&amp;dfs(root.right,root.val,r);\n     &#125;\n &#125;\n</code></pre>\n<h2 id=\"二叉搜索树的最小绝对差\"><a href=\"#二叉搜索树的最小绝对差\" class=\"headerlink\" title=\"二叉搜索树的最小绝对差\"></a>二叉搜索树的最小绝对差</h2><pre><code class=\"plain\">class Solution &#123;\n     int ans=Integer.MAX_VALUE;\n     public int getMinimumDifference(TreeNode root) &#123;\n         dfs(root);\n         return ans;\n     &#125;\n     public void dfs(TreeNode root)&#123;\n         if(root==null) return;\n         //我的题解：寻找左子树里最大值和右子树里面最小值 然后同根节点做差求Min\n         //左子树里最大值就是左孩子的最右结点 右子树同理\n         TreeNode node_l=root.left,node_r=root.right;\n         while(node_l!=null&amp;&amp;node_l.right!=null)&#123;\n             node_l=node_l.right;\n         &#125;\n         while(node_r!=null&amp;&amp;node_r.left!=null)&#123;\n             node_r=node_r.left;\n         &#125;\n         int l=node_l==null?Integer.MAX_VALUE:root.val-node_l.val;\n         int r=node_r==null?Integer.MAX_VALUE:node_r.val-root.val;\n         ans=Math.min(Math.min(l,r),ans);\n         dfs(root.left);\n         dfs(root.right);\n     &#125;\n &#125;\n</code></pre>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/image-20221104202039345.png\" alt=\"img\"></p>\n<pre><code class=\"plain\">class Solution &#123;\n     int pre;\n     int ans;\n     public int getMinimumDifference(TreeNode root) &#123;\n         ans = Integer.MAX_VALUE;\n         pre = -1;\n         dfs(root);\n         return ans;\n     &#125;\n     public void dfs(TreeNode root) &#123;\n         if (root == null) &#123;\n             return;\n         &#125;\n         //中序 左根右  有序\n         //只需要计算相邻结点差值的最小值就可\n         dfs(root.left);\n         if (pre == -1) &#123;\n             pre = root.val;\n         &#125; else &#123;\n             ans = Math.min(ans, root.val - pre);\n             pre = root.val;\n         &#125;\n         dfs(root.right);\n     &#125;\n &#125;\n 优雅！！！！！！！！\n</code></pre>\n<h2 id=\"二叉搜索树中的众数\"><a href=\"#二叉搜索树中的众数\" class=\"headerlink\" title=\"二叉搜索树中的众数\"></a>二叉搜索树中的众数</h2><p>给你一个含重复值的二叉搜索树（BST）的根节点 root ，找出并返回 BST 中的所有 <a href=\"https://baike.baidu.com/item/%E4%BC%97%E6%95%B0/44796\">众数</a>（即，出现频率最高的元素）。</p>\n<p>如果树中有不止一个众数，可以按 <strong>任意顺序</strong> 返回。</p>\n<p>假定 BST 满足如下定义：</p>\n<ul>\n<li>结点左子树中所含节点的值 <strong>小于等于</strong> 当前节点的值</li>\n<li>结点右子树中所含节点的值 <strong>大于等于</strong> 当前节点的值</li>\n<li>左子树和右子树都是二叉搜索树</li>\n</ul>\n<p>我的思路：</p>\n<p>哈希表 dfs遍历结点 map存储结点以及结点出现个数，然后每个entrySet取value 打擂台的方式，最后得出最大的value以及key 然后根据value再遍历一次 看看有无相等的 有就加入结果集List but不想实现。。。。。</p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/image-20221106213939182.png\" alt=\"img\"></p>\n<pre><code class=\"plain\">class Solution &#123;\n     //记录众数\n     List&lt;Integer&gt; answer=new ArrayList&lt;&gt;();\n     //  当前数字 出现个数   最大出现个数\n     int base,count,maxcount;\n \n     public int[] findMode(TreeNode root) &#123;\n         dfs(root);\n         int[] ans=new int[answer.size()];\n         for(int i=0;i&lt;answer.size();i++)&#123;\n             ans[i]=answer.get(i);\n         &#125;\n         return ans;\n     &#125;\n     public void dfs(TreeNode root)&#123;\n     //中序遍历 使得递增顺序\n         if(root==null) return;\n         dfs(root.left);\n         update(root.val);\n         dfs(root.right);\n     &#125;\n     public void update(int val)&#123;\n         if(val==base)&#123;\n             count++;\n         &#125;else&#123;\n             count=1;\n             base=val;\n         &#125;\n         if(count==maxcount)&#123;\n             answer.add(val);\n         &#125;\n         if(count&gt;maxcount)&#123;\n             answer.clear();\n             maxcount=count;\n             answer.add(val);\n         &#125;\n     &#125;\n &#125;\n</code></pre>\n<h2 id=\"二叉树前序遍历\"><a href=\"#二叉树前序遍历\" class=\"headerlink\" title=\"二叉树前序遍历\"></a>二叉树前序遍历</h2><p><strong>递归</strong>（本质栈）</p>\n<pre><code class=\"plain\">class Solution &#123;\n     public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123;\n         List&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;();\n         preorder(root, res);\n         return res;\n     &#125;\n \n     public void preorder(TreeNode root, List&lt;Integer&gt; res) &#123;\n         if (root == null) &#123;\n             return;\n         &#125;\n         res.add(root.val);\n         preorder(root.left, res);\n         preorder(root.right, res);\n     &#125;\n &#125;\n</code></pre>\n<p><strong>迭代</strong>（利用栈）</p>\n<pre><code class=\"plain\">class Solution &#123;\n     public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123;\n         List&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;();\n         if (root == null) &#123;\n             return res;\n         &#125;\n \n         Deque&lt;TreeNode&gt; stack = new LinkedList&lt;TreeNode&gt;();\n         TreeNode node = root;\n         //结束条件：栈为空且node为Null\n         while (!stack.isEmpty() || node != null) &#123;\n             //到达最左\n             while (node != null) &#123;\n                 res.add(node.val);\n                 stack.push(node);\n                 node = node.left;\n             &#125;\n             //到达最左后，node为Null，此时要出栈（也就是返回父结点）\n             node = stack.pop();\n             //遍历右结点\n             node = node.right;\n         &#125;\n         return res;\n     &#125;\n &#125;\n</code></pre>\n<p><strong>Morris 遍历</strong></p>\n<p><a href=\"https://blog.csdn.net/liujia2115/article/details/109215284\">https://blog.csdn.net/liujia2115/article/details/109215284</a></p>\n<pre><code class=\"plain\">class Solution &#123;\n     public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123;\n         return morrisMethod(root);\n     &#125;\n \n     /**\n      * Morris遍历\n      * @param root\n      * @return\n      */\n     private List&lt;Integer&gt; morrisMethod(TreeNode root) &#123;\n         List&lt;Integer&gt; list = new ArrayList&lt;&gt;();\n         if (root == null) &#123;\n             return list;\n         &#125;\n         TreeNode cur = root;\n         TreeNode mostRight = null;\n         while (cur != null) &#123;\n             mostRight = cur.left;\n             if (mostRight != null) &#123; \n                 //左子树最右结点 mostRight.right != cur防止循环回去了\n                 while (mostRight.right != null &amp;&amp; mostRight.right != cur) &#123;\n                     mostRight = mostRight.right;\n                 &#125;\n                 //第一次来\n                 if (mostRight.right == null) &#123;\n                     mostRight.right = cur;\n                     list.add(cur.val); // 第一次到的时候打印\n                     cur = cur.left;\n                     continue;\n                 &#125; else &#123;//第二次来\n                     mostRight.right = null; // 第二次到的时候不打印\n                 &#125;\n             &#125; else &#123; // cur.left为空 直接add cur的值\n                 list.add(cur.val);\n             &#125;\n             cur = cur.right;\n             &#125;\n         return list;\n     &#125;\n &#125;\n</code></pre>\n<p>morris中序遍历就是在第一次到的时候不打印 第二次到的时候打印 list.add(cur.val);移到 mostRight.right &#x3D; null; 后面</p>\n<h2 id=\"合并二叉树\"><a href=\"#合并二叉树\" class=\"headerlink\" title=\"合并二叉树\"></a>合并二叉树</h2><p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/image-20221009174111479.png\" alt=\"img\"></p>\n<pre><code class=\"plain\">class Solution &#123;\n     public TreeNode mergeTrees(TreeNode root1, TreeNode root2) &#123;\n         if(root1 == null) return root2;\n         if(root2 == null) return root1;\n         TreeNode merged = new TreeNode(root1.val + root2.val);//返回结点\n         merged.left=mergeTrees(root1.left, root2.left);//构造左边是啥\n         merged.right=mergeTrees(root1.right, root2.right);//构造右边是啥\n         return merged;\n     &#125;\n &#125;\n</code></pre>\n<h2 id=\"二叉搜索数转累加数\"><a href=\"#二叉搜索数转累加数\" class=\"headerlink\" title=\"二叉搜索数转累加数\"></a>二叉搜索数转累加数</h2><p>给出二叉 搜索 树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），使每个节点 node 的新值等于原树中大于或等于 node.val 的值之和。</p>\n<pre><code class=\"plain\">class Solution &#123;\n     int sum = 0;\n     public TreeNode convertBST(TreeNode root) &#123;\n         dfs(root);\n         return root;\n     &#125;\n     void dfs(TreeNode node) &#123;\n         if (node == null) return;\n         dfs(node.right);\n         sum += node.val;\n         node.val = sum;\n         dfs(node.left);\n     &#125;\n &#125;\n</code></pre>\n<p>我对于本题递归的理解：dfs(node.right)直接递归到最右下结点，sum&#x3D;最右下结点的值，赋给最右下结点值， dfs(node.left); 判断为空 return出来</p>\n<p>dfs(node.right)执行完毕，进入上一递归，此时为上一层根结点，然后sum +&#x3D; node.val;node.val &#x3D; sum;此时算的是根结点的累加值，同理，dfs(node.left)；</p>\n<p>递归不要人肉递归，还是要套模板，只需要关注<img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/image-20221007210341362.png\" alt=\"img\"></p>\n<p>这一部分内容就行，让变量具有普适性</p>\n<h2 id=\"二叉树遍历题和二叉树展开为链表题的对比（均为迭代）\"><a href=\"#二叉树遍历题和二叉树展开为链表题的对比（均为迭代）\" class=\"headerlink\" title=\"二叉树遍历题和二叉树展开为链表题的对比（均为迭代）\"></a>二叉树遍历题和二叉树展开为链表题的对比（均为迭代）</h2><p>做二叉树首先要想到用递归（and迭代）</p>\n<pre><code class=\"plain\">二叉树遍历\n class Solution &#123;\n     public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123;\n         List&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;();\n         Deque&lt;TreeNode&gt; stk = new LinkedList&lt;TreeNode&gt;();\n         while (root != null || !stk.isEmpty()) &#123;\n             while (root != null) &#123;\n                 stk.push(root);\n                 root = root.left;\n             &#125;\n             root = stk.pop();\n             res.add(root.val);\n             root = root.right;\n         &#125;\n         return res;\n     &#125;\n &#125;\n 二叉树展开为链表\n     class Solution &#123;\n         //同中序遍历的题进行对比\n         public void flatten(TreeNode root) &#123;\n             List&lt;TreeNode&gt; list = new ArrayList&lt;&gt;();\n             Deque&lt;TreeNode&gt; stk = new LinkedList&lt;&gt;();\n             while (root != null || !stk.isEmpty()) &#123;\n                 while (root != null) &#123;\n                     list.add(root);//和中序比较多了这一行\n                     stk.push(root);\n                     root = root.left;\n                 &#125;\n                 root = stk.pop();\n                 //少了一行list.add(root.val);\n                 root = root.right;\n             &#125;\n             int size = list.size();\n             for (int i = 1; i &lt; size; i++) &#123;\n                 TreeNode pre = list.get(i - 1), cur = list.get(i);\n                 pre.left = null;\n                 pre.right = cur;\n             &#125;\n \n         &#125;\n</code></pre>\n<h2 id=\"二叉树的最近公共祖先\"><a href=\"#二叉树的最近公共祖先\" class=\"headerlink\" title=\"二叉树的最近公共祖先\"></a>二叉树的最近公共祖先</h2><p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/image-20220919202400688.png\" alt=\"img\"></p>\n<pre><code class=\"plain\">*/\n class Solution &#123;\n     private TreeNode ans;\n     public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123;\n //        TreeNode ans=null;   //这一句不能有，有的话，ans=root就无法覆盖ans的值，ans=root只能识别到 private TreeNode ans;   如果有的话 下面必须return this.ans才行 把外面的引进来作为成员变量\n         dfs(root,p,q);\n         return ans;//想引用外面的变量需要加this.\n     &#125;\n     private boolean dfs(TreeNode root, TreeNode p, TreeNode q)&#123;\n         if(root==null) return false;\n         boolean lson=dfs(root.left,p,q);//这里必须加数据类型呀，因为lson rson第一次出现，都没初始化呢，要指定其数据类型\n         boolean rson=dfs(root.right,p,q);\n         if((lson&amp;&amp;rson)||(p.val==root.val||q.val==root.val)&amp;&amp;(lson||rson))&#123;\n             ans=root;\n             System.out.println(ans);\n         &#125;\n         return root.val==p.val||root.val==q.val||lson||rson;\n     &#125;\n &#125;\n</code></pre>\n<h2 id=\"二叉搜索树最近公共祖先\"><a href=\"#二叉搜索树最近公共祖先\" class=\"headerlink\" title=\"二叉搜索树最近公共祖先\"></a>二叉搜索树最近公共祖先</h2><p>方法一：不用二叉搜索树的性质，直接用二叉树的也可以过。</p>\n<p><strong>方法二：一次遍历</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/image-20221107120758813.png\" alt=\"img\"></p>\n<pre><code class=\"plain\">class Solution &#123;\n     public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123;\n         TreeNode ancestor = root;\n         while (true) &#123;\n             if (p.val &lt; ancestor.val &amp;&amp; q.val &lt; ancestor.val) &#123;\n                 ancestor = ancestor.left;\n             &#125; else if (p.val &gt; ancestor.val &amp;&amp; q.val &gt; ancestor.val) &#123;\n                 ancestor = ancestor.right;\n             &#125; else &#123;\n                 break;\n             &#125;\n         &#125;\n         return ancestor;\n     &#125;\n &#125;\n</code></pre>\n<h2 id=\"二叉搜索树中的插入操作\"><a href=\"#二叉搜索树中的插入操作\" class=\"headerlink\" title=\"二叉搜索树中的插入操作\"></a>二叉搜索树中的插入操作</h2><p>给定二叉搜索树（BST）的根节点 root 和要插入树中的值 value ，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据 <strong>保证</strong> ，新值和原始二叉搜索树中的任意节点值都不同。</p>\n<p><strong>注意</strong>，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回 <strong>任意有效的结果</strong> 。</p>\n<pre><code class=\"plain\">class Solution &#123;\n     public TreeNode insertIntoBST(TreeNode root, int val) &#123;\n         //为空建一个返回\n         if(root==null) return new TreeNode(val);\n         dfs(root,val);\n         return root;\n     &#125;\n     public void dfs(TreeNode root, int val)&#123;\n         //大于的话 需要插入到左子树 看左节点是否为空，空的话直接加入，然后返回， 否则递归到左子树 \n         if(root.val&gt;val)&#123;\n             if(root.left==null)&#123;\n                 root.left=new TreeNode(val);\n                 return;\n             &#125;\n             dfs(root.left,val);\n         &#125;else&#123;\n             if(root.right==null)&#123;\n                 root.right=new TreeNode(val);\n                 return;\n             &#125;\n             dfs(root.right,val);\n         &#125;\n     &#125;\n &#125;\n</code></pre>\n<h2 id=\"删除二叉搜索树的节点\"><a href=\"#删除二叉搜索树的节点\" class=\"headerlink\" title=\"删除二叉搜索树的节点\"></a>删除二叉搜索树的节点</h2><p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/image-20221108190047074.png\" alt=\"img\"></p>\n<pre><code class=\"plain\">class Solution &#123;\n     public TreeNode deleteNode(TreeNode root, int key) &#123;\n         if(root==null) return null;\n         if(key&lt;root.val)&#123;\n             root.left=deleteNode(root.left,key);\n             return root;\n         &#125;\n         if(key&gt;root.val)&#123;\n             root.right=deleteNode(root.right,key);\n             return root;\n         &#125;\n         //key==root.val\n         //左右都空\n         if(key==root.val)&#123;\n             if(root.right==null&amp;&amp;root.left==null)&#123;\n                 return null;\n             &#125;\n             //左子树为空\n             if(root.left==null)&#123;\n                 return root.right;\n             &#125;\n             //右子树为空\n             if(root.right==null)&#123;\n                 return root.left;\n             &#125;\n             //左右都不为空\n             if(root.right!=null&amp;&amp;root.left!=null)&#123;\n                 //寻找左子树最大结点值val\n                 int val=getMaxInLeft(root.left);\n                 //对根节点赋值val \n                 root.val=val;\n                 //删除等于val的那个结点，并更新左结点\n                 root.left=deleteNode(root.left,val);\n                 return root;\n             &#125;\n         &#125;\n         return root;\n         \n     &#125;\n      //找到左子树中最大的值\n     public int getMaxInLeft(TreeNode root)&#123;\n         //递归\n         // if(root.right==null&amp;&amp;root.left==null) return root.val;\n         // //右子树为空 必然最大的就是根节点\n         // if(root.right==null) return root.val;\n         // return getMaxInLeft(root.right);\n         TreeNode node=root;\n         while(node.right!=null)&#123;\n             node=node.right;\n         &#125;\n         return node.val;\n     &#125;\n</code></pre>\n<h2 id=\"修剪二叉搜索树\"><a href=\"#修剪二叉搜索树\" class=\"headerlink\" title=\"修剪二叉搜索树\"></a>修剪二叉搜索树</h2><p>给你二叉搜索树的根节点 root ，同时给定最小边界low 和最大边界 high。通过修剪二叉搜索树，使得所有节点的值在[low, high]中。修剪树 <strong>不应该</strong> 改变保留在树中的元素的相对结构 (即，如果没有被移除，原有的父代子代关系都应当保留)。 可以证明，存在 <strong>唯一的答案</strong> 。</p>\n<p>所以结果应当返回修剪好的二叉搜索树的新的根节点。注意，根节点可能会根据给定的边界发生改变。</p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/image-20221109113639092.png\" alt=\"img\"></p>\n<pre><code class=\"plain\">class Solution &#123;\n     public TreeNode trimBST(TreeNode root, int low, int high) &#123;\n         //在根结点把三种情况解决掉了 套用递归解决问题\n         if(root==null) return null;\n         if(root.val&gt;high)&#123;\n             return trimBST(root.left,low,high);\n         &#125;else if(root.val&lt;low)&#123;\n             return trimBST(root.right,low,high);\n         &#125;else&#123;\n             root.right=trimBST(root.right,low,high);\n             root.left=trimBST(root.left,low,high);\n             return root;\n         &#125;\n     &#125;\n &#125;\n</code></pre>\n<h2 id=\"将有序数组转换为二叉搜索树\"><a href=\"#将有序数组转换为二叉搜索树\" class=\"headerlink\" title=\"将有序数组转换为二叉搜索树\"></a>将有序数组转换为二叉搜索树</h2><p>给你一个整数数组 nums ，其中元素已经按 <strong>升序</strong> 排列，请你将其转换为一棵 <strong>高度平衡</strong> 二叉搜索树。</p>\n<p><strong>高度平衡</strong> 二叉树是一棵满足「每个节点的左右两个子树的高度差的绝对值不超过 1 」的二叉树。</p>\n<pre><code class=\"plain\">class Solution &#123;\n \n     public TreeNode sortedArrayToBST(int[] nums) &#123;\n         return dfs(nums,0,nums.length-1);\n     &#125;\n     public TreeNode dfs(int[] nums,int begin,int end)&#123;\n         //越界返回空\n         if(begin&gt;end) return null;\n         //二分确定根结点\n         int index=(begin+end)/2;\n         int val=nums[index];\n         //创建结点\n         TreeNode root=new TreeNode(val);\n         //递归  创建树\n         root.right=dfs(nums,index+1,end);\n         root.left=dfs(nums,begin,index-1);\n         return root;\n     &#125;\n &#125;\n</code></pre>\n<h2 id=\"把二叉搜索树转换为累加树\"><a href=\"#把二叉搜索树转换为累加树\" class=\"headerlink\" title=\"把二叉搜索树转换为累加树\"></a>把二叉搜索树转换为累加树</h2><p>给出二叉 <strong>搜索</strong> 树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），使每个节点 node 的新值等于原树中大于或等于 node.val 的值之和。</p>\n<p>提醒一下，二叉搜索树满足下列约束条件：</p>\n<ul>\n<li>节点的左子树仅包含键 <strong>小于</strong> 节点键的节点。</li>\n<li>节点的右子树仅包含键 <strong>大于</strong> 节点键的节点。</li>\n<li>左右子树也必须是二叉搜索树。</li>\n</ul>\n<p><strong>方法一：反序中序遍历</strong></p>\n<p>思路及算法</p>\n<p>本题中要求我们将每个节点的值修改为原来的节点值加上所有大于它的节点值之和。这样我们只需要反序中序遍历该二叉搜索树，记录过程中的节点值之和，并不断更新当前遍历到的节点的节点值，即可得到题目要求的累加树。</p>\n<pre><code class=\"plain\">class Solution &#123;\n     int sum=0;\n     public TreeNode convertBST(TreeNode root) &#123;\n         dfs(root);\n         return root;\n     &#125;\n     public void dfs(TreeNode root)&#123;\n         if(root==null) return;\n         dfs(root.right);\n         sum+=root.val;\n         root.val=sum;\n         dfs(root.left);\n     &#125;\n &#125;\n</code></pre>\n<h2 id=\"翻转二叉树\"><a href=\"#翻转二叉树\" class=\"headerlink\" title=\"翻转二叉树\"></a>翻转二叉树</h2><p><strong>递归</strong></p>\n<p>深度优先</p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/0f91f7cbf5740de86e881eb7427c6c3993f4eca3624ca275d71e21c5e3e2c550-226_2.gif\" alt=\"img\"></p>\n<pre><code class=\"plain\">自顶向下(好理解  优先这个)\n class Solution &#123;\n     public TreeNode invertTree(TreeNode root) &#123;\n         //递归函数的终止条件，节点为空时返回\n         if(root==null) &#123;\n             return null;\n         &#125;\n         //下面三句是将当前节点的左右子树交换\n         TreeNode tmp = root.right;\n         root.right = root.left;\n         root.left = tmp;\n         //递归交换当前节点的 左子树\n         invertTree(root.left);\n         //递归交换当前节点的 右子树\n         invertTree(root.right);\n         //函数返回时就表示当前这个节点，以及它的左右子树\n         //都已经交换完了\n         return root;\n     &#125;\n &#125;\n 自底向上(代码简洁)   \n class Solution &#123;\n     public TreeNode invertTree(TreeNode root) &#123;\n         if (root == null) &#123;\n             return null;\n         &#125;\n         TreeNode left = invertTree(root.left);\n         TreeNode right = invertTree(root.right);\n         root.left = right;\n         root.right = left;\n         return root;\n     &#125;\n &#125;\n</code></pre>\n<p><strong>迭代</strong></p>\n<p>广度优先</p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/f9e06159617cbf8372b544daee37be70286c3d9b762c016664e225044fc4d479-226_%E8%BF%AD%E4%BB%A3.gif\" alt=\"img\"></p>\n<pre><code class=\"plain\">class Solution &#123;\n     public TreeNode invertTree(TreeNode root) &#123;\n         if(root==null) &#123;\n             return null;\n         &#125;\n         //将二叉树中的节点逐层放入队列中，再迭代处理队列中的元素\n         LinkedList&lt;TreeNode&gt; queue = new LinkedList&lt;TreeNode&gt;();\n         queue.add(root);\n         while(!queue.isEmpty()) &#123;\n             //每次都从队列中拿一个节点，并交换这个节点的左右子树\n             TreeNode tmp = queue.poll();\n             TreeNode left = tmp.left;\n             tmp.left = tmp.right;\n             tmp.right = left;\n             //如果当前节点的左子树不为空，则放入队列等待后续处理\n             if(tmp.left!=null) &#123;\n                 queue.add(tmp.left);\n             &#125;\n             //如果当前节点的右子树不为空，则放入队列等待后续处理\n             if(tmp.right!=null) &#123;\n                 queue.add(tmp.right);\n             &#125;\n             \n         &#125;\n         //返回处理完的根节点\n         return root;\n     &#125;\n &#125;\n</code></pre>\n<h2 id=\"二叉树的序列化和反序列化\"><a href=\"#二叉树的序列化和反序列化\" class=\"headerlink\" title=\"二叉树的序列化和反序列化\"></a>二叉树的序列化和反序列化</h2><p>题目：</p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/image-20220923172523030.png\" alt=\"img\"></p>\n<p>算法：</p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/image-20220923172455790.png\" alt=\"img\"></p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/image-20220923172606089.png\" alt=\"img\"></p>\n<pre><code class=\"plain\">public class Codec &#123;\n     public String serialize(TreeNode root) &#123;\n         return rserialize(root, &quot;&quot;);\n     &#125;\n   \n     public TreeNode deserialize(String data) &#123;\n         String[] dataArray = data.split(&quot;,&quot;);\n         List&lt;String&gt; dataList = new LinkedList&lt;String&gt;(Arrays.asList(dataArray));\n         return rdeserialize(dataList);\n     &#125;\n \n     public String rserialize(TreeNode root, String str) &#123;\n         if (root == null) &#123;\n             str += &quot;None,&quot;;\n         &#125; else &#123;\n             str += str.valueOf(root.val) + &quot;,&quot;;//或者这样写 str+=String.valueOf(root.val)+&quot;,&quot;;  把root.val转成String类型\n             str = rserialize(root.left, str);\n             str = rserialize(root.right, str);\n         &#125;\n         return str;\n     &#125;\n   \n     public TreeNode rdeserialize(List&lt;String&gt; dataList) &#123;\n         if (dataList.get(0).equals(&quot;None&quot;)) &#123;\n             dataList.remove(0);\n             return null;\n         &#125;\n   \n         TreeNode root = new TreeNode(Integer.valueOf(dataList.get(0)));\n         dataList.remove(0);\n         root.left = rdeserialize(dataList);\n         root.right = rdeserialize(dataList);\n     \n         return root;\n     &#125;\n &#125;\n</code></pre>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/20211030125421.png\" alt=\"img\"><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/20211030125421.png\" alt=\"img\"></p>\n<h2 id=\"二叉树的前序遍历\"><a href=\"#二叉树的前序遍历\" class=\"headerlink\" title=\"二叉树的前序遍历\"></a>二叉树的前序遍历</h2><p>1、递归</p>\n<pre><code class=\"plain\">public class Solution &#123;\n     /**\n      * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可\n      *\n      * \n      * @param root TreeNode类 \n      * @return int整型一维数组\n      */\n     List&lt;Integer&gt; ans=new ArrayList&lt;&gt;();;\n     public int[] preorderTraversal (TreeNode root) &#123;\n         // write code here\n         dfs(root);\n         int[] res=new int[ans.size()];\n         for(int i=0;i&lt;ans.size();i++)&#123;\n             res[i]=ans.get(i);\n         &#125;\n         return res;\n         \n     &#125;\n     public void dfs(TreeNode root)&#123;\n         if(root==null) return;\n         ans.add(root.val);\n         dfs(root.left);\n         dfs(root.right);\n     &#125;\n &#125;\n</code></pre>\n<p>2、迭代</p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/717C18C1D3175AB683DE7E050A4236ED\" alt=\"img\"></p>\n<pre><code class=\"plain\">public int[] preorderTraversal (TreeNode root) &#123;\n         List&lt;Integer&gt; ans=new ArrayList&lt;&gt;();\n         Stack&lt;TreeNode&gt; stack=new Stack&lt;&gt;();\n         // 判空\n         if(root==null) return new int[0];\n         stack.push(root);\n         while(!stack.isEmpty())&#123;\n             TreeNode node=stack.pop();\n             ans.add(node.val);\n             // 栈先进后出\n             if(node.right!=null) stack.push(node.right);\n             if(node.left!=null) stack.push(node.left);\n         &#125;\n         int[] finnal_ans=new int[ans.size()];\n         for(int i=0;i&lt;ans.size();i++)&#123;\n             finnal_ans[i]=ans.get(i);\n         &#125;\n         return finnal_ans;\n     &#125;\n</code></pre>\n<h2 id=\"二叉树中序遍历\"><a href=\"#二叉树中序遍历\" class=\"headerlink\" title=\"二叉树中序遍历\"></a>二叉树中序遍历</h2><h3 id=\"递归\"><a href=\"#递归\" class=\"headerlink\" title=\"递归\"></a>递归</h3><p>换个顺序就行</p>\n<h3 id=\"迭代\"><a href=\"#迭代\" class=\"headerlink\" title=\"迭代\"></a>迭代</h3><p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/23368751A430C010C582743B0E2F9414\" alt=\"img\"></p>\n<pre><code class=\"plain\">public class Solution &#123;\n     /**\n      * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可\n      *\n      * \n      * @param root TreeNode类 \n      * @return int整型一维数组\n      */\n     public int[] inorderTraversal (TreeNode root) &#123;\n         // write code here\n         List&lt;Integer&gt; list=new ArrayList&lt;&gt;();\n         Stack&lt;TreeNode&gt; stack=new Stack&lt;&gt;();\n         if(root==null) return new int[0];\n         while(!stack.isEmpty()||root!=null)&#123;\n             while(root!=null)&#123;\n                 stack.push(root);\n                 root=root.left;\n             &#125;\n             TreeNode node=stack.pop();\n             list.add(node.val);\n             root=node.right;\n         &#125;\n         int[] res=new int[list.size()];\n         for(int i=0;i&lt;list.size();i++)&#123;\n             res[i]=list.get(i);\n         &#125;\n         return res;\n     &#125;\n &#125;\n</code></pre>\n<h2 id=\"二叉树的后序遍历\"><a href=\"#二叉树的后序遍历\" class=\"headerlink\" title=\"二叉树的后序遍历\"></a>二叉树的后序遍历</h2><h3 id=\"迭代-1\"><a href=\"#迭代-1\" class=\"headerlink\" title=\"迭代\"></a>迭代</h3><ul>\n<li>step 1：开辟一个辅助栈，用于记录要访问的子节点，开辟一个前序指针pre。</li>\n<li>step 2：从根节点开始，每次优先进入每棵的子树的最左边一个节点，我们将其不断加入栈中，用来保存父问题。</li>\n<li>step 3：弹出一个栈元素，看成该子树的根，判断这个根的右边有没有节点或是有没有被访问过，如果没有右节点或是被访问过了，可以访问这个根，并将前序节点标记为这个根。</li>\n<li>step 4：如果没有被访问，那这个根必须入栈，进入右子树继续访问，只有右子树结束了回到这里才能继续访问根。</li>\n</ul>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/05EE17BA6FA1FB90EDDEF5A26D0FEEF4\" alt=\"img\"></p>\n<pre><code class=\"plain\">import java.util.*;\n \n /*\n  * public class TreeNode &#123;\n  *   int val = 0;\n  *   TreeNode left = null;\n  *   TreeNode right = null;\n  *   public TreeNode(int val) &#123;\n  *     this.val = val;\n  *   &#125;\n  * &#125;\n  */\n \n public class Solution &#123;\n     /**\n      * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可\n      *\n      * \n      * @param root TreeNode类 \n      * @return int整型一维数组\n      */\n     public int[] postorderTraversal (TreeNode root) &#123;\n         // write code here\n         // 牢记栈的特性  先入栈后访问\n         TreeNode pre=null;//标记这个是访问过的前序节点\n         List&lt;Integer&gt; list=new ArrayList&lt;&gt;();\n         Stack&lt;TreeNode&gt; stack=new Stack&lt;&gt;();\n         while(!stack.isEmpty()||root!=null)&#123;\n             // 找最左边节点\n             while(root!=null)&#123;\n                 stack.push(root);\n                 root=root.left;\n             &#125;\n             TreeNode node=stack.pop();\n             // 如果右节点为空或者已经被访问了\n             if(node.right==null||node.right==pre)&#123;\n                 list.add(node.val);\n                 pre=node;\n             &#125;else&#123;\n                 //该节点入栈\n                 stack.push(node);\n                 //先访问右边\n                 root=node.right;\n             &#125;\n         &#125;\n         int[] res=new int[list.size()];\n         for(int i=0;i&lt;list.size();i++)&#123;\n             res[i]=list.get(i);\n         &#125;\n         return res;\n     &#125;\n &#125;\n</code></pre>\n<h2 id=\"求二叉树的层序遍历\"><a href=\"#求二叉树的层序遍历\" class=\"headerlink\" title=\"求二叉树的层序遍历\"></a>求二叉树的层序遍历</h2><ul>\n<li>step 1：首先判断二叉树是否为空，空树没有遍历结果。</li>\n<li>step 2：建立辅助队列，根节点首先进入队列。不管层次怎么访问，根节点一定是第一个，那它肯定排在队伍的最前面。</li>\n<li>step 3：每次进入一层，统计队列中元素的个数。因为每当访问完一层，下一层作为这一层的子节点，一定都加入队列，而再下一层还没有加入，因此此时队列中的元素个数就是这一层的元素个数。</li>\n<li>step 4：每次遍历这一层这么多的节点数，将其依次从队列中弹出，然后加入这一行的一维数组中，如果它们有子节点，依次加入队列排队等待访问。</li>\n<li>step 5：访问完这一层的元素后，将这个一维数组加入二维数组中，再访问下一层。</li>\n</ul>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/07986E476EB2CECD3C5F81D0BCADBE12\" alt=\"img\"></p>\n<h3 id=\"迭代-2\"><a href=\"#迭代-2\" class=\"headerlink\" title=\"迭代\"></a>迭代</h3><pre><code class=\"plain\">import java.util.*;\n \n /*\n  * public class TreeNode &#123;\n  *   int val = 0;\n  *   TreeNode left = null;\n  *   TreeNode right = null;\n  * &#125;\n  */\n \n public class Solution &#123;\n     /**\n      * \n      * @param root TreeNode类 \n      * @return int整型ArrayList&lt;ArrayList&lt;&gt;&gt;\n      */\n     public ArrayList&lt;ArrayList&lt;Integer&gt;&gt; levelOrder (TreeNode root) &#123;\n         // write code here\n         Queue&lt;TreeNode&gt; queue=new LinkedList&lt;&gt;();\n         ArrayList&lt;ArrayList&lt;Integer&gt;&gt; ans=new ArrayList();\n          //如果是空，则直接返回空数组\n         if(root==null) return ans;\n         // 根加进去\n         queue.add(root);\n         while(!queue.isEmpty())&#123;\n             // 当前层个数\n             int n=queue.size();\n             // 当前层的集合\n             ArrayList&lt;Integer&gt; temp = new ArrayList(); \n             for(int i=0;i&lt;n;i++)&#123;\n                 // poll出来\n                 TreeNode node=queue.poll();\n                 temp.add(node.val);\n                 //若是左右孩子存在，则存入左右孩子作为下一个层次\n                 if(node.left!=null) queue.add(node.left);\n                 if(node.right!=null) queue.add(node.right);\n             &#125;\n             // 每一层加进结果集\n             ans.add(temp);\n         &#125;\n         return ans;\n     &#125;\n &#125;\n</code></pre>\n<h2 id=\"按之字形顺序打印二叉树\"><a href=\"#按之字形顺序打印二叉树\" class=\"headerlink\" title=\"按之字形顺序打印二叉树\"></a>按之字形顺序打印二叉树</h2><p>给定一个二叉树，返回该二叉树的之字形层序遍历，（第一层从左向右，下一层从右向左，一直这样交替）</p>\n<p>和二叉树层序遍历一样 无非就是加一个flag进行一个奇偶判断</p>\n<p>注意一个API </p>\n<p> Collections.reverse();&#x2F;&#x2F;反转集合</p>\n<pre><code class=\"plain\">import java.util.*;\n \n /*\n public class TreeNode &#123;\n     int val = 0;\n     TreeNode left = null;\n     TreeNode right = null;\n \n     public TreeNode(int val) &#123;\n         this.val = val;\n \n     &#125;\n &#125;\n */\n public class Solution &#123;\n     public ArrayList&lt;ArrayList&lt;Integer&gt; &gt; Print(TreeNode pRoot) &#123;\n         Queue&lt;TreeNode&gt; queue=new LinkedList&lt;&gt;();\n         ArrayList&lt;ArrayList&lt;Integer&gt;&gt; ans=new ArrayList();\n          //如果是空，则直接返回空数组\n         if(pRoot==null) return ans;\n         // 根加进去\n         queue.add(pRoot);\n         boolean flag=true;\n         while(!queue.isEmpty())&#123;\n             // 当前层个数\n             int n=queue.size();\n             // 当前层的集合\n             ArrayList&lt;Integer&gt; temp = new ArrayList(); \n             for(int i=0;i&lt;n;i++)&#123;\n                 // poll出来\n                 TreeNode node=queue.poll();\n                 temp.add(node.val);\n                 //若是左右孩子存在，则存入左右孩子作为下一个层次\n                 if(node.left!=null) queue.add(node.left);\n                 if(node.right!=null) queue.add(node.right);\n             &#125;\n             // 每一层加进结果集\n             if(flag) ans.add(temp);\n             else &#123;\n                 Collections.reverse(temp);\n                 ans.add(temp);\n             &#125;\n             flag=!flag;\n         &#125;\n         return ans;\n     &#125;\n \n &#125;\n</code></pre>\n<h2 id=\"求根节点到叶节点数字之和\"><a href=\"#求根节点到叶节点数字之和\" class=\"headerlink\" title=\"求根节点到叶节点数字之和\"></a>求根节点到叶节点数字之和</h2><p>给你一个二叉树的根节点 root ，树中每个节点都存放有一个 0 到 9 之间的数字。</p>\n<p>每条从根节点到叶节点的路径都代表一个数字：</p>\n<ul>\n<li>例如，从根节点到叶节点的路径 1 -&gt; 2 -&gt; 3 表示数字 123 。</li>\n</ul>\n<p>计算从根节点到叶节点生成的 <strong>所有数字之和</strong> 。</p>\n<p><strong>叶节点</strong> 是指没有子节点的节点。</p>\n<pre><code class=\"plain\">//  思路 我把这题类比二叉树的所有路径那题  append的时候简单了 不用加=&gt;  最后用一下Integer.parseInt(s)把字符串转为数字 然后求和就行！\n class Solution &#123;\n     List&lt;String&gt; ans=new ArrayList&lt;&gt;();\n     int sum=0;\n     public int sumNumbers(TreeNode root) &#123;\n         StringBuilder sb=new StringBuilder();\n         dfs(root,sb);\n         for(String s:ans)&#123;\n             int i=Integer.parseInt(s);\n             sum+=i;\n         &#125;\n         return sum;\n     &#125;\n     public void dfs(TreeNode root,StringBuilder sb)&#123;\n         if(root==null) return;\n         sb.append(root.val);\n         if(root.right==null&amp;&amp;root.left==null)&#123;\n             ans.add(sb.toString());\n         &#125;\n         dfs(root.left,new StringBuilder(sb));\n         dfs(root.right,new StringBuilder(sb));\n     &#125;\n &#125;\n</code></pre>\n<h2 id=\"将二叉搜索树变平衡\"><a href=\"#将二叉搜索树变平衡\" class=\"headerlink\" title=\"将二叉搜索树变平衡\"></a>将二叉搜索树变平衡</h2><p>给你一棵二叉搜索树，请你返回一棵 <strong>平衡后</strong> 的二叉搜索树，新生成的树应该与原来的树有着相同的节点值。如果有多种构造方法，请你返回任意一种。</p>\n<p>如果一棵二叉搜索树中，每个节点的两棵子树高度差不超过 1 ，我们就称这棵二叉搜索树是 <strong>平衡的</strong> 。</p>\n<p>题解 中序遍历把二叉树转变为有序数组，然后在根据有序数组构造平衡二叉搜索树。</p>\n<pre><code class=\"plain\">class Solution &#123;\n     List&lt;Integer&gt; res=new ArrayList&lt;&gt;();\n     public TreeNode balanceBST(TreeNode root) &#123;\n         // 中序遍历把二叉树转变为有序数组，然后在根据有序数组构造平衡二叉搜索树。\n         tranval(root);\n         return getTree(0,res.size()-1);\n     &#125;\n     // 有序树转成有序数组\n     public void tranval(TreeNode root)&#123;\n         if(root==null) return;\n         tranval(root.left);\n         res.add(root.val);\n         tranval(root.right);\n     &#125;\n     // 有序数组转成平衡二叉树\n     public TreeNode getTree(int left,int right)&#123;\n         if(left&gt;right) return null;\n         // 二分\n         int mid=(left+right)/2;\n         // 创建结点\n         TreeNode root=new TreeNode(res.get(mid));\n         root.left=getTree(left,mid-1);\n         root.right=getTree(mid+1,right);\n         return root;\n     &#125;\n &#125;\n</code></pre>\n<h2 id=\"相同的树\"><a href=\"#相同的树\" class=\"headerlink\" title=\"相同的树\"></a>相同的树</h2><p>给你两棵二叉树的根节点 p 和 q ，编写一个函数来检验这两棵树是否相同。</p>\n<p>如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。</p>\n<p>题解:和对称树基本一样</p>\n<pre><code class=\"plain\">class Solution &#123;\n     public boolean isSameTree(TreeNode p, TreeNode q) &#123;\n         if(p==null&amp;&amp;q==null) return true;\n         if(p==null||q==null) return false;\n         return p.val==q.val&amp;&amp;isSameTree(p.left,q.left)&amp;&amp;isSameTree(p.right,q.right);\n     &#125;\n &#125;\n</code></pre>\n<h2 id=\"填充每个节点的下一个右侧节点指针\"><a href=\"#填充每个节点的下一个右侧节点指针\" class=\"headerlink\" title=\"填充每个节点的下一个右侧节点指针\"></a>填充每个节点的下一个右侧节点指针</h2><p>给定一个 <strong>完美二叉树</strong> ，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：</p>\n<p>填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。</p>\n<p>初始状态下，所有 next 指针都被设置为 NULL。</p>\n<p>题解：递归</p>\n<pre><code class=\"plain\">if (cur.left != null) cur.left.next = cur.right; // 操作1\n         if (cur.right != null) &#123;\n             if(cur.next != null) cur.right.next = cur.next.left; //操作2\n             else cur.right.next = null;\n         &#125;\n</code></pre>\n<p>最终答案</p>\n<pre><code class=\"plain\">// 递归法\n class Solution &#123;\n     public void traversal(Node cur) &#123;\n         if (cur == null) return;\n         if (cur.left != null) cur.left.next = cur.right; // 操作1\n         if (cur.right != null) &#123;\n             if(cur.next != null) cur.right.next = cur.next.left; //操作2\n             else cur.right.next = null;\n         &#125;\n         traversal(cur.left);  // 左\n         traversal(cur.right); //右\n     &#125;\n     public Node connect(Node root) &#123;\n         traversal(root);\n         return root;\n     &#125;\n &#125;\n</code></pre>\n<h2 id=\"二叉树中和为某一值的路径-一\"><a href=\"#二叉树中和为某一值的路径-一\" class=\"headerlink\" title=\"二叉树中和为某一值的路径(一)\"></a><strong>二叉树中和为某一值的路径(一)</strong></h2><p>给定一个二叉树root和一个值 sum ，判断是否有从根节点到叶子节点的节点值之和等于 sum 的路径。</p>\n<pre><code class=\"plain\">import java.util.*;\n \n /*\n  * public class TreeNode &#123;\n  *   int val = 0;\n  *   TreeNode left = null;\n  *   TreeNode right = null;\n  * &#125;\n  */\n \n public class Solution &#123;\n     /**\n      * \n      * @param root TreeNode类 \n      * @param sum int整型 \n      * @return bool布尔型\n      */\n     public boolean hasPathSum (TreeNode root, int sum) &#123;\n         // write code here\n         if(root==null) return false;\n         if(root.right==null&amp;&amp;root.left==null&amp;&amp;sum-root.val==0) return true;\n         return hasPathSum(root.left,sum-root.val)||hasPathSum(root.right,sum-root.val);\n     &#125;\n \n &#125;\n</code></pre>\n<h2 id=\"二叉搜索树与双向链表\"><a href=\"#二叉搜索树与双向链表\" class=\"headerlink\" title=\"二叉搜索树与双向链表\"></a>二叉搜索树与双向链表</h2><p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表</p>\n<p><strong>思路：</strong></p>\n<p>二叉搜索树最左端的元素一定最小，最右端的元素一定最大，符合“左中右”的特性，因此二叉搜索树的中序遍历就是一个递增序列，我们只要对它中序遍历就可以组装称为递增双向链表。每次遍历的时候构造好双向链表，注意次序；</p>\n<p><strong>具体做法：</strong></p>\n<ul>\n<li>step 1：创建两个指针，一个指向题目中要求的链表头（head），一个指向当前遍历的前一节点（pre)。</li>\n<li>step 2：首先递归到最左，初始化head与pre。</li>\n<li>step 3：然后处理中间根节点，依次连接pre与当前节点，连接后更新pre为当前节点。</li>\n<li>step 4：最后递归进入右子树，继续处理。</li>\n<li>step 5：递归出口即是节点为空则返回。</li>\n</ul>\n<pre><code class=\"plain\">public class Solution &#123;\n     //返回的第一个指针，即为最小值，先定为null\n     public TreeNode head = null; \n     //中序遍历当前值的上一位，初值为最小值，先定为null\n     public TreeNode pre = null; \n     public TreeNode Convert(TreeNode pRootOfTree) &#123;\n         if(pRootOfTree==null) return null;\n         // 首先递归到最左最小值  中序的顺序\n         Convert(pRootOfTree.left);\n         //初始化\n         if(pre==null)&#123;\n             pre=pRootOfTree;\n             head=pRootOfTree;//初始化头结点\n         &#125;\n         else &#123;\n             //总之保证Pre在pRootOfTree的前面\n             pre.right=pRootOfTree;\n             pRootOfTree.left=pre;\n             pre=pRootOfTree;\n         &#125;\n         Convert(pRootOfTree.right);\n         return head;\n     &#125;\n &#125;\n</code></pre>\n<h1 id=\"BFS-amp-DFS\"><a href=\"#BFS-amp-DFS\" class=\"headerlink\" title=\"BFS&amp;DFS\"></a>BFS&amp;DFS</h1><p>DFS 遍历使用递归：</p>\n<pre><code class=\"plain\">void dfs(TreeNode root) &#123;\n    if (root == null) &#123;\n        return;\n    &#125;\n    dfs(root.left);//递归到最后一层最左边节点，左右节点为空，return出来，到最后一层第二个节点\n    dfs(root.right);\n&#125;\n</code></pre>\n<p>BFS 遍历使用队列数据结构：</p>\n<pre><code class=\"plain\">void bfs(TreeNode root) &#123;\n    Queue&lt;TreeNode&gt; queue = new ArrayDeque&lt;&gt;();\n    queue.add(root);\n    while (!queue.isEmpty()) &#123;\n        TreeNode node = queue.poll(); // Java 的 pop 写作 poll()\n        if (node.left != null) &#123;\n            queue.add(node.left);//队列先进后出，所以是按层往外扩，一直从左往右遍历\n        &#125;\n        if (node.right != null) &#123;\n            queue.add(node.right);\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/fdcd3bd27f4008948084f6ec86b58535e71f66862bd89a34bd6fe4cc42d68e89-16578569951531.gif\" alt=\"img\"></p>\n<h2 id=\"BFS-的应用一：层序遍历\"><a href=\"#BFS-的应用一：层序遍历\" class=\"headerlink\" title=\"BFS 的应用一：层序遍历\"></a><strong>BFS 的应用一：层序遍历</strong></h2><p>给定一个二叉树，返回其按层序遍历得到的节点值。 层序遍历即逐层地、从左到右访问所有结点。</p>\n<p>层序遍历要求的输入结果和 BFS 是不同的。层序遍历要求我们区分每一层，也就是返回一个二维数组。而 BFS 的遍历结果是一个一维数组，无法区分每一层。</p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/fd1d63037d0e2f787d2140fee406e109094a4f66ab0837a7273f8b371eef8096.jpg\" alt=\"img\"></p>\n<p>截取 BFS 遍历过程中的某个时刻：</p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/4529bf559c6a2d84d550eebaee027c3b7ae25069e4ec91f27b29a4c6358d6662.gif\" alt=\"img\"></p>\n<p>BFS 遍历中某个时刻队列的状态</p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/9f178b56ff1c94388d893f2fb48e9e77e186aba7cfd7483637776359062d68b8.jpg\" alt=\"img\"></p>\n<p>可以看到，此时队列中的结点是 3、4、5，分别来自第 1 层和第 2 层。这个时候，第 1 层的结点还没出完，第 2 层的结点就进来了，而且两层的结点在队列中紧挨在一起，我们无法区分队列中的结点来自哪一层。</p>\n<p>因此，我们需要稍微修改一下代码，在每一层遍历开始前，先记录队列中的结点数量 n（也就是这一层的结点数量），然后一口气处理完这一层的 n 个结点。</p>\n<pre><code class=\"plain\">// 二叉树的层序遍历\nvoid bfs(TreeNode root) &#123;\n    Queue&lt;TreeNode&gt; queue = new ArrayDeque&lt;&gt;();\n    queue.add(root);\n    while (!queue.isEmpty()) &#123;\n        int n = queue.size();\n        for (int i = 0; i &lt; n; i++) &#123; \n            // 变量 i 无实际意义，只是为了循环 n 次\n            TreeNode node = queue.poll();\n            if (node.left != null) &#123;\n                queue.add(node.left);\n            &#125;\n            if (node.right != null) &#123;\n                queue.add(node.right);\n            &#125;\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<p>这样，我们就将 BFS 遍历改造成了层序遍历。在遍历的过程中，结点进队列和出队列的过程为：</p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/94cd1fa999df0276f1dae77a9cca83f4cabda9e2e0b8571cd9550a8ee3545f56.gif\" alt=\"img\"></p>\n<p>可以看到，在 while 循环的每一轮中，都是将当前层的所有结点出队列，再将下一层的所有结点入队列，这样就实现了层序遍历。</p>\n<p>最终我们得到的题解代码为：</p>\n<pre><code class=\"plain\">public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;\n    List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();\n\n    Queue&lt;TreeNode&gt; queue = new ArrayDeque&lt;&gt;();\n    if (root != null) &#123;\n        queue.add(root);\n    &#125;\n    while (!queue.isEmpty()) &#123;\n        int n = queue.size();\n        List&lt;Integer&gt; level = new ArrayList&lt;&gt;();\n        for (int i = 0; i &lt; n; i++) &#123; \n            TreeNode node = queue.poll();//弹出队头n次 正好就是把上一层的结点全部弹出 剩下的就是这一层的节点数量 \n            level.add(node.val);//level放每一层的值\n            if (node.left != null) &#123;\n                queue.add(node.left);\n            &#125;\n            if (node.right != null) &#123;\n                queue.add(node.right);\n            &#125;\n        &#125;\n        res.add(level);//加入结果集\n    &#125;\n\n    return res;\n&#125;\n</code></pre>\n<h1 id=\"递归-1\"><a href=\"#递归-1\" class=\"headerlink\" title=\"递归\"></a>递归</h1><p>我的理解：</p>\n<p>主要函数里面return一个自定义函数，自定义函数里面前一部分写好递归的统一模板，然后开始递归下一层。</p>\n<p>甩锅给后面的过程，然后得有一个出口。</p>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2023/png/226907/1685799400993-fcd546a8-e08a-44c6-ada3-220be1d8330a.png\" alt=\"img\"></p>\n<pre><code class=\"plain\">/**\n * 合并两有序链表  递归方法 代码少 但效率不行\n */\npublic ListNode mergeTwoLists(ListNode list1,ListNode list2)&#123;\n    if(list1==null||list2==null)&#123;\n        return list1==null?list2:list1;\n    &#125;else if(list1.val&lt;list2.val)&#123;\n        list1.next=mergeTwoLists(list1.next,list2);\n        return list1;\n    &#125;else&#123;\n        list2.next=mergeTwoLists(list2.next,list1);\n        return list2;\n    &#125;\n&#125;\n/**\n * 普通方法 代码多 但效率快\n */\n/*\npublic ListNode mergeTwoLists(ListNode list1,ListNode list2)&#123;\n    if(list1==null||list2==null)&#123;\n        return list1==null?list2:list1;\n    &#125;\n    ListNode head=new ListNode(0);\n    ListNode tail=head,aptr=list1,bptr=list2;\n    while (list1!=null&amp;&amp;list2!=null)&#123;\n        if(list1.val&lt;list2.val)&#123;\n            tail.next=list1;\n            list1=list1.next;\n        &#125;else&#123;\n            tail.next=list2;\n            list2=list2.next;\n        &#125;\n        tail=tail.next;\n    &#125;\n    tail.next=list1!=null?list1:list2;\n    return head.next;\n&#125;\n */\n</code></pre>\n","categories":["算法"]},{"title":"动态规划","url":"/2023/06/04/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/","content":"<h2 id=\"经验\"><a href=\"#经验\" class=\"headerlink\" title=\"经验\"></a>经验</h2><p>不用管最优子结构啊和重叠子问题</p>\n<ol>\n<li>确定dp数组（dp table）以及下标的含义</li>\n<li>确定递推公式<span id=\"more\"></span></li>\n<li>dp数组如何初始化（递推公式决定了dp数组要如何初始化）</li>\n<li>确定遍历顺序</li>\n<li>举例推导dp数组</li>\n</ol>\n<p><strong>如何debug</strong></p>\n<p><em>做动规的题目，写代码之前一定要把状态转移在dp数组的上具体情况模拟一遍，心中有数，确定最后推出的是想要的结果</em>。</p>\n<p>然后再写代码，如果代码没通过就打印dp数组，看看是不是和自己预先推导的哪里不一样。如果打印出来和自己预先模拟推导是一样的，那么就是自己的递归公式、初始化或者遍历顺序有问题了。如果和自己预先模拟推导的不一样，那么就是代码实现细节有问题。</p>\n<ul>\n<li>这道题目我举例推导状态转移公式了么？</li>\n<li>我打印dp数组的日志了么？</li>\n<li>打印出来了dp数组和我想的一样么？</li>\n</ul>\n<p><strong>动态规划的三大步骤</strong></p>\n<p>利用历史记录，来避免重复计算。而这些历史记录，我们得需要一些变量来保存，一般是用一维数组或者<a href=\"https://www.zhihu.com/search?q=%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:%2291582909%22%7D\">二维数组</a>来保存。 第一步骤：定义数组元素的含义，用一个数组，来保存历史数组，假设用一维数组 dp[] 你的 dp[i] 是代表什么意思？</p>\n<p>第二步骤：找出数组元素之间的关系式 第三步骤：找出<a href=\"https://www.zhihu.com/search?q=%E5%88%9D%E5%A7%8B%E5%80%BC&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:%2291582909%22%7D\">初始值</a>。</p>\n<p><strong>什么时候用二维数组？</strong></p>\n<p>涉及到数组和”和“的问题，考虑用二维数组 ，比如目标和这道题：</p>\n<p>定义二维数组 dp，其中 dp<a href=\"https://www.yuque.com/yunanyizhihua/nw82a7/yfg18e2xr2ykmkfh#\">i</a> 表示在数组 num的前 i个数中选取元素，使得这些元素之和等于 j 的方案数。</p>\n<p>再比如分割等和子集这道题</p>\n<p>优化步骤：一般这种dp二维数组的每一行的计算只和上一行有关，因此可以使用滚动数组的方式，去掉 dp 的第一个维度，将空间复杂度降低</p>\n<p> else if (i - dp[i - 1] &gt; 0 &amp;&amp; s.charAt(i - dp[i - 1] - 1) &#x3D;&#x3D; ‘(‘) </p>\n<h2 id=\"斐波那契数\"><a href=\"#斐波那契数\" class=\"headerlink\" title=\"斐波那契数\"></a>斐波那契数</h2><p><strong>斐波那契数</strong> （通常用 F(n) 表示）形成的序列称为 <strong>斐波那契数列</strong> 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是：</p>\n<p>题解:</p>\n<ul>\n<li>dp[i]： 数字值</li>\n<li>和斐波那契数一样，只不过台阶从1开始，因此初始值是int f0&#x3D;1,f1&#x3D;2; i从3开始</li>\n</ul>\n<pre><code class=\"plain\">class Solution &#123;\n     public int fib(int n) &#123;\n         int f0=0,f1=1;\n         if (n &lt; 2) &#123;\n             return n;\n         &#125;\n         for(int i=2;i&lt;=n;i++)&#123;\n             //存一下f0\n             int temp=f0;\n             //改值\n             f0=f1;\n             f1=temp+f1;\n         &#125;\n         return f1;\n     &#125;\n &#125;\n</code></pre>\n<h2 id=\"爬楼梯\"><a href=\"#爬楼梯\" class=\"headerlink\" title=\"爬楼梯\"></a>爬楼梯</h2><p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。</p>\n<p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p>\n<p>题解:</p>\n<ul>\n<li>dp[i]： 爬到第i层楼梯，有dp[i]种方法</li>\n<li>和斐波那契数一样，只不过台阶从1开始，因此初始值是int f0&#x3D;1,f1&#x3D;2; i从3开始</li>\n</ul>\n<pre><code class=\"plain\">class Solution &#123;\n     public int climbStairs(int n) &#123;\n         if(n&lt;3) return n;\n         int f0=1,f1=2;\n         for(int i=3;i&lt;=n;i++)&#123;\n            int temp=f0;\n             f0=f1;\n             f1=temp+f1;\n         &#125;\n         return f1;\n     &#125;\n &#125;\n</code></pre>\n<h2 id=\"使用最小花费爬楼梯\"><a href=\"#使用最小花费爬楼梯\" class=\"headerlink\" title=\"使用最小花费爬楼梯\"></a>使用最小花费爬楼梯</h2><p>给你一个整数数组 cost ，其中 cost[i] 是从楼梯第 i 个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。</p>\n<p>你可以选择从下标为 0 或下标为 1 的台阶开始爬楼梯。</p>\n<p>请你计算并返回达到楼梯顶部的最低花费。</p>\n<pre><code class=\"plain\">//同前面两题一样,初始值 递推公式 temp记录 \n class Solution &#123;\n     public int minCostClimbingStairs(int[] cost) &#123;\n         int n=cost.length;\n         if(n&lt;2) return 0;\n         int f0=0,f1=0;\n         for(int i=2;i&lt;=n;i++)&#123;\n             int temp=f0;\n             f0=f1;\n             f1=Math.min(f1+cost[i-1],temp+cost[i-2]);\n         &#125;\n         return f1;\n     &#125;\n &#125;\n</code></pre>\n<h2 id=\"不同路径\"><a href=\"#不同路径\" class=\"headerlink\" title=\"不同路径\"></a>不同路径</h2><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。</p>\n<p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。</p>\n<p>问总共有多少条不同的路径？</p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/robot_maze.png\" alt=\"img\"></p>\n<pre><code class=\"plain\">class Solution &#123;\n     public int uniquePaths(int m, int n) &#123;\n         // 定义二维数组  dp[i][j]表示到达此处路径个数\n         int[][] dp=new int[m][n];\n         // 第一行和第一列必为1 填充\n         for(int i=1;i&lt;m;i++)&#123;\n             dp[i][0]=1;\n         &#125;\n         Arrays.fill(dp[0],1);\n         // dp\n         for(int i=1;i&lt;m;i++)&#123;\n             for(int j=1;j&lt;n;j++)&#123;\n                 // 等于上一个和左边的和\n                 dp[i][j]=dp[i-1][j]+dp[i][j-1];\n             &#125;\n         &#125;\n         return dp[m-1][n-1];\n     &#125;\n &#125;\n</code></pre>\n<h2 id=\"不同路径-II\"><a href=\"#不同路径-II\" class=\"headerlink\" title=\"不同路径 II\"></a>不同路径 II</h2><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。</p>\n<p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish”）。</p>\n<p>现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？</p>\n<p>网格中的障碍物和空位置分别用 1 和 0 来表示。</p>\n<pre><code class=\"plain\">class Solution &#123;\n     public int uniquePathsWithObstacles(int[][] obstacleGrid) &#123;\n         int m=obstacleGrid.length;\n         int n=obstacleGrid[0].length;\n         int[][] dp= new int[m][n];\n         // 初始化  当遇到障碍物的时候就不再执行循环了   同时正好dp默认值都是0 后面也正好都是0\n         for(int i=0;i&lt;m&amp;&amp;obstacleGrid[i][0]==0;i++)&#123;\n             dp[i][0]=1;\n         &#125;\n         for(int j=0;j&lt;n&amp;&amp;obstacleGrid[0][j]==0;j++)&#123;\n             dp[0][j]=1;\n         &#125; \n         System.out.println(Arrays.deepToString(dp));\n         // 一般情况下\n         for(int i=1;i&lt;m;i++)&#123;\n             for(int j=1;j&lt;n;j++)&#123;\n                 // int up=obstacleGrid[i-1][j]==1?0:dp[i-1][j];\n                 // int left=obstacleGrid[i][j-1]==1?0:dp[i][j-1];  \n                 // 如果此处是障碍物的话 为0 否则两者相加\n                 dp[i][j]=obstacleGrid[i][j]==1?0:dp[i-1][j]+dp[i][j-1];\n             &#125;\n         &#125;\n         return dp[m-1][n-1];       \n     &#125;\n &#125;\n</code></pre>\n<h2 id=\"整数拆分\"><a href=\"#整数拆分\" class=\"headerlink\" title=\"整数拆分\"></a>整数拆分</h2><p>给定一个正整数 n ，将其拆分为 k 个 <strong>正整数</strong> 的和（ k &gt;&#x3D; 2 ），并使这些整数的乘积最大化。</p>\n<p>返回 <em>你可以获得的最大乘积</em> 。</p>\n<pre><code class=\"plain\">class Solution &#123;\n     public int integerBreak(int n) &#123;\n         // dp[i]：分拆数字i，可以得到的最大乘积为dp[i]。\n         // 需要n+1个数 因为最后输出dp[n]\n         int[] dp=new int[n+1];\n         // dp0 1无意义 初始值设为dp2\n         dp[2]=1;\n         for(int i=3;i&lt;=n;i++)&#123;\n             // 从1开始拆   拆到一半就行 免得重复\n             for(int j=1;j&lt;=i/2;j++)&#123;\n                 //j * (i - j) 是单纯的把整数拆分为两个数相乘，而j * dp[i - j]是拆分成两个以及两个以上的个数相乘。\n                 dp[i]=Math.max(dp[i],Math.max((i-j)*j,dp[i-j]*j));\n             &#125;\n         &#125;\n         return dp[n];\n     &#125;\n &#125;\n</code></pre>\n<h2 id=\"不同的二叉搜索树\"><a href=\"#不同的二叉搜索树\" class=\"headerlink\" title=\"不同的二叉搜索树\"></a>不同的二叉搜索树</h2><p>给你一个整数 n ，求恰由 n 个节点组成且节点值从 1 到 n 互不相同的 <strong>二叉搜索树</strong> 有多少种？返回满足题意的二叉搜索树的种数。</p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/uniquebstn3.jpg\" alt=\"img\"></p>\n<p>G(n): 长度为 n 的序列能构成的不同二叉搜索树的个数</p>\n<p>初始：G(0)&#x3D;1,G(0)&#x3D;1;</p>\n<p>给定序列 1⋯n，我们选择数字 i 作为根，则根为 i的所有二叉搜索树的集合是左子树集合和右子树集合的笛卡尔积，对于笛卡尔积中的每个元素，加上根节点之后形成完整的二叉搜索树，如下图所示：</p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/96_fig1.png\" alt=\"img\"></p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/image-20221130155936419.png\" alt=\"img\"></p>\n<pre><code class=\"plain\">class Solution &#123;\n         public int numTrees(int n) &#123;\n //            G(n): 长度为 n的序列能构成的不同二叉搜索树的个数。\n //            F(i,n): 以 i 为根、序列长度为 n 的不同二叉搜索树个数\n //        G（n)=求和从1到n F(i,n)\n //           F(i,n)=G（i-1)G(n-i)\n //        换元：G（n)=求和从1到n G（i-1)G(n-i)\n             int[] G = new int[n + 1];\n             G[0] = 1;\n             G[1] = 1;\n             for (int i = 2; i &lt;= n; i++) &#123;\n                 for (int j = 1; j &lt;= i; j++) &#123;\n                     // 以j作为根结点\n                     G[i] += G[j - 1] * G[i - j];\n                 &#125;\n             &#125;\n             return G[n];\n         &#125;\n     &#125;\n</code></pre>\n<h2 id=\"01背包理论基础\"><a href=\"#01背包理论基础\" class=\"headerlink\" title=\"01背包理论基础\"></a>01背包理论基础</h2><h3 id=\"二维\"><a href=\"#二维\" class=\"headerlink\" title=\"二维\"></a>二维</h3><p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/image-20221202150710208.png\" alt=\"img\"></p>\n<pre><code class=\"plain\">public static void testweightbagproblem(int[] weight, int[] value, int bagsize)&#123;\n         int wlen = weight.length, value0 = 0;\n         //定义dp数组：dp[i][j]表示背包容量为j时，前i个物品能获得的最大价值\n         int[][] dp = new int[wlen + 1][bagsize + 1];\n         //初始化：背包容量为0时，能获得的价值都为0\n         for (int i = 0; i &lt;= wlen; i++)&#123;\n             dp[i][0] = value0;\n         &#125;\n         //遍历顺序：先遍历物品，再遍历背包容量\n         for (int i = 1; i &lt;= wlen; i++)&#123;\n             for (int j = 1; j &lt;= bagsize; j++)&#123;\n                 if (j &lt; weight[i - 1])&#123;\n                     dp[i][j] = dp[i - 1][j];\n                 &#125;else&#123;\n                     dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - weight[i - 1]] + value[i - 1]);\n                 &#125;\n             &#125;\n         &#125;\n</code></pre>\n<p><strong>二维两个for循环可以调换</strong></p>\n<h3 id=\"一维\"><a href=\"#一维\" class=\"headerlink\" title=\"一维\"></a>一维</h3><p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/image-20221202150646521.png\" alt=\"img\"></p>\n<pre><code class=\"plain\">public static void testWeightBagProblem(int[] weight, int[] value, int bagWeight)&#123;\n         int wLen = weight.length;\n         //定义dp数组：dp[j]表示背包容量为j时，能获得的最大价值\n         int[] dp = new int[bagWeight + 1];\n         //遍历顺序：先遍历物品，再遍历背包容量\n         for (int i = 0; i &lt; wLen; i++)&#123;\n             //j &gt;= weight[i]为了保证dp[j - weight[i]] 有界\n             for (int j = bagWeight; j &gt;= weight[i]; j--)&#123;\n                 dp[j] = Math.max(dp[j], dp[j - weight[i]] + value[i]);\n             &#125;\n         &#125;\n         //打印dp数组\n         for (int j = 0; j &lt;= bagWeight; j++)&#123;\n             System.out.print(dp[j] + &quot; &quot;);\n         &#125;\n     &#125;\n</code></pre>\n<p><strong>遍历背包容量必须是逆序，原因如下：</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/image-20221202150558700.png\" alt=\"img\"></p>\n<p><strong>为何二维不用倒序？</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/image-20221202150756755.png\" alt=\"img\"></p>\n<p><strong>两个for循环可以颠倒吗</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/image-20221202151645851.png\" alt=\"img\"></p>\n<h2 id=\"分割等和子集\"><a href=\"#分割等和子集\" class=\"headerlink\" title=\"分割等和子集\"></a>分割等和子集</h2><h3 id=\"方法一\"><a href=\"#方法一\" class=\"headerlink\" title=\"方法一\"></a>方法一</h3><p>给你一个 <strong>只包含正整数</strong> 的 <strong>非空</strong> 数组 nums 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/image-20221005155841234.png\" alt=\"img\"></p>\n<p><strong>改进</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/image-20221005155958315.png\" alt=\"img\"></p>\n<p><strong>我的理解：</strong> 不管j和num[i]的关系 我这个公式一定成立 改进后，行i简化成循环次数，j不变</p>\n<pre><code class=\"plain\">class Solution &#123;\n     public boolean canPartition(int[] nums) &#123;\n         int n = nums.length;\n         if (n &lt; 2) &#123;\n             return false;\n         &#125;\n         int sum = 0, maxNum = 0;\n         for (int num : nums) &#123;\n             sum += num;\n             maxNum = Math.max(maxNum, num);\n         &#125;\n         if (sum % 2 != 0) &#123;\n             return false;\n         &#125;\n         int target = sum / 2;\n         if (maxNum &gt; target) &#123;\n             return false;\n         &#125;\n         boolean[] dp = new boolean[target + 1];\n         dp[0] = true;//目标值为0 不选就行了 因此为true\n         for (int i = 0; i &lt; n; i++) &#123;\n             int num = nums[i];\n             for (int j = target; j &gt;= num; --j) &#123;\n                 dp[j] |= dp[j - num];\n             &#125;\n         &#125;\n         return dp[target];\n     &#125;\n &#125;\n</code></pre>\n<h3 id=\"方法二\"><a href=\"#方法二\" class=\"headerlink\" title=\"方法二\"></a>方法二</h3><p>**dp[j]表示 背包总容量是j，最大可以凑成j的子集总和为dp[j]**。</p>\n<p>dp[j]的数值一定是小于等于j的。因为限定了背包容量，最多是正好填满</p>\n<p><strong>如果dp[j] &#x3D;&#x3D; j 说明，集合中的子集总和正好可以凑成总和j，理解这一点很重要。</strong></p>\n<pre><code class=\"plain\">class Solution &#123;\n     public boolean canPartition(int[] nums) &#123;\n         if(nums == null || nums.length == 0) return false;\n         int n = nums.length;\n         int sum = 0;\n         for(int num : nums)&#123;\n             sum += num;\n         &#125;\n         //总和为奇数，不能平分\n         if(sum % 2 != 0) return false;\n         int target = sum / 2;\n         int[] dp = new int[target + 1];\n         for(int i = 0; i &lt; n; i++)&#123;\n             for(int j = target; j &gt;= nums[i]; j--)&#123;\n                 //物品 i 的重量是 nums[i]，其价值也是 nums[i]\n                 dp[j] = Math.max(dp[j], dp[j-nums[i]] + nums[i]);\n             &#125;\n         &#125;\n         return dp[target] == target;\n     &#125;\n &#125;\n</code></pre>\n<h2 id=\"最后一块石头的重量-II\"><a href=\"#最后一块石头的重量-II\" class=\"headerlink\" title=\"最后一块石头的重量 II\"></a>最后一块石头的重量 II</h2><p>有一堆石头，用整数数组 stones 表示。其中 stones[i] 表示第 i 块石头的重量。</p>\n<p>每一回合，从中选出<strong>任意两块石头</strong>，然后将它们一起粉碎。假设石头的重量分别为 x 和 y，且 x &lt;&#x3D; y。那么粉碎的可能结果如下：</p>\n<ul>\n<li>如果 x &#x3D;&#x3D; y，那么两块石头都会被完全粉碎；</li>\n<li>如果 x !&#x3D; y，那么重量为 x 的石头将会完全粉碎，而重量为 y 的石头新重量为 y-x。</li>\n</ul>\n<p>最后，<strong>最多只会剩下一块</strong> 石头。返回此石头 <strong>最小的可能重量</strong> 。如果没有石头剩下，就返回 0。</p>\n<p>题解:</p>\n<p><strong>dp[j]表示容量（这里说容量更形象，其实就是重量）为j的背包，最多可以背dp[j]这么重的石头</strong>。</p>\n<pre><code class=\"plain\">class Solution &#123;\n     public int lastStoneWeightII(int[] stones) &#123;\n         //求总数\n         int sum=0;\n         for(int stone:stones)&#123;\n             sum+=stone;\n         &#125;\n         int target=sum/2;\n         int[] dp=new int[target+1];\n         int n=stones.length;\n         //背包问题，target容量里面最多能放多少重量，这里weight就是value\n         \n         for(int i=0;i&lt;n;i++)&#123;\n             for(int j=target;j&gt;=stones[i];j--)&#123;\n                 dp[j]=Math.max(dp[j],dp[j-stones[i]]+stones[i]);\n             &#125;\n         &#125;\n         //两个一同粉碎\n         return sum-dp[target]*2;\n     &#125;\n &#125;\n</code></pre>\n<h2 id=\"目标和\"><a href=\"#目标和\" class=\"headerlink\" title=\"目标和\"></a>目标和</h2><p>回溯有</p>\n<p>再回归到01背包问题，为什么是01背包呢？ 因为每个物品（题目中的1）只用一次！</p>\n<ol>\n<li>确定dp数组以及下标的含义</li>\n</ol>\n<p>dp[j] 表示：填满j（包括j）这么大容积的包，有dp[j]种方法</p>\n<ol>\n<li>确定递推公式</li>\n</ol>\n<p>有哪些来源可以推出dp[j]呢？</p>\n<p>不考虑nums[i]的情况下，填满容量为j的背包，有dp[j]种方法。</p>\n<p>那么考虑nums[i]的话（只要搞到nums[i]），凑成dp[j]就有dp[j - nums[i]] 种方法。</p>\n<ol>\n<li>dp数组如何初始化</li>\n</ol>\n<p>dp[0] &#x3D; 1，理论上也很好解释，装满容量为0的背包，有1种方法，就是装0件物品。</p>\n<pre><code class=\"plain\">class Solution &#123;\n     public int findTargetSumWays(int[] nums, int target) &#123;\n         int sum=0;\n         // 计算总和\n         for(int num:nums)&#123;\n             sum+=num;\n         &#125;\n         // 设正数值为S ,那么S-(sum-S)=target\n         // 目标值大于sum或者除不尽 return 0\n         if(target&gt;sum||(target+sum)%2==1) return 0;\n         int S=(target+sum)/2;\n         int n=nums.length;\n         // dp[j] 表示：填满j（包括j）这么大容积的包，有dp[j]种方法\n         int[] dp=new int[S+1];\n         dp[0]=1;\n         // 套用01背包(拿或者不拿)\n         for(int i=0;i&lt;n;i++)&#123;\n             for(int j=S;j&gt;=nums[i];j--)&#123;\n                 dp[j]+=dp[j-nums[i]];\n             &#125;\n         &#125;\n        return dp[S];\n     &#125;\n &#125;自己写的 有待改进 但是现在不想改\n</code></pre>\n<h2 id=\"零钱兑换\"><a href=\"#零钱兑换\" class=\"headerlink\" title=\"零钱兑换\"></a>零钱兑换</h2><p>给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。</p>\n<p>计算并返回可以凑成总金额所需的 最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1 。</p>\n<p>你可以认为每种硬币的数量是无限的。</p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/image-20220927211913746.png\" alt=\"img\"></p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/image-20220927211950883.png\" alt=\"img\"></p>\n<p>在上面的递归树中，我们可以看到许多子问题被多次计算。例如，F(1)F(1)F(1) 被计算了 131313 次。为了避免重复的计算，我们将每个子问题的答案存在一个数组中进行记忆化，如果下次还要计算这个问题的值直接从数组中取出返回即可，这样能保证每个子问题最多只被计算一次。</p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/image-20220927212012322.png\" alt=\"img\"></p>\n<pre><code class=\"plain\">public class Solution &#123;\n     public int coinChange(int[] coins, int amount) &#123;\n         int max = amount + 1;//必然比dp所有值都大\n         int[] dp = new int[amount + 1];\n         Arrays.fill(dp, max);//填充数组\n         dp[0] = 0;\n         //i是金额，自底向上，即i从1一直算到amount,每个dp[i]通过穷举硬币coins[j]计算dp[i - coins[j]]最小值 最后算出结果 \n         for (int i = 1; i &lt;= amount; i++) &#123;\n             for (int j = 0; j &lt; coins.length; j++) &#123;\n                 if (coins[j] &lt;= i) &#123;\n                     dp[i] = Math.min(dp[i], dp[i - coins[j]] + 1);\n                 &#125;\n             &#125;\n         &#125;\n         return dp[amount] &gt; amount ? -1 : dp[amount];\n     &#125;\n &#125;\n</code></pre>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/image-20220927212808445.png\" alt=\"img\"></p>\n<h2 id=\"戳气球\"><a href=\"#戳气球\" class=\"headerlink\" title=\"戳气球\"></a>戳气球</h2><p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/image-20220927162714859.png\" alt=\"img\"></p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/image-20220927162801928.png\" alt=\"img\"></p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/image-20220927162834656.png\" alt=\"img\"></p>\n<pre><code class=\"plain\">class Solution &#123;\n     public int maxCoins(int[] nums) &#123;\n         int n = nums.length;\n         //rec是record\n         int[][] rec = new int[n + 2][n + 2];//初始二维数组元素全为0\n         int[] val = new int[n + 2];\n         val[0] = val[n + 1] = 1;//防止nums下标越界\n         for (int i = 1; i &lt;= n; i++) &#123;\n             val[i] = nums[i - 1];\n         &#125;\n         //自底向下\n         for (int i = n - 1; i &gt;= 0; i--) &#123;\n             for (int j = i + 2; j &lt;= n + 1; j++) &#123;\n                 for (int k = i + 1; k &lt; j; k++) &#123;\n                     int sum = val[i] * val[k] * val[j];\n                     //递归\n                     sum += rec[i][k] + rec[k][j];\n                     rec[i][j] = Math.max(rec[i][j], sum);//能得到的最多硬币数  考虑到会有重复的 因此选择打擂台方法\n                 &#125;\n             &#125;\n         &#125;\n         return rec[0][n + 1];\n     &#125;\n &#125;\n</code></pre>\n<h2 id=\"最佳买卖股票时机含冷冻期\"><a href=\"#最佳买卖股票时机含冷冻期\" class=\"headerlink\" title=\"最佳买卖股票时机含冷冻期\"></a>最佳买卖股票时机含冷冻期</h2><p>给定一个整数数组prices，其中第 prices[i] 表示第 i 天的股票价格 。</p>\n<p>设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:</p>\n<p>卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。</p>\n<p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>\n<p><strong>思路与算法</strong></p>\n<p>我们用 f[i]表示第 ii天结束之后的「累计最大收益」。根据题目描述，由于我们最多只能同时买入（持有）一支股票，并且卖出股票后有冷冻期的限制，因此我们会有三种不同的状态：</p>\n<pre><code class=\"plain\">我们目前持有一支股票，对应的「累计最大收益」记为 f[i][0]；\n \n 我们目前不持有任何股票，并且处于冷冻期中，对应的「累计最大收益」记为 f[i][1]；\n \n 我们目前不持有任何股票，并且不处于冷冻期中，对应的「累计最大收益」记为 f[i][2]。\n</code></pre>\n<p><strong>这里的「处于冷冻期」指的是在第 i天结束之后的状态。也就是说：如果第 i 天结束之后处于冷冻期，那么第 i+1 天无法买入股票。</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/image-20220926192627869.png\" alt=\"img\"></p>\n<p>这里自己手推一遍</p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/image-20220926193642785.png\" alt=\"img\"></p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/image-20220926193754486.png\" alt=\"img\"></p>\n<pre><code class=\"plain\">class Solution &#123;\n     public int maxProfit(int[] prices) &#123;\n         if (prices.length == 0) &#123;\n             return 0;\n         &#125;\n \n         int n = prices.length;\n         //初始化\n         int f0 = -prices[0];\n         int f1 = 0;\n         int f2 = 0;\n         //滚动数组\n         for (int i = 1; i &lt; n; ++i) &#123;\n             int newf0 = Math.max(f0, f2 - prices[i]);\n             int newf1 = f0 + prices[i];\n             int newf2 = Math.max(f1, f2);\n             f0 = newf0;\n             f1 = newf1;\n             f2 = newf2;\n         &#125;\n \n         return Math.max(f1, f2);\n     &#125;\n &#125;\n</code></pre>\n<h2 id=\"完全平方数\"><a href=\"#完全平方数\" class=\"headerlink\" title=\"完全平方数\"></a>完全平方数</h2><p>给你一个整数 n ，返回 和为 n 的完全平方数的最少数量 。</p>\n<p>完全平方数 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。</p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/image-20220921173922046.png\" alt=\"img\"></p>\n<p>从小到大枚举i，以计算f[i]，最终得到f[n]，j也是从小到大枚举，每次把j当作i的一个平方因子，因此f[i]&#x3D;1+f[ i-j^2 ] 初始条件f(0)&#x3D;0，因此可以一步步把f[i]算出来</p>\n<pre><code class=\"plain\">class Solution &#123;\n     public int numSquares(int n) &#123;\n         int[] f = new int[n + 1];\n         for (int i = 1; i &lt;= n; i++) &#123;\n             int minn = Integer.MAX_VALUE;\n             for (int j = 1; j * j &lt;= i; j++) &#123;\n                 minn = Math.min(minn, f[i - j * j]);//\n             &#125;\n             f[i] = minn + 1;\n         &#125;\n         return f[n];\n     &#125;\n &#125;\n</code></pre>\n<h2 id=\"最大正方形\"><a href=\"#最大正方形\" class=\"headerlink\" title=\"最大正方形\"></a><a href=\"https://leetcode.cn/problems/maximal-square/\">最大正方形</a></h2><p>在一个由 ‘0’ 和 ‘1’ 组成的二维矩阵内，找到只包含 ‘1’ 的最大正方形，并返回其面积。</p>\n<p> dp(i,j)&#x3D;min(dp(i−1,j),dp(i−1,j−1),dp(i,j−1))+1&#x2F;&#x2F;状态转移方程  </p>\n<p>dp(i,j）代表以坐标点(i,j) 为右下角的最大正方形 还要注意如果i j之中有一个为0，那么dp值为0</p>\n<pre><code class=\"plain\">class Solution &#123;\n         public int maximalSquare(char[][] matrix) &#123;\n             int maxSide = 0, row = matrix.length, column = matrix[0].length;\n             if (matrix == null || row == 0 || column == 0) return 0;\n             int[][] dp = new int[row][column];\n             for (int i = 0; i &lt; row; i++) &#123;\n                 for (int j = 0; j &lt; column; j++) &#123;\n                     if (matrix[i][j] == &#39;1&#39;) &#123;\n                         if (i == 0 || j == 0) &#123;\n                             dp[i][j] = 1;\n                         &#125; else &#123;\n                             dp[i][j] = Math.min(Math.min(dp[i - 1][j - 1], dp[i - 1][j]), dp[i][j - 1]) + 1;\n                         &#125;\n                         maxSide = Math.max(maxSide, dp[i][j]);\n                     &#125;\n                 &#125;\n             &#125;\n             return maxSide * maxSide;\n         &#125;\n     &#125;\n</code></pre>\n<h2 id=\"最长递增子序列-也可greedy-优先这个\"><a href=\"#最长递增子序列-也可greedy-优先这个\" class=\"headerlink\" title=\"最长递增子序列(也可greedy 优先这个)\"></a>最长递增子序列(也可greedy 优先这个)</h2><pre><code class=\"plain\">输入：nums = [10,9,2,5,3,7,101,18]\n 输出：4\n 解释：最长递增子序列是 [2,3,7,101]，因此长度为 4\n</code></pre>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/image-20220924110440818.png\" alt=\"img\"></p>\n<pre><code class=\"plain\">class Solution &#123;\n     public int lengthOfLIS(int[] nums) &#123;\n         if (nums.length == 0) &#123;\n             return 0;\n         &#125;\n         int[] dp = new int[nums.length];\n         dp[0] = 1;\n         int maxans = 1;//最少为1\n         for (int i = 1; i &lt; nums.length; i++) &#123;\n             dp[i] = 1;//以i为结尾 那必然包括自己 所以至少为\n             for (int j = 0; j &lt; i; j++) &#123;\n                 if (nums[i] &gt; nums[j]) &#123;\n                     dp[i] = Math.max(dp[i], dp[j] + 1);//选取以j为结尾的（j从0到i-1）最长序列，然后加1\n                 &#125;\n             &#125;\n             maxans = Math.max(maxans, dp[i]);\n         &#125;\n         return maxans;\n     &#125;\n &#125;\n</code></pre>\n<h2 id=\"乘积最大子数组\"><a href=\"#乘积最大子数组\" class=\"headerlink\" title=\"乘积最大子数组\"></a>乘积最大子数组</h2><p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/image-20220908161610143.png\" alt=\"img\"></p>\n<pre><code class=\"plain\">class Solution &#123;\n     public int maxProduct(int[] nums) &#123;\n         int maxF=nums[0],minF=nums[0],ans=nums[0];\n         int length=nums.length;\n         for(int i=1;i&lt;length;i++)&#123;\n             int mx=maxF,mn=minF;//每次循环都要重新赋值，因为乘的就是最大最小值\n             maxF=Math.max(nums[i],Math.max(mx*nums[i],mn*nums[i]));//考虑到正负号的原因\n             minF=Math.min(nums[i],Math.min(mx*nums[i],mn*nums[i]));//这个肯定要算，maxF用的上\n             ans=Math.max(ans,maxF);\n         &#125;\n         return ans;\n \n     &#125;\n &#125;\n</code></pre>\n<p><strong>system.arraycopy的作用</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/image-20220908161656999.png\" alt=\"img\"></p>\n<h2 id=\"偷窃\"><a href=\"#偷窃\" class=\"headerlink\" title=\"偷窃\"></a>偷窃</h2><p>计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p>\n<p>给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。</p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/image-20220911163343582.png\" alt=\"img\"></p>\n<h2 id=\"岛屿问题\"><a href=\"#岛屿问题\" class=\"headerlink\" title=\"岛屿问题\"></a>岛屿问题</h2><p><a href=\"https://leetcode-cn.com/problems/number-of-islands/\">L200. 岛屿数量</a> （Easy）</p>\n<p><a href=\"https://leetcode-cn.com/problems/island-perimeter/\">463. 岛屿的周长</a> （Easy）</p>\n<p><a href=\"https://leetcode-cn.com/problems/max-area-of-island/\">695. 岛屿的最大面积</a> （Medium）</p>\n<p><a href=\"https://leetcode-cn.com/problems/making-a-large-island/\">827. 最大人工岛</a> （Hard）</p>\n<p>采用DFS</p>\n<p><strong>基本框架?</strong></p>\n<p>dfs两要素:「<strong>访问相邻结点</strong>」和「<strong>判断 base case</strong>」</p>\n<p><strong>如何避免重复遍历?</strong></p>\n<p>答案是标记已经遍历过的格子</p>\n<p><strong>岛屿数量问题</strong></p>\n<pre><code class=\"plain\">class Solution &#123;\n     public int numIslands(char[][] grid) &#123;\n         int count = 0;\n         for(int i = 0; i &lt; grid.length; i++) &#123;\n             for(int j = 0; j &lt; grid[0].length; j++) &#123;\n                 if(grid[i][j] == &#39;1&#39;)&#123;\n                     dfs(grid, i, j);\n                     count++;\n                 &#125;\n             &#125;\n         &#125;\n         return count;\n     &#125;\n     private void dfs(char[][] grid, int i, int j)&#123;\n         if(i &lt; 0 || j &lt; 0 || i &gt;= grid.length || j &gt;= grid[0].length || grid[i][j] == &#39;0&#39;) return;\n         grid[i][j] = &#39;0&#39;;\n         dfs(grid, i + 1, j);\n         dfs(grid, i, j + 1);\n         dfs(grid, i - 1, j);\n         dfs(grid, i, j - 1);\n     &#125;\n &#125;\n</code></pre>\n<h2 id=\"一和零\"><a href=\"#一和零\" class=\"headerlink\" title=\"一和零\"></a>一和零</h2><p>给你一个二进制字符串数组 strs 和两个整数 m 和 n 。</p>\n<p>请你找出并返回 strs 的最大子集的长度，该子集中 <strong>最多</strong> 有 m 个 0 和 n 个 1 。</p>\n<p>如果 x 的所有元素也是 y 的元素，集合 x 是集合 y 的 <strong>子集</strong> 。</p>\n<ul>\n<li>输入：strs &#x3D; [“10”, “0001”, “111001”, “1”, “0”], m &#x3D; 5, n &#x3D; 3</li>\n<li>输出：4</li>\n<li>解释：最多有 5 个 0 和 3 个 1 的最大子集是 {“10”,”0001”,”1”,”0”} ，因此答案是 4 。 其他满足题意但较小的子集包括 {“0001”,”1”} 和 {“10”,”1”,”0”} 。{“111001”} 不满足题意，因为它含 4 个 1 ，大于 n 的值 3 。</li>\n</ul>\n<pre><code class=\"plain\">class Solution &#123;\n    public int findMaxForm(String[] strs, int m, int n) &#123;\n        // System.out.println(Arrays.toString(res));  \n        int[][] dp=new int[m+1][n+1];\n        // dp[j][k]代表容量为jk的最大子集长度  dp[i][j]：最多有i个0和j个1的strs的最大子集的大小为dp[i][j]。\n        // 依然套用01背包 只是需要二维数组\n        int length=strs.length;\n        for(int i=0;i&lt;length;i++)&#123;\n            int num0=getnum(strs[i])[0];\n            int num1=getnum(strs[i])[1];\n            for(int j=m;j&gt;=num0;j--)&#123;\n                for(int k=n;k&gt;=num1;k--)&#123;\n                    // 递推公式\n                    dp[j][k]=Math.max(dp[j][k],dp[j-num0][k-num1]+1);\n                &#125;\n            &#125;\n        &#125;\n        return dp[m][n];\n    &#125;\n    //获取0 1的数量\n    public int[] getnum(String s)&#123;\n        int num0=0,num1=0;\n        for(int i=0;i&lt;s.length();i++)&#123;\n            if(s.charAt(i)==&#39;0&#39;) num0++;\n            if(s.charAt(i)==&#39;1&#39;) num1++;\n        &#125;\n        return new int[]&#123;num0,num1&#125;;\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"完全背包\"><a href=\"#完全背包\" class=\"headerlink\" title=\"完全背包\"></a>完全背包</h2><p>有N件物品和一个最多能背重量为W的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。<strong>每件物品都有无限个（也就是可以放入背包多次）</strong>，求解将哪些物品装入背包里物品价值总和最大。</p>\n<p>01背包中二维dp数组的两个for遍历的先后循序是可以颠倒了，一维dp数组的两个for循环先后循序一定是先遍历物品，再遍历背包容量（为了保证每个物品仅被添加一次。）</p>\n<p><strong>在完全背包中，对于一维dp数组来说，其实两个for循环嵌套顺序同样无所谓！</strong></p>\n<pre><code class=\"plain\">// 先遍历物品，再遍历背包\nfor(int i = 0; i &lt; weight.size(); i++) &#123; // 遍历物品\n    for(int j = weight[i]; j &lt;= bagWeight ; j++) &#123; // 遍历背包容量  j从weight[i]开始 保证递归函数有效\n        dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"零钱兑换-II\"><a href=\"#零钱兑换-II\" class=\"headerlink\" title=\"零钱兑换 II\"></a>零钱兑换 II</h2><p>给你一个整数数组 coins 表示不同面额的硬币，另给一个整数 amount 表示总金额。</p>\n<p>请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回 0 。</p>\n<p>假设每一种面额的硬币有无限个。 </p>\n<p>题目数据保证结果符合 32 位带符号整数。</p>\n<pre><code class=\"plain\">class Solution &#123;\n    public int change(int amount, int[] coins) &#123;\n        // dp[i]：凑成i金额有dp[i]组合数\n        int n=coins.length;\n        int[] dp=new int[amount+1];\n        dp[0]=1;//\n        for(int i=0;i&lt;n;i++)&#123;\n            for(int j=coins[i];j&lt;=amount;j++)&#123;\n                dp[j]+=dp[j-coins[i]];\n            &#125;\n        &#125;\n        System.out.println(Arrays.toString(dp));\n        return dp[amount];\n    &#125;\n&#125;\n</code></pre>\n<p>遍历物品在外，遍历背包容量在内——&gt;算的是组合数 只有{1, 5}这种情况</p>\n<p>遍历背包容量在外，遍历物品在内——-&gt;算的是排列数 {1，5} {5，1}都有</p>\n<pre><code class=\"plain\">for (int j = 0; j &lt;= amount; j++) &#123; // 遍历背包容量\n    for (int i = 0; i &lt; coins.size(); i++) &#123; // 遍历物品\n        if (j - coins[i] &gt;= 0) dp[j] += dp[j - coins[i]];\n    &#125;\n&#125;\n</code></pre>\n<p>dp[j] +&#x3D; dp[j - nums[i]]</p>\n<p><strong>注意：求装满背包有几种方法类似的题目，递推公式基本都是这样的</strong>。</p>\n<h2 id=\"组合总和-Ⅳ\"><a href=\"#组合总和-Ⅳ\" class=\"headerlink\" title=\"组合总和 Ⅳ\"></a>组合总和 Ⅳ</h2><p>给你一个由 <strong>不同</strong> 整数组成的数组 nums ，和一个目标整数 target 。请你从 nums 中找出并返回总和为 target 的元素组合的个数。</p>\n<p>题目数据保证答案符合 32 位整数范围。</p>\n<p>dp[0]是递归中一切数值的基础所在，如果dp[0]是0的话，其他数值都是0了。</p>\n<pre><code class=\"plain\">class Solution &#123;\n    public int combinationSum4(int[] nums, int target) &#123;\n    // dp[j]表示总和为j的元素组合个数\n        int[] dp=new int[target+1];\n        dp[0]=1;\n        int n=nums.length;\n        // 两个for循环换一下 注意审题！！！！请注意，顺序不同的序列被视作不同的组合。\n        for(int j=0;j&lt;=target;j++)&#123;\n            for(int i=0;i&lt;n;i++)&#123;\n                if(j&gt;=nums[i])&#123;\n                    dp[j]+=dp[j-nums[i]];\n                &#125;\n            &#125;\n        &#125;\n        return dp[target];\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"爬楼梯进阶\"><a href=\"#爬楼梯进阶\" class=\"headerlink\" title=\"爬楼梯进阶\"></a>爬楼梯进阶</h2><p><strong>dp[i]：爬到有i个台阶的楼顶，有dp[i]种方法</strong></p>\n<p>遍历顺序：</p>\n<p>这是背包里求排列问题，即：<strong>1、2 步 和 2、1 步都是上三个台阶，但是这两种方法不一样！</strong> 强调顺序就是求排列问题</p>\n<p>所以需将target放在外循环，将nums放在内循环。</p>\n<p>每一步可以走多次，这是完全背包，内循环需要从前向后遍历。</p>\n<pre><code class=\"plain\">public int climbStairs(int n) &#123;\n        int[] dp=new int[n+1];\n        dp[0]=1;\n        int[] weight=&#123;1,2&#125;;\n        for(int i=0;i&lt;=n;i++)&#123;\n            for(int j=0;j&lt;weight.length;j++)&#123;\n                if(i&gt;=weight[j]) dp[i]+=dp[i-weight[j]];\n            &#125;\n        &#125;\n        return dp[n];\n    &#125;\n</code></pre>\n<h2 id=\"零钱兑换-1\"><a href=\"#零钱兑换-1\" class=\"headerlink\" title=\"零钱兑换\"></a>零钱兑换</h2><p>给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。</p>\n<p>计算并返回可以凑成总金额所需的 <strong>最少的硬币个数</strong> 。如果没有任何一种硬币组合能组成总金额，返回 -1 。</p>\n<p>你可以认为每种硬币的数量是无限的。</p>\n<pre><code class=\"plain\">class Solution &#123;\n    public int coinChange(int[] coins, int amount) &#123;\n        // 完全背包 顺序for循环    排列组合无所谓！\n        // dp[j]:        凑成总金额i所需最少硬币个数为dp[j] dp[j]=min (dp[j],dp[j-coins[i]]+1\n        int[] dp=new int[amount+1];//初始化一个大于amount的数字，因为是求最小值 dp值肯定不会大于amount的最多只能amount（都是面值为1的）\n        Arrays.fill(dp,amount+1);\n        dp[0]=0;\n        for(int i=0;i&lt;coins.length;i++)&#123;\n            for(int j=coins[i];j&lt;=amount;j++)&#123;\n                dp[j]=Math.min(dp[j],dp[j-coins[i]]+1);\n            &#125;\n        &#125;\n        return dp[amount]&gt;amount?-1:dp[amount];\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"完全平方数-1\"><a href=\"#完全平方数-1\" class=\"headerlink\" title=\"完全平方数\"></a>完全平方数</h2><p>给你一个整数 n ，返回 <em>和为</em> <em>n</em> <em>的完全平方数的最少数量</em> 。</p>\n<p><strong>完全平方数</strong> 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。</p>\n<pre><code class=\"plain\">class Solution &#123;\n    public int numSquares(int n) &#123;\n        // 完全背包  dp[j]  和为 j 的完全平方数的最少数量\n        // dp[j]=Math.min(dp[j],dp[j-i^2]);\n        int[] dp=new int[n+1];\n        Arrays.fill(dp,Integer.MAX_VALUE);\n        dp[0]=0;\n        // 先遍历物品 再容量 (顺序无所谓)\n        for(int i=1;i*i&lt;=n;i++)&#123;\n            // int j=i*i根据里面dp[j-i*i]来定\n            for(int j=i*i;j&lt;=n;j++)&#123;\n                dp[j]=Math.min(dp[j],dp[j-i*i]+1);\n            &#125;\n        &#125;\n        return dp[n];\n        \n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"单词拆分\"><a href=\"#单词拆分\" class=\"headerlink\" title=\"单词拆分\"></a>单词拆分</h2><p>给你一个字符串 s 和一个字符串列表 wordDict 作为字典。请你判断是否可以利用字典中出现的单词拼接出 s 。</p>\n<p><strong>注意：</strong>不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用（完全背包）。</p>\n<p>题解：</p>\n<p>组合先物品、排列后物品</p>\n<pre><code class=\"plain\">class Solution &#123;\n    public boolean wordBreak(String s, List&lt;String&gt; wordDict) &#123;\n//dp[i] : 字符串长度为i的话，dp[i]为true，表示可以拆分为一个或多个在字典中出现的单词。\n// dp[j]=dp[i]&amp;&amp;wordDict.contains(s.subString(i,j))\n// 这个是排列 有顺序要求  leetcode =leet+code但不=code+leet   物品遍历在里面  \n// 完全背包   顺序遍历\n        int n=s.length();\n        Set&lt;String&gt; wordDictSet = new HashSet(wordDict);\n        boolean[] dp=new boolean[n+1];\n        dp[0]=true;\n        for(int i=1;i&lt;=n;i++)&#123;\n            for(int j=0;j&lt;i;j++)&#123;\n                if(dp[j]&amp;&amp;wordDictSet.contains(s.substring(j,i)))&#123;\n                    dp[i]=true;\n                    break;\n                &#125;\n            &#125;\n        &#125;\n        return dp[n];\n    &#125;\n&#125;\n</code></pre>\n<p>dp[i] 的状态依靠 dp[j]是否为true，那么dp[0]就是递归的根基，dp[0]一定要为true，否则递归下去后面都都是false了。</p>\n<h2 id=\"多重背包\"><a href=\"#多重背包\" class=\"headerlink\" title=\"多重背包\"></a>多重背包</h2><p>有N种物品和一个容量为V 的背包。第i种物品最多有Mi件可用，每件耗费的空间是Ci ，价值是Wi 。求解将哪些物品装入背包可使这些物品的耗费的空间 总和不超过背包容量，且价值总和最大。</p>\n<p>每件物品最多有Mi件可用，把Mi件摊开，其实就是一个01背包问题了。</p>\n<p>了解即可</p>\n<h2 id=\"背包总结\"><a href=\"#背包总结\" class=\"headerlink\" title=\"背包总结\"></a>背包总结</h2><p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/20210117171307407.png\" alt=\"img\"></p>\n<ol>\n<li>确定dp数组（dp table）以及下标的含义</li>\n<li>确定递推公式</li>\n<li>dp数组如何初始化</li>\n<li>确定遍历顺序</li>\n<li>举例推导dp数组</li>\n</ol>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/image-20221212145752902.png\" alt=\"img\"></p>\n<p>具体总结看代码随想录</p>\n<h2 id=\"打家劫舍\"><a href=\"#打家劫舍\" class=\"headerlink\" title=\"打家劫舍\"></a>打家劫舍</h2><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong>。</p>\n<p>给定一个代表每个房屋存放金额的非负整数数组，计算你 <strong>不触动警报装置的情况下</strong> ，一夜之内能够偷窃到的最高金额。</p>\n<pre><code class=\"plain\">//之前用的滚动数组 省空间   现在用dp 好理解\nclass Solution &#123;\n    public int rob(int[] nums) &#123;\n        // dp[i]表示考虑下标为i能偷到的最高金额\n        int[] dp=new int[nums.length];\n        if(nums.length==0||nums==null) return 0;\n        dp[0]=nums[0];\n        if(nums.length==1) return nums[0];\n        dp[1]=Math.max(nums[0],nums[1]);\n        for(int i=2;i&lt;nums.length;i++)&#123;\n            dp[i]=Math.max(dp[i-1],dp[i-2]+nums[i]);\n        &#125;\n        return dp[nums.length-1];\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"打家劫舍-II\"><a href=\"#打家劫舍-II\" class=\"headerlink\" title=\"打家劫舍 II\"></a>打家劫舍 II</h2><p>你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 <strong>围成一圈</strong> ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong> 。</p>\n<p>给定一个代表每个房屋存放金额的非负整数数组，计算你 <strong>在不触动警报装置的情况下</strong> ，今晚能够偷窃到的最高金额。</p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/image-20221212153240813.png\" alt=\"img\"></p>\n<p>考虑这两种情况取最大值</p>\n<pre><code class=\"plain\">class Solution &#123;\n    public int rob(int[] nums) &#123;\n        //特殊情况\n        int n=nums.length;\n        if(nums==null||n==0) return 0;\n        if(n==1) return nums[0];\n        return Math.max(robAction(nums,0,n-1),robAction(nums,1,n));\n    &#125;\n    //打家1写成一个函数\n    public int robAction(int[] nums,int start,int end)&#123;\n        int x=0,y=0;\n        for(int i=start;i&lt;end;i++)&#123;\n            int temp=x;\n            x=y;\n            y=Math.max(y,temp+nums[i]);\n        &#125;\n        return y;\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"打家劫舍-III\"><a href=\"#打家劫舍-III\" class=\"headerlink\" title=\"打家劫舍 III\"></a>打家劫舍 III</h2><pre><code class=\"plain\">class Solution &#123;\n    Map&lt;TreeNode, Integer&gt; f = new HashMap&lt;TreeNode, Integer&gt;();\n    Map&lt;TreeNode, Integer&gt; g = new HashMap&lt;TreeNode, Integer&gt;();\n\n    public int rob(TreeNode root) &#123;\n        dfs(root);\n        return Math.max(f.getOrDefault(root, 0), g.getOrDefault(root, 0));\n    &#125;\n\n    public void dfs(TreeNode node) &#123;\n        if (node == null) &#123;\n            return;\n        &#125;\n        dfs(node.left);\n        dfs(node.right);\n        f.put(node, node.val + g.getOrDefault(node.left, 0) + g.getOrDefault(node.right, 0));\n        g.put(node, Math.max(f.getOrDefault(node.left, 0), g.getOrDefault(node.left, 0)) + Math.max(f.getOrDefault(node.right, 0), g.getOrDefault(node.right, 0)));\n    &#125;\n&#125;\nclass Solution &#123;\n    public int rob(TreeNode root) &#123;\n        //返回f、g数组\n        int[] rootStatus = dfs(root);\n        //0-&gt;f选择    1-&gt;g未选择\n        return Math.max(rootStatus[0], rootStatus[1]);\n    &#125;\n\n    public int[] dfs(TreeNode node) &#123;\n        if (node == null) &#123;\n            return new int[]&#123;0, 0&#125;;\n        &#125;\n        int[] l = dfs(node.left);\n        int[] r = dfs(node.right);\n        int selected = node.val + l[1] + r[1];\n        int notSelected = Math.max(l[0], l[1]) + Math.max(r[0], r[1]);\n        return new int[]&#123;selected, notSelected&#125;;//必须是new的   否则一直是同一个值 \n    &#125;\n&#125;\n</code></pre>\n<p>我的解法</p>\n<pre><code class=\"plain\">class Solution &#123;\n    public int rob(TreeNode root) &#123;\n        // 二维数组 位置0 表示不偷金额 1表示偷金额\n        // 返回root对应偷不偷的二维数组\n        int[] rootstatus=dfs(root);\n        // root处偷与不偷的最大金额\n        return Math.max(rootstatus[0],rootstatus[1]);\n    &#125;\n    public int[] dfs(TreeNode root)&#123;\n        if(root==null) return new int[]&#123;0,0&#125;;\n        // 左节点\n        int[] l=dfs(root.left);\n        // 右节点\n        int[] r=dfs(root.right);\n        // 偷与不偷值\n        int steal=root.val+l[0]+r[0];\n        int nosteal=Math.max(l[0],l[1])+Math.max(r[0],r[1]);\n        返回\n        return new int[]&#123;nosteal,steal&#125;;\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"买卖股票的最佳时机\"><a href=\"#买卖股票的最佳时机\" class=\"headerlink\" title=\"买卖股票的最佳时机\"></a>买卖股票的最佳时机</h2><p>给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。</p>\n<p>你只能选择 <strong>某一天</strong> 买入这只股票，并选择在 <strong>未来的某一个不同的日子</strong> 卖出该股票。设计一个算法来计算你所能获取的最大利润。</p>\n<p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。</p>\n<p><strong>第一种方法</strong> 维护一个最小值和最大利润 </p>\n<pre><code class=\"plain\">class Solution &#123;\n    public int maxProfit(int[] prices) &#123;\n        int minnum = Integer.MAX_VALUE;\n        int maxsoft = 0;\n        for (int i = 0; i &lt; prices.length; i++) &#123;\n            if (prices[i] &lt; minnum) &#123;\n                minnum = prices[i];\n            &#125; else if (prices[i] - minnum &gt; maxsoft) &#123;\n                maxsoft = prices[i] - minnum;\n            &#125;\n        &#125;\n        return maxsoft;\n\n    &#125;\n&#125;\n</code></pre>\n<p><strong>第二种方法</strong></p>\n<pre><code class=\"plain\">class Solution &#123;\n    public int maxProfit(int[] prices) &#123;\n        // dp0表示不持有股票所得现金\n        // dp1表示持有股票所得现金\n        int dp0=0;\n        int dp1=-prices[0];\n        //滚动数组\n        for(int i=1;i&lt;prices.length;i++)&#123;\n            dp0=Math.max(dp0,dp1+prices[i]);\n            // 因为只能选择某一天买股票 因此从不持有到持有现金肯定是-prices[i]\n            dp1=Math.max(-prices[i],dp1);\n        &#125;\n        return dp0;\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"买卖股票的最佳时机-II\"><a href=\"#买卖股票的最佳时机-II\" class=\"headerlink\" title=\"买卖股票的最佳时机 II\"></a>买卖股票的最佳时机 II</h2><p>给你一个整数数组 prices ，其中 prices[i] 表示某支股票第 i 天的价格。</p>\n<p>在每一天，你可以决定是否购买和&#x2F;或出售股票。你在任何时候 <strong>最多</strong> 只能持有 <strong>一股</strong> 股票。你也可以先购买，然后在 <strong>同一天</strong> 出售。</p>\n<p>返回 <em>你能获得的</em> *<strong>最大*</strong> <em>利润</em> 。</p>\n<p><strong>题解</strong></p>\n<p><em>和I**的区别是可以买多次</em></p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/image-20221120164413694.png\" alt=\"img\"></p>\n<pre><code class=\"plain\">和I的区别就是dp1的表达式变了一下\nclass Solution &#123;\n    public int maxProfit(int[] prices) &#123;\n        //初始值是第一天的 所以i从1开始\n        int dp0=0;\n        int dp1=-prices[0];\n        //滚动数组\n        for(int i=1;i&lt;prices.length;i++)&#123;\n            dp0=Math.max(dp0,dp1+prices[i]);\n            dp1=Math.max(dp0-prices[i],dp1);\n        &#125;\n        return dp0;\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"买卖股票的最佳时机-III\"><a href=\"#买卖股票的最佳时机-III\" class=\"headerlink\" title=\"买卖股票的最佳时机 III\"></a>买卖股票的最佳时机 III</h2><p>给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。</p>\n<p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 <strong>两笔</strong> 交易。</p>\n<p><strong>注意：</strong>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>\n<pre><code class=\"plain\">class Solution &#123;\n    public int maxProfit(int[] prices) &#123;\n//dp[0]初始状态 dp[1]第一次持有股票  dp[2]第一次不持有  dp[3]第二次持有  dp[4]第二次不持有\n        int[] dp=new int[5];\n        dp[1]=-prices[0];\n        dp[3]=-prices[0];\n        for(int i=1;i&lt;prices.length;i++)&#123;\n            dp[1]=Math.max(dp[1],dp[0]-prices[i]);\n            dp[2]=Math.max(dp[2],dp[1]+prices[i]);\n            dp[3]=Math.max(dp[3],dp[2]-prices[i]);\n            dp[4]=Math.max(dp[4],dp[3]+prices[i]);\n            // dp[n]=Math.max(dp[n],dp[n-1]+-price[i])\n        &#125;\n        return dp[4];\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"买卖股票的最佳时机-IV\"><a href=\"#买卖股票的最佳时机-IV\" class=\"headerlink\" title=\"买卖股票的最佳时机 IV\"></a>买卖股票的最佳时机 IV</h2><p>给定一个整数数组 prices ，它的第 i 个元素 prices[i] 是一支给定的股票在第 i 天的价格。</p>\n<p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 <strong>k</strong> 笔交易。</p>\n<p><strong>注意：</strong>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>\n<p>题解：</p>\n<p>类比前面的题目 其实就是找规律</p>\n<pre><code class=\"plain\">class Solution &#123;\n    public int maxProfit(int k, int[] prices) &#123;\n        int[] dp=new int[2*k+1];\n        for(int i=1;i&lt;=2*k-1;i+=2)&#123;\n            dp[i]=-prices[0];\n        &#125;\n        // 奇数代表持有 偶数代表不持有\n        for(int i=1;i&lt;prices.length;i++)&#123;\n            // 根据奇偶不同 选择+-\n            for(int j=1;j&lt;=2*k;j++)&#123;\n                if(j%2==0)&#123;\n                    dp[j]=Math.max(dp[j],dp[j-1]+prices[i]);\n                &#125;else&#123;\n                    dp[j]=Math.max(dp[j],dp[j-1]-prices[i]);\n                &#125;\n            &#125;\n        &#125;\n        // 肯定是不持有股票 也就是2*k的利润最大\n        return dp[2*k];\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"最佳买卖股票时机含冷冻期-1\"><a href=\"#最佳买卖股票时机含冷冻期-1\" class=\"headerlink\" title=\"最佳买卖股票时机含冷冻期\"></a>最佳买卖股票时机含冷冻期</h2><p>给定一个整数数组prices，其中第 prices[i] 表示第 <em>i</em> 天的股票价格 。</p>\n<p>设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:</p>\n<ul>\n<li>卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。</li>\n</ul>\n<p><strong>注意：</strong>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>\n<pre><code class=\"plain\">class Solution &#123;\n    public int maxProfit(int[] prices) &#123;\n        int[] dp=new int[3];\n        dp[2]=-prices[0];\n        for(int i=1;i&lt;prices.length;i++)&#123;\n            int new1=Math.max(dp[1],dp[0]);\n            int new0=dp[2]+prices[i];\n            int new2=Math.max(dp[2],dp[1]-prices[i]);\n            dp[0]=new0;\n            dp[1]=new1;\n            dp[2]=new2;\n        &#125;\n        return Math.max(dp[0],dp[1]);\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"买卖股票的最佳时机含手续费\"><a href=\"#买卖股票的最佳时机含手续费\" class=\"headerlink\" title=\"买卖股票的最佳时机含手续费\"></a>买卖股票的最佳时机含手续费</h2><p>给定一个整数数组 prices，其中 prices[i]表示第 i 天的股票价格 ；整数 fee 代表了交易股票的手续费用。</p>\n<p>你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。</p>\n<p>返回获得利润的最大值。</p>\n<p><strong>注意：</strong>这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。</p>\n<p><strong>题解：</strong> 和买卖股票的最佳时机 II一样，只是多了个手续费</p>\n<p>假设手续费是股票刚入手就交，就是我这种写法，当然卖出交也可以</p>\n<pre><code class=\"plain\">class Solution &#123;\n    public int maxProfit(int[] prices, int fee) &#123;\n        int dp0=0,dp1=-prices[0]-fee;\n        for(int i=1;i&lt;prices.length;i++)&#123;\n            dp0=Math.max(dp0,dp1+prices[i]);//必须是从有股票变成无股票状态才能减去手续费，如果是刚买进股票就付手续费，\n            dp1=Math.max(dp1,dp0-prices[i]-fee);\n        &#125;\n        return dp0;\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"股票总结\"><a href=\"#股票总结\" class=\"headerlink\" title=\"股票总结\"></a>股票总结</h2><p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/%E8%82%A1%E7%A5%A8%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93.jpg\" alt=\"img\"></p>\n<h2 id=\"最长递增子序列\"><a href=\"#最长递增子序列\" class=\"headerlink\" title=\"最长递增子序列\"></a>最长递增子序列</h2><p>给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。</p>\n<p><strong>子序列</strong> 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列</p>\n<pre><code class=\"plain\">class Solution &#123;\n    public int lengthOfLIS(int[] nums) &#123;\n// dp[i]以i为结尾的序列的最长严格递增子序列\n        int n=nums.length;\n        int[] dp=new int[n];\n        // 结果至少是1\n        int ans=1;\n        // 利用数组填充全部初始化为1\n        Arrays.fill(dp,1);\n        // 外层循环从1开始内层从0 遍历每个以i结尾的序列的各个元素值，如果元素小于nums[i]，\n        //维护dp[i],dp[j]+1最大值 并在每次内循环结束后维护结果\n        for(int i=1;i&lt;n;i++)&#123;\n            for(int j=0;j&lt;i;j++)&#123;\n                if(nums[j]&lt;nums[i])&#123;\n                    dp[i]=Math.max(dp[i],dp[j]+1);\n                &#125;\n            &#125;\n            ans=Math.max(ans,dp[i]);\n        &#125;\n        return ans;\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"最长连续递增序列\"><a href=\"#最长连续递增序列\" class=\"headerlink\" title=\"最长连续递增序列\"></a>最长连续递增序列</h2><p>给定一个未经排序的整数数组，找到最长且 <strong>连续递增的子序列</strong>，并返回该序列的长度。</p>\n<p><strong>连续递增的子序列</strong> 可以由两个下标 l 和 r（l &lt; r）确定，如果对于每个 l &lt;&#x3D; i &lt; r，都有 nums[i] &lt; nums[i + 1] ，那么子序列 [nums[l], nums[l + 1], …, nums[r - 1], nums[r]] 就是连续递增子序列。</p>\n<pre><code class=\"plain\">class Solution &#123;\n    public int findLengthOfLCIS(int[] nums) &#123;\n        // 以i结尾的序列最长递增的子序列\n        int n=nums.length;\n        int[] dp=new int[n];\n        Arrays.fill(dp,1);\n        int ans=1;\n        for(int i=1;i&lt;n;i++)&#123;\n            // 如果大于前一个 则dp+1   并维护最大dp值\n            if(nums[i]&gt;nums[i-1])&#123;\n                dp[i]=dp[i-1]+1;\n                ans=Math.max(ans,dp[i]);\n            &#125;\n        &#125;\n        return ans;\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"最长重复子数组\"><a href=\"#最长重复子数组\" class=\"headerlink\" title=\"最长重复子数组\"></a>最长重复子数组</h2><p>给两个整数数组 nums1 和 nums2 ，返回 <em>两个数组中</em> *<strong>公共的*</strong> <em>、长度最长的子数组的长度</em> 。</p>\n<pre><code class=\"plain\">class Solution &#123;\n    public int findLength(int[] nums1, int[] nums2) &#123;\n        // dp[i][j] ：以下标i - 1为结尾的A，和以下标j - 1为结尾的B，最长重复子数组长度为dp[i][j]\n        int n1=nums1.length,n2=nums2.length;\n        //因为算的是i-1 j-1 所以多设置一个\n        int[][] dp=new int[n1+1][n2+1];\n        int ans =0;\n        for(int i=1;i&lt;n1+1;i++)&#123;\n            for(int j=1;j&lt;n2+1;j++)&#123;\n                if(nums1[i-1]==nums2[j-1])&#123;\n                    dp[i][j]=dp[i-1][j-1]+1;\n                    ans=Math.max(ans,dp[i][j]);\n                &#125;\n            &#125;\n        &#125;\n        return ans;\n    &#125;\n&#125;\n//当然可以降为一维 不过我不想做\n</code></pre>\n<h2 id=\"最长公共子序列\"><a href=\"#最长公共子序列\" class=\"headerlink\" title=\"最长公共子序列\"></a>最长公共子序列</h2><p>给定两个字符串 text1 和 text2，返回这两个字符串的最长 <strong>公共子序列</strong> 的长度。如果不存在 <strong>公共子序列</strong> ，返回 0 。</p>\n<p>一个字符串的 <strong>子序列</strong> 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。</p>\n<ul>\n<li>例如，”ace” 是 “abcde” 的子序列，但 “aec” 不是 “abcde” 的子序列。</li>\n</ul>\n<p>两个字符串的 <strong>公共子序列</strong> 是这两个字符串所共同拥有的子序列。</p>\n<p>题解：和最长重复子数组差不多，区别是dp定义有区别 这个不用维护ans最大值 最后</p>\n<p>dp[n1][n2]就是结果</p>\n<pre><code class=\"plain\">class Solution &#123;\n    public int longestCommonSubsequence(String text1, String text2) &#123;\n         int n1=text1.length(),n2=text2.length();\n        //dp[i][j]：长度为[0, i - 1]的字符串text1与长度为[0, j - 1]的字符串text2的最长公共子序列为dp[i][j]\n        int[][] dp=new int[n1+1][n2+1];\n如果text1[i - 1] 与 text2[j - 1]相同，那么找到了一个公共元素，所以dp[i][j] = dp[i - 1][j - 1] + 1;\n如果text1[i - 1] 与 text2[j - 1]不相同，那就看看text1[0, i - 2]与text2[0, j - 1]的最长公共子序列 和 text1[0, i - 1]与text2[0, j - 2]的最长公共子序列，取最大的。即：dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);\n        for(int i=1;i&lt;n1+1;i++)&#123;\n            for(int j=1;j&lt;n2+1;j++)&#123;\n                if(text1.charAt(i-1)==text2.charAt(j-1))&#123;\n                    dp[i][j]=dp[i-1][j-1]+1;\n                &#125;else&#123;\n                    //这里举个例子\n             text1  1 2 3\n             text2  0 1 2\n                    3！=2  则12和012公共子序列2  123和01公共子序列1 最大值为 2\n                    dp[i][j]=Math.max(dp[i-1][j],dp[i][j-1]);\n                &#125;\n            &#125;\n        &#125;\n        return dp[n1][n2];\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"不相交的线\"><a href=\"#不相交的线\" class=\"headerlink\" title=\"不相交的线\"></a>不相交的线</h2><p>在两条独立的水平线上按给定的顺序写下 nums1 和 nums2 中的整数。</p>\n<p>现在，可以绘制一些连接两个数字 nums1[i] 和 nums2[j] 的直线，这些直线需要同时满足满足：</p>\n<ul>\n<li>nums1[i] &#x3D;&#x3D; nums2[j]</li>\n<li>且绘制的直线不与任何其他连线（非水平线）相交。</li>\n</ul>\n<p>请注意，连线即使在端点也不能相交：每个数字只能属于一条连线。</p>\n<p>以这种方法绘制线条，并返回可以绘制的最大连线数。</p>\n<p>题解：</p>\n<p><strong>这题和最长公共子序列一样 就是改个数据结构完事</strong></p>\n<pre><code class=\"plain\">class Solution &#123;\n    public int maxUncrossedLines(int[] nums1, int[] nums2) &#123;\n         int n1=nums1.length,n2=nums2.length;\n        //dp[i][j]：长度为[0, i - 1]的字符串text1与长度为[0, j - 1]的字符串text2的最长公共子序列为dp[i][j]\n        int[][] dp=new int[n1+1][n2+1];\n//如果text1[i - 1] 与 text2[j - 1]相同，那么找到了一个公共元素，所以dp[i][j] = dp[i - 1][j - 1] + 1;\n//如果text1[i - 1] 与 text2[j - 1]不相同，那就看看text1[0, i - 2]与text2[0, j - 1]的最长公共子序列 和 text1[0, i - 1]与text2[0, j - 2]的最长公共子序列，取最大的。即：dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);\n        for(int i=1;i&lt;n1+1;i++)&#123;\n            for(int j=1;j&lt;n2+1;j++)&#123;\n                if(nums1[i-1]==nums2[j-1])&#123;\n                    dp[i][j]=dp[i-1][j-1]+1;\n                &#125;else&#123;\n                    dp[i][j]=Math.max(dp[i-1][j],dp[i][j-1]);\n                &#125;\n            &#125;\n        &#125;\n        return dp[n1][n2];\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"最大子数组和\"><a href=\"#最大子数组和\" class=\"headerlink\" title=\"最大子数组和\"></a>最大子数组和</h2><p>给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>\n<p><strong>子数组</strong> 是数组中的一个连续部分。</p>\n<pre><code class=\"plain\">class Solution &#123;\n    public int maxSubArray(int[] nums) &#123;\n        // 以i-1结尾的连续最大和的值为dp[i]\n        int n=nums.length;\n        int[] dp=new int[n+1];\n        int ans=Integer.MIN_VALUE;\n        for(int i=1;i&lt;=n;i++)&#123;\n            dp[i]=Math.max(dp[i-1]+nums[i-1],nums[i-1]);\n            ans=Math.max(dp[i],ans);\n        &#125;\n        return ans;\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"判断子序列\"><a href=\"#判断子序列\" class=\"headerlink\" title=\"判断子序列\"></a>判断子序列</h2><p>给定字符串 <strong>s</strong> 和 <strong>t</strong> ，判断 <strong>s</strong> 是否为 <strong>t</strong> 的子序列。</p>\n<p>字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，”ace”是”abcde”的一个子序列，而”aec”不是）。</p>\n<pre><code class=\"plain\">class Solution &#123;\n    public boolean isSubsequence(String s, String t) &#123;\n// 判断 s 是否为 t 的子序列  即判断s.size==s和t公共序列？\n// dp[i][j] 表示s以i-1 t以j-1 结尾的公共序列\n        int ns=s.length(),nt=t.length();\n        int[][] dp=new int[ns+1][nt+1];\n        for(int i=1;i&lt;=ns;i++)&#123;\n            for(int j=1;j&lt;=nt;j++)&#123;\n                if(s.charAt(i-1)==t.charAt(j-1))&#123;\n                    dp[i][j]=dp[i-1][j-1]+1;\n                &#125;else&#123;\n                    // 否则当前的j-1就不选择 因为是判断s是否为t子序列 所以只能dp[i][j-1] i可不能-1\n                    dp[i][j]=dp[i][j-1];\n                &#125;\n            &#125;\n        &#125;\n        // 看公共序列长度是不是s的长度 是的话 说明s 是否为 t 的子序列\n        return dp[ns][nt]==ns;\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"不同的子序列\"><a href=\"#不同的子序列\" class=\"headerlink\" title=\"不同的子序列\"></a>不同的子序列</h2><p>给定一个字符串 s 和一个字符串 t ，计算在 s 的子序列中 t 出现的个数。</p>\n<p>字符串的一个 <strong>子序列</strong> 是指，通过删除一些（也可以不删除）字符且不干扰剩余字符相对位置所组成的新字符串。（例如，”ACE” 是 “ABCDE” 的一个子序列，而 “AEC” 不是）</p>\n<p>题目数据保证答案符合 32 位带符号整数范围。</p>\n<pre><code class=\"plain\">class Solution &#123;\n    public int numDistinct(String s, String t) &#123;\n// dp[i][j]表示以i-1结尾的s中出现以j-1结尾的t的个数\n// 递推公式：s.charAt(i-1)==t.charAt(j-1): dp[i][j]=dp[i-1][j-1]+dp[i-1][j];\n            // else  dp[i][j]=dp[i-1][j];\n        问题：为什么还要考虑 不用s[i - 1]来匹配\n        例如： s：bagg 和 t：bag ，s[3] 和 t[2]是相同的，但是字符串s也可以不用s[3]来匹配，即用s[0]s[1]s[2]组成的bag。\n         也就是s里面可以有两个bag和t匹配\n        // 初始化  dp[0][j]=0  dp[i][0]=1(一个，即空字符串);\n        int n1=s.length(),n2=t.length();\n        int[][] dp=new int[n1+1][n2+1];\n        for(int i=0;i&lt;=n1;i++)&#123;\n            dp[i][0]=1;\n        &#125;\n        for(int i=1;i&lt;=n1;i++)&#123;\n            for(int j=1;j&lt;=n2;j++)&#123;\n                if(s.charAt(i-1)==t.charAt(j-1))&#123;\n                    dp[i][j]=dp[i-1][j-1]+dp[i-1][j];\n                &#125;else&#123;\n                    dp[i][j]=dp[i-1][j];\n                &#125;\n            &#125;\n        &#125;\n        return dp[n1][n2];\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"两个字符串的删除操作\"><a href=\"#两个字符串的删除操作\" class=\"headerlink\" title=\"两个字符串的删除操作\"></a>两个字符串的删除操作</h2><p>给定两个单词 word1 和 word2 ，返回使得 word1 和 word2<strong>相同</strong>所需的<strong>最小步数</strong>。</p>\n<p><strong>每步</strong> 可以删除任意一个字符串中的一个字符。</p>\n<p>题解：</p>\n<p>本题和<a href=\"https://programmercarl.com/1143.%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97.html\">动态规划：1143.最长公共子序列 (opens new window)</a>基本相同，只要求出两个字符串的最长公共子序列长度即可，那么除了最长公共子序列之外的字符都是必须删除的，最后用两个字符串的总长度减去两个最长公共子序列的长度就是删除的最少步数。</p>\n<pre><code class=\"plain\">class Solution &#123;\n    public int minDistance(String word1, String word2) &#123;\n        // dp[i][j]两个序列公共序列长度\n        int n1=word1.length(),n2=word2.length();\n        int[][] dp=new int[n1+1][n2+1];\n        for(int i=1;i&lt;=n1;i++)&#123;\n            for(int j=1;j&lt;=n2;j++)&#123;\n                if(word1.charAt(i-1)==word2.charAt(j-1))&#123;\n                    dp[i][j]=dp[i-1][j-1]+1;\n                &#125;else&#123;\n                    dp[i][j]=Math.max(dp[i-1][j],dp[i][j-1]);\n                &#125;\n            &#125;\n        &#125;\n        // 两个字符串的总长度减去两个最长公共子序列的长度就是删除的最少步数。\n        return n1+n2-2*dp[n1][n2];\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"编辑距离\"><a href=\"#编辑距离\" class=\"headerlink\" title=\"编辑距离\"></a>编辑距离</h2><p>给你两个单词 word1 和 word2， <em>请返回将</em> <em>word1</em> <em>转换成</em> <em>word2</em> <em>所使用的最少操作数</em> 。</p>\n<p>你可以对一个单词进行如下三种操作：</p>\n<ul>\n<li>插入一个字符</li>\n<li>删除一个字符</li>\n<li>替换一个字符</li>\n</ul>\n<pre><code class=\"plain\">class Solution &#123;\n    public int minDistance(String word1, String word2) &#123;\n        // dp[i][j] 表示以下标i-1为结尾的字符串word1，和以下标j-1为结尾的字符串word2，最近编辑距离为dp[i][j]。\n        递归公式   \n        //1、if (word1[i - 1] == word2[j - 1]) 那么说明不用任何编辑\n        // 2、不等：\n        2.1 操作一：word1删除一个元素  dp[i][j] = dp[i - 1][j] + 1\n        2.2 操作二：word2删除一个元素  dp[i][j] = dp[i][j - 1] + 1;\n        为何没有添加元素 因为添加元素和删除元素等价\n        例如 word1 = &quot;ad&quot; ，word2 = &quot;a&quot;，word1删除元素&#39;d&#39; 和 word2添加一个元素&#39;d&#39;，变成word1=&quot;a&quot;, word2=&quot;ad&quot;\n        2.3 操作三：替换元素           dp[i][j] = dp[i - 1][j - 1] + 1;\n        int n1=word1.length(),n2=word2.length();\n        int[][] dp=new int[n1+1][n2+1];\n        for(int i=0;i&lt;=n1;i++)&#123;\n            dp[i][0]=i;\n        &#125;\n        for(int j=0;j&lt;=n2;j++)&#123;\n            dp[0][j]=j;\n        &#125;        \n        for(int i=1;i&lt;=n1;i++)&#123;\n            for(int j=1;j&lt;=n2;j++)&#123;\n                if(word1.charAt(i-1)==word2.charAt(j-1))&#123;\n                    dp[i][j]=dp[i-1][j-1];\n                &#125;else&#123;\n                    dp[i][j]=Math.min(Math.min(dp[i-1][j],dp[i][j-1]),dp[i-1][j-1])+1;\n                &#125;\n            &#125;\n        &#125;\n        return dp[n1][n2];\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"回文子串\"><a href=\"#回文子串\" class=\"headerlink\" title=\"回文子串\"></a>回文子串</h2><p>给你一个字符串 s ，请你统计并返回这个字符串中 <strong>回文子串</strong> 的数目。</p>\n<p><strong>回文字符串</strong> 是正着读和倒过来读一样的字符串。</p>\n<p><strong>子字符串</strong> 是字符串中的由连续字符组成的一个序列。</p>\n<p>具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。</p>\n<p>题解：</p>\n<p><strong>我认为双指针比dp简单</strong> 中心扩展见力扣1 </p>\n<pre><code class=\"plain\">class Solution &#123;\npublic:\n    int countSubstrings(string s) &#123;\n        //布尔类型的dp[i][j]：表示区间范围[i,j] （注意是左闭右闭）的子串是否是回文子串，如果是dp[i][j]为true，否则为false。\n        s[i]!=s[j],dp[i][j]=false。\n        s[i]=s[j]\n\n情况一：下标i 与 j相同，同一个字符例如a，当然是回文子串\n情况二：下标i 与 j相差为1，例如aa，也是回文子串\n情况三：下标：i 与 j相差大于1的时候，例如cabac，此时s[i]与s[j]已经相同了，我们看i到j区间是不是回文子串就看aba是不是回文就可以了，那么aba的区间就是 i+1 与 j-1区间，这个区间是不是回文就看dp[i + 1][j - 1]是否为true。\n//遍历顺序： 看递推公式，dp[i][j]依赖于dp[i+1][j-1]，因此i倒着来，j顺着来，且保证j&gt;i；\n       \n        vector&lt;vector&lt;bool&gt;&gt; dp(s.size(), vector&lt;bool&gt;(s.size(), false));\n        int result = 0;\n        for (int i = s.size() - 1; i &gt;= 0; i--) &#123;  // 注意遍历顺序\n            for (int j = i; j &lt; s.size(); j++) &#123;\n                if (s[i] == s[j]) &#123;\n                    if (j - i &lt;= 1) &#123; // 情况一 和 情况二\n                        result++;\n                        dp[i][j] = true;\n                    &#125; else if (dp[i + 1][j - 1]) &#123; // 情况三\n                        result++;\n                        dp[i][j] = true;\n                    &#125;\n                &#125;\n            &#125;\n        &#125;\n        return result;\n    &#125;\n&#125;;\n</code></pre>\n<p>java dp：</p>\n<pre><code class=\"plain\">class Solution &#123;\n    public int countSubstrings(String s) &#123;\n        int len, ans = 0;\n        if (s == null || (len = s.length()) &lt; 1) return 0;\n        //dp[i][j]：s字符串下标i到下标j的字串是否是一个回文串，即s[i, j]\n        boolean[][] dp = new boolean[len][len];\n        for (int j = 0; j &lt; len; j++) &#123;\n            for (int i = 0; i &lt;= j; i++) &#123;\n                //当两端字母一样时，才可以两端收缩进一步判断\n                if (s.charAt(i) == s.charAt(j)) &#123;\n                    //i++，j--，即两端收缩之后i,j指针指向同一个字符或者i超过j了,必然是一个回文串\n                    if (j - i &lt; 3) &#123;\n                        dp[i][j] = true;\n                    &#125; else &#123;\n                        //否则通过收缩之后的字串判断\n                        dp[i][j] = dp[i + 1][j - 1];\n                    &#125;\n                &#125; else &#123;//两端字符不一样，不是回文串\n                    dp[i][j] = false;\n                &#125;\n            &#125;\n        &#125;\n        //遍历每一个字串，统计回文串个数\n        for (int i = 0; i &lt; len; i++) &#123;\n            for (int j = 0; j &lt; len; j++) &#123;\n                if (dp[i][j]) ans++;\n            &#125;\n        &#125;\n        return ans;\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"最长回文子序列（只算长度）\"><a href=\"#最长回文子序列（只算长度）\" class=\"headerlink\" title=\"最长回文子序列（只算长度）\"></a>最长回文子序列（只算长度）</h2><p>给你一个字符串 s ，找出其中最长的回文子序列，并返回该序列的长度。</p>\n<p>子序列定义为：不改变剩余字符顺序的情况下，删除某些字符或者不删除任何字符形成的一个序列。</p>\n<pre><code class=\"plain\">class Solution &#123;\n    public int longestPalindromeSubseq(String s) &#123;\n        // [i,j]范围内最长回文子序列长度为dp[i][j]\n        // 初始化 其余都为0，dp[i][i]=1;\n        // 递归公式： if s.charAt(i)=s.charAt(j):dp[i][j]=dp[i+1][j-1]+2;\n        // else  dp[i][j]=Math.max(dp[i][j-1],dp[i+1][j];\n        // 遍历顺序根据递归公式来\n        int n = s.length();\n        int[][] dp = new int[n][n];\n       // int[][] dp = new int[n+1][n+1];//也能pass  多一点无所谓\n        for(int i=0;i&lt;n;i++)&#123;\n            dp[i][i]=1;\n        &#125;\n        //遍历顺序  两边都可以   只要是从范围小的开始就行\n        for(int i=n-1;i&gt;=0;i--)&#123;\n            for(int j=i+1;j&lt;n;j++)&#123;\n                if(s.charAt(i)==s.charAt(j))&#123;\n                    dp[i][j]=dp[i+1][j-1]+2;\n                &#125;else&#123;\n                    dp[i][j]=Math.max(Math.max(dp[i][j-1],dp[i+1][j]),dp[i][j]);\n                &#125;\n            &#125;\n        &#125;\n        return dp[0][n-1];\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"双指针\"><a href=\"#双指针\" class=\"headerlink\" title=\"双指针\"></a>双指针</h2><pre><code class=\"plain\">package top.hk.gkrpc.client;\n\nimport java.util.Scanner;\n\npublic class Main02 &#123;\n    public static void main(String[] args) &#123;\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int[] nums = new int[n];\n        for (int i = 0; i &lt; n; i++) &#123;\n            nums[i] = scanner.nextInt();\n        &#125;\n        int maxcount=0;\n        for(int i = 0; i&lt; 2*n-1; i++)&#123;\n            int l = i / 2,r = i / 2 + i % 2;//    + i % 2是为了奇偶校验\n            int count;\n            if(l==r-1&amp;&amp;nums[r]==nums[l])&#123;\n                count=2;\n            &#125;else&#123;\n                count=1;\n            &#125;\n            l--;\n            r++;\n            while(l &gt;= 0 &amp;&amp; r &lt; n &amp;&amp; nums[l] == nums[r])&#123;\n                count+=2;\n                l--;\n                r++;\n            &#125;\n            maxcount=Math.max(count,maxcount);\n            if(maxcount==n) break;\n        &#125;\n        System.out.println(n-maxcount);\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"最长回文子串\"><a href=\"#最长回文子串\" class=\"headerlink\" title=\"最长回文子串\"></a>最长回文子串</h2><p>给你一个字符串 s，找到 s 中最长的回文子串。</p>\n<p>如果字符串的反序与原始字符串相同，则该字符串称为回文字符串</p>\n<p>题解：细节比较多，主要方法动态规划 双指针</p>\n<pre><code class=\"plain\">class Solution &#123;\n    public String longestPalindrome(String s) &#123;\n        // dp\n        int maxlen=1;//至少为1\n        int start =0;//记录一下开始的下标  方便截取结果\n        int n=s.length();\n        boolean[][] dp=new boolean[n][n];\n        for(boolean[] bn:dp)&#123;\n            Arrays.fill(bn,true);\n        &#125;\n        if(n&lt;2) return s;\n        for(int L=2;L&lt;=n;L++)&#123;\n            for(int i=0;i&lt;n;i++)&#123;\n                // j-i+1=L   L的另一端下标\n                int j=L+i-1;\n                // j有可能越界\n                if(j&gt;=n) break;//当前的L已经不满足 break\n                if(s.charAt(i)!=s.charAt(j)) dp[i][j]=false;\n                else&#123;\n                    if(j-i&lt;3) dp[i][j]=true;\n                    else&#123;\n                        dp[i][j]=dp[i+1][j-1];\n                    &#125;\n                &#125;\n                if(dp[i][j]&amp;&amp;j-i+1&gt;maxlen)&#123;\n                    maxlen=j-i+1;\n                    start=i;\n                &#125;\n            &#125;\n        &#125;\n        return s.substring(start,start+maxlen);\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"分割回文串-II\"><a href=\"#分割回文串-II\" class=\"headerlink\" title=\"分割回文串 II\"></a>分割回文串 II</h2><p>给你一个字符串 s，请你将 s 分割成一些子串，使每个子串都是回文。</p>\n<p>返回符合要求的 <strong>最少分割次数</strong> 。</p>\n<p>题解：</p>\n<p><strong>含义</strong></p>\n<p>dp[i]：范围是[0, i]的回文子串，最少分割次数是dp[i]</p>\n<p><strong>递推公式</strong></p>\n<p>如果要对长度为[0, i]的子串进行分割，分割点为j。</p>\n<p>那么如果分割后，区间[j + 1, i]是回文子串，那么dp[i] 就等于 dp[j] + 1。</p>\n<p>求最小切割数量：<strong>dp[i] &#x3D; min(dp[i], dp[j] + 1);</strong></p>\n<p><strong>dp数组如何初始化</strong></p>\n<p>那么dp[0]一定是0，长度为1的字符串最小分割次数就是0。这个是比较直观的。</p>\n<p>非零下标的dp[i]初始化为i 因为最多只能分割i次</p>\n<p><strong>确定遍历顺序</strong></p>\n<p>根据递推公式：dp[i] &#x3D; min(dp[i], dp[j] + 1);</p>\n<p>j是在[0，i]之间，所以遍历i的for循环一定在外层，这里遍历j的for循环在内层才能通过 计算过的dp[j]数值推导出dp[i]。</p>\n<p>其中**dp[i] &#x3D; min(dp[i], dp[j] + 1);**需要先用一个二维数组来保存整个字符串的回文情况。（看之前的回文字串即可）</p>\n<p>代码：</p>\n<pre><code class=\"plain\">class Solution &#123;\n    public int minCut(String s) &#123;\n        //if(null == s || &quot;&quot;.equals(s))&#123;\n          //  return 0;\n        //&#125;        \n        int n=s.length();\n        boolean[][] isPalindromic=new boolean[n][n];  \n        // 先计算回文\n        for(int i=n-1;i&gt;=0;i--)&#123;\n            for(int j=i;j&lt;n;j++)&#123;\n                if(s.charAt(i)==s.charAt(j))&#123;\n                    if(j-i&lt;2)&#123;\n                        isPalindromic[i][j]=true;\n                    &#125;else&#123;\n                        isPalindromic[i][j]=isPalindromic[i+1][j-1];\n                    &#125;\n                &#125;else&#123;\n                    isPalindromic[i][j]=false;\n                &#125;\n            &#125;\n        &#125;\n        //  dp[i] 表示[0..i]的最小分割次数\n        int[] dp=new int[n];\n        for(int i=0;i&lt;n;i++)&#123;\n            dp[i]=i;\n        &#125;\n        // i从1-n  j从0-i\n        for(int i=1;i&lt;n;i++)&#123;\n            if(isPalindromic[0][i])&#123;\n                dp[i]=0;\n            &#125;\n            for(int j=0;j&lt;i;j++)&#123;\n                if(isPalindromic[j+1][i])&#123;\n                    dp[i]=Math.min(dp[i],dp[j]+1);\n                &#125;\n            &#125;\n        &#125;\n        return dp[n-1];\n\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"最长递增子序列的个数\"><a href=\"#最长递增子序列的个数\" class=\"headerlink\" title=\"最长递增子序列的个数\"></a>最长递增子序列的个数</h2><p>给定一个未排序的整数数组 nums ， <em>返回最长递增子序列的个数</em> 。</p>\n<p><strong>注意</strong> 这个数列必须是 <strong>严格</strong> 递增的</p>\n<pre><code class=\"plain\">class Solution &#123;\n    public int findNumberOfLIS(int[] nums) &#123;\n        // dp[i] 以i为结尾的最长递增子序列长度   count[i]以i为结尾的最长递增子序列数量\n        int n=nums.length;\n        int[] dp=new int[n];\n        Arrays.fill(dp,1);\n        int[] count=new int[n];\n        Arrays.fill(count,1);\n        int maxlen=1;\n        for(int i=1;i&lt;n;i++)&#123;\n            for(int j=0;j&lt;i;j++)&#123;\n                if(nums[i]&gt;nums[j])&#123;\n                    if(dp[j]+1&gt;dp[i])&#123;\n                        dp[i]=dp[j]+1;//dp[j]基础上加上i变成dp[j]+1了\n                        count[i]=count[j];//但个数不变\n                    &#125;else if(dp[j]+1==dp[i])&#123;\n                        count[i]+=count[j];//长度不变 但数量累加 因为以不同j结尾的子序列是不一样的\n                    &#125;\n                &#125;\n                // 维护最长递增子序列长度\n                if(dp[i]&gt;maxlen)&#123;\n                    maxlen=dp[i];\n                &#125;\n            &#125;\n        &#125;\n        int result=0;\n        for(int i=0;i&lt;n;i++)&#123;\n            // 以不同i结尾的子序列是不一样的 所以加\n            if(dp[i]==maxlen)&#123;\n                result+=count[i];\n            &#125;\n        &#125;\n        return result;\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"最长递增子序列个数三\"><a href=\"#最长递增子序列个数三\" class=\"headerlink\" title=\"最长递增子序列个数三\"></a>最长递增子序列个数三</h2><p>给定数组 arr ，设长度为 n ，输出 arr 的最长上升子序列。（如果有多个答案，请输出其中 按数值(注：区别于按单个字符的ASCII码值)进行比较的 字典序最小的那个）</p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/image-20230404174638522.png\" alt=\"img\"></p>\n<pre><code class=\"plain\">import java.util.*;\n\npublic class Solution &#123;\n    /**\n     * retrun the longest increasing subsequence\n     * @param arr int整型一维数组 the array\n     * @return int整型一维数组\n     */\n    public int[] LIS (int[] arr) &#123;\n        int n=arr.length;\n        //dp[i]表示以i位置元素结尾的最长上升子序列长度\n        int[] dp=new int[n+1];\n        //初始化为1\n        Arrays.fill(dp,1);\n        //记录最长子序列的长度\n        int len=0;\n        for(int i=0;i&lt;n;i++)&#123;\n            for(int j=0;j&lt;i;j++)&#123;\n                //如果小于arr[i]，则可以接在arr[i]前面\n                if(arr[j]&lt;arr[i])&#123;\n                    dp[i]=Math.max(dp[i],dp[j]+1);\n                &#125;\n            &#125;\n            //计算最长子序列的长度\n            len=Math.max(len,dp[i]);\n        &#125;\n        \n        int[] res=new int[len];\n        //从后往前确定目标子序列的每一个值\n        for(int i=n-1;i&gt;=0;i--)&#123;\n            if(dp[i]==len)&#123;\n                res[--len]=arr[i];\n            &#125;\n        &#125;\n        return res;\n    &#125;\n&#125;\n</code></pre>\n","categories":["算法"]},{"title":"单调栈","url":"/2023/06/04/%E5%8D%95%E8%B0%83%E6%A0%88/","content":"<p>什么时候用单调栈呢？</p>\n<p><strong>通常是一维数组，要寻找任一个元素的右边或者左边第一个比自己大或者小的元素的位置，此时我们就要想到可以用单调栈了</strong>。<span id=\"more\"></span></p>\n<p>时间复杂度为O(n)</p>\n<h2 id=\"每日温度\"><a href=\"#每日温度\" class=\"headerlink\" title=\"每日温度\"></a>每日温度</h2><p>就之前的方法就行</p>\n<p>给定一个整数数组 temperatures ，表示每天的温度，返回一个数组 answer ，其中 answer[i] 是指对于第 i 天，下一个更高温度出现在几天后。如果气温在这之后都不会升高，请在该位置用 0 来代替。</p>\n<pre><code class=\"plain\">class Solution &#123;\n    public int[] dailyTemperatures(int[] temperatures) &#123;\n        // 正向遍历温度列表。对于温度列表中的每个元素 temperatures[i]，如果栈为空，则直接将 i 进栈，如果栈不为空，则比较栈顶元素 prevIndex 对应的温度 temperatures[prevIndex] 和当前温度 temperatures[i]，如果 temperatures[i] &gt; temperatures[prevIndex]，则将 prevIndex 移除，并将 prevIndex 对应的等待天数赋为 i - prevIndex，重复上述操作直到栈为空或者栈顶元素对应的温度小于等于当前温度，然后将 i 进栈。\n        int n=temperatures.length;\n        int[] ans=new int[n];\n        Deque&lt;Integer&gt; deque=new LinkedList&lt;&gt;();\n        for(int i=0;i&lt;n;i++)&#123;\n            while(!deque.isEmpty()&amp;&amp;temperatures[i]&gt;temperatures[deque.peek()])&#123;\n                int topNum=deque.pop();\n                ans[topNum]=i-topNum;\n            &#125;\n            deque.push(i);\n        &#125;\n        return ans;\n\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"下一个更大元素-I\"><a href=\"#下一个更大元素-I\" class=\"headerlink\" title=\"下一个更大元素 I\"></a>下一个更大元素 I</h2><p>nums1 中数字 x 的 <strong>下一个更大元素</strong> 是指 x 在 nums2 中对应位置 <strong>右侧</strong> 的 <strong>第一个</strong> 比 x 大的元素。</p>\n<p>给你两个 <strong>没有重复元素</strong> 的数组 nums1 和 nums2 ，下标从 <strong>0</strong> 开始计数，其中nums1 是 nums2 的子集。</p>\n<p>对于每个 0 &lt;&#x3D; i &lt; nums1.length ，找出满足 nums1[i] &#x3D;&#x3D; nums2[j] 的下标 j ，并且在 nums2 确定 nums2[j] 的 <strong>下一个更大元素</strong> 。如果不存在下一个更大元素，那么本次查询的答案是 -1 。</p>\n<p>返回一个长度为 nums1.length 的数组 ans 作为答案，满足 ans[i] 是如上所述的 <strong>下一个更大元素</strong> 。</p>\n<p><strong>题解：</strong></p>\n<p>最后是要求nums1的每个元素在nums2中下一个比当前元素大的元素，那么就要定义一个和nums1一样大小的数组<strong>result</strong>来存放结果</p>\n<p>result数组初始化应该为-1</p>\n<pre><code class=\"plain\">class Solution &#123;\n    public int[] nextGreaterElement(int[] nums1, int[] nums2) &#123;\n        int n1=nums1.length,n2=nums2.length;\n        int[] ans=new int[n1];//结果集\n        // 初始化结果集\n        Arrays.fill(ans,-1);\n        //建立映射\n        Map&lt;Integer,Integer&gt; map=new HashMap&lt;&gt;();\n        for(int i=0;i&lt;n1;i++)&#123;\n            map.put(nums1[i],i);\n        &#125;\n        Deque&lt;Integer&gt; deque=new LinkedList&lt;&gt;();\n        //遍历num2\n        for(int i=0;i&lt;n2;i++)&#123;\n            //维护一个单调减栈\n            while(!deque.isEmpty()&amp;&amp;nums2[i]&gt;nums2[deque.peek()])&#123;\n                //栈顶元素下标对应的值\n                int topNum=nums2[deque.pop()];\n                //如果1包含这个值\n                if(map.containsKey(topNum))&#123;\n                    //存入结果\n                    ans[map.get(topNum)]=nums2[i];\n                &#125;\n            &#125;\n            //进栈\n            deque.push(i);\n        &#125;\n        return ans;\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"下一个更大元素II\"><a href=\"#下一个更大元素II\" class=\"headerlink\" title=\"下一个更大元素II\"></a>下一个更大元素II</h2><p>给定一个循环数组（最后一个元素的下一个元素是数组的第一个元素），输出每个元素的下一个更大元素。数字 x 的下一个更大的元素是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出 -1。</p>\n<p><strong>题解：</strong></p>\n<p>直接把两个数组拼接在一起，然后使用单调栈求下一个最大值也可，但扩充nums数组相当于多了一个O(n)的操作。</p>\n<p>可以不扩充nums，而是在遍历的过程中模拟走了两边nums：</p>\n<pre><code class=\"plain\">//其实和I一样 只是循环次数加倍  下标i每次要%n\nclass Solution &#123;\n    public int[] nextGreaterElements(int[] nums) &#123;\n        int n=nums.length;\n        int[] ans=new int[n];\n        Arrays.fill(ans,-1);\n        Stack&lt;Integer&gt; stack=new Stack&lt;&gt;();\n        for(int i=0;i&lt;2*n;i++)&#123;\n            while(!stack.isEmpty()&amp;&amp;nums[i%n]&gt;nums[stack.peek()])&#123;\n                ans[stack.pop()]=nums[i%n];\n            &#125;\n            stack.push(i%n);\n        &#125;\n        return ans;\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"接雨水\"><a href=\"#接雨水\" class=\"headerlink\" title=\"接雨水\"></a>接雨水</h2><p>给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/20210713205038.png\" alt=\"img\">z</p>\n<h3 id=\"双指针\"><a href=\"#双指针\" class=\"headerlink\" title=\"双指针\"></a>双指针</h3><p>按列算，每一列雨水的高度，取决于，该列 左侧最高的柱子和右侧最高的柱子中最矮的那个柱子的高度，双指针求，最后加</p>\n<h3 id=\"DP解法\"><a href=\"#DP解法\" class=\"headerlink\" title=\"DP解法\"></a>DP解法</h3><p>我们把每一个位置的左边最高高度记录在一个数组上（maxLeft），右边最高高度记录在一个数组上（maxRight）。这样就避免了重复计算，这就用到了动态规划。</p>\n<p>再求和</p>\n<h3 id=\"单调栈解法\"><a href=\"#单调栈解法\" class=\"headerlink\" title=\"单调栈解法\"></a>单调栈解法</h3><p>1、</p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/20210223092629946.png\" alt=\"img\"></p>\n<p>2、 </p>\n<p>递减</p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/2021022309321229.png\" alt=\"img\"></p>\n<p>3、遇到相同高度的柱子怎么办</p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/20210223094619398.png\" alt=\"img\"></p>\n<p>4、栈里保存什么值</p>\n<p>存height 下标 然后高可以height[i]算</p>\n<p>代码：</p>\n<pre><code class=\"plain\">class Solution &#123;\n    public int trap(int[] height) &#123;\n        int n=height.length;\n        Stack&lt;Integer&gt; stack=new Stack&lt;&gt;();\n        stack.push(0);\n        int sum=0;\n        for(int i=1;i&lt;n;i++)&#123;\n            //记录栈顶元素值\n            int top_index=stack.peek();\n            //递减直接进\n            if(height[i]&lt;height[top_index])&#123;\n                stack.push(i);\n            &#125;else if(height[i]==height[top_index])&#123;\n                // 因为相等的相邻墙，左边一个是不可能存放雨水的，所以pop左边的i, push当前的i\n                stack.pop();\n                stack.push(i);\n            &#125;else&#123;\n                while(!stack.isEmpty()&amp;&amp;height[i]&gt;height[top_index])&#123;\n                    栈顶元素\n                    int mid=stack.pop();\n                    if(!stack.isEmpty())&#123;\n                        栈顶左边元素\n                        int left=stack.peek();\n                        //两边最小值-底高 height[i])栈顶右边元素\n                        int h=Math.min(height[left],height[i])-height[mid];\n                        int l=i-left-1;\n                        if(h*l&gt;0) sum+=h*l ;\n                        //因为会有出栈 所以更新栈顶元素\n                        top_index=stack.peek();\n                    &#125;\n                &#125;\n                stack.push(i);\n            &#125;\n        &#125;\n        return sum;\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"柱状图中最大的矩形\"><a href=\"#柱状图中最大的矩形\" class=\"headerlink\" title=\"柱状图中最大的矩形\"></a>柱状图中最大的矩形</h2><p>给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。</p>\n<p>求在该柱状图中，能够勾勒出来的矩形的最大面积。</p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/20210803220437.png\" alt=\"img\"></p>\n<p>接雨水是求和 柱状图是求最大 两个还是有所不同</p>\n<p>前后有个0的作用：</p>\n<ol>\n<li>前面0是让后面元素能进去 </li>\n<li>后面0是让 所有元素都出来 都参与计算</li>\n</ol>\n<p>栈里顺序递增 <strong>栈顶和栈顶的下一个元素以及要入栈的三个元素组成了我们要求最大面积的高度和宽度</strong></p>\n<p>56的例子：</p>\n<ol>\n<li>2&lt;6 6出栈： 结果6*1</li>\n<li>2&lt;5 5出栈 结果 5*2</li>\n</ol>\n<pre><code class=\"plain\">class Solution &#123;\n    public int largestRectangleArea(int[] heights) &#123;\n        Stack&lt;Integer&gt; stack =new Stack&lt;Integer&gt;();\n        int[] newheights=new int[heights.length+2];\n        newheights[0]=0;\n        newheights[newheights.length-1]=0;\n        // 初始化\n        for(int i=1;i&lt;newheights.length-1;i++)&#123;\n            newheights[i]=heights[i-1];\n        &#125;\n        heights=newheights;\n        int result=0;\n        stack.push(0);\n        for(int i=1;i&lt;heights.length;i++)&#123;\n            if(heights[i]&gt;heights[stack.peek()])&#123;\n                stack.push(i);\n            &#125;else if(heights[i]==heights[stack.peek()])&#123;\n                stack.pop();\n                stack.push(i);\n            &#125;else&#123;\n                while(heights[i]&lt;heights[stack.peek()])&#123;\n                    int mid = stack.peek();\n                    stack.pop();\n                    int left=stack.peek();\n                    int right=i;\n                    int w=right-left-1;\n                    int h=heights[mid];\n                    // 算最大值\n                    result=Math.max(result,h*w);\n                &#125;\n                stack.push(i);\n            &#125;\n        &#125;\n        return result;\n    &#125;\n&#125;\n</code></pre>\n","categories":["算法"]},{"title":"哈希表","url":"/2023/06/04/%E5%93%88%E5%B8%8C%E8%A1%A8/","content":"<h2 id=\"同构字符串\"><a href=\"#同构字符串\" class=\"headerlink\" title=\"同构字符串\"></a>同构字符串</h2><p>给定两个字符串 s 和 t ，判断它们是否是同构的。<span id=\"more\"></span></p>\n<p>如果 s 中的字符可以按某种映射关系替换得到 t ，那么这两个字符串是同构的。</p>\n<p>每个出现的字符都应当映射到另一个字符，同时不改变字符的顺序。不同字符不能映射到同一个字符上，相同字符只能映射到同一个字符上，字符可以映射到自己本身。</p>\n<pre><code class=\"plain\">class Solution &#123;\n     public boolean isIsomorphic(String s, String t) &#123;\n         Map&lt;Character, Character&gt; map1 = new HashMap&lt;&gt;();\n         Map&lt;Character, Character&gt; map2 = new HashMap&lt;&gt;();\n         for (int i = 0, j = 0; i &lt; s.length(); i++, j++) &#123;\n             if (!map1.containsKey(s.charAt(i))) &#123;\n                 map1.put(s.charAt(i), t.charAt(j)); // map1保存 s[i] 到 t[j]的映射\n             &#125;\n             if (!map2.containsKey(t.charAt(j))) &#123;\n                 map2.put(t.charAt(j), s.charAt(i)); // map2保存 t[j] 到 s[i]的映射\n             &#125;  \n             // 无法映射，返回 false   //之前映射一次了 所以这次不行 例如 a-&gt;b   又遇到a  c 那必然失败\n             if (map1.get(s.charAt(i)) != t.charAt(j) || map2.get(t.charAt(j)) != s.charAt(i)) &#123;\n                 return false;\n             &#125;\n         &#125;\n         return true;\n     &#125;\n &#125;\n</code></pre>\n<h2 id=\"查找共用字符\"><a href=\"#查找共用字符\" class=\"headerlink\" title=\"查找共用字符\"></a>查找共用字符</h2><p>给你一个字符串数组 words ，请你找出所有在 words 的每个字符串中都出现的共用字符（ <strong>包括重复字符</strong>），并以数组形式返回。你可以按 <strong>任意顺序</strong> 返回答案。</p>\n<p>思路</p>\n<pre><code class=\"plain\">class Solution &#123;\n     public List&lt;String&gt; commonChars(String[] words) &#123;\n         // 哈希    hash数组存储每个字符对应的在各个字符串里面出现的最小频率    \n         // 输入：words = [&quot;bella&quot;,&quot;label&quot;,&quot;roller&quot;]\n         // hash[1]=0,hash[&#39;l&#39;-&#39;a&#39;]=2\n         // 输出：[&quot;e&quot;,&quot;l&quot;,&quot;l&quot;]   \n         List&lt;String&gt; res=new ArrayList&lt;&gt;();\n         int[] hash=new int[26];\n         //给hash初始化一个最大值\n         Arrays.fill(hash,Integer.MAX_VALUE);\n         for(int i=0;i&lt;words.length;i++)&#123;\n             int[] newhash=new int[26];\n             for(int j=0;j&lt;words[i].length();j++)&#123;\n                 newhash[words[i].charAt(j)-&#39;a&#39;]++;\n             &#125;\n             for(int k=0;k&lt;26;k++)&#123;\n                 hash[k]=Math.min(hash[k],newhash[k]);\n             &#125;\n         &#125;\n         for(int i=0;i&lt;26;i++)&#123;\n             while(hash[i]!=0)&#123;\n                 char c=(char)(&#39;a&#39;+i);//必须指定转的类型\n                 res.add(String.valueOf(c));\n                 hash[i]--;\n             &#125;\n         &#125;\n         return res;\n \n     &#125;\n &#125;\n</code></pre>\n<h2 id=\"赎金信\"><a href=\"#赎金信\" class=\"headerlink\" title=\"赎金信\"></a>赎金信</h2><p>给你两个字符串：ransomNote 和 magazine ，判断 ransomNote 能不能由 magazine 里面的字符构成。</p>\n<p>如果可以，返回 true ；否则返回 false 。</p>\n<p>magazine 中的每个字符只能在 ransomNote 中使用一次。</p>\n<p><strong>官方题解</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/image-20221017202244463.png\" alt=\"img\"></p>\n<p><strong>我的题解</strong></p>\n<pre><code class=\"plain\">class Solution &#123;\n     //我的思路：先magazine存kv，然后ransomNote找如果没key或者value为0直接返回false，否则magazine对应v-1\n     public boolean canConstruct(String ransomNote, String magazine) &#123;\n         Map&lt;Character,Integer&gt; map=new HashMap&lt;&gt;();\n         for(char c:magazine.toCharArray())&#123;\n             map.put(c,map.getOrDefault(c,0)+1);\n         &#125;\n         for(char d:ransomNote.toCharArray())&#123;  \n             if(!map.containsKey(d)||map.get(d)==0)&#123;\n                 return false;\n             &#125;else&#123;\n                 map.put(d,map.get(d)-1);\n             &#125;\n         &#125;\n         return true;\n     &#125;\n &#125;\n</code></pre>\n<h2 id=\"四数相加II\"><a href=\"#四数相加II\" class=\"headerlink\" title=\"四数相加II\"></a>四数相加II</h2><p><strong>这题和四数之和不一样 四数之和是一个数组里面 用排序+双重for循环+双指针，这个用两次hash就行</strong></p>\n<p>给你四个整数数组nums1、nums2、nums3 和 nums4 ，数组长度都是 n ，请你计算有多少个元组 (i, j, k, l) 能满足：</p>\n<ul>\n<li>0 &lt;&#x3D; i, j, k, l &lt; n</li>\n<li>nums1[i] + nums2[j] + nums3[k] + nums4[l] &#x3D;&#x3D; 0</li>\n</ul>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/image-20221017155818344.png\" alt=\"img\"></p>\n<pre><code class=\"plain\">class Solution &#123;\n     public int fourSumCount(int[] A, int[] B, int[] C, int[] D) &#123;\n         Map&lt;Integer, Integer&gt; countAB = new HashMap&lt;Integer, Integer&gt;();\n         for (int u : A) &#123;\n             for (int v : B) &#123;\n                 countAB.put(u + v, countAB.getOrDefault(u + v, 0) + 1);\n             &#125;\n         &#125;\n         int ans = 0;\n         for (int u : C) &#123;\n             for (int v : D) &#123;\n                 if (countAB.containsKey(-u - v)) &#123;\n                     ans += countAB.get(-u - v);\n                 &#125;\n             &#125;\n         &#125;\n         return ans;\n     &#125;\n &#125;\n</code></pre>\n<h2 id=\"1-两数之和\"><a href=\"#1-两数之和\" class=\"headerlink\" title=\"1. 两数之和\"></a>1. 两数之和</h2><p><strong>方法一：****暴力</strong></p>\n<p>最容易想到的方法是枚举数组中的每一个数 x，寻找数组中是否存在 target - x。 时间复杂度：O(N2)</p>\n<p><strong>方法二（优先）：哈希表</strong></p>\n<p>注意到方法一的时间复杂度较高的原因是寻找 target - x 的时间复杂度过高。因此，我们需要一种更优秀的方法，能够快速寻找数组中是否存在目标元素。如果存在，我们需要找出它的索引。</p>\n<p>哈希表：存key 数字 value 下标</p>\n<p>使用哈希表，可以将寻找 target - x 的时间复杂度降低到从 O(N) 降低到 O(1)。</p>\n<p>这样我们创建一个哈希表，对于每一个 x，我们首先查询哈希表中是否存在 target - x，然后将 x 插入到哈希表中，即可保证不会让 x 和自己匹配。</p>\n<pre><code class=\"plain\">class Solution &#123;\n     public int[] twoSum(int[] nums, int target) &#123;\n         Map&lt;Integer, Integer&gt; hashtable = new HashMap&lt;Integer, Integer&gt;();\n         for (int i = 0; i &lt; nums.length; ++i) &#123;\n             if (hashtable.containsKey(target - nums[i])) &#123;\n                 return new int[]&#123;hashtable.get(target - nums[i]), i&#125;;\n             &#125;\n             hashtable.put(nums[i], i);\n         &#125;\n         return new int[0];\n     &#125;\n &#125;\n</code></pre>\n<h2 id=\"202-快乐数\"><a href=\"#202-快乐数\" class=\"headerlink\" title=\"202. 快乐数\"></a>202. 快乐数</h2><p>编写一个算法来判断一个数 n 是不是快乐数。</p>\n<p>「快乐数」 定义为：</p>\n<p>对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。如果这个过程 结果为 1，那么这个数就是快乐数。</p>\n<p><strong>方法一（选这个）</strong>（简单一点）</p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/image-20221016165323827.png\" alt=\"img\"></p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/image-20221016165445320.png\" alt=\"img\"></p>\n<pre><code class=\"plain\">class Solution &#123;\n     //简单 求下一个元素\n     private int getNext(int n) &#123;\n         int totalSum = 0;\n         while (n &gt; 0) &#123;\n             int d = n % 10;\n             n = n / 10;\n             totalSum += d * d;\n         &#125;\n         return totalSum;\n     &#125;\n     //hashset存  要么循环要么最后为1\n     public boolean isHappy(int n) &#123;\n         Set&lt;Integer&gt; seen = new HashSet&lt;&gt;();\n         while (n != 1 &amp;&amp; !seen.contains(n)) &#123;\n             seen.add(n);\n             n = getNext(n);\n         &#125;\n         return n == 1;\n     &#125;\n &#125;\n</code></pre>\n<p><strong>方法二</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/image-20221016165617310.png\" alt=\"img\"></p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/image-20221016165555141.png\" alt=\"img\"></p>\n<pre><code class=\"plain\">class Solution &#123;\n      public int getNext(int n) &#123;\n         int totalSum = 0;\n         while (n &gt; 0) &#123;\n             int d = n % 10;\n             n = n / 10;\n             totalSum += d * d;\n         &#125;\n         return totalSum;\n     &#125;\n \n     public boolean isHappy(int n) &#123;\n         int slowRunner = n;\n         int fastRunner = n;\n         while (fastRunner != 1 &amp;&amp; slowRunner != fastRunner) &#123;\n             slowRunner = getNext(slowRunner);\n             fastRunner = getNext(getNext(fastRunner));\n         &#125;\n         return fastRunner == 1;\n     &#125;\n &#125;\n</code></pre>\n<h2 id=\"349-两个数组的交集\"><a href=\"#349-两个数组的交集\" class=\"headerlink\" title=\"349. 两个数组的交集\"></a>349. 两个数组的交集</h2><p>给定两个数组 nums1 和 nums2 ，返回 <em>它们的交集</em> 。输出结果中的每个元素一定是 <strong>唯一</strong> 的。我们可以 <strong>不考虑输出结果的顺序</strong> 。</p>\n<p>我自己的解法</p>\n<pre><code class=\"plain\">class Solution &#123;\n     public int[] intersection(int[] nums1, int[] nums2) &#123;\n         int n=nums1.length;\n         int m=nums2.length;\n         Set&lt;Integer&gt; hashSet=new HashSet&lt;&gt;();\n         Set&lt;Integer&gt; mergeSet=new HashSet&lt;&gt;();\n         //1、利用Set无重复元素的特点 把nums1进行去重\n         for(int i=0;i&lt;n;i++)&#123;\n             hashSet.add(nums1[i]);\n         &#125;\n         //2、判断hashSet里面有么有nums2,有的话把nums2放到Set结果里面\n         for(int i=0;i&lt;m;i++)&#123;\n             if(hashSet.contains(nums2[i]))&#123;\n                 mergeSet.add(nums2[i]);\n             &#125;\n         &#125;\n         //Set转int[]\n         int[] res=new int[mergeSet.size()];\n         int i=0;\n         for(int num:mergeSet)&#123;\n             res[i++]=num;\n         &#125;\n         return res;\n     &#125;\n &#125;\n</code></pre>\n<h2 id=\"242-有效的字母异位词\"><a href=\"#242-有效的字母异位词\" class=\"headerlink\" title=\"242.有效的字母异位词\"></a>242.有效的字母异位词</h2><p>题解：这个比寻找字母异位词起始下标还简单一点 是基础 那个是用滑动窗口，然后每次移动后再去判断 这个都不用 直接算</p>\n<p>给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。</p>\n<p>注意：若 s 和 t 中每个字符出现的次数都相同，则称 s 和 t 互为字母异位词。</p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/image-20221015215819113.png\" alt=\"img\"></p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/image-20221015215826918.png\" alt=\"img\"></p>\n","categories":["算法"]},{"title":"双指针","url":"/2023/06/04/%E5%8F%8C%E6%8C%87%E9%92%88/","content":"<h2 id=\"四数之和\"><a href=\"#四数之和\" class=\"headerlink\" title=\"四数之和\"></a>四数之和</h2><p>与三数之和类似，使用两重循环分别枚举前两个数，然后在两重循环枚举到的数之后使用双指针枚举剩下的两个数。<span id=\"more\"></span></p>\n<ul>\n<li>每一种循环枚举到的下标必须大于上一重循环枚举到的下标；</li>\n<li>同一重循环中，如果当前元素与上一个元素相同，则跳过当前元素。（去重）剪枝操作：内存溢出 加(long)<img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/image-20221018194452672.png\" alt=\"img\"></li>\n</ul>\n<pre><code class=\"plain\">按照三数之和写\nclass Solution &#123;\n    public List&lt;List&lt;Integer&gt;&gt; fourSum(int[] nums, int target) &#123;\n        Arrays.sort(nums);\n        List&lt;List&lt;Integer&gt;&gt; ans=new ArrayList&lt;&gt;();\n        int n=nums.length;\n        for(int i=0;i&lt;n-3;i++)&#123;\n            //严格来说前面这个条件break，后面continue\n            if((long) nums[i]+nums[i+1]+nums[i+2]+nums[i+3]&gt;target||(long) nums[i]+nums[n-1]+nums[n-2]+nums[n-3]&lt;target) continue; \n            if(i&gt;0&amp;&amp;nums[i]==nums[i-1]) continue;\n            for(int j=i+1;j&lt;n-2;j++)&#123;\n                 //严格来说前面这个条件break，后面continue\n                if((long) nums[i]+nums[j]+nums[j+1]+nums[j+2]&gt;target||(long) nums[i]+nums[j]+nums[n-1]+nums[n-2]&lt;target) continue;\n                if(j&gt;i+1&amp;&amp;nums[j]==nums[j-1]) continue;\n                int k=j+1,l=n-1;\n                while(k&lt;l)&#123;\n                    long sum=(long) nums[i]+nums[j]+nums[k]+nums[l];\n                    if(sum&gt;target)&#123;\n                        while(k&lt;l&amp;&amp;nums[l]==nums[--l]);\n                    &#125;else if(sum&lt;target)&#123;\n                        while(k&lt;l&amp;&amp;nums[k]==nums[++k]);\n                    &#125;else&#123;\n                        ans.add(Arrays.asList(nums[i],nums[j],nums[k],nums[l]));\n                        while(k&lt;l&amp;&amp;nums[l]==nums[--l]);\n                        while(k&lt;l&amp;&amp;nums[k]==nums[++k]);\n                    &#125;\n                &#125;\n\n            &#125;\n        &#125;\n        return ans;\n\n    &#125;\n&#125;\n</code></pre>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/image-20221018204117697.png\" alt=\"img\"></p>\n<p>遇到这种情况，是因为溢出了，强转为 long即可，int存不下这么大数字</p>\n<h2 id=\"三数之和\"><a href=\"#三数之和\" class=\"headerlink\" title=\"三数之和\"></a>三数之和</h2><p>给你一个整数数组 nums ，判断是否存在三元组 [nums[i], nums[j], nums[k]] 满足 i !&#x3D; j、i !&#x3D; k 且 j !&#x3D; k ，同时还满足 nums[i] + nums[j] + nums[k] &#x3D;&#x3D; 0 。请</p>\n<p>你返回所有和为 0 且不重复的三元组。注意：答案中不可以包含重复的三元组。</p>\n<p>双指针：</p>\n<p>1、排序</p>\n<p>2、第一层循环记得去重if(k &gt; 0 &amp;&amp; nums[k] &#x3D;&#x3D; nums[k - 1]) continue;</p>\n<p>3、然后第二第三个数 双指针两端根据和0的关系移动指针</p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/image-20221017211410717.png\" alt=\"img\"></p>\n<pre><code class=\"plain\">//感觉k神比官方题解好一点\nclass Solution &#123;\n    public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123;\n        //排序 递增排列\n        Arrays.sort(nums);//复杂度nlogn\n        List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();\n        for(int k = 0; k &lt; nums.length - 2; k++)&#123;\n            //三个大于0的不可能满足 直接结束所有循环\n            if(nums[k] &gt; 0) break;\n            //从第二个开始\n            //基于有序 例如 -1 -1 0 1 \n            if(k &gt; 0 &amp;&amp; nums[k] == nums[k - 1]) continue;\n            int i = k + 1, j = nums.length - 1;\n            while(i &lt; j)&#123;\n                int sum = nums[k] + nums[i] + nums[j];\n                //小于0 左指针移动到和上一个元素不同的数字上面\n                //大于0 右指针移动到和上一个元素不同的数字上面\n                //等于0 左右指针移动到和上一个元素不同的数字上面\n                if(sum &lt; 0)&#123;\n                    while(i &lt; j &amp;&amp; nums[i] == nums[++i]);\n                &#125; else if (sum &gt; 0) &#123;\n                    while(i &lt; j &amp;&amp; nums[j] == nums[--j]);\n                &#125; else &#123;\n                    res.add(new ArrayList&lt;Integer&gt;(Arrays.asList(nums[k], nums[i], nums[j])));\n                    while(i &lt; j &amp;&amp; nums[i] == nums[++i]);   \n                    while(i &lt; j &amp;&amp; nums[j] == nums[--j]);\n                &#125;\n            &#125;\n        &#125;\n        return res;\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"下一个排列\"><a href=\"#下一个排列\" class=\"headerlink\" title=\"下一个排列\"></a>下一个排列</h2><p>反过来就会报错 必须保证先不出界才能继续后面条件判断双指针</p>\n<p>这个方法就是我们常说的「双指针」，当我们需要枚举数组中的两个元素时，如果我们发现随着第一个元素的递增，第二个元素是递减的，那么就可以使用双指针的方法，</p>\n<p><strong>将给定数字序列重新排列成字典序中下一个更大的排列。</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/31.gif\" alt=\"img\"></p>\n<h2 id><a href=\"#\" class=\"headerlink\" title></a></h2><h2 id=\"27-移除元素\"><a href=\"#27-移除元素\" class=\"headerlink\" title=\"27 移除元素\"></a>27 移除元素</h2><p>给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。 元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/image-20221012161829652.png\" alt=\"img\"></p>\n<pre><code class=\"plain\">class Solution &#123;\n    public int removeElement(int[] nums, int val) &#123;\n        int left=0,right=nums.length-1;\n        while(left&lt;=right)&#123;\n            if(nums[left]==val)&#123;\n                nums[left]=nums[right];\n                right--;\n            &#125;else&#123;\n                left++;\n            &#125;\n        &#125;\n        return left;\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"977-有序数组的平方\"><a href=\"#977-有序数组的平方\" class=\"headerlink\" title=\"977. 有序数组的平方\"></a>977. 有序数组的平方</h2><p>给你一个按 <strong>非递减顺序</strong> 排序的整数数组 nums，返回 <strong>每个数字的平方</strong> 组成的新数组，要求也按 <strong>非递减顺序</strong> 排序。</p>\n<p>方法一：原地平方加sort 但nlogn</p>\n<p>方法二：双指针</p>\n<p>使用两个指针分别指向位置 0和 n−1，每次比较两个指针对应的数，选择较大的那个<strong>逆序</strong>放入答案并移动指针。</p>\n<p>空间换时间</p>\n<pre><code class=\"plain\">class Solution &#123;\n    public int[] sortedSquares(int[] nums) &#123;\n        int n = nums.length;\n        int[] ans = new int[n];\n        //注意i &lt;= j;后面有分号\n        for (int i = 0, j = n - 1, pos = n - 1; i &lt;= j;) &#123;\n            if (nums[i] * nums[i] &gt; nums[j] * nums[j]) &#123;\n                ans[pos] = nums[i] * nums[i];\n                ++i;\n            &#125; else &#123;\n                ans[pos] = nums[j] * nums[j];\n                --j;\n            &#125;\n            --pos;\n        &#125;\n        return ans;\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"209-长度最小的子数组（滑动窗口）\"><a href=\"#209-长度最小的子数组（滑动窗口）\" class=\"headerlink\" title=\"209.长度最小的子数组（滑动窗口）\"></a>209.长度最小的子数组（滑动窗口）</h2><p>所以，滑动窗口也算是双指针的一个类吧</p>\n<p>题目：</p>\n<p>给定一个含有 n 个正整数的数组和一个正整数 target 。</p>\n<p>找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 [numsl, numsl+1, …, numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。</p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/image-20221012224459033.png\" alt=\"img\"></p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/209.%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84.gif\" alt=\"img\"></p>\n<pre><code class=\"plain\">class Solution &#123;\n    public int minSubArrayLen(int s, int[] nums) &#123;\n        int n = nums.length;\n        //这个判断条件不写也可以通过\n        if (n == 0) &#123;\n            return 0;\n        &#125;\n        int ans = Integer.MAX_VALUE;\n        int start = 0, end = 0;\n        int sum = 0;\n        while (end &lt; n) &#123;\n            sum += nums[end];\n            //因为有可能出现当前sum不是最接近target的情况，所以要滑动start，顺便记录len的最小长度\n            while (sum &gt;= s) &#123;\n                ans = Math.min(ans, end - start + 1);\n                sum -= nums[start];\n                start++;\n            &#125;\n            end++;\n        &#125;\n        return ans == Integer.MAX_VALUE ? 0 : ans;\n    &#125;\n&#125;\n</code></pre>\n","categories":["算法"]},{"title":"回溯","url":"/2023/06/04/%E5%9B%9E%E6%BA%AF/","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p><a href=\"https://www.zhihu.com/question/325665309/answer/2245817776\">https://www.zhihu.com/question/325665309/answer/2245817776</a></p>\n<p><strong>很多需要列举所有可能性的题需要用回溯</strong><span id=\"more\"></span></p>\n<pre><code class=\"plain\">def backtrack(...):\n     for 选择 in 选择列表:\n         做选择\n         backtrack(...)\n         撤销选择\n1、路径：也就是已经做出的选择。\n \n 2、选择列表：也就是你当前可以做的选择。\n \n 3、结束条件：也就是到达决策树底层，无法再做选择的条件。\n result = []\n def backtrack(路径, 选择列表):\n     if 满足结束条件:\n         result.add(路径)\n         return\n \n     for 选择 in 选择列表:\n         做选择\n         backtrack(路径, 选择列表)\n         撤销选择\n</code></pre>\n<p>一般涉及到做选择的问题都可以考虑用回溯法，写回溯的题的时候，方法参数可以先空着，用到什么加什么、</p>\n<p>当只有两个选择的时候，就不用for循环了，直接写出来就行，比如+- ()这种</p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/20210130173631174.png\" alt=\"img\"></p>\n<h3 id=\"去重问题\"><a href=\"#去重问题\" class=\"headerlink\" title=\"去重问题\"></a>去重问题</h3><p>for循环外面定义一个HashSet for循环里面判断是否重复并continue</p>\n<h3 id=\"为什么定义为全局变量\"><a href=\"#为什么定义为全局变量\" class=\"headerlink\" title=\"为什么定义为全局变量\"></a>为什么定义为全局变量</h3><p>当然把参数放进函数里传进去也是可以的，我是尽量控制函数里参数的长度。</p>\n<h3 id=\"递归返回值问题\"><a href=\"#递归返回值问题\" class=\"headerlink\" title=\"递归返回值问题\"></a>递归返回值问题</h3><p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/image-20221115155029111.png\" alt=\"img\"></p>\n<h2 id=\"组合问题：\"><a href=\"#组合问题：\" class=\"headerlink\" title=\"组合问题：\"></a>组合问题：</h2><h2 id=\"组合\"><a href=\"#组合\" class=\"headerlink\" title=\"组合\"></a>组合</h2><p>给定两个整数 n 和 k，返回范围 [1, n] 中所有可能的 k 个数的组合。</p>\n<p>你可以按 <strong>任何顺序</strong> 返回答案。</p>\n<pre><code class=\"plain\">class Solution &#123;\n     List&lt;List&lt;Integer&gt;&gt; ans=new ArrayList&lt;&gt;();\n     public List&lt;List&lt;Integer&gt;&gt; combine(int n, int k) &#123;\n         List&lt;Integer&gt; cur=new ArrayList&lt;&gt;();\n         backtrack(1,cur,n,k);\n         return ans;\n     &#125;\n     public void backtrack(int start,List&lt;Integer&gt; cur,int n,int k)&#123;\n         //长度为K\n         if(cur.size()==k)&#123;\n             ans.add(new ArrayList(cur));\n             return;\n         &#125;\n         //选择列表\n         for(int i=start;i&lt;=n-(k-cur.size())+1;i++)&#123;\n             cur.add(i);\n             //这个地方是i+1 不是start+1!!!!(自己最开始bug就这个)\n             backtrack(i+1,cur,n,k);\n             //回溯\n             cur.remove(cur.size()-1);\n         &#125;\n     &#125;\n &#125;\n</code></pre>\n<h2 id=\"组合问题之剪枝\"><a href=\"#组合问题之剪枝\" class=\"headerlink\" title=\"组合问题之剪枝\"></a>组合问题之剪枝</h2><p><strong>如果for循环我们选择的起始位置之后的元素个数 已经不足 我们需要的元素个数了，那么就没有必要搜索了</strong>。</p>\n<p>举个例子，n &#x3D; 4，k &#x3D; 3， 目前已经选取的元素为0（path.size为0），n - (k - 0) + 1 即 4 - ( 3 - 0) + 1 &#x3D; 2。</p>\n<p>从2开始搜索都是合理的，可以是组合[2, 3, 4]。 因为k是3 如果选择从3开始 最多3 4 依然不满足</p>\n<p>组合问题可以套用</p>\n<p>k是当前组合元素个数 n是i的范围</p>\n<p>  i &lt;&#x3D; n - (k - path.size()) + 1</p>\n<h2 id=\"组合总和\"><a href=\"#组合总和\" class=\"headerlink\" title=\"组合总和\"></a>组合总和</h2><pre><code class=\"plain\">//给你一个 无重复元素 的整数数组 candidates 和一个目标整数 target ，找出 candidates 中可以使数字和为目标数 target 的\n // 所有 不同组合 ，并以列表形式返回。你可以按 任意顺序 返回这些组合。\nclass Solution &#123;\n     public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) &#123;\n         List&lt;List&lt;Integer&gt;&gt; ans=new ArrayList&lt;&gt;();\n         List&lt;Integer&gt; cur=new ArrayList&lt;&gt;();\n         backtrack(candidates,target,ans,cur,0,0);\n         return ans;\n     &#125;\n     public void backtrack(int[] candidates,int target,List&lt;List&lt;Integer&gt;&gt; ans,List&lt;Integer&gt; cur,int sum,int index) &#123;\n         if (sum == target) &#123;\n             ans.add(new ArrayList&lt;Integer&gt;(cur));\n             //此处为啥不是ans.add(cur)？\n             //答案：因为cur是数组的引用地址，直接add最后是空的\n \n             return;\n         &#125;\n \n         if (sum &lt; target) &#123;\n             //index的作用是为了使得不出现 测试结果:[[2,2,3],[2,3,2],[3,2,2],[7]] 期望结果:[[2,2,3],[7]]\n             //这种情况，保持数组cur升序，也就避免了重复\n                 for (int i = index; i &lt; candidates.length; i++) &#123;\n                 cur.add(candidates[i]);\n                 sum = sum + candidates[i];\n                 backtrack(candidates, target, ans, cur, sum,i);//i传进去\n                 cur.remove(cur.size() - 1);\n                 sum = sum - candidates[i];//剪枝操作 返回回原来状态 否则sum只会越来越大\n             &#125;\n         &#125;\n     &#125;\n \n &#125;\n</code></pre>\n<h2 id=\"组合总和II\"><a href=\"#组合总和II\" class=\"headerlink\" title=\"组合总和II\"></a>组合总和II</h2><p>给定一个候选人编号的集合 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</p>\n<p>candidates 中的每个数字在每个组合中只能使用 <strong>一次</strong> 。</p>\n<pre><code class=\"plain\">class Solution &#123;\n     List&lt;List&lt;Integer&gt;&gt; ans=new ArrayList&lt;&gt;();\n     public List&lt;List&lt;Integer&gt;&gt; combinationSum2(int[] candidates, int target) &#123;\n         List&lt;Integer&gt; cur=new ArrayList&lt;&gt;();\n         //排序\n         Arrays.sort(candidates);\n         backtrack(target,0,cur,0,candidates);\n         return ans;\n \n     &#125;\n     public void backtrack(int target,int sum,List&lt;Integer&gt; cur,int start,int[] candidates)&#123;\n         if(sum==target)&#123;\n             ans.add(new ArrayList&lt;&gt;(cur));\n             return;\n         &#125;\n         //这个地方剪枝很关键，sum+candidates[i]&lt;= target 判断一下是不是超过Num，超过的话就不执行\n         for(int i=start;i&lt;candidates.length&amp;&amp;sum+candidates[i]&lt;= target;i++)&#123;\n             //去重  比如 1125  会出现两个125 我们所以到第二个1就不执行\n             if(i!=start&amp;&amp;candidates[i]==candidates[i-1]) continue;\n             cur.add(candidates[i]);\n             sum+=candidates[i];\n             backtrack(target,sum,cur,i+1,candidates);\n             cur.remove(cur.size()-1);\n             sum-=candidates[i];\n         &#125;\n     &#125;\n &#125;\n</code></pre>\n<h2 id=\"组合总和III\"><a href=\"#组合总和III\" class=\"headerlink\" title=\"组合总和III\"></a>组合总和III</h2><p>找出所有相加之和为 n 的 k 个数的组合，且满足下列条件：</p>\n<ul>\n<li>只使用数字1到9</li>\n<li>每个数字 <strong>最多使用一次</strong></li>\n</ul>\n<p>返回 <em>所有可能的有效组合的列表</em> 。该列表不能包含相同的组合两次，组合可以以任何顺序返回。</p>\n<pre><code class=\"plain\">class Solution &#123;\n     List&lt;List&lt;Integer&gt;&gt; ans=new ArrayList&lt;&gt;();\n     public List&lt;List&lt;Integer&gt;&gt; combinationSum3(int k, int n) &#123;\n         List&lt;Integer&gt; cur=new ArrayList&lt;&gt;();\n         backtrack(k,n,0,1,cur);\n         return ans;\n     &#125;\n     public void backtrack(int k, int n,int sum,int start,List&lt;Integer&gt; cur)&#123;\n         //出口\n         if(cur.size()==k)&#123;\n             if(n==sum)&#123;\n                 ans.add(new ArrayList&lt;&gt;(cur));\n             &#125;\n             return;\n         &#125;\n         for(int i=start;i&lt;=9-(k-cur.size())+1;i++)&#123;\n             cur.add(i);\n             sum=sum+i;\n             backtrack(k,n,sum,i+1,cur);\n             //sum和cur都回溯\n             cur.remove(cur.size()-1);\n             sum=sum-i;\n         &#125;\n     &#125;\n &#125;\n</code></pre>\n<h2 id=\"电话号码的字母组合\"><a href=\"#电话号码的字母组合\" class=\"headerlink\" title=\"电话号码的字母组合\"></a>电话号码的字母组合</h2><p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/image-20221110215820412.png\" alt=\"img\"></p>\n<pre><code class=\"plain\">class Solution &#123;\n     List&lt;String&gt; ans=new ArrayList&lt;&gt;();\n     public List&lt;String&gt; letterCombinations(String digits) &#123;\n         Map&lt;Character,String&gt; map=new HashMap&lt;&gt;()&#123;\n             &#123;\n                 put(&#39;2&#39;, &quot;abc&quot;);\n                 put(&#39;3&#39;, &quot;def&quot;);\n                 put(&#39;4&#39;, &quot;ghi&quot;);\n                 put(&#39;5&#39;, &quot;jkl&quot;);\n                 put(&#39;6&#39;, &quot;mno&quot;);\n                 put(&#39;7&#39;, &quot;pqrs&quot;);\n                 put(&#39;8&#39;, &quot;tuv&quot;);\n                 put(&#39;9&#39;, &quot;wxyz&quot;);\n             &#125;\n         &#125;;\n         StringBuilder cur=new StringBuilder();\n         backtrack(digits,map,0,cur);\n         return ans;\n     &#125;\n     public void backtrack(String digits,Map&lt;Character,String&gt; map,int index,StringBuilder cur)&#123;\n         //digits空的情况\n         if(digits.length()==0) return;\n         if(index==digits.length())&#123;\n             ans.add(cur.toString());\n             return;\n         &#125;\n         char dight=digits.charAt(index);\n         String letters=map.get(dight);\n         for(int i=0;i&lt;letters.length();i++)&#123;\n             cur.append(letters.charAt(i));\n             backtrack(digits,map,index+1,cur);\n             cur.deleteCharAt(index);\n         &#125;\n     &#125;\n &#125;\n</code></pre>\n<h2 id=\"分割问题：\"><a href=\"#分割问题：\" class=\"headerlink\" title=\"分割问题：\"></a>分割问题：</h2><p>我们来分析一下切割，<strong>其实切割问题类似组合问题</strong>。</p>\n<p>例如对于字符串abcdef：</p>\n<ul>\n<li>组合问题：选取一个a之后，在bcdef中再去选取第二个，选取b之后在cdef中在选组第三个…..。</li>\n<li>切割问题：切割一个a之后，在bcdef中再去切割第二段，切割b之后在cdef中在切割第三段…..。</li>\n</ul>\n<p>感受出来了不？</p>\n<p>所以切割问题，也可以抽象为一棵树形结构，如图：</p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/131.%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2.jpg\" alt=\"img\"></p>\n<p>递归用来纵向遍历，for循环用来横向遍历，切割线（就是图中的红线）切割到字符串的结尾位置，说明找到了一个切割方法。</p>\n<p>此时可以发现，切割问题的回溯搜索的过程和组合问题的回溯搜索的过程是差不多的。</p>\n<h2 id=\"分割回文串\"><a href=\"#分割回文串\" class=\"headerlink\" title=\"分割回文串\"></a>分割回文串</h2><p>给你一个字符串 s，请你将 s 分割成一些子串，使每个子串都是 <strong>回文串</strong> 。返回 s 所有可能的分割方案。</p>\n<p><strong>回文串</strong> 是正着读和反着读都一样的字符串。</p>\n<pre><code class=\"plain\">class Solution &#123;\n     List&lt;List&lt;String&gt;&gt; ans=new ArrayList&lt;&gt;();\n     List&lt;String&gt; cur=new ArrayList&lt;&gt;();\n     public List&lt;List&lt;String&gt;&gt; partition(String s) &#123;\n         backtrack(0,s);\n         return ans;        \n     &#125;\n     public void backtrack(int start,String s)&#123;\n         //出口 切割到头就结束\n         if(start==s.length())&#123;\n             ans.add(new ArrayList&lt;&gt;(cur));\n             return;\n         &#125;\n         for(int i=start;i&lt;s.length();i++)&#123;\n             String substring=s.substring(start,i+1);\n             if(isPalindrome(substring))&#123;\n                 cur.add(substring);\n                 backtrack(i+1,s);\n                 cur.remove(cur.size()-1);\n             &#125;\n         &#125;\n     &#125;\n     //判断是否为回文串\n     public  boolean isPalindrome(String s)&#123;\n         for(int i=0,j=s.length()-1;i&lt;j;i++,j--)&#123;\n             if(s.charAt(i)!=s.charAt(j)) return false;\n         &#125;\n         return true;\n     &#125;\n &#125;\n</code></pre>\n<h2 id=\"复原-IP-地址\"><a href=\"#复原-IP-地址\" class=\"headerlink\" title=\"复原 IP 地址\"></a>复原 IP 地址</h2><p><strong>有效 IP 地址</strong> 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 0），整数之间用 ‘.’ 分隔。</p>\n<ul>\n<li>例如：”0.1.2.201” 和”192.168.1.1” 是 <strong>有效</strong> IP 地址，但是 “0.011.255.245”、”192.168.1.312” 和 “<a href=\"mailto:&#49;&#57;&#50;&#x2e;&#x31;&#54;&#x38;&#x40;&#49;&#x2e;&#x31;\">&#49;&#57;&#50;&#x2e;&#x31;&#54;&#x38;&#x40;&#49;&#x2e;&#x31;</a>“ 是 <strong>无效</strong> IP 地址。</li>\n</ul>\n<p>给定一个只包含数字的字符串 s ，用以表示一个 IP 地址，返回所有可能的<strong>有效 IP 地址</strong>，这些地址可以通过在 s 中插入 ‘.’ 来形成。你 <strong>不能</strong> 重新排序或删除 s 中的任何数字。你可以按 <strong>任何</strong> 顺序返回答案。</p>\n<pre><code class=\"plain\">class Solution &#123;\n     //事实证明 结果集和当前集都放外面即可\n     List&lt;String&gt; ans=new ArrayList&lt;&gt;();\n     StringBuilder sb=new StringBuilder();\n     // List&lt;String&gt; temp=new ArrayList();\n     public List&lt;String&gt; restoreIpAddresses(String s) &#123;\n         backtrack(s,0,0);\n         return ans;\n     &#125;\n     public void backtrack(String s,int start,int sum)&#123;\n         //四个数且到头了\n         if(sum==4&amp;&amp;start==s.length())&#123;\n             ans.add(new String(sb));\n             // ans.add(String.join(&quot;.&quot;,temp));\n             return;\n         &#125;\n         //i&lt;start+3是剪支\n         for(int i=start;i&lt;start+3&amp;&amp;i&lt;s.length();i++)&#123;\n             String substring=s.substring(start,i+1);\n             if(islegal(substring))&#123;\n                 int sz = sb.length();\n                 if(sb.length()==0)&#123;\n                     sb.append(substring);\n                 &#125;else&#123;\n                     sb.append(&quot;.&quot;).append(substring);\n                 &#125;\n                 // temp.add(substring);\n                 sum+=1;\n                 backtrack(s,i+1,sum);\n                 // temp.remove(temp.size()-1);\n                 sb.delete(sz,sb.length());\n                 sum-=1;\n             &#125;\n         &#125;\n     &#125;\n     public boolean islegal(String s)&#123;\n         if(s.charAt(0)==&#39;0&#39;&amp;&amp;s.length()&gt;1) return false;\n         for(char c:s.toCharArray())&#123;\n             if(!Character.isDigit(c)) return false;\n         &#125;\n         long number=Long.parseLong(s);\n         if(number&gt;255) return false;\n         return true;\n     &#125;\n &#125;\n</code></pre>\n<h3 id=\"结果有符号问题\"><a href=\"#结果有符号问题\" class=\"headerlink\" title=\"结果有符号问题\"></a>结果有符号问题</h3><p>遇到这种需要加中间符号分割的题目 两种解决办法：</p>\n<p>第一种我的想法：</p>\n<pre><code class=\"plain\">if(sb.length()==0)&#123;\n sb.append(substring);\n &#125;else&#123;\n sb.append(&quot;.&quot;).append(substring);\n &#125;\n</code></pre>\n<p>第二种先放到一个tmp集合里面</p>\n<p>然后 </p>\n<p>  ans.add(String.join(“.”,temp));</p>\n<h3 id=\"回溯需要注意的地方\"><a href=\"#回溯需要注意的地方\" class=\"headerlink\" title=\"回溯需要注意的地方\"></a>回溯需要注意的地方</h3><p>进括号了就不用再回溯，因为进括号后，相当于我当前未作选择</p>\n<p>所以要么</p>\n<pre><code class=\"plain\">sum+=1;\n backtrack(s,i+1,sum);\n sum-=1;\n</code></pre>\n<p>要么</p>\n<p> backtrack(s,i+1,sum+1); </p>\n<p>StringBuilder回溯:</p>\n<pre><code class=\"plain\">int sz = sb.length();\n sb.delete(sz,sb.length());\n</code></pre>\n<h2 id=\"子集问题：\"><a href=\"#子集问题：\" class=\"headerlink\" title=\"子集问题：\"></a>子集问题：</h2><p>求子集问题和<a href=\"https://programmercarl.com/0077.%E7%BB%84%E5%90%88.html\">77.组合</a><a href=\"https://programmercarl.com/0077.%E7%BB%84%E5%90%88.html\">(opens new window)</a>和<a href=\"https://programmercarl.com/0131.%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2.html\">131.分割回文串</a></p>\n<p><a href=\"https://programmercarl.com/0131.%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2.html\">(opens new window)</a>又不一样了。</p>\n<p>如果把 子集问题、组合问题、分割问题都抽象为一棵树的话，<strong>那么组合问题和分割问题都是收集树的叶子节点，而子集问题是找树的所有节点！</strong></p>\n<p>其实子集也是一种组合问题，因为它的集合是无序的，子集{1,2} 和 子集{2,1}是一样的。</p>\n<p><strong>那么既然是无序，取过的元素不会重复取，写回溯算法的时候，for就要从startIndex开始，而不是从0开始！</strong></p>\n<p>什么时候for可以从0开始呢？求排列问题的时候，就要从0开始，因为集合是有序的，{1, 2} 和{2, 1}是两个集合，排列问题我们后续的文章就会讲到的。</p>\n<p>以示例中nums &#x3D; [1,2,3]为例把求子集抽象为树型结构，如下：</p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/202011232041348.png\" alt=\"img\"></p>\n<h2 id=\"子集\"><a href=\"#子集\" class=\"headerlink\" title=\"子集\"></a>子集</h2><p>给你一个整数数组 nums ，数组中的元素 <strong>互不相同</strong> 。返回该数组所有可能的子集（幂集）。</p>\n<p>解集 <strong>不能</strong> 包含重复的子集。你可以按 <strong>任意顺序</strong> 返回解集。</p>\n<pre><code class=\"plain\">class Solution &#123;\n     List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;();\n     List&lt;Integer&gt; cur = new ArrayList&lt;&gt;();\n     public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) &#123;\n         backtrack(0,nums);\n         return ans;\n     &#125;\n     public void backtrack(int start,int[] nums)&#123;\n         // 收集子集，要放在终止添加的上面，否则会漏掉自己\n         ans.add(new ArrayList&lt;Integer&gt;(cur));\n         // 下面三行可以不写 因为本来我们就要遍历整棵树。代码随想录具体有讲解\n         if(start==nums.length)&#123;\n             return;\n         &#125;\n         for(int i=start;i&lt;nums.length;i++)&#123;\n             cur.add(nums[i]);\n             backtrack(i+1,nums);\n             cur.remove(cur.size()-1);\n         &#125;\n     &#125;\n &#125;\n</code></pre>\n<h2 id=\"子集II\"><a href=\"#子集II\" class=\"headerlink\" title=\"子集II\"></a>子集II</h2><p>给你一个整数数组 nums ，其中可能包含重复元素，请你返回该数组所有可能的子集（幂集）。</p>\n<p>解集 <strong>不能</strong> 包含重复的子集。返回的解集中，子集可以按 <strong>任意顺序</strong> 排列。</p>\n<p><strong>和1不同的是要去重</strong></p>\n<pre><code class=\"plain\">class Solution &#123;\n     //Set去重\n     Set&lt;List&lt;Integer&gt;&gt; set = new HashSet&lt;&gt;();\n     List&lt;Integer&gt; cur = new ArrayList&lt;&gt;();\n     public List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(int[] nums) &#123;\n         //先排序 \n         Arrays.sort(nums);\n         backtrack(0,nums);\n         return new ArrayList(set);\n     &#125;\n     public void backtrack(int start,int[] nums)&#123;\n         // 收集子集，要放在终止添加的上面，否则会漏掉自己\n         set.add(new ArrayList&lt;Integer&gt;(cur));\n         // 下面三行可以不写 因为本来我们就要遍历整棵树。代码随想录具体有讲解\n         if(start==nums.length)&#123;\n             return;\n         &#125;\n         for(int i=start;i&lt;nums.length;i++)&#123;\n             // 另一种去重方法  \n             // if (i &gt; start &amp;&amp; nums[i] == nums[i - 1]) continue;\n             cur.add(nums[i]);\n             backtrack(i+1,nums);\n             cur.remove(cur.size()-1);\n         &#125;\n     &#125;\n &#125;\n</code></pre>\n<h2 id=\"递增子序列\"><a href=\"#递增子序列\" class=\"headerlink\" title=\"递增子序列\"></a>递增子序列</h2><p>给你一个整数数组 nums ，找出并返回所有该数组中不同的递增子序列，递增子序列中 <strong>至少有两个元素</strong> 。你可以按 <strong>任意顺序</strong> 返回答案。</p>\n<p>数组中可能含有重复元素，如出现两个整数相等，也可以视作递增序列的一种特殊情况。</p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/20201124200229824.png\" alt=\"img\"></p>\n<pre><code class=\"plain\">class Solution &#123;\n     List&lt;List&lt;Integer&gt;&gt; ans=new ArrayList&lt;&gt;();\n     List&lt;Integer&gt; cur=new ArrayList&lt;&gt;();\n     public List&lt;List&lt;Integer&gt;&gt; findSubsequences(int[] nums) &#123;\n         backtrack(nums,0);\n         return ans;\n     &#125;\n     public void backtrack(int[] nums,int start)&#123;\n         if(cur.size()&gt;=2)&#123;\n             ans.add(new ArrayList&lt;&gt;(cur));\n         &#125;\n         //记录当前层的结点  只在当前层有效  到下一层又初始化了 因此达到了去重当前层的效果\n         Set&lt;Integer&gt; seen=new HashSet&lt;&gt;();\n         for(int i=start;i&lt;nums.length;i++)&#123;\n             //先写continue的部分\n             //保证递增\n             if(cur.size()!=0&amp;&amp;nums[i]&lt;cur.get(cur.size()-1)) continue;\n             //去重   例如 446   46 46会重复 所以需要记录当前层的结点也就是第一个4取了之后 后一个4就不要取了\n             if(seen.contains(nums[i])) continue;\n             //for循环结束就无了\n             seen.add(nums[i]);\n             cur.add(nums[i]);\n             backtrack(nums,i+1);\n             cur.remove(cur.size()-1);\n             \n         &#125;\n     &#125;\n &#125;\n</code></pre>\n<h2 id=\"排列问题：\"><a href=\"#排列问题：\" class=\"headerlink\" title=\"排列问题：\"></a>排列问题：</h2><p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/20211027181706.png\" alt=\"img\"></p>\n<p>1、for循环里不用start，而用0</p>\n<p>2、出口： f (path.size() &#x3D;&#x3D; nums.size())</p>\n<p>3、使用used数组，其实就是记录此时path里都有哪些元素使用了，一个排列里一个元素只能使用一次。</p>\n<h2 id=\"全排列\"><a href=\"#全排列\" class=\"headerlink\" title=\"全排列\"></a>全排列</h2><p>给定一个不含重复数字的数组 nums ，返回其 <em>所有可能的全排列</em> 。你可以 <strong>按任意顺序</strong> 返回答案。</p>\n<pre><code class=\"plain\">class Solution &#123;\n     List&lt;List&lt;Integer&gt;&gt; ans=new ArrayList&lt;&gt;();\n     List&lt;Integer&gt; cur=new ArrayList&lt;&gt;();\n     boolean[] used;\n     public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) &#123;\n         //used数组  因为for从0开始   123 选了1递归进去防止还选1\n         used=new boolean[nums.length]; \n         backtrack(nums);\n         return ans;\n     &#125;\n     public void backtrack(int[] nums)&#123;\n         if(cur.size()==nums.length)&#123;\n             ans.add(new ArrayList&lt;&gt;(cur));\n             return;\n         &#125;\n         for(int i=0;i&lt;nums.length;i++)&#123;\n             if(used[i]==true) continue;\n             cur.add(nums[i]);\n             used[i]=true;\n             backtrack(nums);\n             used[i]=false;\n             cur.remove(cur.size()-1);\n         &#125;\n \n     &#125;\n &#125;\n</code></pre>\n<h2 id=\"全排列-II\"><a href=\"#全排列-II\" class=\"headerlink\" title=\"全排列 II\"></a>全排列 II</h2><p>给定一个可包含重复数字的序列 nums ，<em><strong>按任意顺序</strong></em> 返回所有不重复的全排列。</p>\n<pre><code class=\"plain\">class Solution &#123;\n     List&lt;List&lt;Integer&gt;&gt; ans=new ArrayList&lt;&gt;();\n     List&lt;Integer&gt; cur=new ArrayList&lt;&gt;();\n     boolean[] used;\n     public List&lt;List&lt;Integer&gt;&gt; permuteUnique(int[] nums) &#123;\n         used=new boolean[nums.length]; \n         backtrack(nums);\n         return ans;\n     &#125;\n     public void backtrack(int[] nums)&#123;\n     if(cur.size()==nums.length)&#123;\n         ans.add(new ArrayList&lt;&gt;(cur));\n         return;\n     &#125;\n     Set&lt;Integer&gt; seen=new HashSet&lt;&gt;();\n     for(int i=0;i&lt;nums.length;i++)&#123;\n         if(used[i]==true) continue;\n         //记录当前层结点 为了去重      这是含有重复元素去重的一个重要技巧\n         if(seen.contains(nums[i])) continue;\n         seen.add(nums[i]);\n         cur.add(nums[i]);\n         used[i]=true;\n         backtrack(nums);\n         used[i]=false;\n         cur.remove(cur.size()-1);\n     &#125;\n \n &#125;\n &#125;\n</code></pre>\n<h2 id=\"重新安排行程\"><a href=\"#重新安排行程\" class=\"headerlink\" title=\"重新安排行程\"></a>重新安排行程</h2><p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/image-20221115191220877.png\" alt=\"img\"></p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/2020111518065555.png\" alt=\"img\"></p>\n<pre><code class=\"plain\">class Solution &#123;\n     List&lt;String&gt; res=new ArrayList&lt;&gt;();\n     List&lt;String&gt; cur = new ArrayList&lt;&gt;();\n     boolean[] used;\n     public List&lt;String&gt; findItinerary(List&lt;List&lt;String&gt;&gt; tickets) &#123;\n         //按照字母顺序排目的地的顺序\n         Collections.sort(tickets, (a, b) -&gt; a.get(1).compareTo(b.get(1)));\n         System.out.println(tickets);\n         cur.add(&quot;JFK&quot;);\n         used = new boolean[tickets.size()];\n         backtrack(tickets);\n         return res;\n     &#125;\n     public boolean backtrack(List&lt;List&lt;String&gt;&gt; tickets) &#123;\n         //个数等于行程数+1\n         if (cur.size() == tickets.size() + 1) &#123;\n             res = new ArrayList(cur);\n             return true;\n         &#125;\n         for (int i = 0; i &lt; tickets.size(); i++) &#123;\n             // 避免反身性和保证前一个航班的到后一个航班的正确性\n             //这里不用考虑下标 因为cur已经添加了jfk\n             if (!used[i] &amp;&amp; tickets.get(i).get(0).equals(cur.get(cur.size()-1))) &#123;\n                 //当前ticket出发地和cur最后一个元素等的话就可以加\n                 cur.add(tickets.get(i).get(1));\n                 used[i] = true;\n                 //只要找到一个就Ok 相当于剪枝\n                 if (backtrack(tickets)) &#123;\n                     return true;\n                 &#125;\n                 used[i] = false;\n                 cur.remove(cur.size()-1);\n             &#125;\n         &#125;\n         return false;\n     &#125;\n &#125;\n</code></pre>\n<h2 id=\"N皇后\"><a href=\"#N皇后\" class=\"headerlink\" title=\"N皇后\"></a>N皇后</h2><p>按照国际象棋的规则，皇后可以攻击与之处在同一行或同一列或同一斜线上的棋子。</p>\n<p><strong>n 皇后问题</strong> 研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。</p>\n<p>给你一个整数 n ，返回所有不同的 <strong>n 皇后问题</strong> 的解决方案。</p>\n<p>每一种解法包含一个不同的 <strong>n 皇后问题</strong> 的棋子放置方案，该方案中 ‘Q’ 和 ‘.’ 分别代表了皇后和空位。</p>\n<p>例如：</p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/20211020232201.png\" alt=\"img\"></p>\n<p>输出：[[“.Q..”,”…Q”,”Q…”,”..Q.”],[“..Q.”,”Q…”,”…Q”,”.Q..”]]</p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/20210130182532303.jpg\" alt=\"img\"></p>\n<pre><code class=\"plain\">class Solution &#123;\n     List&lt;List&lt;String&gt;&gt; ans=new ArrayList&lt;&gt;();\n     //row行 col列\n     public List&lt;List&lt;String&gt;&gt; solveNQueens(int n) &#123;\n         char[][] board=new char[n][n];\n         //初始化\n         for(char[] c:board)&#123;\n             //数组填充\n             Arrays.fill(c,&#39;.&#39;);\n         &#125;\n         backtrack(n,0,board);\n         return ans;\n     &#125;\n     public void backtrack(int n,int row,char[][] board)&#123;\n         //出口\n         if(row==n)&#123;\n             //char[][] 转ArrayList\n             ans.add(toArrayList(board));\n             return;\n         &#125;\n         for(int col=0;col&lt;n;col++)&#123;\n             //满足条件\n             if(isValid(row,col,board,n))&#123;\n                 board[row][col]=&#39;Q&#39;;\n                 //row+1传进去就不用回溯row了\n                 backtrack(n,row+1,board);\n                 //回溯\n                 board[row][col]=&#39;.&#39;;\n             &#125;\n         &#125;\n     &#125;\n     //char转ArrayList\n     public List toArrayList(char[][] board)&#123;\n         List&lt;String&gt; list=new ArrayList&lt;&gt;();\n         for(char[] c:board)&#123;\n             list.add(String.copyValueOf(c));\n         &#125;\n         return list;\n     &#125;\n     //保证正上方   左上斜线  右上斜线  没有重复就行\n     public boolean isValid(int row,int col,char[][] board,int n)&#123;\n         //当前列正上方 \n         for(int i=0;i&lt;row;i++)&#123;\n             if(board[i][col]==&#39;Q&#39;)&#123;\n                 return false;\n             &#125;\n         &#125;\n         //左上方\n         for(int i=row-1,j=col-1;i&gt;=0&amp;&amp;j&gt;=0;i--,j--)&#123;\n             if(board[i][j]==&#39;Q&#39;)&#123;\n                 return false;\n             &#125;\n         &#125;\n         //右上方\n         for(int i=row-1,j=col+1;i&gt;=0&amp;&amp;j&lt;n;i--,j++)&#123;\n             if(board[i][j]==&#39;Q&#39;)&#123;\n                 return false;\n             &#125;\n         &#125;\n         return true;\n     &#125;\n &#125;\n</code></pre>\n<h2 id=\"解数独\"><a href=\"#解数独\" class=\"headerlink\" title=\"解数独\"></a>解数独</h2><p>编写一个程序，通过填充空格来解决数独问题。</p>\n<p>数独的解法需 <strong>遵循如下规则</strong>：</p>\n<p>数字 1-9 在每一行只能出现一次。数字 1-9 在每一列只能出现一次。数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。</p>\n<p>数独部分空格内已填入了数字，空白格用 ‘.’ 表示。</p>\n<p>1、可以理解为二维递归</p>\n<p><strong>2、为什么递归函数的返回值需要是bool类型</strong></p>\n<p>因为解数独找到一个符合的条件（就在树的叶子节点上）立刻就返回，相当于找从根节点到叶子节点一条唯一路径，所以需要使用bool返回值。</p>\n<pre><code class=\"plain\">class Solution &#123;\n     public void solveSudoku(char[][] board) &#123;\n         backrtrack(board);\n     &#125;\n     public boolean backrtrack(char[][] board)&#123;\n         for(int i=0;i&lt;9;i++)&#123;\n             for(int j=0;j&lt;9;j++)&#123;\n                 //如果不是. 跳过这个数字\n                 if(board[i][j]!=&#39;.&#39;) continue;\n                 for(char k=&#39;1&#39;;k&lt;=&#39;9&#39;;k++)&#123;\n                     //符合要求\n                     if(isValid(i,j,k,board))&#123;\n                         board[i][j]=k;\n                         //填完这个如果符合要求 那么赶紧return true;\n                         if(backrtrack(board)) return true;\n                         board[i][j]=&#39;.&#39;;\n                     &#125;\n                 &#125;\n                 //既然到这里了，说明都试了一次，且都不成功，因此返回false;\n                 return false;\n             &#125;\n         &#125;\n         //都到这里了 说明全部遍历了一次 且没有返回false 直接返回true\n         return true;\n     &#125;\n     public boolean isValid(int row,int col,char k,char[][] board)&#123;\n         //行是否符合要求 这里不能剪枝 因为后面也有原本的数字\n         for(int i=0;i&lt;9;i++)&#123;\n             if(board[row][i]==k) return false;\n         &#125;\n         //列是否符合要求\n         for(int j=0;j&lt;9;j++)&#123;\n             if(board[j][col]==k) return false;\n         &#125;\n         //算九宫格左上角的位置  row/3 前面有几个3的倍数(向下取整)\n         int startRow=(row/3)*3;\n         int startCol=(col/3)*3;\n         for(int i=startRow;i&lt;startRow+3;i++)&#123;\n             for(int j=startCol;j&lt;startCol+3;j++)&#123;\n                 if(board[i][j]==k) return false;\n             &#125;\n         &#125;\n         return true;\n     &#125;\n &#125;\n</code></pre>\n<h2 id=\"目标和\"><a href=\"#目标和\" class=\"headerlink\" title=\"目标和\"></a>目标和</h2><p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/image-20221006230012446.png\" alt=\"img\"></p>\n<pre><code class=\"plain\">class Solution &#123;\n     int count=0;\n     public int findTargetSumWays(int[] nums, int target) &#123;\n         backtrack(nums, 0, 0, target);\n         return count;\n     &#125;\n     private void backtrack(int[] nums, int i, int sum, int target)&#123;\n         //结束条件\n         if(i == nums.length)&#123;   \n             if(sum == target)&#123;\n                 count++;\n             &#125;\n             return;\n         &#125;else&#123;\n             //两个选择\n             backtrack(nums,i+1,sum+nums[i],target);\n             backtrack(nums,i+1,sum-nums[i],target);\n         &#125;\n     &#125;\n &#125;\n</code></pre>\n<p>我的理解：讲道理这个就是递归呀 相当于二叉树递归</p>\n<h2 id=\"删除无效括号\"><a href=\"#删除无效括号\" class=\"headerlink\" title=\"删除无效括号\"></a>删除无效括号</h2><p>给你一个由若干括号和字母组成的字符串 s ，删除最小数量的无效括号，使得输入的字符串有效。</p>\n<p>返回所有可能的结果。答案可以按 <strong>任意顺序</strong> 返回。</p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/image-20220926152136279.png\" alt=\"img\"></p>\n<pre><code class=\"plain\">class Solution &#123;\n     List&lt;String&gt; res=new ArrayList&lt;&gt;();\n     public List&lt;String&gt; removeInvalidParentheses(String s) &#123;\n         int lremove=0,rremove=0;\n         \n         //统计最少需要去除的左括号以及右括号\n         for(int i=0;i&lt;s.length();i++)&#123;\n             if(s.charAt(i)==&#39;(&#39;)&#123;\n                 lremove++;\n             &#125;else if(s.charAt(i)==&#39;)&#39;)&#123;//注意审题 有字母 所以 不能直接else 需要elseif 后面也是一样\n                 if(lremove==0)&#123;\n                     rremove++;\n                 &#125;else&#123;\n                     lremove--;\n                 &#125;\n             &#125;\n         &#125;\n         //进行回溯\n         backtrack(s,0,lremove,rremove);\n         return res;\n     &#125;\n     public void backtrack(String str,int start,int lremove,int rremove)&#123;\n         //结束条件\n         if(lremove==0&amp;&amp;rremove==0)&#123;\n             //判断是否有效\n             if(isValid(str))&#123;\n                 res.add(str);\n             &#125;\n             return;\n         &#125;\n         for(int i=start;i&lt;str.length();i++)&#123;\n             //剪枝 有连着重复的括号 跳过回溯 因为第一个已经回溯了 后面没必要了\n             我们在每次进行搜索时，如果遇到连续相同的括号我们只需要搜索一次即可，比如当前遇到的字符串为 &quot;(((())&quot;，去掉前四个左括号中的任意一个，生成的字符串是一样的，均为 &quot;((())&quot;，因此我们在尝试搜索时，只需去掉一个左括号进行下一轮搜索，不需要将前四个左括号都尝试一遍。\n             if(i!=start&amp;&amp;str.charAt(i)==str.charAt(i-1)) continue;\n             //剪枝 需要去除括号大于所剩长度 直接返回\n             if(lremove+rremove&gt;str.length()-i) return;\n             //去除一个(   再加上后面一个元素 下标还是i，不会改变  因此“去除(”可以理解为选择 i++即为取消选择(即老子不去除这个括号)\n             if(lremove&gt;0&amp;&amp;str.charAt(i)==&#39;(&#39;)&#123;\n                 //substring 左开右闭\n                 backtrack(str.substring(0,i)+str.substring(i+1),i,lremove-1,rremove);\n             &#125;                   \n             if(rremove&gt;0&amp;&amp;str.charAt(i)==&#39;)&#39;)&#123;\n                 backtrack(str.substring(0,i)+str.substring(i+1),i,lremove,rremove-1);\n             &#125;\n         &#125;\n \n     &#125;\n  \n     public boolean isValid(String str)&#123;\n         int cnt=0;\n         for(int i=0;i&lt;str.length();i++)&#123;\n             if(str.charAt(i)==&#39;(&#39;)&#123;\n                 cnt++;\n             &#125;else if(str.charAt(i)==&#39;)&#39;)&#123;\n                 if(cnt==0)&#123;\n                     return false;\n                 &#125;else &#123;\n                     cnt--;\n                 &#125;\n             &#125;\n         &#125;\n         return cnt==0;\n     &#125;\n &#125;\n</code></pre>\n<h2 id=\"括号匹配\"><a href=\"#括号匹配\" class=\"headerlink\" title=\"括号匹配\"></a>括号匹配</h2><p><strong>if的两个选择 括号匹配</strong></p>\n<p>![image-20220422101329099](C:\\Users\\viacheung\\OneDrive\\ZWY\u0014{��.assets\\image-20220422101329099.png)</p>\n<h2 id=\"例题3\"><a href=\"#例题3\" class=\"headerlink\" title=\"例题3\"></a>例题3</h2><pre><code class=\"plain\">vector&lt;int&gt; t;\n void dfs(int cur, int n) &#123;\n     if (cur == n) &#123;\n         // 记录答案\n         // ...\n         return;\n     &#125;\n     // 考虑选择当前位置\n     t.push_back(cur);\n     dfs(cur + 1, n, k);\n     t.pop_back();\n     // 考虑不选择当前位置\n     dfs(cur + 1, n, k);\n &#125;\n</code></pre>\n<p> ![image-20220531161347850](C:\\Users\\viacheung\\OneDrive\\ZWY\u0014{��.assets\\image-20220531161347850.png)</p>\n<h2 id=\"N-皇后-II\"><a href=\"#N-皇后-II\" class=\"headerlink\" title=\"N 皇后 II\"></a>N 皇后 II</h2><p><strong>n 皇后问题</strong> 研究的是如何将 n 个皇后放置在 n × n 的棋盘上，并且使皇后彼此之间不能相互攻击。</p>\n<p>给你一个整数 n ，返回 <strong>n 皇后问题</strong> 不同的解决方案的数量</p>\n<p>题解：和N皇后1一样 简化了 1要求解的集合，而2只求数量 也就是1是维护一个List 2是count</p>\n","categories":["算法"]},{"title":"字符串","url":"/2023/06/04/%E5%AD%97%E7%AC%A6%E4%B8%B2/","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><h3 id=\"正则表达式\"><a href=\"#正则表达式\" class=\"headerlink\" title=\"正则表达式\"></a>正则表达式</h3><p>利于记忆</p>\n<p><a href=\"https://juejin.cn/post/6844903845227659271\">https://juejin.cn/post/6844903845227659271</a></p>\n<p>可视化</p>\n<p><a href=\"https://regexper.com/\">https://regexper.com/</a></p>\n<span id=\"more\"></span>\n\n<p>String是直接+</p>\n<pre><code class=\"plain\">1、return s.substring(n, s.length()) + s.substring(0, n);\n 2、\n String res = &quot;&quot;;\n res += s.charAt(i % s.length())\n</code></pre>\n<p>StringBulider是append</p>\n<pre><code class=\"plain\">StringBuilder res = new StringBuilder();\n res.append(s.charAt(i % s.length()));\n return res.toString();\n</code></pre>\n<p>append和+的区别：</p>\n<p><strong>append</strong>:StringBuilder是可变对象，每轮遍历拼接字符时，只是向列表尾部添加一个新的字符元素。最终拼接转化为字符串时，系统 <strong>仅申请一次内存</strong> 。(√)</p>\n<p>**+**：字符串是 “不可变对象” 。因此，每轮遍历拼接字符时，都需要新建一个字符串；因此，系统 <strong>需申请 N 次内存</strong> ，数据量较大时效率低下。</p>\n<p><strong>int和字符串互转</strong></p>\n<pre><code class=\"plain\">//int-&gt;String\n String s=Integer.toString(n)\n String s=String.valueOf(n); \n //String-&gt; int\n int n=Integer.parseInt(s);\n</code></pre>\n<p><strong>字符串和字符数组转化</strong></p>\n<pre><code class=\"plain\">//char[]-&gt;String\n String s=String.valueOf(chars)\n //String-&gt;char[]\n char[] chars=s.toCharArray();\n</code></pre>\n<h2 id=\"重复的子字符串\"><a href=\"#重复的子字符串\" class=\"headerlink\" title=\"重复的子字符串\"></a>重复的子字符串</h2><p>给定一个非空的字符串 s ，检查是否可以通过由它的一个子串重复多次构成。</p>\n<p><strong>方法一：枚举</strong></p>\n<pre><code class=\"plain\">class Solution &#123;\n     public boolean repeatedSubstringPattern(String s) &#123;\n         // return (s+s).indexOf(s,1) != s.length();\n         // 如果一个长度为 n 的字符串 s 可以由它的一个长度为 n′ 的子串 s′ 重复多次构成\n         // n&#39;范围 1到n/2     且n′必须要被n整除\n         int n=s.length();\n         for(int i=1;i&lt;=n/2;i++)&#123;\n             if(n%i==0)&#123;\n                 boolean ans=true;\n                 for(int j=i;j&lt;n;j++)&#123;\n                     if(s.charAt(j)!=s.charAt(j-i))&#123;\n                         ans=false;\n                         break;\n                     &#125;\n                 &#125;\n                 if(ans) return ans;\n             &#125;\n         &#125;\n         return false;\n     &#125;\n &#125;\n</code></pre>\n<p><strong>方法二：字符串匹配</strong>（这个）</p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/image-20221023224136692.png\" alt=\"img\"></p>\n<pre><code class=\"plain\">class Solution &#123;\n     public boolean repeatedSubstringPattern(String s) &#123;\n      // (s + s).indexOf(s, 1) : 返回从 1 位置开始查找指定字符s在字符串s+s中第一次出现处的索引，如果此字符串中没有这样的字符，则返回 -1。\n         return (s + s).indexOf(s, 1) != s.length();\n     &#125;\n &#125;\n</code></pre>\n<p><strong>方法三 ： KMP</strong></p>\n<h2 id=\"28-实现-strStr\"><a href=\"#28-实现-strStr\" class=\"headerlink\" title=\"28. 实现 strStr()\"></a>28. 实现 strStr()</h2><p>给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串的第一个匹配项的下标（下标从 0 开始）。如果 needle 不是 haystack 的一部分，则返回 -1 </p>\n<p><strong>暴力</strong></p>\n<pre><code class=\"plain\">class Solution &#123;\n     public int strStr(String haystack, String needle) &#123;\n         // haystack 原串    needle匹配串\n         int h=haystack.length();\n         int n=needle.length();\n         for(int i=0;i&lt;=h-n;i++)&#123;\n             //a从0  b从i\n             int a=0,b=i;\n             while(a&lt;n &amp;&amp; haystack.charAt(b)==needle.charAt(a))&#123;\n                 a++;\n                 b++;\n             &#125;\n             //说明匹配到了\n             if(a==n) return i;\n         &#125;\n         return -1;\n     &#125;\n &#125;\n</code></pre>\n<h3 id=\"KMP\"><a href=\"#KMP\" class=\"headerlink\" title=\"KMP\"></a>KMP</h3><p>图和代码略有不符 理解即可</p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/image-20221023164358460.png\" alt=\"img\"></p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/image-20221025171752387.png\" alt=\"img\"></p>\n<p>我的理解：</p>\n<p>next数组可以理解为最长相等前缀所处的位置，j所指向的位置也可以理解为最长相等前缀所处的位置</p>\n<p>构建：首先i j所指位置如果相等， next[i] &#x3D; j，二者都向后移动，如果不相等，回退，找相等的时候再赋值，如果一直不相等，next[i] &#x3D; 0;然后i继续往后移动 </p>\n<p>匹配：和构建过程一样，不同的是1、对原串进行迭代 2、每次循环后判断j是否等于匹配串长度</p>\n<pre><code class=\"plain\">class Solution &#123;\n     public int strStr(String haystack, String needle) &#123;\n         // KMP算法：如果已经匹配的字符串包含相同的前缀和后缀，遇到下一个不匹配的位置时，指向needle的指针跳转到前缀的后一个位置，还是不匹配的话，再往前跳转后继续比较；先构造一个next数组来记录needle指针跳转的位置\n         int n=haystack.length(), m=needle.length();\n         if(m==0) return 0;\n         // 先构造next数组，next数组中的元素表示当前两个元素不匹配时，needle指针要跳转的位置\n         // haystack: [a, b, e, a, b, a, b, e, a, b, f]\n         // needle:   [a, b, e, a, b, f]\n         // next:     [0, 0, 0, 1, 2, 0]\n         我的理解 Next的意思就是如果下一个位置不匹配的话 我可以靠到位置几再进行匹配\n          int[] next = new int[m];\n         for(int i=1,j=0; i&lt;m; i++)&#123;\n               // 匹配不成功的话，j = next(j-1)\n             while(j&gt;0 &amp;&amp; needle.charAt(i)!=needle.charAt(j)) j = next[j-1]; \n            // 一直和前一位置的值比较，直到遇到相等的字符或者j=0；j通过next[j-1]来回退\n             // 匹配成功的话，先让 j++\n             if(needle.charAt(i)==needle.charAt(j)) j++;\n             // 更新 next[i]，结束本次循环，i++\n             next[i] = j;//因为i最后再移动，所以最后再更新\n         &#125;\n         // 利用next数组进行跳转匹配，不再需要回退haystack的指针i\n         for(int i=0,j=0; i&lt;n; i++)&#123;\n             // 匹配不成功，needle指针j回退并继续比较\n             while(j&gt;0 &amp;&amp; haystack.charAt(i)!=needle.charAt(j)) j = next[j-1];  \n             if(haystack.charAt(i)==needle.charAt(j)) j++;\n             //匹配成功的话，先让 j++，结束本次循环后 i++\n             // 整一段匹配成功，直接返回下标\n             if(j==m) return i - m + 1;\n         &#125;\n         return -1;\n     &#125;\n &#125;\n</code></pre>\n<h2 id=\"左旋转字符串\"><a href=\"#左旋转字符串\" class=\"headerlink\" title=\"左旋转字符串\"></a>左旋转字符串</h2><p>字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串”abcdefg”和数字2，该函数将返回左旋转两位得到的结果”cdefgab”</p>\n<p><strong>方法一：字符串切片</strong></p>\n<p> return s.substring(n, s.length()) + s.substring(0, n);</p>\n<p><strong>方法二：列表遍历拼接</strong>（若面试规定不允许使用 <strong>切片函数</strong> ，则使用此方法）</p>\n<pre><code class=\"plain\">class Solution &#123;\n     public String reverseLeftWords(String s, int n) &#123;\n         StringBuilder res = new StringBuilder();\n         for(int i = n; i &lt; n + s.length(); i++)\n             res.append(s.charAt(i % s.length()));\n         return res.toString();\n     &#125;\n &#125;//利用求余运算，可以简化代码\n</code></pre>\n<p><strong>方法三：字符串遍历拼接</strong>(不用StringBulider)</p>\n<pre><code class=\"plain\">class Solution &#123;\n     public String reverseLeftWords(String s, int n) &#123;\n         String res = &quot;&quot;;\n         for(int i = n; i &lt; s.length(); i++)\n             res += s.charAt(i);\n         for(int i = 0; i &lt; n; i++)\n             res += s.charAt(i);\n         return res;\n     &#125;\n &#125;\n</code></pre>\n<h2 id=\"翻转字符串里的单词\"><a href=\"#翻转字符串里的单词\" class=\"headerlink\" title=\"翻转字符串里的单词\"></a>翻转字符串里的单词</h2><p>split+reverse+join</p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/image-20221019213126600.png\" alt=\"img\">、</p>\n<pre><code class=\"plain\">class Solution &#123;\n     public String reverseWords(String s) &#123;\n         // 除去开头和末尾的空白字符\n         s = s.trim();\n         // 正则匹配连续的空白字符作为分隔符分割\n         List&lt;String&gt; wordList = Arrays.asList(s.split(&quot;\\\\s+&quot;));\n         Collections.reverse(wordList);\n         return String.join(&quot; &quot;, wordList);//用啥连接这些\n     &#125;\n &#125;\n</code></pre>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/image-20221019214203980.png\" alt=\"img\"></p>\n<h2 id=\"替换空格\"><a href=\"#替换空格\" class=\"headerlink\" title=\"替换空格\"></a>替换空格</h2><p>​    return s.replace(“ “, “%20”);&#x2F;&#x2F;第一种，直接api</p>\n<pre><code class=\"plain\">//第二种 循环\n class Solution &#123;\n     public String replaceSpace(String s) &#123;\n         StringBuilder sb=new StringBuilder();\n         for(char c:s.toCharArray())&#123;\n             if(c==&#39; &#39;)&#123;\n                 sb.append(&quot;%20&quot;);\n             &#125;else&#123;\n                 sb.append(c);\n             &#125;\n         &#125;\n         return sb.toString();\n     &#125;\n &#125;\n</code></pre>\n<h2 id=\"反转字符串\"><a href=\"#反转字符串\" class=\"headerlink\" title=\"反转字符串\"></a>反转字符串</h2><p>双指针：</p>\n<pre><code class=\"plain\">class Solution &#123;\n     public void reverseString(char[] s) &#123;\n         int l=0,r=s.length-1;\n         while(l&lt;r)&#123;\n             char temp=s[l];\n             s[l]=s[r];\n             s[r]=temp;\n             l++;\n             r--;\n         &#125;\n     &#125;\n &#125;\n</code></pre>\n<h2 id=\"反转字符串II\"><a href=\"#反转字符串II\" class=\"headerlink\" title=\"反转字符串II\"></a>反转字符串II</h2><p>给定一个字符串 s 和一个整数 k，从字符串开头算起，每计数至 2k 个字符，就反转这 2k 字符中的前 k 个字符。</p>\n<p>如果剩余字符少于 k 个，则将剩余字符全部反转。如果剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符，其余字符保持原样。</p>\n<pre><code class=\"plain\">class Solution &#123;\n     public String reverseStr(String s, int k) &#123;\n         char[] str=s.toCharArray();\n         for(int i=0;i&lt;s.length();i+=2*k)&#123;\n             //少于k的情况考虑了\n             reverse(str,i,Math.min(s.length()-1,i+k-1));\n         &#125;\n         return new String(str);\n     &#125;\n     public void reverse(char[] str,int l,int r)&#123;\n         while(l&lt;r)&#123;\n             char temp=str[l];\n             str[l]=str[r];\n             str[r]=temp;\n             l++;\n             r--;\n         &#125;\n     &#125;\n &#125;\n</code></pre>\n<h2 id=\"回文子串\"><a href=\"#回文子串\" class=\"headerlink\" title=\"回文子串\"></a>回文子串</h2><p>给你一个字符串 s ，请你统计并返回这个字符串中 回文子串 的数目。回文字符串 是正着读和倒过来读一样的字符串。子字符串 是字符串中的由连续字符组成的一个序列。具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。</p>\n<p>中心拓展：</p>\n<p>对于位置i,回文中心有i和(i,i+1),但最后一个元素只有i，否则越界 因此2n-1</p>\n<pre><code class=\"plain\">我对于2n-1的理解  对于位置i,回文中心有i和(i,i+1)，但是最后一个只有i没有(i,i+1),i+1越界了\n     所以是2n-1个回文中心\n class Solution &#123;\n     public int countSubstrings(String s) &#123;\n         int n = s.length();\n         int count = 0;\n         for(int i = 0; i&lt; 2*n-1; i++)&#123;\n             int l = i / 2,r = i / 2 + i % 2;//    + i % 2是为了奇偶校验\n             while(l &gt;= 0 &amp;&amp; r &lt; n &amp;&amp; s.charAt(l) == s.charAt(r))&#123;\n                 count++;\n                 l--;\n                 r++;\n             &#125;\n         &#125;\n         return count;\n     &#125;\n &#125;\n</code></pre>\n<p>dp</p>\n<pre><code class=\"plain\">class Solution &#123;\n     public int countSubstrings(String s) &#123;\n         int len, ans = 0;\n         if (s == null || (len = s.length()) &lt; 1) return 0;\n         //dp[i][j]：s字符串下标i到下标j的字串是否是一个回文串，即s[i, j]\n         boolean[][] dp = new boolean[len][len];\n         for (int j = 0; j &lt; len; j++) &#123;\n             for (int i = 0; i &lt;= j; i++) &#123;\n                 //当两端字母一样时，才可以两端收缩进一步判断\n                 if (s.charAt(i) == s.charAt(j)) &#123;\n                     //i++，j--，即两端收缩之后i,j指针指向同一个字符或者i超过j了,必然是一个回文串\n                     if (j - i &lt; 3) &#123;\n                         dp[i][j] = true;\n                     &#125; else &#123;\n                         //否则通过收缩之后的字串判断\n                         dp[i][j] = dp[i + 1][j - 1];\n                     &#125;\n                 &#125; else &#123;//两端字符不一样，不是回文串\n                     dp[i][j] = false;\n                 &#125;\n             &#125;\n         &#125;\n         //遍历每一个字串，统计回文串个数\n         for (int i = 0; i &lt; len; i++) &#123;\n             for (int j = 0; j &lt; len; j++) &#123;\n                 if (dp[i][j]) ans++;\n             &#125;\n         &#125;\n         return ans;\n     &#125;\n &#125;\n</code></pre>\n<h2 id=\"438寻找字母异位词\"><a href=\"#438寻找字母异位词\" class=\"headerlink\" title=\"438寻找字母异位词\"></a>438寻找字母异位词</h2><p>给定两个字符串 s 和 p，找到 s 中所有 p 的 异位词 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。</p>\n<p>异位词 指由相同字母重排列形成的字符串（包括相同的字符串）。</p>\n<p>思路：滑动窗口，首先维护两个数组 记录当前s要和p匹配的以及p的每种字符数量</p>\n<p>然后移动滑动窗口 每次都比较一下 equals的话即符合条件 存入结果集</p>\n<p>方法一</p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/image-20221006155802666.png\" alt=\"img\"></p>\n<pre><code class=\"plain\">class Solution &#123;\n     public List&lt;Integer&gt; findAnagrams(String s, String p) &#123;\n         int sLen = s.length(), pLen = p.length();\n         \n         if (sLen &lt; pLen) &#123;\n             return new ArrayList&lt;Integer&gt;();\n         &#125;\n         \n         List&lt;Integer&gt; ans = new ArrayList&lt;Integer&gt;();\n         int[] sCount = new int[26];\n         int[] pCount = new int[26];\n         //初始滑动窗口内记录各字母数目\n         for (int i = 0; i &lt; pLen; ++i) &#123;\n             ++sCount[s.charAt(i) - &#39;a&#39;];\n             ++pCount[p.charAt(i) - &#39;a&#39;];//这个不会变了\n         &#125;\n         //判断数组是否相等\n         if (Arrays.equals(sCount, pCount)) &#123;\n             ans.add(0);\n         &#125;\n         //左出右进 scount要变 \n         for (int i = 0; i &lt; sLen - pLen; ++i) &#123;\n             --sCount[s.charAt(i) - &#39;a&#39;];//左边出去的\n             ++sCount[s.charAt(i + pLen) - &#39;a&#39;];//右边进来的\n             //再判断\n             if (Arrays.equals(sCount, pCount)) &#123;\n                 ans.add(i + 1);\n             &#125;\n         &#125;\n \n         return ans;\n     &#125;\n &#125;\n</code></pre>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/image-20221006160224094.png\" alt=\"img\"></p>\n<pre><code class=\"plain\">class Solution &#123;\n     public List&lt;Integer&gt; findAnagrams(String s, String p) &#123;\n         int sLen = s.length(), pLen = p.length();\n \n         if (sLen &lt; pLen) &#123;\n             return new ArrayList&lt;Integer&gt;();\n         &#125;\n \n         List&lt;Integer&gt; ans = new ArrayList&lt;Integer&gt;();\n         int[] count = new int[26];\n         //初始滑动窗口\n         for (int i = 0; i &lt; pLen; ++i) &#123;\n             ++count[s.charAt(i) - &#39;a&#39;];\n             --count[p.charAt(i) - &#39;a&#39;];\n         &#125;\n         //count代表滑动窗口中每种字母的数量与字符串p中每种字母的数量差值\n         //differ代表当前窗口与p不同字母个数\n         int differ = 0;\n         for (int j = 0; j &lt; 26; ++j) &#123;\n             if (count[j] != 0) &#123;\n                 ++differ;\n             &#125;\n         &#125;\n \n         if (differ == 0) &#123;\n             ans.add(0);\n         &#125;\n \n         for (int i = 0; i &lt; sLen - pLen; ++i) &#123;\n             //因为是要去除一个元素，且count是滑动窗口里面的s减去p ，去除元素只会让count减少，因此只有1-&gt;0 或者0-&gt;-1才能让differ变化\n             if (count[s.charAt(i) - &#39;a&#39;] == 1) &#123;  //1-&gt;0  --differ\n                 --differ;\n             &#125; else if (count[s.charAt(i) - &#39;a&#39;] == 0) &#123;  //0-&gt;1   ++differ\n                 ++differ;\n             &#125;\n             --count[s.charAt(i) - &#39;a&#39;];\n             //因为是要增加一个元素，且count是滑动窗口里面的s减去p ，增加元素只会让count增加，因此只有-1-&gt;0 或者0-&gt;1才能让differ变化\n             if (count[s.charAt(i + pLen) - &#39;a&#39;] == -1) &#123;  // -1-&gt;0  --differ\n                 --differ;\n             &#125; else if (count[s.charAt(i + pLen) - &#39;a&#39;] == 0) &#123;  // 0-&gt;1   ++differ\n                 ++differ;\n             &#125;\n             ++count[s.charAt(i + pLen) - &#39;a&#39;];\n             \n             if (differ == 0) &#123;\n                 ans.add(i + 1);\n             &#125;\n         &#125;\n \n         return ans;\n     &#125;\n &#125;\n</code></pre>\n<h3 id=\"滑动窗口\"><a href=\"#滑动窗口\" class=\"headerlink\" title=\"滑动窗口\"></a>滑动窗口</h3><p>滑动窗口总结：</p>\n<p>初始化滑动窗口</p>\n<p>开始滑动</p>\n<h2 id=\"字符串解码\"><a href=\"#字符串解码\" class=\"headerlink\" title=\"字符串解码\"></a>字符串解码</h2><pre><code class=\"plain\">输入：s = &quot;3[a2[c]]&quot;\n 输出：&quot;accaccacc&quot;\n</code></pre>\n<p><strong>解法一：辅助栈法</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/image-20221001100508616.png\" alt=\"img\"></p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/ezgif-5-e7185c1cac.gif\" alt=\"img\"></p>\n<p>举例：3 [ a 2 [ c ] ] </p>\n<p>维护两个stack 前一个是数字 后一个res </p>\n<p>3：muti&#x3D;3</p>\n<p>[ : 分别把3和”” 入栈，(3,””) 并把res和muti置为空</p>\n<p>a: res&#x3D;a</p>\n<p>2: muti &#x3D;2</p>\n<p>]: 出栈，res&#x3D;””+3*res</p>\n<p>我的理解：维护一个数字栈和字母栈 左括号前把东西记录进muti和res，出现左括号就muti res清空，清空这个很秒，首先后面的括号也要用res和muti作为临时存储 ，其次我情空但是然后后面入了数字栈和字母栈 所以res依然保留着，出现右括号就计算当前括号的res </p>\n<pre><code class=\"plain\">class Solution &#123;\n     public String decodeString(String s) &#123;\n         StringBuilder res = new StringBuilder();\n         int multi = 0;\n         LinkedList&lt;Integer&gt; stack_multi = new LinkedList&lt;&gt;();\n         LinkedList&lt;String&gt; stack_res = new LinkedList&lt;&gt;();\n         for(Character c : s.toCharArray()) &#123;\n             if(c == &#39;[&#39;) &#123;\n                 stack_multi.addLast(multi);//放到尾部\n                 stack_res.addLast(res.toString());\n                 //这俩置为0和空\n                 multi = 0;\n                 res = new StringBuilder();\n             &#125;\n             else if(c == &#39;]&#39;) &#123;\n                 StringBuilder tmp = new StringBuilder();\n                 int cur_multi = stack_multi.removeLast();\n                 for(int i = 0; i &lt; cur_multi; i++) tmp.append(res);\n                 res = new StringBuilder(stack_res.removeLast() + tmp);\n             &#125;\n             else if(c &gt;= &#39;0&#39; &amp;&amp; c &lt;= &#39;9&#39;) multi = multi * 10 + Integer.parseInt(c + &quot;&quot;);//防止有连续的数字\n             else res.append(c);\n         &#125;\n         return res.toString();\n     &#125;\n &#125;\nfor(int i=0;i&lt;muti_stack.pop();i++)&#123;\n     tmp.append(res);\n &#125;\n 这样写会报错的原因是每次循环后muti_stack.pop()都会执行一次，最终导致EmptyStackException\n 正确方法是用一个变量保存它\n</code></pre>\n<h2 id=\"长按键入\"><a href=\"#长按键入\" class=\"headerlink\" title=\"长按键入\"></a>长按键入</h2><p>你的朋友正在使用键盘输入他的名字 name。偶尔，在键入字符 c 时，按键可能会被<em>长按</em>，而字符可能被输入 1 次或多次。</p>\n<p>你将会检查键盘输入的字符 typed。如果它对应的可能是你的朋友的名字（其中一些字符可能被长按），那么就返回 True。</p>\n<p>题解：模拟同时遍历两个数组，进行对比就可以了。</p>\n<pre><code class=\"plain\">class Solution &#123;\n     public boolean isLongPressedName(String name, String typed) &#123;\n         int i=0,j=0;\n         int n1=name.length();\n         int n2=typed.length();\n         while(i&lt;n1&amp;&amp;j&lt;n2)&#123;\n             // 对应字符匹配\n             if(name.charAt(i)==typed.charAt(j))&#123;\n                 i++;\n                 j++;\n             &#125;else&#123;\n                 // 如果键入字符是第一个 直接返回false\n                 if(j==0) return false;\n                 // j开始跨越重复项\n                 //这里要注意 因为如果满足条件的话 j会++ 所以j&lt;n2-1\n                 while(j&lt;n2-1&amp;&amp;typed.charAt(j)==typed.charAt(j-1))&#123;\n                     j++;\n                 &#125;\n                 // 再判断字符是否匹配\n                 if(name.charAt(i)==typed.charAt(j))&#123;\n                     i++;\n                     j++;\n                 &#125;else&#123;\n                     // 不匹配直接false\n                     return false;\n                 &#125;\n             &#125;\n         &#125;\n         // name没用完 typed到头了 必然不符合要求\n         if(i&lt;n1) return false;\n         //typed多余 那必须后面元素都要和当前j处字符一样才符合要求\n         while(j&lt;n2)&#123;\n             if(typed.charAt(j)==typed.charAt(j-1))&#123;\n                 j++;\n             &#125;else&#123;\n                 return false;\n             &#125;\n         &#125;\n         return true;\n \n         \n     &#125;\n &#125;\n</code></pre>\n<h2 id=\"比较含退格的字符串\"><a href=\"#比较含退格的字符串\" class=\"headerlink\" title=\"比较含退格的字符串\"></a>比较含退格的字符串</h2><p>给定 s 和 t 两个字符串，当它们分别被输入到空白的文本编辑器后，如果两者相等，返回 true 。# 代表退格字符。</p>\n<p><strong>注意：</strong>如果对空文本输入退格字符，文本继续为空。</p>\n<pre><code class=\"plain\">// 普通方法（使用栈的思路）\n class Solution &#123;\n     public boolean backspaceCompare(String s, String t) &#123;\n         StringBuilder ssb = new StringBuilder(); // 模拟栈\n         StringBuilder tsb = new StringBuilder(); // 模拟栈\n         // 分别处理两个 String\n         for (char c : s.toCharArray()) &#123;\n             if (c != &#39;#&#39;) &#123;\n                 ssb.append(c); // 模拟入栈\n             &#125; else if (ssb.length() &gt; 0)&#123; // 栈非空才能弹栈\n                 ssb.deleteCharAt(ssb.length() - 1); // 模拟弹栈\n             &#125;\n         &#125;\n         for (char c : t.toCharArray()) &#123;\n             if (c != &#39;#&#39;) &#123;\n                 tsb.append(c); // 模拟入栈\n             &#125; else if (tsb.length() &gt; 0)&#123; // 栈非空才能弹栈\n                 tsb.deleteCharAt(tsb.length() - 1); // 模拟弹栈\n             &#125;\n         &#125;\n         return ssb.toString().equals(tsb.toString());\n     &#125;\n &#125;\n</code></pre>\n<h2 id=\"反转字符串中的单词-III\"><a href=\"#反转字符串中的单词-III\" class=\"headerlink\" title=\"反转字符串中的单词 III\"></a>反转字符串中的单词 III</h2><p>给定一个字符串 s ，你需要反转字符串中每个单词的字符顺序，同时仍保留空格和单词的初始顺序。</p>\n<p>思路：</p>\n<p>开辟一个新字符串StringBuilder。然后从头到尾遍历原字符串，直到找到空格为止，此时找到了一个单词，并能得到单词的起止位置。随后，根据单词的起止位置，可以将该单词逆序放到新字符串当中。如此循环多次，直到遍历完原字符串，就能得到翻转后的结果。</p>\n<p>这里逆序：(i-1-j+start) 可以想象是从i-1—-0开始 所以i-1依次减去j-start（j从start到i）</p>\n<pre><code class=\"plain\">class Solution &#123;\n     public String reverseWords(String s) &#123;\n         StringBuilder sb=new StringBuilder();\n         int n=s.length();\n         int i=0;\n         while(i&lt;n)&#123;\n             int start=i;\n             while(i&lt;n&amp;&amp;s.charAt(i)!=&#39; &#39;) i++;\n             for(int j=start;j&lt;i;j++)&#123;\n                 sb.append(s.charAt(i-1-j+start));\n             &#125;\n             while(i&lt;n&amp;&amp;s.charAt(i)==&#39; &#39;)&#123;\n                 i++;\n                 sb.append(&#39; &#39;);\n             &#125;\n         &#125;\n         return sb.toString();\n     &#125;\n &#125;\n</code></pre>\n","categories":["算法"]},{"title":"图论","url":"/2023/06/04/%E5%9B%BE%E8%AE%BA/","content":"<h2 id=\"邻接矩阵\"><a href=\"#邻接矩阵\" class=\"headerlink\" title=\"邻接矩阵\"></a>邻接矩阵</h2><p><strong>无向图</strong></p>\n<p>分析1：无向图的邻接矩阵是对称的； 分析2：顶点i的度&#x3D;第i行（列）中1的个数；<strong>特别：完全图的邻接矩阵中，对角元素为0，其余1。</strong><span id=\"more\"></span></p>\n<p><a href=\"https://blog.csdn.net/diviner_s/article/details/106978910\">https://blog.csdn.net/diviner_s/article/details/106978910</a></p>\n<p><strong>有向图</strong></p>\n<p>行列出入</p>\n<p>在有向图的邻接矩阵中，第i行含义：以结点vi为尾的弧（即出度边）；第i列含义：以结点vi为头的弧（即入度边）。分析1：有向图的邻接矩阵可能是不对称的；分析2：顶点的出度 &#x3D; 第 i 行元素之和 顶点的入度 &#x3D; 第 i 列元素之和 顶点的度 &#x3D; 第 i 行元素之和 + 第 i 列元素之和</p>\n<h2 id=\"拓扑排序\"><a href=\"#拓扑排序\" class=\"headerlink\" title=\"拓扑排序\"></a>拓扑排序</h2><h3 id=\"课程表问题-待看\"><a href=\"#课程表问题-待看\" class=\"headerlink\" title=\"课程表问题(待看 )\"></a><strong>课程表问题(待看 )</strong></h3><p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/image-20220915153720951.png\" alt=\"img\"></p>\n<pre><code class=\"plain\">示例：\n输入：numCourses = 4, prerequisites = [[1,0],[2,0],[3,1],[3,2]]\n输出：[0,2,1,3]\n解释：总共有 4 门课程。要学习课程 3，你应该先完成课程 1 和课程 2。并且课程 1 和课程 2 都应该排在课程 0 之后。\n因此，一个正确的课程顺序是 [0,1,2,3] 。另一个正确的排序是 [0,2,1,3] 。\n</code></pre>\n<p><strong>拓扑排序定义</strong>：给定一个包含 n个节点的有向图 G，我们给出它的节点编号的一种排列，如果满足：对于图 G中的任意一条有向边 (u,v)，u在排列中都出现在 v的前面。</p>\n<p><strong>推导结论：</strong>1. 不可有环 2. 拓扑排序不止一种</p>\n<p><strong>解题：</strong></p>\n<p><strong>BFS</strong></p>\n<p>考虑拓扑排序中最前面的节点入度为0，它没有先修课程要求。将此节点加入答案中后，移除它的所有出边，如果某个相邻节点变成了「没有任何入边的节点」，那么就代表着这门课可以开始学习了。按照这样的流程，我们不断地将没有入边的节点加入答案，直到答案中包含所有的节点（得到了一种拓扑排序）或者不存在没有入边的节点（图中包含环）。</p>\n<p>我们使用一个队列来进行广度优先搜索。在广度优先搜索的每一步中，我们取出队首的节点 u，我们将 u 放入答案中；移除 u 的所有出边，也就是将 u的所有相邻节点的入度减少 1。如果某个相邻节点 v 的入度变为 0，那么我们就将 v放入队列中。在广度优先搜索的过程结束后。如果答案中包含了这 n 个节点，那么我们就找到了一种拓扑排序（从队列队首取出的结点构成的排序），否则说明图中存在环，也就不存在拓扑排序了。</p>\n<pre><code class=\"plain\">class Solution &#123;\n    // 存储有向图\n    List&lt;List&lt;Integer&gt;&gt; edges;\n    // 存储每个节点的入度\n    int[] indeg;\n    // 存储答案\n    int[] result;\n    // 答案下标\n    int index;\n\n    public int[] findOrder(int numCourses, int[][] prerequisites) &#123;\n        edges = new ArrayList&lt;List&lt;Integer&gt;&gt;();\n        //初始化edges，下标从0到numcourses-1\n        for (int i = 0; i &lt; numCourses; ++i) &#123;\n            edges.add(new ArrayList&lt;Integer&gt;());\n        &#125;\n        //初始化\n        indeg = new int[numCourses];\n        result = new int[numCourses];\n        index = 0;\n        //把每个Info的后面一位数当下标，前面一位数当值\n        for (int[] info : prerequisites) &#123;\n            edges.get(info[1]).add(info[0]);\n            ++indeg[info[0]];//对应入度表修改\n        &#125;\n\n        Queue&lt;Integer&gt; queue = new LinkedList&lt;Integer&gt;();\n        // 将所有入度为 0 的节点放入队列中\n        for (int i = 0; i &lt; numCourses; ++i) &#123;\n            if (indeg[i] == 0) &#123;\n                queue.offer(i);//添加到队列\n            &#125;\n        &#125;\n\n        while (!queue.isEmpty()) &#123;\n            // 从队首取出一个节点\n            int u = queue.poll();\n            // 放入答案中\n            result[index++] = u;\n            for (int v: edges.get(u)) &#123;\n                //这个结点指向的另一个结点的入度要减1\n                --indeg[v];\n                // 如果相邻节点 v 的入度为 0，就可以选 v 对应的课程了\n                if (indeg[v] == 0) &#123;\n                    queue.offer(v);\n                &#125;\n            &#125;\n        &#125;\n        //理论上课程数要和下标一致，不一致说明有环或是其他情况\n        if (index != numCourses) &#123;\n            return new int[0];\n        &#125;\n        return result;\n    &#125;\n&#125;\n</code></pre>\n<p>以前面示例作为例子，画个图理解一下</p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/image-20220915160038236.png\" alt=\"img\"></p>\n<p>这道题是课程二，让我们返回拓扑排序，课程一问题让我们返回是否能修完所有课程，无非就是return的不一样罢了。 </p>\n<p>return visited &#x3D;&#x3D; numCourses;</p>\n<p><strong>DFS</strong></p>\n<p>真不想看了，二刷的时候再说吧</p>\n<h2 id=\"钥匙和房间\"><a href=\"#钥匙和房间\" class=\"headerlink\" title=\"钥匙和房间\"></a>钥匙和房间</h2><p>有 n 个房间，房间按从 0 到 n - 1 编号。最初，除 0 号房间外的其余所有房间都被锁住。你的目标是进入所有的房间。然而，你不能在没有获得钥匙的时候进入锁住的房间。</p>\n<p>当你进入一个房间，你可能会在里面找到一套不同的钥匙，每把钥匙上都有对应的房间号，即表示钥匙可以打开的房间。你可以拿上所有钥匙去解锁其他房间。</p>\n<p>给你一个数组 rooms 其中 rooms[i] 是你进入 i 号房间可以获得的钥匙集合。如果能进入 <strong>所有</strong> 房间返回 true，否则返回 false。</p>\n<p><strong>题解：</strong></p>\n<p>有向图：</p>\n<p>深搜（DFS）或者广搜（BFS）</p>\n<ol>\n<li>确认递归函数，参数</li>\n</ol>\n<p>二维数组rooms来遍历地图 还需要一个数组，用来记录我们都走过了哪些房间</p>\n<ol>\n<li>确认终止条件</li>\n</ol>\n<p>如果我们是处理当前访问的节点，当前访问的节点如果是 true ，说明是访问过的节点，那就终止本层递归，如果不是true，我们就把它赋值为true，因为我们处理本层递归的节点。</p>\n<pre><code class=\"plain\">class Solution &#123;\n    public boolean canVisitAllRooms(List&lt;List&lt;Integer&gt;&gt; rooms) &#123;\n        int n=rooms.size();\n        List&lt;Boolean&gt; visited=new ArrayList&lt;&gt;();\n        for(int i=0;i&lt;n;i++)&#123;\n            visited.add(false);\n        &#125;\n        dfs(0,rooms,visited);\n        for(boolean flag:visited)&#123;\n            if(!flag) return false;\n        &#125;\n        return true;\n    &#125;\n    // 深度优先遍历\n    // List   下标索引：value\n    public void dfs(int key,List&lt;List&lt;Integer&gt;&gt; rooms,List&lt;Boolean&gt; visited)&#123;\n        if(visited.get(key)==true) return;\n        visited.set(key,true);\n        for(int k:rooms.get(key))&#123;\n            dfs(k,rooms,visited);\n        &#125;\n</code></pre>\n<h2 id=\"单词接龙\"><a href=\"#单词接龙\" class=\"headerlink\" title=\"单词接龙\"></a>单词接龙</h2><p>字典 wordList 中从单词 beginWord 和 endWord 的 <strong>转换序列</strong> 是一个按下述规格形成的序列 beginWord -&gt; s1 -&gt; s2 -&gt; … -&gt; sk：</p>\n<ul>\n<li>每一对相邻的单词只差一个字母。</li>\n<li>对于 1 &lt;&#x3D; i &lt;&#x3D; k 时，每个 si 都在 wordList 中。注意， beginWord 不需要在 wordList 中。</li>\n<li>sk &#x3D;&#x3D; endWord</li>\n</ul>\n<p>给你两个单词 beginWord 和 endWord 和一个字典 wordList ，返回 <em>从</em> <em>beginWord</em> <em>到</em> <em>endWord</em> <em>的</em> *<strong>最短转换序列*</strong> <em>中的</em> *<strong>单词数目*</strong> 。如果不存在这样的转换序列，返回 0 。</p>\n<p><strong>题解</strong></p>\n<p>本题只需要求出最短长度就可以了，不用找出路径。</p>\n<p>所以这道题要解决两个问题：</p>\n<ul>\n<li>图中的线是如何连在一起的</li>\n<li>起点和终点的最短路径长度</li>\n</ul>\n<p>首先题目中并没有给出点与点之间的连线，而是要我们自己去连，条件是字符只能差一个，所以判断点与点之间的关系，要自己判断是不是差一个字符，如果差一个字符，那就是有链接。</p>\n<p>然后就是求起点和终点的最短路径长度，<strong>这里无向图求最短路，广搜最为合适，广搜只要搜到了终点，那么一定是最短的路径</strong>。因为广搜就是以起点中心向四周扩散的搜索。</p>\n<p>本题如果用深搜，会比较麻烦，要在到达终点的不同路径中选则一条最短路。 而广搜只要达到终点，一定是最短路。</p>\n<p>另外需要有一个注意点：</p>\n<ul>\n<li>本题是一个无向图，需要用标记位，标记着节点是否走过，否则就会死循环！</li>\n<li>本题给出集合是数组型的，可以转成set结构，查找更快一些</li>\n</ul>\n<pre><code class=\"plain\">public int ladderLength(String beginWord, String endWord, List&lt;String&gt; wordList) &#123;\n    HashSet&lt;String&gt; wordSet = new HashSet&lt;&gt;(wordList); //转换为hashset 加快速度  便于查找单词在不在里面\n    if (wordSet.size() == 0 || !wordSet.contains(endWord)) &#123;  //特殊情况判断\n        return 0;l\n    &#125;\n    Queue&lt;String&gt; queue = new LinkedList&lt;&gt;(); //bfs 队列\n    queue.offer(beginWord);\n    Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;(); //记录beginword到该单词的转换长度\n    map.put(beginWord, 1);\n\n    while (!queue.isEmpty()) &#123;\n        String word = queue.poll(); //取出队头单词\n        int path  = map.get(word); //获取到该单词的路径长度\n        for (int i = 0; i &lt; word.length(); i++) &#123; //遍历单词的每个字符\n            char[] chars = word.toCharArray(); //将单词转换为char array，方便替换\n            for (char k = &#39;a&#39;; k &lt;= &#39;z&#39;; k++) &#123; //从&#39;a&#39; 到 &#39;z&#39; 遍历替换\n                chars[i] = k; //替换第i个字符\n                String newWord = String.valueOf(chars); //得到新的字符串\n                if (newWord.equals(endWord)) &#123;  //如果新的字符串值与endWord一致，返回当前长度+1\n                    return path + 1;\n                &#125;\n                if (wordSet.contains(newWord) &amp;&amp; !map.containsKey(newWord)) &#123; //如果新单词在set中，但是没有访问过\n                    map.put(newWord, path + 1); //记录单词对应的路径长度\n                    queue.offer(newWord);//加入队尾\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n    return 0; //未找到\n&#125;\n</code></pre>\n","categories":["算法"]},{"title":"小技巧","url":"/2023/06/04/%E5%B0%8F%E6%8A%80%E5%B7%A7/","content":"<h2 id=\"快捷键\"><a href=\"#快捷键\" class=\"headerlink\" title=\"快捷键\"></a>快捷键</h2><p>~~~java就用这个来创建代码块</p>\n<p><strong>一些变量符号</strong><span id=\"more\"></span></p>\n<p>表示数量的话用cnt</p>\n<p>flag表示标志，一般为正负</p>\n<p><strong>IDEA插件LeetEditor</strong></p>\n<p>出现cookie问题 怎么办？在idea进行插件更新！这是没想到的！</p>\n<pre><code class=\"plain\">class Solution &#123;\n    public boolean exist(char[][] board, String word) &#123;\n        int h = board.length, w = board[0].length;\n        boolean[][] visited = new boolean[h][w];\n        for (int i = 0; i &lt; h; i++) &#123;//遍历每个格子看以其开头是否可行\n            for (int j = 0; j &lt; w; j++) &#123;\n                boolean flag = check(board, visited, i, j, word, 0);\n                if (flag) &#123;\n                    return true;\n                &#125;\n            &#125;\n        &#125;\n        return false;//都不行的话才返回false\n    &#125;\npublic boolean check(char[][] board, boolean[][] visited, int i, int j, String s, int k) &#123;\n    if (board[i][j] != s.charAt(k)) &#123;\n        return false;\n    &#125; else if (k == s.length() - 1) &#123;\n        return true;\n    &#125;\n    visited[i][j] = true;\n    int[][] directions = &#123;&#123;0, 1&#125;, &#123;0, -1&#125;, &#123;1, 0&#125;, &#123;-1, 0&#125;&#125;;\n    boolean result = false;\n    for (int[] dir : directions) &#123;//做选择\n        int newi = i + dir[0], newj = j + dir[1];\n        if (newi &gt;= 0 &amp;&amp; newi &lt; board.length &amp;&amp; newj &gt;= 0 &amp;&amp; newj &lt; board[0].length) &#123;\n            if (!visited[newi][newj]) &#123;//看是否被用过\n                boolean flag = check(board, visited, newi, newj, s, k + 1);回溯 此时是在board[i][j]=s.charAt(k)的基础上，因此k+1;\n                if (flag) &#123;\n                    result = true;\n                    break;//只要有一条路径可行 直接跳过for循环 返回true\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n    visited[i][j] = false;//每一格判断完是否是可行的之后需要将其置为false，因为其他格子也要用到该格子作为路径\n    return result; 返回结果\n&#125;\n</code></pre>\n<p>}</p>\n<p><strong>求最值</strong></p>\n<p>求最大值就int maxSum &#x3D; Integer.MIN_VALUE;</p>\n<p>反之亦然</p>\n","categories":["算法"]},{"title":"多线程","url":"/2023/06/04/%E5%A4%9A%E7%BA%BF%E7%A8%8B/","content":"<h2 id=\"请简要描述线程与进程的关系-区别及优缺点？\"><a href=\"#请简要描述线程与进程的关系-区别及优缺点？\" class=\"headerlink\" title=\"请简要描述线程与进程的关系,区别及优缺点？\"></a>请简要描述线程与进程的关系,区别及优缺点？</h2><p><strong>根本区别</strong>：进程是操作系统资源分配的基本单位，而线程是处理器任务调度和执行的基本单位<span id=\"more\"></span></p>\n<p><strong>资源开销</strong>：进程独享内存空间，进程之间的切换会有较大的开销；而线程有自己独立的运行栈和程序计数器（PC），线程之间切换的开销小。</p>\n<p><strong>包含关系</strong>：线程是进程划分成更小的运行单位</p>\n<p><strong>影响关系</strong>：一个进程崩溃后，不会对其他进程产生影响，但是一个线程崩溃整个进程都死掉。所以多进程要比多线程健壮。</p>\n<h2 id=\"简述线程、程序、进程的基本概念。以及他们之间关系是什么\"><a href=\"#简述线程、程序、进程的基本概念。以及他们之间关系是什么\" class=\"headerlink\" title=\"简述线程、程序、进程的基本概念。以及他们之间关系是什么?\"></a>简述线程、程序、进程的基本概念。以及他们之间关系是什么?</h2><p>程序： 含有数据和指令的静态 文件（存在磁盘）</p>\n<p>进程：程序的一次执行过程</p>\n<p>线程：进程划分为更小的运行单位 同类的多个线程共享进程的堆和⽅法区 但每个线程有⾃⼰的程序计数器、 虚拟机栈和本地⽅法栈 </p>\n<h2 id=\"创建线程的三种方式的对比？\"><a href=\"#创建线程的三种方式的对比？\" class=\"headerlink\" title=\"创建线程的三种方式的对比？\"></a>创建线程的三种方式的对比？</h2><ul>\n<li>定义Thread类的子类，并重写该类的run方法(new完Thread,直接start)</li>\n<li>定义Runnable接口的实现类，并重写该接口的run()方法(new完Thread,再实现一个Runnable接口放到Thread里面)</li>\n<li>定义Callable接口的实现类，并重写该接口的call()方法，一般配合Future使用</li>\n<li>线程池的方式</li>\n</ul>\n<p><strong>1、采用实现Runnable. Callable接口的方式创建多线程：</strong></p>\n<p>优势：只是实现接口，还可以继承其他类，功能扩展好劣势：要访问当前线程，则必须使用Thread.currentThread()</p>\n<p><strong>Runnable和Callable的区别</strong>：</p>\n<p>1、重写方法一个run 一个call</p>\n<p>2、有无返回值 <strong>callable有</strong></p>\n<p>3、call可以抛出异常 run不可以</p>\n<p>4、运行Callable任务可以拿到一个Future对象，表示异步计算的结果</p>\n<p><strong>2、使用继承Thread类的方式创建多线程</strong>：</p>\n<p><strong>优势是：</strong></p>\n<p>如果需要访问当前线程，直接使用this即可获得当前线程。</p>\n<p><strong>劣势是：</strong></p>\n<p>已经继承了Thread类，所以不能再继承其他父类。</p>\n<h2 id=\"多线程的好处\"><a href=\"#多线程的好处\" class=\"headerlink\" title=\"多线程的好处\"></a>多线程的好处</h2><p>1、基于高并发的需求</p>\n<p>2、<strong>线程间的切换和调度的成本远远小于进程</strong></p>\n<h2 id=\"程序计数器为什么是私有的\"><a href=\"#程序计数器为什么是私有的\" class=\"headerlink\" title=\"程序计数器为什么是私有的?\"></a>程序计数器为什么是私有的?</h2><p>程序计数器记录当前线程执行位置，主要是为了线程切换后能恢复到正确的执⾏位置。 </p>\n<h2 id=\"虚拟机栈和本地⽅法栈为什么是私有的\"><a href=\"#虚拟机栈和本地⽅法栈为什么是私有的\" class=\"headerlink\" title=\"虚拟机栈和本地⽅法栈为什么是私有的?\"></a><strong>虚拟机栈和本地⽅法栈为什么是私有的?</strong></h2><p>为了保证当前线程的局部变量不被别的线程访问</p>\n<h2 id=\"⼀句话简单了解堆和⽅法区\"><a href=\"#⼀句话简单了解堆和⽅法区\" class=\"headerlink\" title=\"⼀句话简单了解堆和⽅法区\"></a>⼀句话简单了解堆和⽅法区</h2><p>堆：对象</p>\n<p>方法区：已经加载的类信息、常量、静态变量，JIT编译的代码</p>\n<h2 id=\"说说并发与并⾏的区别\"><a href=\"#说说并发与并⾏的区别\" class=\"headerlink\" title=\"说说并发与并⾏的区别?\"></a>说说并发与并⾏的区别?</h2><p>并发：一段时间</p>\n<p>并行：同一时刻</p>\n<h2 id=\"为什么要使⽤多线程呢-（而不是多进程）\"><a href=\"#为什么要使⽤多线程呢-（而不是多进程）\" class=\"headerlink\" title=\"为什么要使⽤多线程呢? （而不是多进程）\"></a>为什么要使⽤多线程呢? （而不是多进程）</h2><p>线程间切换调度成本小于进程</p>\n<p>多核时代 利用多个cpu 提高利用率</p>\n<h2 id=\"使⽤多线程可能带来什么问题\"><a href=\"#使⽤多线程可能带来什么问题\" class=\"headerlink\" title=\"使⽤多线程可能带来什么问题?\"></a>使⽤多线程可能带来什么问题?</h2><p>内存泄漏、 上下⽂切换、 死锁 。 </p>\n<h2 id=\"说说线程的⽣命周期和状态\"><a href=\"#说说线程的⽣命周期和状态\" class=\"headerlink\" title=\"说说线程的⽣命周期和状态?\"></a>说说线程的⽣命周期和状态?</h2><p>新建-可运行-运行-等待-超时等待-阻塞-中止</p>\n<h2 id=\"什么是上下⽂切换\"><a href=\"#什么是上下⽂切换\" class=\"headerlink\" title=\"什么是上下⽂切换?\"></a>什么是上下⽂切换?</h2><p>每个线程分配时间片并轮转，当前任务切换到其他线程之前需要保存自己状态，以便回来时再继续加载之前状态</p>\n<h2 id=\"线程有哪些基本状态\"><a href=\"#线程有哪些基本状态\" class=\"headerlink\" title=\"线程有哪些基本状态?\"></a>线程有哪些基本状态?</h2><p>新建</p>\n<p>可运行（就绪）</p>\n<p>运行 </p>\n<p>阻塞</p>\n<p>等待</p>\n<p>超时等待</p>\n<p>终止</p>\n<p>说下过程？</p>\n<p>notify notifyAll</p>\n<h2 id=\"什么是线程死锁-如何避免死锁\"><a href=\"#什么是线程死锁-如何避免死锁\" class=\"headerlink\" title=\"什么是线程死锁?如何避免死锁?\"></a>什么是线程死锁?如何避免死锁?</h2><p><strong>线程死锁：</strong></p>\n<p>两个或两个以上的线程在执行过程中,因争夺资源而造成的一种互相等待的现象 </p>\n<p><strong>如何避免</strong>？：<strong>1、如果自己获取不到，主动释放自己占有的资源</strong> 2、按序申请资源 反序释放</p>\n<p>破坏死锁条件：</p>\n<ol>\n<li>互斥条件：该资源任意⼀个时刻只由⼀个线程占⽤。（解决：不能破坏）</li>\n<li>请求与保持条件：⼀个进程因请求资源⽽阻塞时，对加锁资源保持不放。（一直阻塞在那里）（解决：一次性申请所有资源）</li>\n<li>不剥夺条件:线程已获得的资源在末使⽤完之前不能被其他线程强⾏剥夺，只有⾃⼰使⽤完毕（解决：<strong>如果自己获取不到，主动释放自己占有的资源</strong>）后才释放资源。（占着锁 非抢占式）</li>\n<li>循环等待条件:若⼲进程之间形成⼀种头尾相接的循环等待资源关系。（解决：按序申请资源 反序释放 ）</li>\n</ol>\n<h2 id=\"常见线程相关api对比\"><a href=\"#常见线程相关api对比\" class=\"headerlink\" title=\"常见线程相关api对比\"></a>常见线程相关api对比</h2><h3 id=\"Runnable-VS-Callable\"><a href=\"#Runnable-VS-Callable\" class=\"headerlink\" title=\"Runnable VS Callable\"></a>Runnable VS Callable</h3><ul>\n<li>Callable 接口可以返回结果或抛出检查异常</li>\n<li>Runnable 接口不会</li>\n<li>Executors 可以实现 Runnable 对象和 Callable 对象之间的相互转换</li>\n</ul>\n<h3 id=\"shutdown-VS-shutdownNow\"><a href=\"#shutdown-VS-shutdownNow\" class=\"headerlink\" title=\"shutdown() VS shutdownNow()\"></a>shutdown() VS shutdownNow()</h3><ul>\n<li>shutdown（） :关闭线程池，线程池的状态变为 SHUTDOWN。线程池不再接受新任务了，但是队列里的任务得执行完毕。</li>\n<li>shutdownNow（） :关闭线程池，线程的状态变为 STOP。线程池会终止当前正在运行的任务，并停止处理排队的任务并返回正在等待执行的 List。 shutdownNow的原理是遍历线程池中的工作线程，然后逐个调用线程的interrupt方法来中断线程，所以无法响应中断的任务可能永远无法终止</li>\n</ul>\n<h3 id=\"isTerminated-VS-isShutdown\"><a href=\"#isTerminated-VS-isShutdown\" class=\"headerlink\" title=\"isTerminated() VS isShutdown()\"></a>isTerminated() VS isShutdown()</h3><ul>\n<li>isShutDown 当调用 shutdown() 方法后返回为 true。</li>\n<li>isTerminated 当调用 shutdown() 方法后，并且所有提交的任务完成后返回为 true</li>\n</ul>\n<h2 id=\"排查死锁\"><a href=\"#排查死锁\" class=\"headerlink\" title=\"排查死锁\"></a>排查死锁</h2><p><strong>命令</strong></p>\n<p>jps -l 查看当前进程运行状况jstack 进程编号 查看该进程信息 </p>\n<p><strong>图形化</strong></p>\n<p>jconsole 打开线程 ，点击 检测死锁 </p>\n<h2 id=\"说说-sleep-⽅法和-wait-⽅法区别和共同点\"><a href=\"#说说-sleep-⽅法和-wait-⽅法区别和共同点\" class=\"headerlink\" title=\"说说 sleep() ⽅法和 wait() ⽅法区别和共同点?\"></a>说说 sleep() ⽅法和 wait() ⽅法区别和共同点?</h2><p>原理： </p>\n<ul>\n<li>sleep方法：是Thread类的静态方法，当前线程将睡眠n毫秒，线程进入阻塞状态。当睡眠时间到了，会解除阻塞，进入可运行状态，等待CPU的到来。睡眠不释放锁（如果有的话）。</li>\n<li>wait方法：是Object的方法，必须与synchronized关键字一起使用，线程进入阻塞状态，当notify或者notifyall被调用后，会解除阻塞。但是，只有重新占用互斥锁之后才会进入可运行状态。睡眠时，会释放互斥锁。</li>\n</ul>\n<p>区别：sleep() ⽅法没有释放锁，⽽ wait() ⽅法释放了锁 </p>\n<p>sleep之后自动苏醒，wait需要notify（）唤醒</p>\n<p>共同点：两者都可以暂停线程的执⾏。</p>\n<h2 id=\"为什么我们调⽤-start-⽅法时会执⾏-run-⽅法，为什么我们不能直接调⽤-run-⽅法\"><a href=\"#为什么我们调⽤-start-⽅法时会执⾏-run-⽅法，为什么我们不能直接调⽤-run-⽅法\" class=\"headerlink\" title=\"为什么我们调⽤ start() ⽅法时会执⾏ run() ⽅法，为什么我们不能直接调⽤ run() ⽅法\"></a>为什么我们调⽤ start() ⽅法时会执⾏ run() ⽅法，为什么我们不能直接调⽤ run() ⽅法</h2><p>直接调用就是main线程的一个普通方法，并不会在某个线程里面执行</p>\n<p>而new 一个 Thread，线程进入了新建状态; 调用start() ，线程进入了就绪状态，然后获得时间片就可以运行了</p>\n<h2 id=\"Thread类中的yield方法有什么作用？\"><a href=\"#Thread类中的yield方法有什么作用？\" class=\"headerlink\" title=\"Thread类中的yield方法有什么作用？\"></a>Thread类中的yield方法有什么作用？</h2><p>暂停当前正在执行的线程对象，让其它有相同优先级的线程执行。它是一个静态方法而且只保证当前线程放弃CPU占用而不能保证使其它线程一定能占用CPU，执行yield()的线程有可能在进入到暂停状态后马上又被执行（我暂停了我又回来了吼吼）。</p>\n<h2 id=\"如何创建线程实例并运行\"><a href=\"#如何创建线程实例并运行\" class=\"headerlink\" title=\"如何创建线程实例并运行\"></a>如何创建线程实例并运行</h2><ol>\n<li>创建 Thread 的子类并重写 run()</li>\n</ol>\n<p>run() 方在调用 start() 方法后被执行，而且一旦线程启动后 start() 方法后就会立即返回，而不是等到 run() 方法执行完毕后再返回。</p>\n<ol>\n<li>实现 Runnable 接口</li>\n</ol>\n<p>在新建类时实现 Runnable 接口，然后在 Thread 类的构造函数（new Thread的时候传参）中传入 MyRunnable 的实例对象，最后执行 start() 方法即可；</p>\n<h2 id=\"线程阻塞的三种情况\"><a href=\"#线程阻塞的三种情况\" class=\"headerlink\" title=\"线程阻塞的三种情况\"></a>线程阻塞的三种情况</h2><ol>\n<li><strong>等待阻塞（Object.wait -&gt; 等待队列）</strong></li>\n</ol>\n<p>RUNNING 状态的线程执行 Object.wait() 方法后，JVM 会将线程放入等待序列（waitting queue）；</p>\n<ol>\n<li><strong>同步阻塞（lock -&gt; 锁池）</strong></li>\n</ol>\n<p>RUNNING 状态的线程在获取对象的同步锁时，若该 <strong>同步锁被其他线程占用，则 JVM 将该线程放入锁池（lock pool）中</strong>；</p>\n<ol>\n<li><strong>其他阻塞（sleep&#x2F;join）</strong></li>\n</ol>\n<p>RUNNING 状态的线程执行 Thread.sleep(long ms) 或 Thread.join() 方法，或发出 I&#x2F;O 请求时，JVM 会将该线程置为阻塞状态。当 sleep() 状态超时，join() 等待线程终止或超时. 或者 I&#x2F;O 处理完毕时，线程重新转入可运行状态（RUNNABLE）；</p>\n<h2 id=\"线程死亡的三种方式\"><a href=\"#线程死亡的三种方式\" class=\"headerlink\" title=\"线程死亡的三种方式\"></a>线程死亡的三种方式</h2><ol>\n<li><strong>正常结束</strong></li>\n</ol>\n<p>run() 或者 call() 方法执行完成后，线程正常结束；</p>\n<ol>\n<li><strong>异常结束</strong></li>\n</ol>\n<p>线程抛出一个未捕获的 Exception 或 Error，导致线程异常结束；</p>\n<ol>\n<li><strong>调用 stop()</strong></li>\n</ol>\n<p>直接调用线程的 stop() 方法来结束该线程，但是一般不推荐使用该种方式，<strong>因为该方法通常容易导致死锁</strong>；</p>\n<h2 id=\"守护线程是啥？\"><a href=\"#守护线程是啥？\" class=\"headerlink\" title=\"守护线程是啥？\"></a>守护线程是啥？</h2><p>运行在后台的一种特殊进程，在 Java 中垃圾回收线程就是特殊的守护线程。</p>\n<h2 id=\"了解Fork-x2F-Join框架吗？\"><a href=\"#了解Fork-x2F-Join框架吗？\" class=\"headerlink\" title=\"了解Fork&#x2F;Join框架吗？\"></a>了解Fork&#x2F;Join框架吗？</h2><p>Java7提供 ，用于并行执行任务，把大任务分割成若干个小任务，最终汇总每个小任务结果后得到大任务结果的框架。</p>\n<p><strong>「分而治之」</strong>和<strong>「工作窃取算法」</strong>。</p>\n<p><strong>「分而治之」</strong></p>\n<p><strong>「工作窃取算法」</strong></p>\n<p>把大任务拆分成小任务，放到不同队列执行，交由不同的线程分别执行时。有的线程优先把自己负责的任务执行完了，其他线程还在慢慢悠悠处理自己的任务，这时候为了充分提高效率，就需要工作盗窃算法啦~</p>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2023/gif/226907/1684751100102-13cfdaec-0df9-4904-963b-bd1ba83c68f9.gif\" alt=\"img\"></p>\n<p>工作盗窃算法就是，<strong>「某个线程从其他队列中窃取任务进行执行的过程」</strong>。一般就是指做得快的线程（盗窃线程）抢慢的线程的任务来做，同时为了减少锁竞争，通常使用双端队列，即快线程和慢线程各在一端。</p>\n<h2 id=\"补充\"><a href=\"#补充\" class=\"headerlink\" title=\"补充\"></a>补充</h2><h3 id=\"如何保证线程安全\"><a href=\"#如何保证线程安全\" class=\"headerlink\" title=\"如何保证线程安全\"></a>如何保证线程安全</h3><p>1、原子:Atomic synchronized</p>\n<p>2、可见:synchronized volatile</p>\n<p>3、有序：</p>\n<p>synchronized lock接口</p>\n<h2 id=\"synchronized\"><a href=\"#synchronized\" class=\"headerlink\" title=\"synchronized\"></a>synchronized</h2><h3 id=\"说说-synchronized-关键字和-volatile-关键字的区别\"><a href=\"#说说-synchronized-关键字和-volatile-关键字的区别\" class=\"headerlink\" title=\"说说 synchronized 关键字和 volatile 关键字的区别\"></a>说说 synchronized 关键字和 volatile 关键字的区别</h3><p>互补 存在</p>\n<p>1、volatile 只能用于变量，syn可以变量、方法、类级别、代码块</p>\n<p>2、volatile 关键字能保证数据的可⻅性，但不能保证数据的原⼦性。 synchronized 关键字两者都能保证 </p>\n<p>3、volatile <strong>不会造成线程的阻塞</strong>；synchronized <strong>可能会造成线程的阻塞</strong>。</p>\n<p>4、volatile 关键字主要⽤于解决变量在多个线程之间的可⻅性，⽽ synchronized 关键字解决的是多个线程之间访问资源的同步性</p>\n<p>5、volatile 本质是告诉当前变量工作内存中的值是不确定的，需要从主存中读取； synchronized 则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。</p>\n<h3 id=\"synchronized-和-Lock-有什么区别？\"><a href=\"#synchronized-和-Lock-有什么区别？\" class=\"headerlink\" title=\"synchronized 和 Lock 有什么区别？\"></a>synchronized 和 Lock 有什么区别？</h3><ul>\n<li>synchronized 可以给类. 方法. 代码块加锁；而 lock 只能给代码块加锁。</li>\n<li>synchronized 不需要手动获取锁和释放锁，使用简单，发生异常会自动释放锁，不会造成死锁；而 lock 需要自己加锁和释放锁，如果使用不当没有 unLock()去释放锁就会造成死锁。</li>\n<li>通过 Lock 可以知道有没有成功获取锁，而 synchronized 却无法办到。</li>\n</ul>\n<h3 id=\"synchronized-和-ReentrantLock-区别是什么？\"><a href=\"#synchronized-和-ReentrantLock-区别是什么？\" class=\"headerlink\" title=\"synchronized 和 ReentrantLock 区别是什么？\"></a>synchronized 和 ReentrantLock 区别是什么？</h3><p><strong>相同：两者都是可重入锁</strong></p>\n<p>递归锁，指的是在一个线程中可以多次获取同一把锁，比如： 一个线程在执行一个带锁的方法，该方法中又调用了另一个需要相同锁的方法，则该线程可以直接执行调用的方法，而无需重新获得锁， 两者都是同一个线程每进入一次，锁的计数器都自增1，所以要等到锁的计数器下降为0时才能释放锁。</p>\n<p><strong>1.synchronized 依赖于 JVM 而 ReentrantLock 依赖于 jdk API</strong></p>\n<ul>\n<li>synchronized 是依赖于 JVM 实现的， 虚拟机团队在 JDK1.6 为 synchronized 关键字进行了很多优化，但是这些优化都是在虚拟机层面实现的</li>\n<li>ReentrantLock 是 JDK 层面实现的（也就是 API 层面，需要 lock() 和 unlock() 方法配合 try&#x2F;finally 语句块来完成）</li>\n</ul>\n<p><strong>2.ReentrantLock 比 synchronized 增加了一些高级功能</strong></p>\n<p>相比synchronized，ReentrantLock增加了一些高级功能。主要来说主要有三点：①等待可中断；②可实现公平锁；③可实现选择性通知（锁可以绑定多个条件）</p>\n<ul>\n<li>2.1 等待可中断.通过lock.lockInterruptibly()来实现这个机制。也就是说正在等待的线程可以选择放弃等待，改为处理其他事情。</li>\n<li>2.2 ReentrantLock可以指定是公平锁还是非公平锁。而synchronized只能是非公平锁。所谓的公平锁就是先等待的线程先获得锁。 ReentrantLock默认情况是非公平的，可以通过 ReentrantLock类的ReentrantLock(boolean fair)<strong>构造方法</strong>来制定是否是公平的。</li>\n<li>2.3 ReentrantLock类线程对象可以注册在指定的Condition中，从而可以有选择性的进行线程通知，在调度线程上更加灵活。 在使用notify()&#x2F;notifyAll()方法进行通知时，被通知的线程是由 JVM 选择的，<strong>用ReentrantLock类结合Condition实例可以实现“选择性通知”</strong></li>\n</ul>\n<p><strong>4.使用选择</strong></p>\n<ul>\n<li>除非需要使用 ReentrantLock 的高级功能，否则<strong>优先使用 synchronized。</strong></li>\n<li>synchronized 是 JVM 实现的一种锁机制，<strong>JVM 原生地支持</strong>它，而 ReentrantLock 不是所有的 JDK 版本都支持。并且使用 synchronized <strong>不用担心没有释放锁而导致死锁问题</strong>，因为 JVM 会确保锁的释放</li>\n</ul>\n<h3 id=\"synchronized的用法有哪些\"><a href=\"#synchronized的用法有哪些\" class=\"headerlink\" title=\"synchronized的用法有哪些?\"></a>synchronized的用法有哪些?</h3><ul>\n<li>修饰普通方法:作用于当前对象实例，进入同步代码前要获得当前对象实例的锁</li>\n<li>修饰静态方法:作用于当前类，进入同步代码前要获得当前类对象的锁,synchronized 关键字加到 static 静态方法和 synchronized(class)代码块上都是是给 Class 类上锁</li>\n<li>修饰代码块:指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁（里面可以写.class（类锁）也可以写this（对象锁））</li>\n</ul>\n<p>特别注意：</p>\n<p>①如果一个线程A调用一个实例对象的非静态 synchronized 方法，而线程B需要调用这个实例对象所属类的静态 synchronized 方法，是允许的，不会发生互斥现象，因为访问静态 synchronized 方法占用的锁是当前类的锁（因为加的不是一把锁）</p>\n<p>②尽量不要使用 synchronized(String s) ,因为JVM中，字符串常量池具有缓冲功能</p>\n<p>（就是说由于字符串常量池的原因不同的变量可能引用着同一个对象，锁不同变量的时候会锁成同一个对象，从而造成意料之外的同步，降低效率）</p>\n<h3 id=\"Synchronized的作用有哪些？\"><a href=\"#Synchronized的作用有哪些？\" class=\"headerlink\" title=\"Synchronized的作用有哪些？\"></a>Synchronized的作用有哪些？</h3><ol>\n<li>原子性：确保线程互斥的访问同步代码；</li>\n<li>可见性：保证共享变量的修改能够及时可见，其实是通过Java内存模型中的 “<strong>对一个变量unlock操作之前，必须要同步到主内存中；如果对一个变量进行lock操作，则将会清空工作内存中此变量的值，在执行引擎使用此变量前，需要重新从主内存中load操作或assign操作初始化变量值</strong>（lock unlock里面可能对变量有改动）” 来保证的；</li>\n<li>有序性：有效解决重排序问题，即 “一个unlock操作先行发生(happen-before)于后面对同一个锁的lock操作”。</li>\n</ol>\n<h3 id=\"说⼀说⾃⼰对于-synchronized-关键字的了解\"><a href=\"#说⼀说⾃⼰对于-synchronized-关键字的了解\" class=\"headerlink\" title=\"说⼀说⾃⼰对于 synchronized 关键字的了解\"></a>说⼀说⾃⼰对于 synchronized 关键字的了解</h3><p>属于重量级锁，效率低，线程之间的切换通过操作系统层面，需要从⽤户态转换到内核态，这俩状态之间的转换成本高</p>\n<p>1.6之后对synchronized引入大量优化，自旋 锁消除（每个线程一把锁）锁粗化（锁的都是一个对象） 偏向 轻量级锁来减少开销</p>\n<h3 id=\"单例模式了解吗？来给我⼿写⼀下！给我解释⼀下双重检验锁⽅式实现单例模式的原理呗！\"><a href=\"#单例模式了解吗？来给我⼿写⼀下！给我解释⼀下双重检验锁⽅式实现单例模式的原理呗！\" class=\"headerlink\" title=\"单例模式了解吗？来给我⼿写⼀下！给我解释⼀下双重检验锁⽅式实现单例模式的原理呗！\"></a>单例模式了解吗？来给我⼿写⼀下！给我解释⼀下双重检验锁⽅式实现单例模式的原理呗！</h3><p>两个判断：防止加锁过程对象被其他线程实例化</p>\n<p>uniqueInstance &#x3D; new Singleton(); </p>\n<p>1、分配内存空间</p>\n<p>2、初始化</p>\n<p>3、指向分配地址</p>\n<p>jvm指令重排 导致线程获得还没初始化的实例，解决办法：volatile 保证多线程无指令重排</p>\n<h3 id=\"构造⽅法可以使⽤-synchronized-关键字修饰么？\"><a href=\"#构造⽅法可以使⽤-synchronized-关键字修饰么？\" class=\"headerlink\" title=\"构造⽅法可以使⽤ synchronized 关键字修饰么？\"></a>构造⽅法可以使⽤ synchronized 关键字修饰么？</h3><p>不可</p>\n<h3 id=\"对象锁是啥？\"><a href=\"#对象锁是啥？\" class=\"headerlink\" title=\"对象锁是啥？\"></a>对象锁是啥？</h3><p>管程</p>\n<h3 id=\"什么是可重入锁\"><a href=\"#什么是可重入锁\" class=\"headerlink\" title=\"什么是可重入锁\"></a>什么是可重入锁</h3><p>同一个线程在外层方法获取锁的时候，再进入该线程的内层方法会自动获取<strong>锁</strong>(前提，锁对象得是同一个对象)，不会因为之前已经获取过还没释放而阻塞。 </p>\n<p>执行monitorenter，如果锁对象计数器0，那么说明没有被其他线程持有，jvm把该锁对象持有线程设为当前线程，当计数器不为0，如果持有线程是当前线程，jvm把计数器+1，否则等待。执行monitorexit时，Java虚拟机则需将锁对象的计数器减1。计数器为零代表锁已被释放。 </p>\n<p>ReentrantLock和synchronized都是可重入锁 （可以避免死锁）<strong>syn隐式，lock unlock显式</strong> 假如lock unlock不成对，单线程情况下问题不大，但多线程下出问题 </p>\n<h3 id=\"讲⼀下-synchronized底层\"><a href=\"#讲⼀下-synchronized底层\" class=\"headerlink\" title=\"讲⼀下 synchronized底层\"></a>讲⼀下 synchronized底层</h3><p>反编译带syn的代码块，可以看到，同步代码块开始结束位置有个monitorenter 和 monitorexit，到<strong>monitorenter</strong>这个指令时，会先尝试获取对象的锁，本质上来说，Synchronized其实是通过在对象头上设置标记，锁的计数器就会+1，而当执行到<strong>monitorexit</strong>这个指令时，锁计数器就会-1，直到减到0，这个锁也就被释放了。如果获取对象锁失败，那当前线程就要阻塞等待，直到锁被另外一个线程释放为止</p>\n<p>synchronized 修饰的方法并没有 monitorenter 指令和 monitorexit 指令，取得代之的确实是 ACC_SYNCHRONIZED 标识，该标识指明了该方法是一个同步方法，JVM 通过该 ACC_SYNCHRONIZED 访问标志来辨别一个方法是否声明为同步方法，从而执行相应的同步调用。</p>\n<h4 id=\"为什么任何一个对象都可以成为一个锁？\"><a href=\"#为什么任何一个对象都可以成为一个锁？\" class=\"headerlink\" title=\"为什么任何一个对象都可以成为一个锁？\"></a>为什么任何一个对象都可以成为一个锁？</h4><p>追溯底层可以发现<strong>每个对象天生都带着一个对象监视器</strong>： ObjectMonitor ：记录线程获取锁次数，记录哪个线程持有我</p>\n<pre><code class=\"plain\">ObjectMonitor() &#123;\n     _header       = NULL;\n     _count        = 0; // 记录个数\n     _waiters      = 0,\n     _recursions   = 0;\n     _object       = NULL;\n     _owner        = NULL;\n     _WaitSet      = NULL;  // 处于wait状态的线程，会被加入到_WaitSet\n     _WaitSetLock  = 0 ;\n     _Responsible  = NULL ;\n     _succ         = NULL ;\n     _cxq          = NULL ;\n     FreeNext      = NULL ;\n     _EntryList    = NULL ;  // 处于等待锁block状态的线程，会被加入到该列表\n     _SpinFreq     = 0 ;\n     _SpinClock    = 0 ;\n     OwnerIsThread = 0 ;\n   &#125;\n</code></pre>\n<h4 id=\"synchronized-同步语句块的情况\"><a href=\"#synchronized-同步语句块的情况\" class=\"headerlink\" title=\"synchronized 同步语句块的情况\"></a>synchronized 同步语句块的情况</h4><p>synchronized 同步语句块的实现使⽤的是 monitorenter 和 monitorexit 指令，其中monitorenter 指令指向同步代码块的开始位置， monitorexit 指令则指明同步代码块的结束位置。当执⾏ monitorenter 指令时，线程试图获取锁也就是获取 对象监视器 monitor 的持有权。</p>\n<p>moniter enter –&gt;exit</p>\n<p>objectmoniter 类owner谁持有谁记录</p>\n<h4 id=\"synchronized-修饰⽅法的的情况\"><a href=\"#synchronized-修饰⽅法的的情况\" class=\"headerlink\" title=\"synchronized 修饰⽅法的的情况\"></a>synchronized 修饰⽅法的的情况</h4><p>JVM 通过该ACC_SYNCHRONIZED (true or false)访问标志来辨别⼀个⽅法是否声明为同步⽅法，从⽽执⾏相应的同步调⽤。 </p>\n<p>为什么这俩不一样？ 我的理解：代码块里面锁可以重入 方法不可</p>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p>synchronized 同步语句块的实现使⽤的是 monitorenter 和 monitorexit 指令，其中monitorenter 指令指向同步代码块的开始位置， monitorexit 指令则指明同步代码块的结束位置。 锁的计数器为 0 1 进＋1 出 -1synchronized 修饰的⽅法并没有 monitorenter 指令和 monitorexit 指令，取得代之的确实是<strong>ACC_SYNCHRONIZED</strong> 标识，该标识指明了该⽅法是⼀个同步⽅法。不过两者的本质都是对对象监视器 monitor 的获取。</p>\n<h3 id=\"对象和moniter关联\"><a href=\"#对象和moniter关联\" class=\"headerlink\" title=\"对象和moniter关联\"></a>对象和moniter关联</h3><h3 id=\"多线程中-synchronized-锁升级的原理是什么？\"><a href=\"#多线程中-synchronized-锁升级的原理是什么？\" class=\"headerlink\" title=\"多线程中 synchronized 锁升级的原理是什么？\"></a>多线程中 synchronized 锁升级的原理是什么？</h3><h5 id=\"1、偏向锁\"><a href=\"#1、偏向锁\" class=\"headerlink\" title=\"1、偏向锁\"></a>1、偏向锁</h5><p>当一段同步代码一直被同一个线程多次访问，由于只有一个线程访问那么该线程在后续访问时便会自动获得锁。连CAS都无，（目的：防止不停的在用户态和内核态之间切换） </p>\n<p>在锁对象的对象头里面MarkWord里面存的有当前线程id，第一次进，为空，把id设为自己的，以后每次进的时候没有加锁解锁，直接会去检查锁的MarkWord里面是不是放的自己的线程ID ，是的话，直接进，无CAS，如果不一致，尝试使用CAS来替换MarkWord里面的线程ID为新线程的ID ，竞争成功，表示之前的线程不存在了，MarkWord里面的线程ID为新线程的ID，锁不会升级，仍然为偏向锁； </p>\n<h5 id=\"2、轻量级锁\"><a href=\"#2、轻量级锁\" class=\"headerlink\" title=\"2、轻量级锁\"></a>2、轻量级锁</h5><p>（续上）如果竞争失败，这时候会等待一个全局安全点，也就是没有代码执行，暂停原来持有偏向锁的线程，检查偏向锁线程是否处于代码块，处于代码块的话，升级为轻量，此时持有线程的还是之前原持有偏向锁的线程，线程B自旋等待；如果已经退出代码块了，锁设为无锁状态。 </p>\n<p>作用：有线程来参与锁的竞争，但是获取锁的冲突时间极短，本质就是自选锁CAS </p>\n<p>轻量级锁是为了在线程近乎交替执行同步块时提高性能 ，说白了先自旋，不行才升级阻塞。 </p>\n<p>若一个线程获得锁时发现是轻量级锁，会把锁的MarkWord复制到自己的Displaced Mark Word（JVM会为每个线程在 当前线程的栈帧中创建用于存储锁记录的空间 ）里面。然后线程尝试用CAS将锁的MarkWord替换为指向锁记录的指针。 <strong>总结：就是这里MarkWord存的是指问线程栈中Lock Record的指针</strong></p>\n<p>java6之后有个【自适应自选锁】：</p>\n<p>线程如果自旋成功了，那下次自旋的最大次数会增加，因为JVM认为既然上次成功了，那么这一次也很大概率会成功。反之如果很少会自旋成功，那么下次会减少自旋的次数甚至不自旋，避免CPU空转。总之，自适应意味着自选的次数不是固定不变的，而是根据：<strong>同一个锁上一次自旋的时间和拥有锁线程的状态来决定。</strong></p>\n<h5 id=\"轻量锁和偏向锁的区别和不同：\"><a href=\"#轻量锁和偏向锁的区别和不同：\" class=\"headerlink\" title=\"轻量锁和偏向锁的区别和不同：\"></a>轻量锁和偏向锁的区别和不同：</h5><ol>\n<li>争夺轻量级锁失败时，自旋尝试抢占锁</li>\n<li>轻量级锁每次退出同步块都需要释放锁，而偏向锁是在竞争发生时才释放锁</li>\n</ol>\n<h5 id=\"3、重量级锁\"><a href=\"#3、重量级锁\" class=\"headerlink\" title=\"3、重量级锁\"></a>3、重量级锁</h5><p>Java中synchronized的重量级锁，是基于进入和退出Monitor对象实现的。在编译时会将同步块的开始位置插入monitor enter指令，在结束位置插入monitor exit指令。当线程执行到monitor enter指令时，会尝试获取对象所对应的Monitor所有权，如果获取到了，即获取到了锁，会在Monitor的owner中存放当前线程的id，这样它将处于锁定状态，除非退出同步块，否则其他线程无法获取到这个Monitor </p>\n<p>锁的升级的目的：锁升级是为了减低了锁带来的性能消耗。在 Java 6 之后优化 synchronized 的实现方式，使用了偏向锁升级为轻量级锁再升级到重量级锁的方式，从而减低了锁带来的性能消耗。</p>\n<p>此时Mark Word存的是指向互斥量的指针 </p>\n<p>锁升级为轻量级或重量级锁后，Mark Word中保存的分别是线程栈帧里的锁记录指针和重量级锁指针，己经没有位置再保存哈希码，GC年龄了，那么这些信息被移动到哪里去了呢 </p>\n<h3 id=\"锁升级发生后，hashcode去哪啦\"><a href=\"#锁升级发生后，hashcode去哪啦\" class=\"headerlink\" title=\"锁升级发生后，hashcode去哪啦\"></a>锁升级发生后，hashcode去哪啦</h3><p>·1、在无锁状态下，Mark Word中可以存储对象的hashcode值。当对象的hashCode()方法第一次被调用时，JVM会生成对应的identity hash code值并将该值存储到Mark Word中。2、对于偏向锁，在线程获取偏向锁时，会用Thread ID和epoch值覆盖identity hash code所在的位置。如果一个对象的hashCode()方法己经被调用过一次之后，这个对象不能被设置偏向锁。因为如果可以的化，那Mark Word中的identity hash code必然会被偏向线程Id给覆盖，这就会造成同一个对象前后两次调用hashCode()方法得到的结果不一致。3、升级为轻量级锁时，JVM会在当前线程的栈帧中创建一个锁记录(Lock Record)空间，用于存储锁对象的Mark Word拷贝，该拷贝中可以包含identity hash code，所以轻量级锁可以和identity hashcode<strong>共存</strong>，哈希码和GC年龄自然保存在此，释放锁后会将这些信息写回到对象头。（加锁肯定没法访问啊）4、升级为重量级锁后，Mark Word保存的重量级锁指针，代表重量级锁的ObjectMonitor类里有字段记录非加锁状态下的Mark Word，锁释放后也会将信息写回到对象头。 </p>\n<h3 id=\"synchronized-为什么是非公平锁？非公平体现在哪些地方？\"><a href=\"#synchronized-为什么是非公平锁？非公平体现在哪些地方？\" class=\"headerlink\" title=\"synchronized 为什么是非公平锁？非公平体现在哪些地方？\"></a><strong>synchronized 为什么是非公平锁？非公平体现在哪些地方？</strong></h3><p>synchronized 的非公平其实在源码中应该有不少地方，因为设计者就没按公平锁来设计，核心有以下几个点：</p>\n<p>1）当持有锁的线程释放锁时，该线程会执行以下两个重要操作：</p>\n<ol>\n<li>先将锁的持有者 owner 属性赋值为 null</li>\n<li>唤醒等待链表中的一个线程（假定继承者）。</li>\n</ol>\n<p>在1和2之间，如果有其他线程刚好在尝试获取锁（例如自旋），则可以马上获取到锁。</p>\n<p>2）<strong>当线程尝试获取锁失败，进入阻塞时，放入链表的顺序，和最终被唤醒的顺序是不一致的，也就是说你先进入链表，不代表你就会先被唤醒</strong>。</p>\n<h3 id=\"JVM对synchronized的优化有哪些？\"><a href=\"#JVM对synchronized的优化有哪些？\" class=\"headerlink\" title=\"JVM对synchronized的优化有哪些？\"></a>JVM对synchronized的优化有哪些？</h3><h5 id=\"1-锁膨胀\"><a href=\"#1-锁膨胀\" class=\"headerlink\" title=\"1. 锁膨胀\"></a><strong>1. 锁膨胀</strong></h5><p>上面讲到锁有四种状态，并且会因实际情况进行膨胀升级，其膨胀方向是：<strong>无锁——&gt;偏向锁——&gt;轻量级锁——&gt;重量级锁</strong>，并且膨胀方向不可逆。</p>\n<h5 id=\"2-锁消除\"><a href=\"#2-锁消除\" class=\"headerlink\" title=\"2.锁消除\"></a>2.锁消除</h5><p>每个线程一把锁 等于没有 直接消除</p>\n<h5 id=\"3-锁粗化\"><a href=\"#3-锁粗化\" class=\"headerlink\" title=\"3.锁粗化\"></a>3.锁粗化</h5><p>锁同一个对象 合并</p>\n<p>4.<strong>自适应自旋锁</strong></p>\n<p>轻量级锁失败后，因为一个线程持有一把锁的时间并不长，切换线程不值得，因此就自旋等待</p>\n<p>自适应自旋锁属于进一步优化，它的自旋的次数不再固定，其自旋的次数由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定，这就解决了自旋锁带来的缺点。</p>\n<h3 id=\"synchronized-锁能降级吗？\"><a href=\"#synchronized-锁能降级吗？\" class=\"headerlink\" title=\"synchronized 锁能降级吗？\"></a>synchronized 锁能降级吗？</h3><p>可以的。</p>\n<p>具体的触发时机：在全局安全点（safepoint）中，执行清理任务的时候会触发尝试降级锁。</p>\n<p>当锁降级时，主要进行了以下操作：</p>\n<p>1）恢复锁对象的 markword 对象头；（哦哦 原来所说的markword都是锁对象的呀）</p>\n<p>2）重置 ObjectMonitor，然后将该 ObjectMonitor 放入全局空闲列表，等待后续使用。</p>\n<h2 id=\"中断机制\"><a href=\"#中断机制\" class=\"headerlink\" title=\"中断机制\"></a>中断机制</h2><p>一种协作协商机制 ，中断的过程完全需要程序员自己实现 </p>\n<h3 id=\"如何使用中断标识停止线程？\"><a href=\"#如何使用中断标识停止线程？\" class=\"headerlink\" title=\"如何使用中断标识停止线程？\"></a>如何使用中断标识停止线程？</h3><p>① 通过一个volatile变量实现 </p>\n<p>volatile保证了可见性，t2修改了标志位后能马上被t1看到 </p>\n<p>② 通过AtomicBoolean（原子布尔型） </p>\n<p>③ 通过Thread类自带的中断api方法实现 </p>\n<p>interrupt() ：处于正常活动状态，那么会将该线程的中断标志设置为 true 仅此而已</p>\n<p>如果线程处于被阻塞状态,在别的线程中调用当前线程对象的interrupt方法，那么线程将立即退出被阻塞状态（中断状态将被清除），并抛出一个InterruptedException异常 </p>\n<p>interrupted():1 返回当前线程的中断状态2 将当前线程的中断状态设为false </p>\n<p><strong>isinterrupt</strong> 只是判断</p>\n<h3 id=\"3种让线程等待和唤醒的方法\"><a href=\"#3种让线程等待和唤醒的方法\" class=\"headerlink\" title=\"3种让线程等待和唤醒的方法\"></a>3种让线程等待和唤醒的方法</h3><p>1、wait和notify方法必须要在同步块或者方法里面，且成对出现使用，先wait后notify才OK,顺序 </p>\n<h3 id=\"LockSupport的阻塞唤醒\"><a href=\"#LockSupport的阻塞唤醒\" class=\"headerlink\" title=\"LockSupport的阻塞唤醒\"></a>LockSupport的阻塞唤醒</h3><p>3、LockSupport用来创建锁和其他同步类的基本线程阻塞原语 ，Lock Support调用的Unsafe中的native代码 ，使用了一种名为Permit（许可） 的概念来做到阻塞和唤醒线程的功能， 每个线程都有一个许可(permit)， -permit（许可）只有两个值1和0，默认是0。0 是阻塞，1是唤醒 - 可以把许可看成是一种(0,1)信号量（Semaphore），但与 Semaphore 不同的是，许可的累加上限是1 </p>\n<p>许可证只需要一个 先 unpark 再 park无效</p>\n<h3 id=\"为什么可以突破wait-x2F-notify的原有调用顺序\"><a href=\"#为什么可以突破wait-x2F-notify的原有调用顺序\" class=\"headerlink\" title=\"为什么可以突破wait&#x2F;notify的原有调用顺序?\"></a>为什么可以突破wait&#x2F;notify的原有调用顺序?</h3><p>因为unpark获得了一个凭证， 之后再调用park方法， 就可以名正言顺的凭证消费， 故不会阻塞。 先发放了凭证后续可以畅通无阻。</p>\n<h3 id=\"为什么唤醒两次后阻塞两次，但最终结果还会阻塞线程\"><a href=\"#为什么唤醒两次后阻塞两次，但最终结果还会阻塞线程\" class=\"headerlink\" title=\"为什么唤醒两次后阻塞两次，但最终结果还会阻塞线程?\"></a>为什么唤醒两次后阻塞两次，但最终结果还会阻塞线程?</h3><p>因为凭证的数量最多为1， 连续调用两次un park和调用一次un park效果一样， 只会增加一个凭证； 而调用两次park却需要消费两个凭证， 证不够， 不能放行。 </p>\n<h2 id=\"JMM\"><a href=\"#JMM\" class=\"headerlink\" title=\"JMM\"></a>JMM</h2><h3 id=\"为什么要弄⼀个-CPU-⾼速缓存呢？\"><a href=\"#为什么要弄⼀个-CPU-⾼速缓存呢？\" class=\"headerlink\" title=\"为什么要弄⼀个 CPU ⾼速缓存呢？\"></a>为什么要弄⼀个 CPU ⾼速缓存呢？</h3><p><strong>CPU 缓存</strong> 解决 CPU 处理速度和内存处理速度不对等的问题。 </p>\n<p><strong>如何解决内存缓存不⼀致性问题？</strong></p>\n<p>通过制定缓存⼀致协议</p>\n<h3 id=\"讲⼀下-JMM-Java-内存模型\"><a href=\"#讲⼀下-JMM-Java-内存模型\" class=\"headerlink\" title=\"讲⼀下 JMM(Java 内存模型)\"></a>讲⼀下 JMM(Java 内存模型)</h3><p>每个线程都有自己的本地内存，读变量从自己内存里面，写变量，自己先改，改完刷回主存</p>\n<p>volatile 关键字 除了防⽌ JVM 的指令重排 ，还有⼀个重要的作⽤就是保证变量的可⻅性 </p>\n<p>什么是JMM？</p>\n<p>通过JMM来实现线程和主内存之间的读写关系，主要围绕三个特性展开</p>\n<p>三大特性：原子性、可见性和有序性 </p>\n<p>原子性：一个操作是不可中断 </p>\n<p>可见：当一个线程修改了某一个共享变量的值，其他线程能够立即知道该变更 普通的共享变量不保证可见性 线程间变量值的传递均需要通过主内存来完成 </p>\n<p>有序性：指令重排 如果一个操作执行的结果需要对另一个操作可见性或者代码重新排序 </p>\n<p>happens-before：明确指定了一组排序规则，来保证线程间的可见性，这个规则就是happensbefore</p>\n<p>如果一个操作happens-before另一个操作，那么<strong>第一个操作的执行结果将对第二个操作可见，</strong>而且第一个操作的执行顺序排在第二个操作之前** </p>\n<p>要想保证 B 操作能够看到 A 操作的结果（无论它们是否在同一个线程），那么 A 和 B 之间必须满足 <strong>Happens-Before 关系</strong>：</p>\n<ul>\n<li><strong>单线程规则</strong>：一个线程中的每个动作都 happens-before 该线程中后续的每个动作</li>\n<li><strong>监视器锁定规则</strong>：监听器的<strong>解锁</strong>动作 happens-before 后续对这个监听器的<strong>锁定</strong>动作 (unlock lock)</li>\n<li><strong>volatile 变量规则</strong>：对 volatile 字段的写入动作 happens-before 后续对这个字段的每个读取动作</li>\n<li><strong>线程 start 规则</strong>：线程 <strong>start()</strong> 方法的执行 happens-before 一个启动线程内的任意动作</li>\n<li><strong>线程 join 规则</strong>：一个线程内的所有动作 happens-before 任意其他线程在该线程 <strong>join()</strong> 成功返回之前</li>\n<li><strong>传递性</strong>：如果 A happens-before B, 且 B happens-before C, 那么 A happens-before C</li>\n</ul>\n<p>八条原则：1次序（unlock lock） 2传递 3线程启动（先写再读） （先start） 4 线程中断规则 (先interrupt() ，再Thread.interrupted()检测中断 ) 5线程终止规则(线程中的所有操作都先行发生于对此线程的终止检测 ) 6对象终结规则 （对象初始化先于finalize）</p>\n<p><strong>Java 内存模型描述的是多线程对共享内存修改后彼此之间的可见性</strong></p>\n<h2 id=\"volatile\"><a href=\"#volatile\" class=\"headerlink\" title=\"volatile\"></a>volatile</h2><p>volatile只能保证可见性和有序性 </p>\n<h3 id=\"为什么volatile可以实现这些功能呢？-内存屏障\"><a href=\"#为什么volatile可以实现这些功能呢？-内存屏障\" class=\"headerlink\" title=\"为什么volatile可以实现这些功能呢？(内存屏障)\"></a>为什么volatile可以实现这些功能呢？(内存屏障)</h3><p>底层就是内存屏障 ,使得之前的所有读写操作都执行后才可以开始执行此点之后的操作 JVM指令 </p>\n<p>写指令后加store屏障 读指令前加load屏障</p>\n<p>内存屏障之前的所有写操作都要回写到主内存， 内存屏障之后的所有读操作都能获得内存屏障之前的所有写操作的最新结果(实现了可见性)。 </p>\n<h3 id=\"内存屏障能干嘛？\"><a href=\"#内存屏障能干嘛？\" class=\"headerlink\" title=\"内存屏障能干嘛？\"></a>内存屏障能干嘛？</h3><h3 id=\"volatile的内存语义\"><a href=\"#volatile的内存语义\" class=\"headerlink\" title=\"volatile的内存语义\"></a>volatile的内存语义</h3><p>volatile的写内存语义是直接刷新到主内存中，读的内存语义是直接从主内存中读取。一句话，volatile修饰的变量在某个工作内存修改后立刻会刷新会主内存，并把其他工作内存的该变量设置为无效。 </p>\n<h3 id=\"读屏障和写屏障\"><a href=\"#读屏障和写屏障\" class=\"headerlink\" title=\"读屏障和写屏障\"></a>读屏障和写屏障</h3><p>写屏障：把存储在缓存的数据写回主内存 写屏障之前的写指令全部执行后面指令才能执行</p>\n<p>读屏障：之后的读操作都需要在读屏障之后操作 保证读最新</p>\n<p>我先写 你们后面先别读</p>\n<p>隔断！我重新读主存</p>\n<h3 id=\"happens-before之volatile变量规则\"><a href=\"#happens-before之volatile变量规则\" class=\"headerlink\" title=\"happens-before之volatile变量规则\"></a>happens-before之volatile变量规则</h3><p>1读2写</p>\n<h3 id=\"为什么volatile不能保证原子性\"><a href=\"#为什么volatile不能保证原子性\" class=\"headerlink\" title=\"为什么volatile不能保证原子性\"></a>为什么volatile不能保证原子性</h3><p>i++</p>\n<p>大家一起读，一起加一，就看谁提交的快了。提交快的直接让另一个计算失效</p>\n<p>比如说你在计算的时候，别的线程已经提交了，所以你的计算直接失效了 </p>\n<p>本来是6 变成5</p>\n<p>总结：第二个线程在第一个线程读取旧值和写回新值期间读取i的阈值，也就造成了线程安全问题 </p>\n<h3 id=\"内存屏障的四大指令\"><a href=\"#内存屏障的四大指令\" class=\"headerlink\" title=\"内存屏障的四大指令\"></a>内存屏障的四大指令</h3><p>读屏障在每个volatile读操作的后面插入一个LoadLoad屏障在每个volatile读操作的后面插入一个LoadStore屏障 </p>\n<p>写屏障在每个volatile写操作的前面插入一个StoreStore屏障在每个volatile写操作的后面插入一个StoreLoad屏障 </p>\n<h3 id=\"说说-synchronized-关键字和-volatile-关键字的区别-1\"><a href=\"#说说-synchronized-关键字和-volatile-关键字的区别-1\" class=\"headerlink\" title=\"说说 synchronized 关键字和 volatile 关键字的区别\"></a>说说 synchronized 关键字和 volatile 关键字的区别</h3><p>互补 存在</p>\n<p>1、volatile 只能用于变量，syn可以变量、方法、类级别、代码块</p>\n<p>2、volatile 关键字能保证数据的可⻅性，但不能保证数据的原⼦性。 synchronized 关键字两者都能保证 </p>\n<p>3、volatile <strong>不会造成线程的阻塞</strong>；synchronized <strong>可能会造成线程的阻塞</strong>。</p>\n<p>4、volatile 关键字主要⽤于解决变量在多个线程之间的可⻅性，⽽ synchronized 关键字解决的是多个线程之间访问资源的同步性</p>\n<p>5、volatile 本质是告诉当前变量工作内存中的值是不确定的，需要从主存中读取； synchronized 则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。</p>\n<h3 id=\"策略\"><a href=\"#策略\" class=\"headerlink\" title=\"策略\"></a>策略</h3><p>是读用volatile，写用synchronized可以提高性能 </p>\n<h3 id=\"案例\"><a href=\"#案例\" class=\"headerlink\" title=\"案例\"></a>案例</h3><p>DCL双锁案例 多线程指令重排 new 一个对象 空间–对象 –对象指向空间 解决：volatile</p>\n<h3 id=\"凭什么我们java写了一个volatile关键字系统底层加入内存屏障？两者关系怎么勾搭上的？\"><a href=\"#凭什么我们java写了一个volatile关键字系统底层加入内存屏障？两者关系怎么勾搭上的？\" class=\"headerlink\" title=\"凭什么我们java写了一个volatile关键字系统底层加入内存屏障？两者关系怎么勾搭上的？\"></a>凭什么我们java写了一个volatile关键字系统底层加入内存屏障？两者关系怎么勾搭上的？</h3><p>字节码层面javap -c xx.class它其实添加了一个<strong>ACC_VOLATILE</strong></p>\n<h2 id=\"CAS\"><a href=\"#CAS\" class=\"headerlink\" title=\"CAS\"></a>CAS</h2><h3 id=\"cas原理\"><a href=\"#cas原理\" class=\"headerlink\" title=\"cas原理\"></a>cas原理</h3><p>CAS （CompareAndSwap） CAS有3个操作数，位置内存值V，旧的预期值A，要修改的更新值B。 当且仅当旧的预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做或重来*当它重来重试的这种行为成为—自旋（do while）！ </p>\n<h3 id=\"硬件级别保证\"><a href=\"#硬件级别保证\" class=\"headerlink\" title=\"硬件级别保证\"></a>硬件级别保证</h3><p>对总线加锁，效率比synchronized效率高 </p>\n<p>JDK提供的非阻塞原子性操作 <strong>Unsafe<strong><strong>提供的</strong></strong>CAS方法</strong>&#96;（如compareAndSwapXXX）底层实现即为CPU指令cmpxchg。</p>\n<p><strong>CAS cpu并发原语</strong> 原子操作</p>\n<p>AtomicInteger 类主要利用CAS (compare and swap) + volatile和 native 方法来保证原子操作，从而避免 synchronized 的高开销，执行效率大为提升。 </p>\n<p>执行cmpxchg指令的时候，会判断当前系统是否为多核系统，如果是就<strong>给总线加锁* *，</strong>只有一个<em>线程会对总线加锁<strong>成功</strong>，加锁成功之后会执行cas操作，也就是说CAS的原子性实际上是**CPU实现的</em></p>\n<h3 id=\"unsafe\"><a href=\"#unsafe\" class=\"headerlink\" title=\"unsafe\"></a>unsafe</h3><p>Unsafe类中的方法都直接调用操作系统底层资源执行相应任务 </p>\n<h3 id=\"自旋锁\"><a href=\"#自旋锁\" class=\"headerlink\" title=\"自旋锁\"></a>自旋锁</h3><p>尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试*获取锁 </p>\n<h3 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h3><p><strong>1. ABA 问题</strong></p>\n<p>并发环境下，假设初始条件是A，去修改数据时，发现是A就会执行修改。但是看到的虽然是A，中间可能发生了A变B，B又变回A的情况。此时A已经非彼A，数据即使成功修改，也可能有问题。</p>\n<p>1、时间戳 2、版本号</p>\n<p>可以通过AtomicStampedReference<strong>解决ABA问题</strong>，它，一个带有标记的原子引用类，通过控制变量值的版本来保证CAS的正确性。</p>\n<p><strong>2. 循环时间长开销</strong></p>\n<p>自旋CAS，如果一直循环执行，一直不成功，会给CPU带来非常大的执行开销。</p>\n<p>很多时候，CAS思想体现，是有个自旋次数的，就是为了避开这个耗时问题~</p>\n<p><strong>3. 只能保证一个变量的原子操作。</strong></p>\n<p>CAS 保证的是对一个变量执行操作的原子性，如果对多个变量操作时，CAS 目前无法直接保证操作的原子性的。</p>\n<p><strong>可以通过这两个方式解决这个问题</strong>：</p>\n<ul>\n<li>使用互斥锁来保证原子性；</li>\n<li>将多个变量封装成对象，通过AtomicReference来保证原子性。</li>\n</ul>\n<h2 id=\"ThreadLocal\"><a href=\"#ThreadLocal\" class=\"headerlink\" title=\"ThreadLocal\"></a>ThreadLocal</h2><p>ThreadLocal，即线程本地变量。如果你创建了一个ThreadLocal变量，那么访问这个变量的每个线程都会有这个变量的一个本地拷贝，多个线程操作这个变量的时候，实际是操作自己本地内存里面的变量，从而起到线程隔离的作用，避免了线程安全问题。</p>\n<p><strong>ThreadLocal的应用场景有</strong></p>\n<ul>\n<li>数据库连接池</li>\n<li>会话管理中使用</li>\n</ul>\n<h3 id=\"ThreadLocal-了解么？\"><a href=\"#ThreadLocal-了解么？\" class=\"headerlink\" title=\"ThreadLocal 了解么？\"></a>ThreadLocal 了解么？</h3><ul>\n<li>Thread类有一个类型为ThreadLocal.ThreadLocalMap的实例变量threadLocals，即每个线程都有一个属于自己的ThreadLocalMap。</li>\n</ul>\n<p>每⼀个线程都有⾃⼰的专属本地变量</p>\n<p>可以使⽤ get 和 set ⽅法来获取默认值或将其值更改为当前线程所存的副本的值</p>\n<p>最终变量存在ThreadLocalMap 中，key 为当前对象的 Thread 对象，值为 Object 对象 （ThreadLocalMap 是 ThreadLocal 的静态内部类。 ）</p>\n<h3 id=\"ThreadLocal-内存泄露问题了解不？\"><a href=\"#ThreadLocal-内存泄露问题了解不？\" class=\"headerlink\" title=\"ThreadLocal 内存泄露问题了解不？\"></a>ThreadLocal 内存泄露问题了解不？</h3><p>ThreadLocalMap 中使⽤的 key 为 ThreadLocal 的弱引⽤,⽽ value 是强引⽤。 </p>\n<p>GC的时候，key变成Null，value无了，ThreadLocalMap 实现中已经考虑了这种情况，在调⽤ set() 、 get() 、 remove() ⽅法的时候，会清理掉 key 为 null的记录。使⽤完 ThreadLocal ⽅法后 最好⼿动调⽤ remove() ⽅法 最好需要手动调用remove方法。</p>\n<h2 id=\"ReentrantLock\"><a href=\"#ReentrantLock\" class=\"headerlink\" title=\"ReentrantLock\"></a>ReentrantLock</h2><h3 id=\"了解ReentrantLock吗？\"><a href=\"#了解ReentrantLock吗？\" class=\"headerlink\" title=\"了解ReentrantLock吗？\"></a>了解ReentrantLock吗？</h3><p>ReetrantLock是一个可重入的独占锁，主要有两个特性，一个是支持公平锁和非公平锁，一个是可重入。 ReetrantLock实现依赖于AQS(AbstractQueuedSynchronizer)。</p>\n<p>ReetrantLock主要依靠AQS维护一个阻塞队列，多个线程对加锁时，失败则会进入阻塞队列。等待唤醒，重新尝试加锁。</p>\n<h3 id=\"ReadWriteLock是什么？\"><a href=\"#ReadWriteLock是什么？\" class=\"headerlink\" title=\"ReadWriteLock是什么？\"></a>ReadWriteLock是什么？</h3><p><strong>一句话 读读不影响</strong></p>\n<p>首先ReentrantLock某些时候有局限，如果使用ReentrantLock，可能本身是为了防止线程A在写数据、线程B在读数据造成的数据不一致，但这样，如果线程C在读数据、线程D也在读数据，读数据是不会改变数据的，没有必要加锁，但是还是加锁了，降低了程序的性能。</p>\n<p>因为这个，才诞生了读写锁ReadWriteLock。ReadWriteLock是一个读写锁接口，ReentrantReadWriteLock是ReadWriteLock接口的一个具体实现，实现了读写的分离，读锁是共享的，写锁是独占的，读和读之间不会互斥，读和写、写和读、写和写之间才会互斥，提升了读写的性能</p>\n<h3 id=\"为什么要⽤线程池？\"><a href=\"#为什么要⽤线程池？\" class=\"headerlink\" title=\"为什么要⽤线程池？\"></a>为什么要⽤线程池？</h3><p>（线程池、数据库连接池、 Http 连接池 ）</p>\n<p>主要是为了减少每次获取资源的消耗，提⾼对资源的利⽤率。 </p>\n<p>1、降低资源消耗：服用线程</p>\n<p>2、提高速度：任务来的时候不用创建直接执行</p>\n<p>3、使⽤线程池可以进⾏统⼀的分配，调优和监控。 </p>\n<h2 id=\"Atomic\"><a href=\"#Atomic\" class=\"headerlink\" title=\"Atomic\"></a>Atomic</h2><h3 id=\"介绍⼀下-Atomic-原⼦类\"><a href=\"#介绍⼀下-Atomic-原⼦类\" class=\"headerlink\" title=\"介绍⼀下 Atomic 原⼦类\"></a>介绍⼀下 Atomic 原⼦类</h3><p>具有原⼦&#x2F;原⼦操作特征的类 </p>\n<h3 id=\"JUC-包中的原⼦类是哪-4-类\"><a href=\"#JUC-包中的原⼦类是哪-4-类\" class=\"headerlink\" title=\"JUC 包中的原⼦类是哪 4 类?\"></a>JUC 包中的原⼦类是哪 4 类?</h3><p>4个类型 基本 数组 引用 属性修改</p>\n<p>基本：Integer Long Boolean </p>\n<p>数组： 后面加个Array</p>\n<p>引用：去掉基本类型 加reference stampleReference </p>\n<p>属性修改：基本后面加FileldUpdater</p>\n<h3 id=\"基本类型\"><a href=\"#基本类型\" class=\"headerlink\" title=\"基本类型\"></a>基本类型</h3><p>AtomicInteger ：整形原⼦类AtomicLong ：⻓整型原⼦类AtomicBoolean ：布尔型原⼦类 </p>\n<h3 id=\"数组类型\"><a href=\"#数组类型\" class=\"headerlink\" title=\"数组类型\"></a>数组类型</h3><p>使⽤原⼦的⽅式更新数组⾥的某个元素AtomicIntegerArray ：整形数组原⼦类AtomicLongArray ：⻓整形数组原⼦类AtomicReferenceArray ：引⽤类型数组原⼦类</p>\n<h3 id=\"引⽤类型\"><a href=\"#引⽤类型\" class=\"headerlink\" title=\"引⽤类型\"></a>引⽤类型</h3><p>AtomicReference ：引⽤类型原⼦类AtomicStampedReference ：原⼦更新<strong>带有版本号</strong>的引⽤类型。该类将整数值与引⽤关联起来，可⽤于解决原⼦的更新数据和数据的版本号，可以解决使⽤ CAS 进⾏原⼦更新时可能出现的 ABA 问题。AtomicMarkableReference ：原⼦更新带有标记位的引⽤类型</p>\n<h3 id=\"对象的属性修改类型\"><a href=\"#对象的属性修改类型\" class=\"headerlink\" title=\"对象的属性修改类型\"></a>对象的属性修改类型</h3><p>AtomicIntegerFieldUpdater ：原⼦更新整形字段的更新器AtomicLongFieldUpdater ：原⼦更新⻓整形字段的更新器AtomicReferenceFieldUpdater ：原⼦更新引⽤类型字段的更新器 </p>\n<h3 id=\"Longadder\"><a href=\"#Longadder\" class=\"headerlink\" title=\"Longadder\"></a>Longadder</h3><p><strong>AtomicLong</strong>线程安全，可允许一些性能损耗，要求高精度时可使用AtomicLong是多个线程针对单个热点值value进行原子操作<strong>LongAdder</strong>当需要在高并发下有较好的性能表现，且对值的精确度要求不高时，可以使用保证性能，精度代价LongAdder是每个线程拥有自己的槽，各个线程一般只对自己槽中的那个值进行CAS操作<strong>小总结****AtomicLong</strong>原理:CAS+自旋incrementAndGet场景:低并发下的全局计算AtomicLong能保证并发情况下计数的准确性，其内部通过<strong>CAS</strong>来解决并发安全性的问题缺陷高并发后性能急剧下降why?AtomicLong的自旋会称为瓶颈（N个线程CAS操作修改线程的值，每次只有一个成功过，其它N -1失败，失败的不停的自旋直到成功，这样大量失败自旋的情况，一下子cpu就打高了。）<strong>LongAdder</strong>原理CAS+Base+Cell数组分散空间换时间并分散了热点数据场景高并发的全局计算缺陷sum求和后还有计算线程修改结果的话，最后结果不够准确</p>\n<h2 id=\"AQS\"><a href=\"#AQS\" class=\"headerlink\" title=\"AQS\"></a>AQS</h2><h3 id=\"AQS-了解么？\"><a href=\"#AQS-了解么？\" class=\"headerlink\" title=\"AQS 了解么？\"></a>AQS 了解么？</h3><p>AbstractQueuedSynchronizer </p>\n<p>AbstractQueuedSynchronizer(AQS)提供了一套可用于实现锁同步机制的框架，不夸张地说，AQS是JUC同步框架的基石。AQS通过一个FIFO队列维护线程同步状态，实现类只需要继承该类，并重写指定方法即可实现一套线程同步机制。</p>\n<p>AQS根据资源互斥级别提供了<strong>独占和共享</strong>两种资源访问模式；同时其定义Condition结构提供了wait&#x2F;signal等待唤醒机制。在JUC中，诸如ReentrantLock、CountDownLatch等都基于AQS实现。</p>\n<p>抽象（基石）队列Queue（）同步器</p>\n<h3 id=\"AQS原理概况\"><a href=\"#AQS原理概况\" class=\"headerlink\" title=\"AQS原理概况\"></a>AQS原理概况</h3><p>如果当前线程访问的资源空闲，将线程设置为有效工作线程，否则需要一套线程阻塞等待唤醒的机制，这个机制是由CLH队列（双向队列）实现的，即将暂时获取不到锁的线程加⼊到队列中。 </p>\n<p>AQS的原理并不复杂，AQS维护了一个volatile int state变量和一个CLH(三个人名缩写)双向队列，队列中的节点持有线程引用，每个节点均可通过getState()、setState()和compareAndSetState()对state进行修改和访问。</p>\n<p>当线程获取锁时，即试图对state变量做修改，如修改成功则获取锁；如修改失败则包装为节点挂载到队列中，等待持有锁的线程释放锁并唤醒队列中的节点。</p>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2023/webp/226907/1684751100181-5421c582-3c61-4e25-adc5-98f4ffc5781d.webp\" alt=\"img\"></p>\n<h3 id=\"AQS-对资源的共享⽅式\"><a href=\"#AQS-对资源的共享⽅式\" class=\"headerlink\" title=\"AQS 对资源的共享⽅式\"></a>AQS 对资源的共享⽅式</h3><ol>\n<li>独占</li>\n</ol>\n<p>如reentrantLock </p>\n<p>分为非公平（谁抢到是谁）和公平（排队顺序）</p>\n<ol>\n<li>共享</li>\n</ol>\n<p>CountDownLatch 、 Semaphore </p>\n<p>ReentrantReadWriteLock 可以看成是组合式，因为 ReentrantReadWriteLock 也就是读写锁允许多个线程同时对某⼀资源进⾏读。 </p>\n<h3 id=\"AQS-底层使⽤了模板⽅法模式\"><a href=\"#AQS-底层使⽤了模板⽅法模式\" class=\"headerlink\" title=\"AQS 底层使⽤了模板⽅法模式\"></a>AQS 底层使⽤了模板⽅法模式</h3><ol>\n<li>⾃定义同步器时 ，使⽤者继承 AbstractQueuedSynchronizer 并重写指定的⽅法 </li>\n<li>将AQS组合在自定义同步组件的实现中，并调用其模板方法，而这些模板方法会调用使用者重写的方法。</li>\n<li><strong>AQS使用了模板方法模式，自定义同步器时需要重写下面几个AQS提供的模板方法：</strong></li>\n</ol>\n<pre><code class=\"plain\">isHeldExclusively()//该线程是否正在独占资源。只有用到condition才需要去实现它。\n tryAcquire(int)//独占方式。尝试获取资源，成功则返回true，失败则返回false。\n tryRelease(int)//独占方式。尝试释放资源，成功则返回true，失败则返回false。\n tryAcquireShared(int)//共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。\n tryReleaseShared(int)//共享方式。尝试释放资源，成功则返回true，失败则返回false。\n</code></pre>\n<h3 id=\"⽤过-CountDownLatch-么？什么场景下⽤的？\"><a href=\"#⽤过-CountDownLatch-么？什么场景下⽤的？\" class=\"headerlink\" title=\"⽤过 CountDownLatch 么？什么场景下⽤的？\"></a>⽤过 CountDownLatch 么？什么场景下⽤的？</h3><p>允许 count 个线程阻塞在⼀个地⽅，直⾄所有线程的任务都执⾏完毕。 </p>\n<p>Service:十个service注入，多线程</p>\n<h3 id=\"AQS-组件了解吗\"><a href=\"#AQS-组件了解吗\" class=\"headerlink\" title=\"AQS 组件了解吗?\"></a>AQS 组件了解吗?</h3><ul>\n<li><strong>Semaphore(信号量)-允许多个线程同时访问：</strong> synchronized 和 ReentrantLock 都是一次只允许一个线程访问某个资源，Semaphore(信号量)可以指定多个线程同时访问某个资源。</li>\n<li><strong>CountDownLatch （倒计时器）：</strong> CountDownLatch是一个同步工具类，用来协调多个线程之间的同步。这个工具通常用来控制线程等待，它可以让某一个线程等待直到倒计时结束，再开始执行。</li>\n<li><strong>CyclicBarrier(循环栅栏)：</strong> CyclicBarrier 和 CountDownLatch 非常类似，它也可以实现线程间的技术等待，但是它的功能比 CountDownLatch 更加复杂和强大。主要应用场景和 CountDownLatch 类似。CyclicBarrier 的字面意思是可循环使用（Cyclic）的屏障（Barrier）。它要做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活。CyclicBarrier默认的构造方法是 CyclicBarrier(int parties)，其参数表示屏障拦截的线程数量，每个线程调用await方法告诉 CyclicBarrier 我已经到达了屏障，然后当前线程被阻塞。</li>\n</ul>\n","categories":["八股"]},{"title":"并查集","url":"/2023/06/04/%E5%B9%B6%E6%9F%A5%E9%9B%86/","content":"<p><a href=\"https://blog.csdn.net/the_zed/article/details/105126583\">https://blog.csdn.net/the_zed/article/details/105126583</a></p>\n<p>查找和合并 ，一边查询一边修改结点指向是并查集的特色。<span id=\"more\"></span></p>\n<h2 id=\"除法求值399\"><a href=\"#除法求值399\" class=\"headerlink\" title=\"除法求值399\"></a>除法求值399</h2><p>&#96;&#96;&#96;plain<br>public class Solution {<br>            public double[] calcEquation(List&lt;List<String>&gt; equations, double[] values, List&lt;List<String>&gt; queries) {<br>                int equationsSize &#x3D; equations.size();<br>                &#x2F;&#x2F;因为子数组里面有两个元素[[“a”,”b”],[“b”,”c”]], values &#x3D; [2.0,3.0], queries &#x3D; [[“a”,”c”],[“b”,”a”],[“a”,”e”]<br>                UnionFind unionFind &#x3D; new UnionFind(2 * equationsSize);<br>                &#x2F;&#x2F; 第 1 步：预处理，将变量的值与 id 进行映射，使得并查集的底层使用数组实现，方便编码<br>                Map&lt;String, Integer&gt; hashMap &#x3D; new HashMap&lt;&gt;(2 * equationsSize);<br>                int id &#x3D; 0;<br>                for (int i &#x3D; 0; i &lt; equationsSize; i++) {<br>                    List<String> equation &#x3D; equations.get(i);<br>                    String var1 &#x3D; equation.get(0);<br>                    String var2 &#x3D; equation.get(1);</String></String></String></p>\n<pre><code>                if (!hashMap.containsKey(var1)) &#123;\n                    hashMap.put(var1, id);\n                    id++;\n                &#125;\n                if (!hashMap.containsKey(var2)) &#123;\n                    hashMap.put(var2, id);\n                    id++;\n                &#125;\n                //hashmap   -&gt;   \n</code></pre>\n","categories":["算法"]},{"title":"开发岗开发题","url":"/2023/06/04/%E5%BC%80%E5%8F%91%E5%B2%97%E5%BC%80%E5%8F%91%E9%A2%98/","content":"<h2 id=\"linux、docker操作\"><a href=\"#linux、docker操作\" class=\"headerlink\" title=\"linux、docker操作\"></a>linux、docker操作</h2><h4 id=\"2、Docker\"><a href=\"#2、Docker\" class=\"headerlink\" title=\"2、Docker\"></a>2、Docker</h4><p>Docker如何解决大型项目依赖关系复杂，不同组件依赖的兼容性问题？<span id=\"more\"></span></p>\n<ul>\n<li>Docker允许开发中将应用、依赖、函数库、配置一起<strong>打包</strong>，形成可移植镜像</li>\n<li>Docker应用运行在容器中，使用沙箱机制，相互<strong>隔离</strong></li>\n</ul>\n<p>Docker如何解决开发、测试、生产环境有差异的问题？</p>\n<ul>\n<li>Docker镜像中包含完整运行环境，包括系统函数库，仅依赖系统的Linux内核，因此可以在任意Linux操作系统上运行</li>\n</ul>\n<p>Docker是一个快速交付应用、运行应用的技术，具备下列优势：</p>\n<ul>\n<li>可以将程序及其依赖、运行环境一起打包为一个镜像，可以迁移到任意Linux操作系统</li>\n<li>运行时利用沙箱机制形成隔离容器，各个应用互不干扰</li>\n<li>启动、移除都可以通过一行命令完成，方便快捷</li>\n</ul>\n<p>Docker和虚拟机的差异：</p>\n<ul>\n<li>docker是一个系统进程；虚拟机是在操作系统中的操作系统</li>\n<li>docker体积小、启动速度快、性能好；虚拟机体积大、启动速度慢、性能一般</li>\n</ul>\n<h5 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a><strong>基本概念</strong></h5><p>镜像：</p>\n<ul>\n<li>将应用程序及其依赖、环境、配置打包在一起</li>\n</ul>\n<p>容器：</p>\n<ul>\n<li>镜像运行起来就是容器，一个镜像可以运行多个容器 容器有自己独立的cpu 内存 文件系统 避免污染镜像</li>\n</ul>\n<p>Docker结构：</p>\n<ul>\n<li>服务端：接收命令或远程请求，操作镜像或容器</li>\n<li>客户端：发送命令或者请求到Docker服务端</li>\n</ul>\n<p>DockerHub：</p>\n<ul>\n<li>一个镜像托管的服务器，类似的还有阿里云镜像服务，统称为DockerRegistry</li>\n</ul>\n<h5 id=\"命令\"><a href=\"#命令\" class=\"headerlink\" title=\"命令\"></a><strong>命令</strong></h5><p>docker run命令的常见参数有哪些？</p>\n<ul>\n<li>–name：指定容器名称</li>\n<li>-p：指定端口映射</li>\n<li>-d：让容器后台运行</li>\n</ul>\n<p>查看容器日志的命令：</p>\n<ul>\n<li>docker logs</li>\n<li>添加 -f 参数可以持续查看日志</li>\n</ul>\n<p>查看容器状态：</p>\n<ul>\n<li>docker ps</li>\n<li>docker ps -a 查看所有容器，包括已经停止的</li>\n</ul>\n<h5 id=\"数据卷\"><a href=\"#数据卷\" class=\"headerlink\" title=\"数据卷\"></a>数据卷</h5><p>数据卷的作用：</p>\n<ul>\n<li>将容器与数据分离，解耦合，方便操作容器内数据，保证数据安全</li>\n</ul>\n<p>数据卷操作：</p>\n<ul>\n<li>docker volume create：创建数据卷</li>\n<li>docker volume ls：查看所有数据卷</li>\n<li>docker volume inspect：查看数据卷详细信息，包括关联的宿主机目录位置</li>\n<li>docker volume rm：删除指定数据卷</li>\n<li>docker volume prune：删除所有未使用的数据卷</li>\n</ul>\n<p>docker run的命令中通过 -v 参数挂载文件或目录到容器中：</p>\n<ul>\n<li>-v volume名称:容器内目录</li>\n<li>-v 宿主机文件:容器内文件</li>\n<li>-v 宿主机目录:容器内目录</li>\n</ul>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/image-20230403002812590.png\" alt=\"img\"></p>\n<p>数据卷挂载与目录直接挂载的</p>\n<ul>\n<li>数据卷挂载耦合度低，由docker来管理目录，但是目录较深，不好找</li>\n<li>目录挂载耦合度高，需要我们自己管理目录，不过目录容易寻找查看、</li>\n</ul>\n<h5 id=\"dockerfile\"><a href=\"#dockerfile\" class=\"headerlink\" title=\"dockerfile\"></a>dockerfile</h5><ol>\n<li>Dockerfile的本质是一个文件，通过指令描述镜像的构建过程</li>\n<li>Dockerfile的第一行必须是FROM，从一个基础镜像来构建</li>\n<li>基础镜像可以是基本操作系统，如Ubuntu。也可以是其他人制作好的镜像，例如：java:8-alpine</li>\n</ol>\n<h5 id=\"dockercompose\"><a href=\"#dockercompose\" class=\"headerlink\" title=\"dockercompose\"></a>dockercompose</h5><p>Docker Compose可以基于Compose文件帮我们快速的部署分布式应用，而无需手动一个个创建和运行容器！</p>\n<h4 id=\"3、linux命令\"><a href=\"#3、linux命令\" class=\"headerlink\" title=\"3、linux命令\"></a>3、linux命令</h4><p><strong>切换用户</strong></p>\n<p>su name</p>\n<p>exit</p>\n<p><strong>目录操作</strong></p>\n<p>切换cd</p>\n<p>查看ls</p>\n<p>删除rm</p>\n<p>修改mv</p>\n<p><strong>文件操作</strong></p>\n<p>touch rm vi cat chmod 777 a.txt</p>\n<p>查找进程top ps-ef</p>\n<p><strong>递归操作</strong></p>\n<p>-R</p>\n<h2 id=\"查找端口号冲突\"><a href=\"#查找端口号冲突\" class=\"headerlink\" title=\"查找端口号冲突\"></a>查找端口号冲突</h2><pre><code class=\"plain\">netstat -ano | findstr &quot;8080&quot;               //查找\ntaskkill /pid 8080 /f                       //释放\n</code></pre>\n<h2 id=\"topk问题\"><a href=\"#topk问题\" class=\"headerlink\" title=\"topk问题\"></a>topk问题</h2><p>路：只找到TopK，不排序TopK。</p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/v2-7a9fcf4d6fe7e0b7f873d8d3c6cf40e8_720w.webp\" alt=\"img\"></p>\n<p>先用前k个元素生成一个小顶堆，这个小顶堆用于存储，当前最大的k个元素。</p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/v2-f7aec1e403b784753102a0a11626658a_720w.webp\" alt=\"img\"></p>\n<p>接着，从第k+1个元素开始扫描，和堆顶（堆中最小的元素）比较，如果被扫描的元素大于堆顶，则替换堆顶的元素，并调整堆，以保证堆内的k个元素，总是当前最大的k个元素。</p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/v2-d8c1720ea1dc61a64b867350b8705ebd_720w.webp\" alt=\"img\"></p>\n<p>直到，扫描完所有n-k个元素，最终堆中的k个元素，就是猥琐求的TopK。</p>\n<p>伪代码：</p>\n<p>heap[k] &#x3D; make_heap(arr[1, k]);</p>\n<p>for(i&#x3D;k+1 to n){</p>\n<p>adjust_heap(heep[k],arr[i]);</p>\n<p>}</p>\n<p>return heap[k];</p>\n<p>时间复杂度：O(n*lg(k))</p>\n<p>画外音：n个元素扫一遍，假设运气很差，每次都入堆调整，调整时间复杂度为堆的高度，即lg(k)，故整体时间复杂度是n*lg(k)。</p>\n<p>分析：堆，将冒泡的TopK排序优化为了TopK不排序，节省了计算资源。堆，是求TopK的经典算法，那还有没有更快的方案呢？</p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/image-20230328215529635.png\" alt=\"img\"></p>\n<p>从复杂度来说，部分（nlogk），完全（klogn）完全入堆的复杂度必然要低一点 那为什么网上都用部分入堆呢？我感觉减少空间占用把</p>\n<h3 id=\"位图\"><a href=\"#位图\" class=\"headerlink\" title=\"位图\"></a>位图</h3><p>例如，集合S&#x3D;{1,3,5,7,9}，容易发现，S中所有元素都在1-16之间，于是，可以用16个bit来表示这个集合：存在于集合中的元素，对应bit置1，否则置0。</p>\n<p>画外音：究竟需要多少存储空间，取决于集合中元素的值域，在什么范围之内。</p>\n<p>上述集合S，可以用1010101010000000这样一个16bit的bitmap来表示，其中，第1, 3, 5, 7, 9个bit位置是1。</p>\n<p>但会存在重复元素去重的问题</p>\n<p>解决：维护一个count去计数，从最高位找count和为k的</p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/20181004205225541\" alt=\"img\"></p>\n<h2 id=\"100亿数字10mb找中位数\"><a href=\"#100亿数字10mb找中位数\" class=\"headerlink\" title=\"100亿数字10mb找中位数\"></a>100亿数字10mb找中位数</h2><p>链接：<a href=\"https://www.nowcoder.com/questionTerminal/359d6869d5ce4738bf9c9a42b67d9568%E6%9D%A5%E6%BA%90%EF%BC%9A%E7%89%9B%E5%AE%A2%E7%BD%91\">https://www.nowcoder.com/questionTerminal/359d6869d5ce4738bf9c9a42b67d9568来源：牛客网</a></p>\n<p>中位数定义：数字排序之后，位于中间的那个数。比如将100亿个数字进行排序，排序之后，位于第50亿个位置的那个数 就是中位数。 </p>\n<p>①内存够：内存够还慌什么啊，直接把100亿个全部排序了，你用冒泡都可以…然后找到中间那个就可以了。但是你以为面试官会给你内存？？ </p>\n<p>②内存不够：题目说是整数，我们认为是带符号的int,所以4字节，占32位。 </p>\n<p>假设100亿个数字保存在一个大文件中，依次读一部分文件到内存(不超过内存的限制)，将每个数字用二进制表示，比较二进制的最高位(第32位，符号位，0是正，1是负)，如果数字的最高位为0，则将这个数字写入 file_0文件中；如果最高位为 1，则将该数字写入file_1文件中。 </p>\n<p>从而将100亿个数字分成了两个文件，假设 file_0文件中有 60亿 个数字，file_1文件中有 40亿 个数字。那么中位数就在 file_0 文件中，并且是 file_0 文件中所有数字排序之后的第 10亿 个数字。（file_1中的数都是负数，file_0中的数都是正数，也即这里一共只有40亿个负数，那么排序之后的第50亿个数一定位于file_0中） </p>\n<p>现在，我们只需要处理 file_0 文件了（不需要再考虑file_1文件）。对于 file_0 文件，同样采取上面的措施处理：将file_0文件依次读一部分到内存(不超内存限制)，将每个数字用二进制表示，比较二进制的 次高位（第31位），如果数字的次高位为0，写入file_0_0文件中；如果次高位为1，写入file_0_1文件 中。 </p>\n<p>现假设 file_0_0文件中有30亿个数字，file_0_1中也有30亿个数字，则中位数就是：file_0_0文件中的数字从小到大排序之后的第10亿个数字。 </p>\n<p>抛弃file_0_1文件，继续对 file_0_0文件 根据 次次高位(第30位) 划分，假设此次划分的两个文件为：file_0_0_0中有5亿个数字，file_0_0_1中有25亿个数字，那么中位数就是 file_0_0_1文件中的所有数字排序之后的 第 5亿 个数。</p>\n<p>按照上述思路，直到划分的文件可直接加载进内存时，就可以直接对数字进行快速排序，找出中位数了。</p>\n<h2 id=\"大文件排序问题\"><a href=\"#大文件排序问题\" class=\"headerlink\" title=\"大文件排序问题\"></a>大文件排序问题</h2><p>设想你有一个20GB的文件，每行一个字符串，说明如何对这个文件进行排序。</p>\n<p>内存肯定没有20GB大，所以不可能采用传统排序法。但是可以将文件分成许多块，每块xMB,针对每个快各自进行排序，存回文件系统。</p>\n<p>然后将这些块逐一合并，最终得到全部排好序的文件。</p>\n<p>外排序的一个例子是外归并排序（External merge sort），它读入一些能放在内存内的数据量，在内存中排序后输出为一个顺串（即是内部数据有序的临时文件），处理完所有的数据后再进行归并。<a href=\"https://www.yuque.com/yunanyizhihua/nw82a7/mnq44dey61kan0en#\">1</a>比如，要对900MB的数据进行排序，但机器上只有100 MB的可用内存时，外归并排序按如下方法操作：</p>\n<p>1、读入100 MB的数据至内存中，用某种常规方式（如快速排序、堆排序、归并排序等方法）在内存中完成排序。2、将排序完成的数据写入磁盘。3、重复步骤1和2直到所有的数据都存入了不同的100 MB的块（临时文件）中。在这个例子中，有900 MB数据，单个临时文件大小为100 MB，所以会产生9个临时文件。4、读入每个临时文件（顺串）的前10 MB（ &#x3D; 100 MB &#x2F; (9块 + 1)）的数据放入内存中的输入缓冲区，最后的10 MB作为输出缓冲区。（实践中，将输入缓冲适当调小，而适当增大输出缓冲区能获得更好的效果。）5、执行九路归并算法，将结果输出到输出缓冲区。一旦输出缓冲区满，将缓冲区中的数据写出至目标文件，清空缓冲区。一旦9个输入缓冲区中的一个变空，就从这个缓冲区关联的文件，读入下一个10M数据，除非这个文件已读完。这是“外归并排序”能在主存外完成排序的关键步骤 – 因为“归并算法”(merge algorithm)对每一个大块只是顺序地做一轮访问(进行归并)，每个大块不用完全载入主存。</p>\n<h2 id=\"cpu飙高，系统反应慢如何排查\"><a href=\"#cpu飙高，系统反应慢如何排查\" class=\"headerlink\" title=\"cpu飙高，系统反应慢如何排查\"></a>cpu飙高，系统反应慢如何排查</h2><p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/image-20230410172241467.png\" alt=\"img\"></p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/image-20230410172257087.png\" alt=\"img\"></p>\n<p>top命令找java进程pid,然后使用jmap命令生成dump文件。file后面是保存的文件名称，1246则是java程序的PID。</p>\n<p>jmap -dump:format&#x3D;b,file&#x3D;user.dump 1246</p>\n<p>或者启动时加上如下参数，HeapDumpPath表示生成dump文件保存的目录。</p>\n<p>-XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath&#x3D;D:\\tmp</p>\n<p>然后用jprofile查看占用多的地方</p>\n<p>两种情况：</p>\n<p>1、如果cpu利用率高的线程一直是一个，jstack获取该线程Dump日志，然后定位到线程日志，找到对应问题代码</p>\n<p>1、如果cpu利用率高的线程一直变，说明线程创建多了，有可能是正常的，只是某一刻飙高</p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/image-20230412005359864.png\" alt=\"img\"></p>\n<h2 id=\"mysql\"><a href=\"#mysql\" class=\"headerlink\" title=\"mysql\"></a>mysql</h2><p>查安装路径</p>\n<p>whereis mysql</p>\n<p>查询运行路径</p>\n<p>which mysql</p>\n","categories":["八股"]},{"title":"插件","url":"/2023/06/04/%E6%8F%92%E4%BB%B6/","content":"<h1 id=\"Leetcode插件\"><a href=\"#Leetcode插件\" class=\"headerlink\" title=\"Leetcode插件\"></a>Leetcode插件</h1><p>因为我已经在一台电脑上配置好了，因此在新电脑上面只需要在idea安装leetcode editor，输入用户名密码保存路径和格式设置（可直接远程操作原电脑进行复制操作）</p>\n<p><a href=\"mailto:505371530@qq.com\">505371530@qq.com</a> 4873350781cet</p>\n<pre><code class=\"plain\">$&#123;question.content&#125;\n  package leetcode.editor.en;\n  public class $!velocityTool.camelCaseName($&#123;question.titleSlug&#125;)&#123;\n      public static void main(String[] args) &#123;\n           Solution solution = new $!velocityTool.camelCaseName($&#123;question.titleSlug&#125;)().new Solution();\n      &#125;\n      $&#123;question.code&#125;\n  &#125;\n$&#123;question.title&#125;   题目标题    示例:两数之和\n$&#123;question.titleSlug&#125;   题目标记    示例:two-sum\n$&#123;question.frontendQuestionId&#125;  题目编号\n$&#123;question.content&#125; 题目描述\n$&#123;question.code&#125;    题目代码\n$!velocityTool.camelCaseName(str)   转换字符为大驼峰样式（开头字母大写）\n$!velocityTool.smallCamelCaseName(str)  转换字符为小驼峰样式（开头字母小写）\n$!velocityTool.snakeCaseName(str)   转换字符为蛇形样式\n$!velocityTool.leftPadZeros(str,n)  在字符串的左边填充0，使字符串的长度至少为n\n$!velocityTool.date()   获取当前时间\n</code></pre>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/image-20220706213501965.png\" alt=\"img\"></p>\n<p>记得勾选画框处，Custom Templete ,如果有的题模板不对的话，右键clear cache</p>\n","categories":["教程"]},{"title":"数学","url":"/2023/06/04/%E6%95%B0%E5%AD%A6/","content":"<h2 id=\"Pow-x-n\"><a href=\"#Pow-x-n\" class=\"headerlink\" title=\"Pow(x, n)\"></a>Pow(x, n)</h2><p>实现 <a href=\"https://www.cplusplus.com/reference/valarray/pow/\">pow(x,n)</a> ，即计算 x 的整数 n 次幂函数（即，xn ）。</p>\n<p><strong>题解：</strong></p>\n<p>本质就是递归算法，<span id=\"more\"></span>不用一个个乘，比如要计算x^64 可以计算x—x2—x4—x8—x16—x32—x65</p>\n<p>如果n为奇数再乘以个x，为0的话结果为1</p>\n<pre><code class=\"plain\">class Solution &#123;\n    public double myPow(double x, int n) &#123;\n        // 判断正负\n        return n&gt;=0?quickMul(x,n):1.0/quickMul(x,-n);\n    &#125;\n    public double quickMul(double x,int n)&#123;\n        if(n==0) return 1.0;\n        // 计算n/2的值\n        double y=quickMul(x,n/2);\n        return n%2==0?y*y:y*y*x;\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"回文数\"><a href=\"#回文数\" class=\"headerlink\" title=\"回文数\"></a>回文数</h2><p>给你一个整数 x ，如果 x 是一个回文整数，返回 true ；否则，返回 false 。</p>\n<p>回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。</p>\n<ul>\n<li>例如，121 是回文，而 123 不是。</li>\n</ul>\n<p><strong>题解：</strong></p>\n<p>1、特殊情况，负数不是回文，尾数为0的话只有0符合回文要求</p>\n<p>2、为了避免数字反转可能导致的溢出问题，只反转一半和数字前半部分比较</p>\n<ul>\n<li><p>每次进行取余然后计算反转数字revertNumber，并计算移除数字x，循环出口为revertNumber&gt;x；</p>\n</li>\n<li><ul>\n<li>奇数的话revertNumber要移除最后一位</li>\n<li>偶数不用管</li>\n</ul>\n</li>\n</ul>\n<pre><code class=\"plain\">class Solution &#123;\n    public boolean isPalindrome(int x) &#123;\n        // 特殊情况\n        if(x&lt;0||x%10==0&amp;&amp;x!=0) return false;\n        int revertNumber=0;\n        while(x&gt;revertNumber)&#123;\n            revertNumber=revertNumber*10+x%10;\n            x/=10;\n        &#125;\n        // 考虑奇数偶数两种情况\n        return revertNumber==x||revertNumber/10==x;\n    &#125;\n&#125;\n</code></pre>\n<p> <img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/202306031148423.png\" alt=\"img\"></p>\n<h2 id=\"特征方程解法\"><a href=\"#特征方程解法\" class=\"headerlink\" title=\"特征方程解法\"></a>特征方程解法</h2><p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/202306031151072.png\" alt=\"img\"></p>\n<h2 id=\"力扣48题翻转矩阵\"><a href=\"#力扣48题翻转矩阵\" class=\"headerlink\" title=\"力扣48题翻转矩阵\"></a><strong>力扣48题翻转矩阵</strong></h2><p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/202306031149078.png\" alt=\"img\"><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/202306031150218.png\" alt=\"img\"></p>\n<p>只关注我画黑框的部分 其余三块都是每个元素旋转而成</p>\n<pre><code class=\"plain\">//        官方第二种方法\n        class Solution &#123;\n            public void rotate(int[][] matrix) &#123;\n                int n = matrix.length;\n                for (int i = 0; i &lt; n / 2; ++i) &#123;//行数 向下区取余\n                    for (int j = 0; j &lt; (n + 1) / 2; ++j) &#123;//列数 加一再向下取余\n                        int temp = matrix[i][j];\n                        matrix[i][j] = matrix[n - j - 1][i];\n                        matrix[n - j - 1][i] = matrix[n - i - 1][n - j - 1];\n                        matrix[n - i - 1][n - j - 1] = matrix[j][n - i - 1];\n                        matrix[j][n - i - 1] = temp;\n                    &#125;\n                &#125;\n            &#125;\n        &#125;\n</code></pre>\n<p>最终解法 将旋转分解为水平翻转和主对角线翻转(因为这俩翻转都是俩俩交换 直接temp换就完事儿，而旋转是4个元素在换)</p>\n<pre><code class=\"plain\">class Solution &#123;\n    public void rotate(int[][] matrix) &#123;\n        int n = matrix.length;\n        // 水平翻转\n        for (int i = 0; i &lt; n / 2; ++i) &#123;\n            for (int j = 0; j &lt; n; ++j) &#123;\n                int temp = matrix[i][j];\n                matrix[i][j] = matrix[n - i - 1][j];\n                matrix[n - i - 1][j] = temp;\n            &#125;\n        &#125;\n        // 主对角线翻转\n        for (int i = 0; i &lt; n; ++i) &#123;\n            for (int j = 0; j &lt; i; ++j) &#123;\n                int temp = matrix[i][j];\n                matrix[i][j] = matrix[j][i];\n                matrix[j][i] = temp;\n            &#125;\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n","categories":["算法"]},{"title":"操作系统","url":"/2023/06/04/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/","content":"<h2 id=\"什么是操作系统？\"><a href=\"#什么是操作系统？\" class=\"headerlink\" title=\"什么是操作系统？\"></a>什么是操作系统？</h2><p>管理计算机硬件与软件资源的程序 </p>\n<p>屏蔽了硬件层的复杂性 <span id=\"more\"></span></p>\n<p>内核负责系统的内存管理，硬件设备的管理，⽂件系统的管理以及应⽤程序的管理。 </p>\n<h2 id=\"系统调⽤\"><a href=\"#系统调⽤\" class=\"headerlink\" title=\"系统调⽤\"></a>系统调⽤</h2><p>用户态内核态</p>\n<p>⽤户程序中，凡是与系统态级别的资源有关的操作（如⽂件管理、进程控制、内存管理等)，都必须通过系统调⽤⽅式向操作系统提出服务请求，并由操作系统代为完成。 </p>\n<h2 id=\"进程和线程的区别\"><a href=\"#进程和线程的区别\" class=\"headerlink\" title=\"进程和线程的区别\"></a>进程和线程的区别</h2><ul>\n<li>调度：进程是资源管理的基本单位，线程是程序执行的基本单位。</li>\n<li>切换：线程上下文切换比进程上下文切换要快得多。</li>\n<li>拥有资源： 进程是拥有资源的一个独立单位，线程不拥有系统资源，但是可以访问隶属于进程的资源。</li>\n<li>系统开销： 创建或撤销进程时，系统都要为之分配或回收系统资源，如内存空间，I&#x2F;O设备等，OS所付出的开销显著大于在创建或撤销线程时的开销，进程切换的开销也远大于线程切换的开销。</li>\n</ul>\n<h2 id=\"协程与线程的区别？\"><a href=\"#协程与线程的区别？\" class=\"headerlink\" title=\"协程与线程的区别？\"></a>协程与线程的区别？</h2><ul>\n<li>线程和进程都是同步机制，而协程是异步机制。</li>\n<li>线程是抢占式，而协程是非抢占式的。需要用户释放使用权切换到其他协程，因此同一时间其实只有一个协程拥有运行权，相当于单线程的能力。</li>\n<li>一个线程可以有多个协程，一个进程也可以有多个协程(包含关系)。</li>\n<li>协程不被操作系统内核管理，而完全是由程序控制。线程是被分割的CPU资源，协程是组织好的代码流程，线程是协程的资源。但协程不会直接使用线程，协程直接利用的是执行器关联任意线程或线程池。</li>\n<li>协程能保留上一次调用时的状态。</li>\n</ul>\n<h2 id=\"并发和并行有什么区别？\"><a href=\"#并发和并行有什么区别？\" class=\"headerlink\" title=\"并发和并行有什么区别？\"></a><a href=\"https://www.javalearn.cn/#/doc/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E9%9D%A2%E8%AF%95%E9%A2%98?id=_3-%E5%B9%B6%E5%8F%91%E5%92%8C%E5%B9%B6%E8%A1%8C%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F\">并发和并行有什么区别？</a></h2><p>并发：1、一段时间，有多个任务在执行； 但某一时刻 ，只有一个任务在执行 本质是因为进程切换时间片足够块来达到同时多个程序在运行的错觉</p>\n<p>并行：2、同一时刻，确实有多个任务在执行。需要多核处理器才能完成，不同的程序被放到不同的处理器上运行</p>\n<h2 id=\"进程与线程的切换流程？\"><a href=\"#进程与线程的切换流程？\" class=\"headerlink\" title=\"进程与线程的切换流程？\"></a><a href=\"https://www.javalearn.cn/#/doc/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E9%9D%A2%E8%AF%95%E9%A2%98?id=_4-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%87%E6%8D%A2%E6%B5%81%E7%A8%8B%EF%BC%9F\">进程与线程的切换流程？</a></h2><p>进程切换分两步：</p>\n<p>1、切换<strong>页表</strong>以使用新的地址空间（换其他线程的虚拟地址空间），一旦去切换上下文，处理器中所有已经缓存的内存地址一瞬间都作废了。（虚拟地址空间转换）</p>\n<p>2、切换内核栈和硬件上下文。</p>\n<p>线程只有：</p>\n<p>切换内核栈和硬件上下文。</p>\n<p>因为每个进程都有自己的虚拟地址空间，而线程是共享所在进程的虚拟地址空间的，因此同一个进程中的线程进行线程切换时不涉及虚拟地址空间的转换。</p>\n<h2 id=\"为什么虚拟地址空间切换会比较耗时？\"><a href=\"#为什么虚拟地址空间切换会比较耗时？\" class=\"headerlink\" title=\"为什么虚拟地址空间切换会比较耗时？\"></a><a href=\"https://www.javalearn.cn/#/doc/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E9%9D%A2%E8%AF%95%E9%A2%98?id=_5-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E5%88%87%E6%8D%A2%E4%BC%9A%E6%AF%94%E8%BE%83%E8%80%97%E6%97%B6%EF%BC%9F\">为什么虚拟地址空间切换会比较耗时？</a></h2><p>进程都有自己的虚拟地址空间，把虚拟地址转换为物理地址需要查找页表，页表查找是一个很慢的过程，因此通常使用Cache来缓存常用的地址映射，这样可以加速页表查找，这个Cache就是TLB（translation Lookaside Buffer，TLB本质上就是一个Cache，是用来加速页表查找的）。</p>\n<p>由于每个进程都有自己的虚拟地址空间，那么显然每个进程都有自己的页表，那么<strong>当进程切换后页表也要进行切换，页表切换后TLB就失效了</strong>，Cache失效导致命中率降低，那么虚拟地址转换为物理地址就会变慢，表现出来的就是程序运行会变慢，而线程切换则不会导致TLB失效，因为线程无需切换地址空间，因此我们通常说线程切换要比较进程切换块，原因就在这里。</p>\n<p>总结：虚拟地址到物理地址需要用到页表进行转换，为了加速转换，一般把页表放到Cache（TLB）里面 进程切换后页表也要进行切换，页表切换后TLB就失效了，所以这个转换就变慢了</p>\n<h2 id=\"进程间通信方式有哪些？\"><a href=\"#进程间通信方式有哪些？\" class=\"headerlink\" title=\"进程间通信方式有哪些？\"></a>进程间通信方式有哪些？</h2><ul>\n<li>管道：管道这种通讯方式有两种限制，一是半双工的通信，数据只能单向流动，二是只能在具有亲缘关系的进程间(父子进程关系)。管道可以分为两类：匿名管道和命名管道。匿名管道是单向的，只能在有亲缘关系的进程间通信；命名管道以磁盘文件的方式存在，可以实现本机任意两个进程通信。</li>\n<li>信号 ： 信号是一种比较复杂的通信方式，信号可以在任何时候发给某一进程，而无需知道该进程的状态。</li>\n<li>Socket：与其他通信机制不同的是，它可用于不同机器间的进程通信。</li>\n<li>消息队列：消息队列克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺点。</li>\n<li>共享内存：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号量，配合使用，来实现进程间的同步和通信。</li>\n<li>信号量：信号量是一个<strong>计数器</strong>，可以用来控制多个进程对共享资源的访问。它常作为一种<strong>锁机制</strong>，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。</li>\n</ul>\n<p><strong>优缺点</strong>：</p>\n<ul>\n<li>管道：速度慢，容量有限；</li>\n<li>Socket：任何进程间都能通讯，但速度慢；</li>\n<li>消息队列：容量受到系统限制，且要注意第一次读的时候，要考虑上一次没有读完数据的问题；</li>\n<li>信号量：不能传递复杂消息，只能用来同步；</li>\n<li>共享内存区：能够很容易控制容量，速度快，但要保持同步，比如一个进程在写的时候，另一个进程要注意读写的问题，相当于线程中的线程安全，当然，共享内存区同样可以用作线程间通讯，不过没这个必要，线程间本来就已经共享了同一进程内的一块内存。</li>\n</ul>\n<h2 id=\"进程间的通信⽅式总结：\"><a href=\"#进程间的通信⽅式总结：\" class=\"headerlink\" title=\"进程间的通信⽅式总结：\"></a>进程间的通信⽅式总结：</h2><p>管道&#x2F;匿名管道(Pipes) </p>\n<p>信号(Signal) </p>\n<p>消息队列(Message Queuing) </p>\n<p>信号量(Semaphores) ：计数器，⽤于多进程对共享数据的访问 </p>\n<p>共享内存(Shared memory) </p>\n<p>套接字(Sockets) : 客户端和服务器之间通过⽹络进⾏通信 </p>\n<h2 id=\"进程间同步的方式有哪些？\"><a href=\"#进程间同步的方式有哪些？\" class=\"headerlink\" title=\"进程间同步的方式有哪些？\"></a><a href=\"https://www.javalearn.cn/#/doc/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E9%9D%A2%E8%AF%95%E9%A2%98?id=_7-%E8%BF%9B%E7%A8%8B%E9%97%B4%E5%90%8C%E6%AD%A5%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F\">进程间同步的方式有哪些？</a></h2><p>1、<strong>临界区</strong>：通过多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问。（只能同步本进程内的线程）</p>\n<p>优点：保证在某一时刻只有一个线程能访问数据的简便办法。</p>\n<p>缺点：虽然临界区同步速度很快，但却只能用来同步本进程内的线程，而不可用来同步多个进程中的线程。</p>\n<p>2、<strong>互斥量</strong>（锁）：为协调共同对一个共享资源的单独访问而设计的。互斥量跟临界区很相似，比临界区复杂，互斥对象只有一个，只有拥有互斥对象的线程才具有访问资源的权限。（可以在不同进程的线程之间进行同步）</p>\n<p>优点：使用互斥不仅仅能够在同一应用程序不同线程中实现资源的安全共享，而且可以在不同应用程序的线程之间实现对资源的安全共享。</p>\n<p>缺点：</p>\n<ul>\n<li>互斥量是可以命名的，也就是说它可以跨越进程使用，所以创建互斥量需要的资源更多，所以如果只为了在进程内部是用的话使用临界区会带来速度上的优势并能够减少资源占用量。（跨进程 需要资源多）</li>\n<li>通过互斥量可以指定资源被独占的方式使用，但如果有下面一种情况通过互斥量就无法处理，比如现在一位用户购买了一份三个并发访问许可的数据库系统，可以根据用户购买的访问许可数量来决定有多少个线程&#x2F;进程能同时进行数据库操作，这时候如果利用互斥量就没有办法完成这个要求，信号量对象可以说是一种资源计数器。（无法处理多个线程一起同步的问题 要用到信号量）</li>\n</ul>\n<p>3、<strong>信号量</strong>：为控制一个具有有限数量用户资源而设计。它允许多个线程在同一时刻访问同一资源，但是需要限制在同一时刻访问此资源的最大线程数目。互斥量是信号量的一种特殊情况，当信号量的最大资源数&#x3D;1就是互斥量了。</p>\n<p>优点：适用于对Socket（套接字）程序中线程的同步。</p>\n<p>缺点:</p>\n<ul>\n<li>信号量机制必须有公共内存，<strong>不能用于分布式操作系统</strong>，这是它最大的弱点；</li>\n<li>信号量机制功能强大，但使用时对信号量的操作分散， 而且难以控制，读写和维护都很困难，加重了程序员的编码负担；</li>\n<li>核心操作P-V分散在各用户程序的代码中，不易控制和管理，一旦错误，后果严重，且不易发现和纠正。</li>\n</ul>\n<p>4、<strong>事件</strong>： 用来通知线程有一些事件已发生，从而启动后继任务的开始。</p>\n<p>优点：事件对象通过通知操作的方式来保持线程的同步，并且<strong>可以实现不同进程中的线程同步操作</strong>。</p>\n<h2 id=\"线程间的同步的⽅式\"><a href=\"#线程间的同步的⽅式\" class=\"headerlink\" title=\"线程间的同步的⽅式\"></a>线程间的同步的⽅式</h2><p>1、临界区（同进程）：当多个线程访问一个独占性共享资源时，可以使用临界区对象。拥有临界区的线程可以访问被保护起来的资源或代码段，其他线程若想访问，则被挂起，直到拥有临界区的线程放弃临界区为止，以此达到用原子方式操 作共享资源的目的。</p>\n<p>2、事件：事件机制，则允许一个线程在处理完一个任务后，主动唤醒另外一个线程执行任务。</p>\n<p>3、互斥量：互斥对象和临界区对象非常相似，<strong>只是其允许在进程间使用</strong>（可以不同进程的线程同步），而临界区只限制与同一进程的各个线程之间使用，但是更节省资源，更有效率。</p>\n<p>（ Java 中的synchronized 关键词和各种 Lock 都是这种机制。）</p>\n<p>4、信号量：当需要一个计数器来限制可以使用某共享资源的线程数目时，可以使用“信号量”对象。</p>\n<p>区别：</p>\n<ul>\n<li>互斥量与临界区的作用非常相似，但互斥量是可以命名的，也就是说互斥量可以跨越进程使用，但创建互斥量需要的资源更多，所以如果只为了在进程内部是用的话使用临界区会带来速度上的优势并能够减少资源占用量 。因为互斥量是跨进程的互斥量一旦被创建，就可以通过名字打开它。</li>\n<li>互斥量，信号量，事件都可以被跨越进程使用来进行同步数据操作</li>\n</ul>\n<h2 id=\"线程的分类？\"><a href=\"#线程的分类？\" class=\"headerlink\" title=\"线程的分类？\"></a>线程的分类？</h2><p>从线程的运行空间来说，分为用户级线程（user-level thread, ULT）和内核级线程（kernel-level, KLT）</p>\n<p><strong>内核级线程</strong>：这类线程依赖于内核，又称为内核支持的线程或轻量级进程。无论是在用户程序中的线程还是系统进程中的线程，它们的<strong>创建、撤销和切换都由内核实现</strong>。比如英特尔i5-8250U是4核8线程，这里的线程就是内核级线程</p>\n<p><strong>用户级线程</strong>：它仅存在于用户级中，这种线程是<strong>不依赖于操作系统核心</strong>的。应用进程利用<strong>线程库来完成其创建和管理</strong>，速度比较快，<strong>操作系统内核无法感知用户级线程的存在</strong>。</p>\n<h2 id=\"什么是临界区，如何解决冲突？\"><a href=\"#什么是临界区，如何解决冲突？\" class=\"headerlink\" title=\"什么是临界区，如何解决冲突？\"></a>什么是临界区，如何解决冲突？</h2><p><strong>每个进程中访问临界资源的那段程序</strong>称为临界区，<strong>一次仅允许一个进程使用的资源称为临界资源。</strong></p>\n<p>解决冲突的办法：</p>\n<ul>\n<li>【一次只允许一个进程进入，其他进程在外面等】如果有若干进程要求进入空闲的临界区，<strong>一次仅允许一个进程进入</strong>，如已有进程进入自己的临界区，则其它所有试图进入临界区的进程必须等待；</li>\n<li>【进入时间优先】进入临界区的进程要在<strong>有限时间内退出</strong>。</li>\n<li>【进不去的话 让出CPU，避免出现忙等】如果进程不能进入自己的临界区，则应<strong>让出CPU</strong>，避免进程出现“忙等”现象。</li>\n</ul>\n<h2 id=\"什么是死锁？死锁产生的条件？\"><a href=\"#什么是死锁？死锁产生的条件？\" class=\"headerlink\" title=\"什么是死锁？死锁产生的条件？\"></a>什么是死锁？死锁产生的条件？</h2><p><strong>什么是死锁</strong>：</p>\n<p>两个或者多个进程持有某种资源而又等待其它进程释放现在保持着的资源，然后形成一种无限期的阻塞、相互等待的一种状态。</p>\n<p><strong>死锁产生的四个必要条件</strong>：（有一个条件不成立，则不会产生死锁）</p>\n<ul>\n<li>互斥条件：一个资源一次只能被一个进程使用</li>\n<li>请求与保持条件：一个进程因请求资源而阻塞时，对已获得资源保持不放</li>\n<li>不剥夺条件：进程获得的资源，在未完全使用完之前，不能强行剥夺</li>\n<li>循环等待条件：若干进程之间形成一种头尾相接的环形等待资源关系</li>\n</ul>\n<h3 id=\"如何处理死锁问题\"><a href=\"#如何处理死锁问题\" class=\"headerlink\" title=\"如何处理死锁问题\"></a><a href=\"https://www.javalearn.cn/#/doc/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E9%9D%A2%E8%AF%95%E9%A2%98?id=%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E6%AD%BB%E9%94%81%E9%97%AE%E9%A2%98\">如何处理死锁问题</a></h3><p>常用的处理死锁的方法有：死锁预防、死锁避免、死锁检测、死锁解除、鸵鸟策略。</p>\n<p><strong>（1）死锁的预防：</strong>基本思想就是确保死锁发生的四个必要条件中至少有一个不成立：</p>\n<ul>\n<li>① 破除资源互斥条件：无法破坏</li>\n<li>② 破除“请求与保持”条件：进程在运行之前，必须一次性获取所有的资源。缺点：在很多情况下，无法预知进程执行前所需的全部资源，因为进程是动态执行的，同时也会降低资源利用率，导致降低了进程的并发性。</li>\n<li>③ 破除“不可剥夺”条件：允许进程强行从占有者那里夺取某些资源。当一个已经保持了某些不可被抢占资源的进程，提出新的资源请求而不能得到满足时，它必须释放已经保持的所有资源，待以后需要时再重新申请。这意味着进程已经占有的资源会被暂时被释放，或者说被抢占了。</li>\n<li>④ 破除“循环等待”条件：对所有资源排序编号，按照顺序获取资源，将紧缺的，稀少的采用较大的编号，在申请资源时必须按照编号的顺序进行，一个进程只有获得较小编号的进程才能申请较大编号的进程。（申请资源有序 释放资源反序）</li>\n</ul>\n<p><strong>（2）死锁避免：</strong></p>\n<p>死锁避免则允许前三个必要条件，但是通过动态地检测资源分配状态，以确保循环等待条件不成立，从而确保系统处于安全状态。</p>\n<p>所谓安全状态是指：如果系统能按某个顺序为每个进程分配资源（不超过其最大值），那么系统状态是安全的，换句话说就是，如果存在一个安全序列，那么系统处于安全状态。银行家算法是经典的死锁避免的算法。</p>\n<p><strong>（3）死锁检测：</strong></p>\n<p>死锁预防策略是非常保守的，他们通过限制访问资源和在进程上强加约束来解决死锁的问题。死锁检测则是完全相反，它不限制资源访问或约束进程行为，只要有可能，被请求的资源就被授权给进程。但是操作系统会周期性地执行一个算法检测前面的循环等待的条件。<strong>死锁检测算法是通过资源分配图来检测是否存在环来实现，从一个节点出发进行深度优先搜索，对访问过的节点进行标记，如果访问了已经标记的节点，就表示有存在环，也就是检测到死锁的发生</strong>。</p>\n<p>dfs</p>\n<ul>\n<li>（1）如果进程-资源分配图中无环路，此时系统没有死锁。</li>\n<li>（2）如果进程-资源分配图中有环路，且每个资源类中只有一个资源，则系统发生死锁。</li>\n<li>（3）如果进程-资源分配图中有环路，且所涉及的资源类有多个资源，则不一定会发生死锁。（因为不止一个资源嘛 你再访问也没事）</li>\n</ul>\n<p><strong>（4）死锁解除：</strong></p>\n<p>死锁解除的常用方法就是终止进程和资源抢占，回滚。所谓进程终止就是简单地终止一个或多个进程以打破循环等待，包括两种方式：终止所有死锁进程和一次只终止一个进程直到取消死锁循环为止；所谓资源抢占就是从一个或者多个死锁进程那里抢占一个或多个资源。</p>\n<p><strong>（5）鸵鸟策略：</strong></p>\n<p>把头埋在沙子里，假装根本没发生问题。因为解决死锁问题的代价很高，因此鸵鸟策略这种不采取任何措施的方案会获得更高的性能。<strong>当发生死锁时不会对用户造成多大影响，或发生死锁的概率很低，可以采用鸵鸟策略</strong>。大多数操作系统，包括 Unix，Linux 和 Windows，处理死锁问题的办法仅仅是忽略它。</p>\n<h2 id=\"进程的调度算法\"><a href=\"#进程的调度算法\" class=\"headerlink\" title=\"进程的调度算法\"></a>进程的调度算法</h2><ul>\n<li><strong>先来先服务</strong>：非抢占式的调度算法，按照请求的顺序进行调度。有利于长作业，但不利于短作业，因为短作业必须一直等待前面的长作业执行完毕才能执行，而长作业又需要执行很长时间，造成了短作业等待时间过长。另外，对I&#x2F;O密集型进程也不利，因为这种进程每次进行I&#x2F;O操作之后又得重新排队。</li>\n<li><strong>短作业优先</strong>：非抢占式的调度算法，按估计运行时间最短的顺序进行调度。长作业有可能会饿死，处于一直等待短作业执行完毕的状态。因为如果一直有短作业到来，那么长作业永远得不到调度。</li>\n<li><strong>最短剩余时间优先</strong>：最短作业优先的抢占式版本，按剩余运行时间的顺序进行调度。 当一个新的作业到达时，其整个运行时间与当前进程的剩余时间作比较。如果新的进程需要的时间更少，则挂起当前进程，运行新的进程。否则新的进程等待。</li>\n<li><strong>时间片轮转</strong>：将所有就绪进程按 FCFS 的原则排成一个队列，每次调度时，把 CPU 时间分配给队首进程，该进程可以执行一个时间片。当时间片用完时，由计时器发出时钟中断，调度程序便停止该进程的执行，并将它送往就绪队列的末尾，同时继续把 CPU 时间分配给队首的进程。时间片轮转算法的效率和时间片的大小有很大关系：因为进程切换都要保存进程的信息并且载入新进程的信息，如果时间片太小，会导致进程切换得太频繁，在进程切换上就会花过多时间。 而如果时间片过长，那么实时性就不能得到保证。</li>\n<li><strong>优先级调度</strong>：为每个进程分配一个优先级，按优先级进行调度。为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级。</li>\n</ul>\n<h2 id=\"进程有哪些状态？\"><a href=\"#进程有哪些状态？\" class=\"headerlink\" title=\"进程有哪些状态？\"></a>进程有哪些状态？</h2><p>进程一共有5种状态，分别是创建、就绪、运行（执行）、终止、阻塞。</p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/A61F5B5322ED49038C64BDD82D341987\" alt=\"img\"></p>\n<ul>\n<li>运行状态就是进程正在CPU上运行。在单处理机环境下，每一时刻最多只有一个进程处于运行状态。</li>\n<li>就绪状态就是说进程已处于准备运行的状态，即进程获得了除CPU之外的一切所需资源，一旦得到CPU即可运行。</li>\n<li>阻塞状态就是进程正在等待某一事件而暂停运行，比如等待某资源为可用或等待I&#x2F;O完成。即使CPU空闲，该进程也不能运行。</li>\n</ul>\n<p><strong>运行态→阻塞态</strong>：往往是由于等待外设，等待主存等资源分配或等待人工干预而引起的。 </p>\n<p><strong>阻塞态→就绪态</strong>：则是等待的条件已满足，只需分配到处理器后就能运行。</p>\n<p><strong>运行态→就绪态</strong>：不是由于自身原因，而是由外界原因使运行状态的进程让出处理器，这时候就变成就绪态。例如时间片用完，或有更高优先级的进程来抢占处理器等。</p>\n<p><strong>就绪态→运行态</strong>：系统按某种策略选中就绪队列中的一个进程占用处理器，此时就变成了运行态。</p>\n<h2 id=\"什么是分页？\"><a href=\"#什么是分页？\" class=\"headerlink\" title=\"什么是分页？\"></a>什么是分页？</h2><p>把内存空间划分为<strong>大小相等且固定的块</strong>，作为主存的基本单位。因为程序数据存储在不同的页面中，而页面又离散的分布在内存中，<strong>因此需要一个页表来记录映射关系，以实现从页号到物理块号的映射。</strong></p>\n<p>访问分页系统中内存数据需要<strong>两次的内存访问</strong> (一次是从内存中访问页表，从中找到指定的物理块号，加上页内偏移得到实际物理地址(页号*每页块数+页内偏移量&#x3D;物理块号)；第二次就是根据第一次得到的物理地址访问内存取出数据)。</p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/image-20210610173249387.png\" alt=\"img\"></p>\n<h2 id=\"什么是分段？\"><a href=\"#什么是分段？\" class=\"headerlink\" title=\"什么是分段？\"></a>什么是分段？</h2><p><strong>分页是为了提高内存利用率，而分段是为了满足程序员在编写代码的时候的一些逻辑需求(比如数据共享，数据保护，动态链接等)。</strong></p>\n<p>分段内存管理当中，<strong>地址是二维的，一维是段号，二维是段内地址；其中每个段的长度是不一样的，而且每个段内部都是从0开始编址的</strong>。由于分段管理中，每个段内部是连续内存分配，但是段和段之间是<strong>离散分配</strong>的，因此也存在一个逻辑地址到物理地址的映射关系，相应的就是段表机制。</p>\n<p>基址+偏移量（看看有没有超过段长 超过说明越界了）</p>\n<p>根据段号确认基址，加上偏移量 （还要判断是否越界）</p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/image-20230330225823075.png\" alt=\"img\"></p>\n<h2 id=\"分页和分段有什区别？\"><a href=\"#分页和分段有什区别？\" class=\"headerlink\" title=\"分页和分段有什区别？\"></a>分页和分段有什区别？</h2><ul>\n<li>（分页透明 分段不透明 需要自己显式划分）分页对程序员是透明的，但是分段需要程序员显式划分每个段。</li>\n<li>分页的地址空间是一维地址空间，分段是二维的。（一个给地址就行 一个需要给段码+段内地址）</li>\n</ul>\n<p>解释：分页之所以是一维的，原因在于分页的大小是固定的，且页码之间是连续的，操作的时候只需给出一个地址，就能够根据所给地址的大小与页面大小计算出在页码和页内地址，粗略举例，比如页面大小是4KB，给一个地址为5000，可以算出所在页码是2，页内地址是5000-4000&#x3D;1000，即在第二页的第1000个位置。而分段的因为每段的长度不一样，必须给出段码和段内地址</p>\n<ul>\n<li><strong>页的大小不可变，段的大小可以动态改变</strong>。</li>\n<li>分页主要用于实现虚拟内存，从而获得更大的地址空间（for max）；分段主要是为了使程序和数据可以被划分为逻辑上独立的地址空间并且有助于共享和保护(独立化)。</li>\n</ul>\n<h2 id=\"什么是交换空间？\"><a href=\"#什么是交换空间？\" class=\"headerlink\" title=\"什么是交换空间？\"></a>什么是交换空间？</h2><p>操作系统把物理内存(physical RAM)分成一块一块的小内存，每一块内存被称为<strong>页(page)。当内存资源不足时，</strong>Linux把某些页的内容转移至硬盘上的一块空间上，以释放内存空间<strong>。硬盘上的那块空间叫做</strong>交换空间**(swap space),而这一过程被称为交换(swapping)。**物理内存和交换空间的总容量就是虚拟内存的可用容量。</p>\n<p>用途：</p>\n<ul>\n<li>物理内存不足时一些不常用的页可以被交换出去，腾给系统。</li>\n<li>程序启动时很多内存页被用来初始化，之后便不再需要，可以交换出去。</li>\n</ul>\n<h2 id=\"物理地址、逻辑地址（有效地址）、虚拟地址（线性地址）的区别\"><a href=\"#物理地址、逻辑地址（有效地址）、虚拟地址（线性地址）的区别\" class=\"headerlink\" title=\"物理地址、逻辑地址（有效地址）、虚拟地址（线性地址）的区别?\"></a>物理地址、逻辑地址（有效地址）、虚拟地址（线性地址）的区别?</h2><p>物理地址就是内存中<strong>真正的地址</strong>，具有唯一性。<strong>不管哪种地址，最终都会映射为物理地址</strong>。</p>\n<p>在实模式下，段基址 + 段内偏移经过地址加法器的处理，经过地址总线传输，最终也会转换为物理地址。</p>\n<p>但是在保护模式下，段基址 + 段内偏移被称为线性地址，不过此时的段基址不能称为真正的地址，而是会被称作为一个选择子的东西，选择子就是个索引，相当于数组的下标，通过这个索引能够在 GDT 中找到相应的段描述符，段描述符记录了<strong>段的起始、段的大小</strong>等信息，这样便得到了基地址。如果此时没有开启内存分页功能，那么这个线性地址可以直接当做物理地址来使用，直接访问内存。如果开启了分页功能，那么这个线性地址又多了一个名字，这个名字就是虚拟地址。</p>\n<p>不论在实模式还是保护模式下，段内偏移地址都叫做有效地址。有效地址也是逻辑地址。</p>\n<p>线性地址可以看作是虚拟地址，虚拟地址不是真正的物理地址，但是虚拟地址会最终被映射为物理地址。下面是虚拟地址 -&gt; 物理地址的映射。</p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/image-20210807152300643.png\" alt=\"img\"></p>\n<h2 id=\"什么是缓冲区溢出？有什么危害？\"><a href=\"#什么是缓冲区溢出？有什么危害？\" class=\"headerlink\" title=\"什么是缓冲区溢出？有什么危害？\"></a>什么是缓冲区溢出？有什么危害？</h2><p>缓冲区溢出是指当计算机向缓冲区填充数据时超出了缓冲区本身的容量，溢出的数据覆盖在合法数据上。</p>\n<p>危害有以下两点：</p>\n<ul>\n<li>程序崩溃，导致拒绝服务</li>\n<li>跳转并且执行一段恶意代码</li>\n</ul>\n<p>造成缓冲区溢出的主要原因是程序中没有仔细检查用户输入。</p>\n<h2 id=\"什么是虚拟内存？\"><a href=\"#什么是虚拟内存？\" class=\"headerlink\" title=\"什么是虚拟内存？\"></a>什么是虚拟内存？</h2><p>因为只加载进程的一部分进入内存 然后用页面置换技术就完事</p>\n<p>虚拟内存就是说，让物理内存扩充成更大的逻辑内存，从而让程序获得更多的可用内存。虚拟内存使用部分加载的技术，让一个进程或者资源的<strong>某些</strong>页面加载进内存，从而能够加载更多的进程，甚至能加载比内存大的进程，这样看起来好像内存变大了，这部分内存其实包含了磁盘或者硬盘，并且就叫做虚拟内存。</p>\n<h2 id=\"虚拟内存的实现方式有哪些\"><a href=\"#虚拟内存的实现方式有哪些\" class=\"headerlink\" title=\"虚拟内存的实现方式有哪些?\"></a>虚拟内存的实现方式有哪些?</h2><p>虚拟内存中，允许将一个作业分多次调入内存。釆用连续分配方式时，会使相当一部分内存空间都处于暂时或永久的空闲状态，造成内存资源的严重浪费，而且也无法从逻辑上扩大内存容量。因此，虚拟内存的实需要建立在<strong>离散分配</strong>的内存管理方式的基础上。虚拟内存的实现有以下三种方式：</p>\n<p>肯定要离散呀 连续的话 那相当于没有虚拟内存 使用起始位置+偏移量 </p>\n<ul>\n<li>请求分页存储管理。（分页）</li>\n<li>请求分段存储管理。(分段)</li>\n<li>请求段页式存储管理。（段页）</li>\n</ul>\n<p>感觉主要是这个离散分配让虚拟内存好像范围大了很多</p>\n<h2 id=\"讲一讲IO多路复用\"><a href=\"#讲一讲IO多路复用\" class=\"headerlink\" title=\"讲一讲IO多路复用\"></a>讲一讲IO多路复用</h2><p><a href=\"https://juejin.cn/post/6882984260672847879\">https://juejin.cn/post/6882984260672847879</a></p>\n<p><strong>IO多路复用是指内核一旦发现进程指定的一个或者多个IO条件准备读取，它就通知该进程。IO多路复用适用如下场合</strong>：</p>\n<ul>\n<li>当客户处理多个描述字时（一般是交互式输入和网络套接口），必须使用I&#x2F;O复用。</li>\n<li>当一个客户同时处理多个套接口时，而这种情况是可能的，但很少出现。</li>\n<li>如果一个TCP服务器既要处理监听套接口，又要处理已连接套接口，一般也要用到I&#x2F;O复用。</li>\n<li>如果一个服务器即要处理TCP，又要处理UDP，一般要使用I&#x2F;O复用。</li>\n<li>如果一个服务器要处理多个服务或多个协议，一般要使用I&#x2F;O复用。</li>\n<li>与多进程和多线程技术相比，I&#x2F;O多路复用技术的最大优势是系统开销小，系统不必创建进程&#x2F;线程，也不必维护这些进程&#x2F;线程，从而大大减小了系统的开销</li>\n</ul>\n<h2 id=\"硬链接和软链接有什么区别？\"><a href=\"#硬链接和软链接有什么区别？\" class=\"headerlink\" title=\"硬链接和软链接有什么区别？\"></a>硬链接和软链接有什么区别？</h2><h3 id=\"inode\"><a href=\"#inode\" class=\"headerlink\" title=\"inode\"></a>inode</h3><p>inode 是一个描述文件或目录属性的数据库，如元信息、硬盘物理地址等。通过 inode，操作系统可以检索文件权限信息、物理地址等信息。当一个文件从一个文件夹移到另一个文件夹，文件将被移动到硬盘的另一个位置，文件的 inode 值也会自动发生变化。</p>\n<h3 id=\"硬连接\"><a href=\"#硬连接\" class=\"headerlink\" title=\"硬连接\"></a>硬连接</h3><p>硬连接直接通过 inode 引用文件。硬连接只能用于文件，而不能用于目录。</p>\n<p>硬连接（Hard Link）扮演着源文件拷贝或镜像的角色。可以访问源文件的数据，如果源文件被删除，硬连接依然可以访问源文件的数据。</p>\n<h3 id=\"软连接\"><a href=\"#软连接\" class=\"headerlink\" title=\"软连接\"></a>软连接</h3><p>软连接本质上是源文件的一个快捷方式，指向源文件本身，而不是源文件的 inode 值。软连接可以同时用于文件和目录，也可以在不同的硬盘或容器之间使用。</p>\n<p>软连接（Soft Link 或 Symbolic Link）扮演着源文件指针的角色。不可以访问源文件数据，如果源文件被删除，软连接将会指向一个不再存在的文件地址。</p>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2023/webp/226907/1684914769452-d1ec9390-2694-4a1e-85d1-4594b50d186d.webp\" alt=\"img\"></p>\n<p>硬连接直接引用源文件引用的 inode，软连接则直接引用源文件。</p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/image-20230331214416885.png\" alt=\"img\"></p>\n<h2 id=\"中断的处理过程\"><a href=\"#中断的处理过程\" class=\"headerlink\" title=\"中断的处理过程?\"></a>中断的处理过程?</h2><ol>\n<li>保护现场：将当前执行程序的相关数据保存在寄存器中，然后入栈。</li>\n<li>开中断：以便执行中断时能响应较高级别的中断请求。</li>\n<li>中断处理</li>\n<li>关中断：保证恢复现场时不被新中断打扰</li>\n<li>恢复现场：从堆栈中按序取出程序数据，恢复中断前的执行状态。</li>\n</ol>\n<h2 id=\"中断和轮询有什么区别？\"><a href=\"#中断和轮询有什么区别？\" class=\"headerlink\" title=\"中断和轮询有什么区别？\"></a>中断和轮询有什么区别？</h2><ul>\n<li>轮询：CPU对<strong>特定设备</strong>轮流询问。中断：通过<strong>特定事件</strong>提醒CPU。</li>\n<li>轮询：效率低等待时间长，CPU利用率不高。中断：容易遗漏问题，CPU利用率不高。</li>\n</ul>\n<h2 id=\"什么是用户态和内核态？\"><a href=\"#什么是用户态和内核态？\" class=\"headerlink\" title=\"什么是用户态和内核态？\"></a>什么是用户态和内核态？</h2><p>用户态和系统态是操作系统的两种运行状态：</p>\n<ul>\n<li>内核态：内核态运行的程序可以访问计算机的任何数据和资源，不受限制，包括外围设备，比如网卡、硬盘等。处于内核态的 CPU 可以从一个程序切换到另外一个程序，并且占用 CPU 不会发生抢占情况。</li>\n<li>用户态：用户态运行的程序只能受限地访问内存，只能直接读取用户程序的数据，并且不允许访问外围设备，用户态下的 CPU 不允许独占，也就是说 CPU 能够被其他程序获取。</li>\n</ul>\n<p>将操作系统的运行状态分为用户态和内核态，主要是为了对访问能力进行限制，<strong>防止随意进行一些比较危险的操作导致系统的崩溃</strong>，比如设置时钟、内存清理，这些都需要在内核态下完成 。</p>\n<h2 id=\"用户态和内核态是如何切换的\"><a href=\"#用户态和内核态是如何切换的\" class=\"headerlink\" title=\"用户态和内核态是如何切换的?\"></a>用户态和内核态是如何切换的?</h2><p>所有的用户进程都是运行在用户态的，但是我们上面也说了，用户程序的访问能力有限，一些比较重要的比如从硬盘读取数据，从键盘获取数据的操作则是内核态才能做的事情，而这些数据却又对用户程序来说非常重要。所以就涉及到两种模式下的转换，即<strong>用户态 -&gt; 内核态 -&gt; 用户态</strong>，而唯一能够做这些操作的只有 系统调用，而能够执行系统调用的就只有 操作系统。</p>\n<p>一般用户态 -&gt; 内核态的转换我们都称之为 trap 进内核，也被称之为 陷阱指令(trap instruction)。</p>\n<p>他们的工作流程如下：</p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/image-20210807152619210.png\" alt=\"img\"></p>\n<ul>\n<li>首先用户程序会调用 glibc 库，glibc 是一个标准库，同时也是一套核心库，库中定义了很多关键 API。</li>\n<li>glibc 库知道针对不同体系结构调用系统调用的正确方法，它会根据体系结构应用程序的二进制接口设置用户进程传递的参数，来准备系统调用。</li>\n<li>然后，glibc 库调用软件中断指令(SWI) ，这个指令通过更新 CPSR 寄存器将模式改为超级用户模式，然后跳转到地址 0x08 处。</li>\n<li>到目前为止，整个过程仍处于用户态下，在执行 SWI 指令后，允许进程执行内核代码，MMU 现在允许内核虚拟内存访问</li>\n<li>从地址 0x08 开始，进程执行加载并跳转到中断处理程序，这个程序就是 ARM 中的 vector_swi()。</li>\n<li>在 vector_swi() 处，从 SWI 指令中提取系统调用号 SCNO，然后使用 SCNO 作为系统调用表 sys_call_table 的索引，调转到系统调用函数。</li>\n<li>执行系统调用完成后，将还原用户模式寄存器，然后再以用户模式执行。</li>\n</ul>\n<h2 id=\"Unix-常见的IO模型\"><a href=\"#Unix-常见的IO模型\" class=\"headerlink\" title=\"Unix 常见的IO模型\"></a>Unix 常见的IO模型</h2><p>对于一次IO访问（以read举例），数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。所以说，当一个read操作发生时，它会经历两个阶段：</p>\n<ul>\n<li>等待数据准备就绪 (Waiting for the data to be ready)</li>\n<li>将数据从内核拷贝到进程中 (Copying the data from the kernel to the process)</li>\n</ul>\n<p>正式因为这两个阶段，linux系统产生了下面五种网络模式的方案：</p>\n<ul>\n<li>阻塞式IO模型(blocking IO model)</li>\n<li>非阻塞式IO模型(noblocking IO model)</li>\n<li>IO复用式IO模型(IO multiplexing model)</li>\n<li>信号驱动式IO模型(signal-driven IO model)</li>\n<li>异步IO式IO模型(asynchronous IO model)</li>\n</ul>\n<p>对于这几种 IO 模型的详细说明，可以参考这篇文章：<a href=\"https://juejin.cn/post/6942686874301857800#heading-13\">https://juejin.cn/post/6942686874301857800#heading-13</a></p>\n<p>其中，IO多路复用模型指的是：使用单个进程同时处理多个网络连接IO，他的原理就是select、poll、epoll 不断轮询所负责的所有 socket，当某个socket有数据到达了，就通知用户进程。该模型的优势并不是对于单个连接能处理得更快，而是在于能处理更多的连接。</p>\n<h2 id=\"select、poll-和-epoll-之间的区别\"><a href=\"#select、poll-和-epoll-之间的区别\" class=\"headerlink\" title=\"select、poll 和 epoll 之间的区别?\"></a>select、poll 和 epoll 之间的区别?</h2><p>（1）select：时间复杂度 O(n)</p>\n<p>select 仅仅知道有 I&#x2F;O 事件发生，但并不知道是哪几个流，所以只能<strong>无差别轮询所有流</strong>，找出能读出数据或者写入数据的流，并对其进行操作。所以 select 具有 O(n) 的无差别轮询复杂度，同时处理的流越多，无差别轮询时间就越长。</p>\n<p>（2）poll：时间复杂度 O(n)</p>\n<p>poll 本质上和 select 没有区别，它将用户传入的数组拷贝到内核空间，然后查询每个 fd 对应的设备状态， 但是它<strong>没有最大连接数的限制</strong>，原因是它是基于<strong>链表</strong>来存储的。</p>\n<p>（3）epoll：时间复杂度 O(1)</p>\n<p>epoll 可以理解为 event poll，不同于忙轮询和无差别轮询，epoll 会把哪个流发生了怎样的 I&#x2F;O 事件通知我们。所以说 epoll 实际上是事件驱动（每个事件关联上 fd）的。</p>\n<p>select，poll，epoll 都是 IO 多路复用的机制。I&#x2F;O 多路复用就是通过一种机制监视多个描述符，<strong>一旦某个描述符就绪（一般是读就绪或者写就绪）</strong>，就通知程序进行相应的读写操作。但 select，poll，epoll 本质上都是同步 I&#x2F;O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的，而异步 I&#x2F;O 则无需自己负责进行读写，异步 I&#x2F;O 的实现会负责把数据从内核拷贝到用户空间。</p>\n<h2 id=\"操作系统的内存管理主要是做什么\"><a href=\"#操作系统的内存管理主要是做什么\" class=\"headerlink\" title=\"操作系统的内存管理主要是做什么\"></a>操作系统的内存管理主要是做什么</h2><p>主要负责内存的分配与回收 </p>\n<h2 id=\"常⻅的⼏种内存管理机制\"><a href=\"#常⻅的⼏种内存管理机制\" class=\"headerlink\" title=\"常⻅的⼏种内存管理机制\"></a>常⻅的⼏种内存管理机制</h2><p>块式管理 ：碎⽚ </p>\n<p>⻚式管理 ： 提⾼了内存利⽤率，减少了碎⽚ </p>\n<p>段式管理 ：实际意义的 </p>\n<h2 id=\"快表和多级⻚表\"><a href=\"#快表和多级⻚表\" class=\"headerlink\" title=\"快表和多级⻚表\"></a>快表和多级⻚表</h2><p><strong>解决了⻚表管理中很重要的两个问题</strong></p>\n<ol>\n<li>虚拟地址到物理地址的转换要快。</li>\n<li>解决虚拟地址空间⼤，⻚表也会很⼤的问题。</li>\n</ol>\n<p>快表 (类似缓存)</p>\n<p>\\1.根据虚拟地址中的⻚号查快表；\\2. 如果该⻚在快表中，直接从快表中读取相应的物理地址；\\3. 如果该⻚不在快表中，就访问内存中的⻚表，再从⻚表中得到物理地址，同时将⻚表中的该映射表项添加到快表中；\\4. 当快表填满后，⼜要登记新⻚时，就按照⼀定的淘汰策略淘汰掉快表中的⼀个⻚。 </p>\n<p>多级⻚表 </p>\n<p>时间换空间 </p>\n<h2 id=\"分⻚机制和分段机制的共同点和区别\"><a href=\"#分⻚机制和分段机制的共同点和区别\" class=\"headerlink\" title=\"分⻚机制和分段机制的共同点和区别\"></a>分⻚机制和分段机制的共同点和区别</h2><p>共同点 ：1、都是为了提⾼内存利⽤率，较少内存碎⽚。2、每个⻚和段中的内存是连续的。 </p>\n<p>区别 ： </p>\n<p>1、⻚的⼤⼩是固定的，由操作系统决定；⽽段的⼤⼩不固定，取决于我们当前运⾏的程序。 </p>\n<p>2、分⻚仅仅是为了满⾜操作系统内存管理的需求，⽽段是逻辑信息的单位， </p>\n<h2 id=\"逻辑-虚拟-地址和物理地址\"><a href=\"#逻辑-虚拟-地址和物理地址\" class=\"headerlink\" title=\"逻辑(虚拟)地址和物理地址\"></a>逻辑(虚拟)地址和物理地址</h2><p>逻辑地址：指针⾥⾯存储的数值 </p>\n<p>物理地址指的是真实物理内存中地址 （内存地址寄存器 ）</p>\n<h2 id=\"CPU-寻址了解吗-为什么需要虚拟地址空间\"><a href=\"#CPU-寻址了解吗-为什么需要虚拟地址空间\" class=\"headerlink\" title=\"CPU 寻址了解吗?为什么需要虚拟地址空间?\"></a>CPU 寻址了解吗?为什么需要虚拟地址空间?</h2><p>如果直接把物理地址暴露出来的话会带来严重问题，⽐如可能对操作系统造成伤害以及给同时运⾏多个程序造成困难。 </p>\n<h2 id=\"虚拟内存\"><a href=\"#虚拟内存\" class=\"headerlink\" title=\"虚拟内存\"></a>虚拟内存</h2><p>只是多个进程被分割为多个物理内存块（还有部分暂时存储在外部磁盘存储器上，在需要时进⾏数据交换。 ） 感觉上是独享主存 </p>\n<h2 id=\"局部性原理\"><a href=\"#局部性原理\" class=\"headerlink\" title=\"局部性原理\"></a>局部性原理</h2><p>时间局部：如果程序中的某条指令⼀旦执⾏，不久以后该指令可能再次执⾏ </p>\n<p>空间局部性 ：⼀旦程序访问了某个存储单元，在不久之后，其附近的存储单元也将被访问， </p>\n<h2 id=\"⻚⾯置换算法\"><a href=\"#⻚⾯置换算法\" class=\"headerlink\" title=\"⻚⾯置换算法\"></a>⻚⾯置换算法</h2><p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/image-20210807152232136.png\" alt=\"img\"></p>\n<p>OPT ⻚⾯置换算法（最佳⻚⾯置换算法） ：最⻓时间内不再被访问的⻚⾯ </p>\n<p>FIFO（First In First Out） ⻚⾯置换算法（先进先出⻚⾯置换算法） : 总是淘汰最先进⼊内存的⻚⾯，即选择在内存中驻留时间最久的⻚⾯进⾏淘汰 </p>\n<p>LRU （Least Currently Used）⻚⾯置换算法（最近最久未使⽤⻚⾯置换算法） </p>\n<p>LFU （Least Frequently Used）⻚⾯置换算法（最少使⽤⻚⾯置换算法） </p>\n","categories":["八股"]},{"title":"数组","url":"/2023/06/04/%E6%95%B0%E7%BB%84/","content":"<h2 id=\"API、经验\"><a href=\"#API、经验\" class=\"headerlink\" title=\"API、经验\"></a>API、经验</h2><h4 id=\"填充数组\"><a href=\"#填充数组\" class=\"headerlink\" title=\"填充数组\"></a><strong>填充数组</strong></h4><pre><code class=\"plain\">一维数组\n boolean[] a1 = new boolean[5];\n     Arrays.fill( a1,true );\n Arrays.fill( a1,3,4,false);//下标3变为false 左开右闭\n 二维数组  把一维数组当作一个对象\n  int[][] map=new int[4][5];\n    int[] ten=new int[10];\n    Arrays.fill(ten, -1);\n    Arrays.fill(map,ten);  //成功\n</code></pre>\n<h4 id=\"填充集合\"><a href=\"#填充集合\" class=\"headerlink\" title=\"填充集合\"></a><span id=\"more\"></span>填充集合</h4><p>  Collections.fill();</p>\n<h4 id=\"判断数组相等\"><a href=\"#判断数组相等\" class=\"headerlink\" title=\"判断数组相等\"></a><strong>判断数组相等</strong></h4><p>Arrays.equals（a,b)</p>\n<h4 id=\"边界条件\"><a href=\"#边界条件\" class=\"headerlink\" title=\"边界条件\"></a>边界条件</h4><p>数组可以为空也可以长度为0，都要考虑</p>\n<pre><code class=\"plain\">if(nums==null||nums.length==0)&#123;\n     return 0;\n &#125;\n</code></pre>\n<h4 id=\"新建包含一定元素的可变数组\"><a href=\"#新建包含一定元素的可变数组\" class=\"headerlink\" title=\"新建包含一定元素的可变数组\"></a>新建包含一定元素的可变数组</h4><pre><code class=\"plain\">int[] ans=new int[]&#123;1,1,1&#125;;\n \n Arrays.asList(nums[i],nums[j],nums[k]);\n</code></pre>\n<h4 id=\"数组排序\"><a href=\"#数组排序\" class=\"headerlink\" title=\"数组排序\"></a>数组排序</h4><pre><code class=\"plain\">1、Arrays.sort(a, Collections.reverseOrder());//a需要是Integer\n 2、实现Comparator接口 复写compare方法 return o2 - o1;\n</code></pre>\n<h2 id=\"59-螺旋矩阵-II（√）\"><a href=\"#59-螺旋矩阵-II（√）\" class=\"headerlink\" title=\"59 螺旋矩阵 II（√）\"></a>59 螺旋矩阵 II（√）</h2><p>给你一个正整数 n ，生成一个包含 1 到 n2 所有元素，且元素按顺时针顺序螺旋排列的 n x n 正方形矩阵 matrix\t</p>\n<p>遍历，边界记得变化一下</p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/image-20221013000130186.png\" alt=\"img\"></p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/image-20221013000449047.png\" alt=\"img\"></p>\n<pre><code class=\"plain\">class Solution &#123;\n     public int[][] generateMatrix(int n) &#123;\n         int l = 0, r = n - 1, t = 0, b = n - 1;\n         int[][] mat = new int[n][n];\n         int num = 1, tar = n * n;\n         while(num &lt;= tar)&#123;\n             //先mat[t][i] = num  再num++\n             for(int i = l; i &lt;= r; i++) mat[t][i] = num++; // left to right.\n             //for循环外面做t++\n             t++;\n             for(int i = t; i &lt;= b; i++) mat[i][r] = num++; // top to bottom.\n             r--;\n             for(int i = r; i &gt;= l; i--) mat[b][i] = num++; // right to left.\n             b--;\n             for(int i = b; i &gt;= t; i--) mat[i][l] = num++; // bottom to top.\n             l++;\n         &#125;\n         return mat;\n     &#125;\n &#125;\n</code></pre>\n<h2 id=\"最短无序连续子数组（√）\"><a href=\"#最短无序连续子数组（√）\" class=\"headerlink\" title=\"最短无序连续子数组（√）\"></a>最短无序连续子数组（√）</h2><p>给你一个整数数组 nums ，你需要找出一个 连续子数组 ，如果对这个子数组进行升序排序，那么整个数组都会变为升序排序。</p>\n<p>请你找出符合题意的 最短 子数组，并输出它的长度。</p>\n<p>1、遍历找排序入口和排序出口</p>\n<p>2、中间找最大最小值</p>\n<p>3、遍历找左边小于min的值，找右边大于max值</p>\n<p>4、结果</p>\n<pre><code class=\"plain\">class Solution &#123;\n     public int findUnsortedSubarray(int[] nums) &#123;\n         int n = nums.length;\n         int max = Integer.MIN_VALUE, min = Integer.MAX_VALUE;\n         int left = 0, right = 0;\n         //找到排序的入口\n         //注意数组越界\n         for(int i = 1; i &lt; n; i++)&#123;\n             if(nums[i] &lt; nums[i - 1])&#123;\n                 left = i - 1;//记录严格升序的最后一个元素\n                 break;\n             &#125;\n         &#125;\n         //找到排序的出口\n         for(int i = n - 1; i &gt; 0; i--)&#123;\n             if(nums[i] &lt; nums[i - 1])&#123;\n                 right = i;//记录严格升序的第一个元素\n                 break;\n             &#125;\n         &#125;\n         //找到最大最小值\n         for(int i = left; i &lt;= right; i++)&#123;\n             max = Math.max(nums[i], max);\n             min = Math.min(nums[i], min);\n         &#125;\n         //l向左扩展，r向右扩展\n         //找到比Min小的 因为max min 已经是在l-r里面产生，因此需要从l-1 r+1开始比较\n         while(left &gt; 0 &amp;&amp; nums[left - 1] &gt; min) left --;\n         //找到比max大的\n         while(right &lt; n - 1 &amp;&amp; nums[right + 1] &lt; max) right ++;\n         if(left == right) return 0;//决定了我的初始l r的取值就得是0 0\n         return right - left + 1;\n     &#125;\n &#125;\n</code></pre>\n<h2 id=\"寻找重复数（√）\"><a href=\"#寻找重复数（√）\" class=\"headerlink\" title=\"寻找重复数（√）\"></a>寻找重复数（√）</h2><p>给定一个包含 n + 1 个整数的数组 nums ，其数字都在 [1, n] 范围内（包括 1 和 n），可知至少存在一个重复的整数。</p>\n<p>假设 nums 只有 一个重复的整数 ，返回 这个重复的数 。</p>\n<p>你设计的解决方案必须 不修改 数组 nums 且只用常量级 O(1) 的额外空间。</p>\n<p><strong>快慢指针(floyd判圈算法)</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/image-20220923113728679.png\" alt=\"img\"></p>\n<p><strong>结论：不管是什么数据结构，用上快慢指针，快慢指针相遇之后，把slow放起点，两个指针同时移动，必然于入环点相遇，也就是答案，包括之前的环形链表II</strong></p>\n<pre><code class=\"plain\">class Solution &#123;\n     public int findDuplicate(int[] nums) &#123;\n         int slow = 0, fast = 0;\n         //初始化随便写\n         slow=nums[slow];\n         fast=nums[nums[fast]];\n         //不用单独建环，思路就是环的思想，数组里面快慢指针不能像像链表那样next next.next，但我们想象有i-&gt;nums[i]的边，也就与链表无异了,即  nums[slow]   nums[nums[fast]]\n         while(fast!=slow)&#123;\n             slow=nums[slow];\n             fast=nums[nums[fast]];  \n         &#125;\n         slow = 0;//相遇之后的骚操作     slow 回到起点\n         while (slow != fast) &#123;\n             slow = nums[slow];\n             fast = nums[fast];\n         &#125;\n         //此时slow和fast相等 因此重复元素必然就是slow 直接返回即可\n         return slow;\n     &#125;\n &#125;\n</code></pre>\n<h2 id=\"移动零\"><a href=\"#移动零\" class=\"headerlink\" title=\"移动零\"></a>移动零</h2><pre><code class=\"plain\">输入: nums = [0,1,0,3,12]\n 输出: [1,3,12,0,0]\n</code></pre>\n<p>我的思路：双指针，左右指针都指向数组最左侧，左指针找到第一个为0的数字，右指针往右找到第一个非0数字，交换，注意边界条件，<strong>很Tm烦人</strong> 不可取</p>\n<pre><code class=\"plain\">class Solution &#123;\n     public void moveZeroes(int[] nums) &#123;\n         int n=nums.length,left=0,right=0;\n         //left到倒数第二个的时候已经没必要继续下去\n         while(left&lt;n-1)&#123;\n             if(nums[left]==0)&#123;\n                 right=left+1; \n                 while(right&lt;n&amp;&amp;nums[right]==0)&#123;\n                     right++;\n                     //有可能right=n-1且nums[n-1]=0，防止right出界 swap函数数组越界\n                     if(right&gt;=n) return;\n                 &#125;\n                 swap(nums,left,right);\n             &#125;\n             left++;\n         &#125;\n \n     &#125;\n     public void swap(int[] nums,int i,int j)&#123;\n             int tmp=nums[i];\n             nums[i]=nums[j];\n             nums[j]=tmp;\n     &#125;\n &#125;\n</code></pre>\n<p>代码随想录方法</p>\n<p><strong>双指针</strong> （推荐这个） slow指针存元素 fast管遍历&#x3D;&#x3D;</p>\n<pre><code class=\"plain\">public void moveZeroes(int[] nums) &#123;\n         int slow = 0;\n     //   fast用来遍历，nums[fast] != 0的话，slow就存储nums[fast]\n         for (int fast = 0; fast &lt; nums.length; fast++) &#123;\n             if (nums[fast] != 0) &#123;\n                 nums[slow++] = nums[fast];\n             &#125;\n         &#125;\n         // 后面的元素全变成 0\n         for (int j = slow; j &lt; nums.length; j++) &#123;\n             nums[j] = 0;\n         &#125;\n     &#125;\n</code></pre>\n<h2 id=\"除自身以外数组的乘积（√）\"><a href=\"#除自身以外数组的乘积（√）\" class=\"headerlink\" title=\"除自身以外数组的乘积（√）\"></a>除自身以外数组的乘积（√）</h2><p>题目：给你一个整数数组 nums，返回 <em>数组</em> <em>answer</em> <em>，其中</em> <em>answer[i]</em> <em>等于</em> <em>nums</em> <em>中除</em> <em>nums[i]</em> <em>之外其余各元素的乘积</em> 。</p>\n<p>给定两个概念，L数组 R数组</p>\n<p>L[i] 代表的是 i 左侧所有数字的乘积，R[i] 代表的是 i 右侧所有数字的乘积。</p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/image-20220920154818329.png\" alt=\"img\"></p>\n<p>改进算法：空间复杂度 O(1) 的方法</p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/image-20220920154907687.png\" alt=\"img\"></p>\n<pre><code class=\"plain\">//我的代码\n class Solution &#123;\n     public int[] productExceptSelf(int[] nums) &#123;\n         int[] answer=new int[nums.length];\n         int L=1;\n         answer[0]=1;//显而易见\n         //L数组\n         for(int i=1;i&lt;nums.length;i++)&#123;\n             answer[i]=nums[i-1]*L;\n             L=L*nums[i-1];\n         &#125;\n         //i=num.length-1不用变\n         int R=1;\n         for(int i=nums.length-2;i&gt;=0;i--)&#123;\n             R=R*nums[i+1];\n             answer[i]=answer[i]*R;\n         &#125;\n         return answer;\n     &#125;\n &#125;\n</code></pre>\n<h2 id=\"滚动数组\"><a href=\"#滚动数组\" class=\"headerlink\" title=\"滚动数组\"></a>滚动数组</h2><p>结果只和前两个数据有关系，可以采用滚动数组，复杂度可以从O（n)降低到O（1）；</p>\n<h2 id=\"多数元素（√）\"><a href=\"#多数元素（√）\" class=\"headerlink\" title=\"多数元素（√）\"></a>多数元素（√）</h2><p>给定一个大小为 n 的数组 nums ，返回其中的多数元素。多数元素是指在数组中出现次数 大于 ⌊ n&#x2F;2 ⌋ 的元素。</p>\n<p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/image-20220917190606201.png\" alt=\"img\"></p>\n<pre><code class=\"plain\">class Solution &#123;\n     private Map&lt;Integer, Integer&gt; countNums(int[] nums) &#123;\n         Map&lt;Integer, Integer&gt; counts = new HashMap&lt;Integer, Integer&gt;();\n         for (int num : nums) &#123;\n             //不包含设为1 包含就加一\n             if (!counts.containsKey(num)) &#123;\n                 counts.put(num, 1);\n             &#125; else &#123;\n                 counts.put(num, counts.get(num) + 1);\n             &#125;\n         &#125;\n         return counts;\n     &#125;\n \n     public int majorityElement(int[] nums) &#123;\n         Map&lt;Integer, Integer&gt; counts = countNums(nums);\n \n         Map.Entry&lt;Integer, Integer&gt; majorityEntry = null;//定义一下\n         for (Map.Entry&lt;Integer, Integer&gt; entry : counts.entrySet()) &#123;\n             //打擂台，挑选出value最大的entry作为majorityEntry\n             //这里要加majorityEntry == null的原因是防止出现NullPointerException，majorityEntry为Null时， majorityEntry.getValue()无法执行\n             if (majorityEntry == null || entry.getValue() &gt; majorityEntry.getValue()) &#123;\n                 majorityEntry = entry;\n             &#125;\n         &#125;\n \n         return majorityEntry.getKey();\n     &#125;\n &#125;\n</code></pre>\n<p>推荐这个快一点</p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/image-20220911115300392.png\" alt=\"img\"></p>\n<p>但这个复杂度是nlog(n)</p>\n<h3 id=\"方法五\"><a href=\"#方法五\" class=\"headerlink\" title=\"方法五\"></a>方法五</h3><h4 id=\"Boyer-Moore-投票算法\"><a href=\"#Boyer-Moore-投票算法\" class=\"headerlink\" title=\"Boyer-Moore 投票算法\"></a>Boyer-Moore 投票算法</h4><p>我们维护一个候选众数 candidate 和它出现的次数 count。初始时 candidate 可以为任意值，count 为 0；</p>\n<p>我们遍历数组 nums 中的所有元素，对于每个元素 x，在判断 x 之前，如果 count 的值为 0，我们先将 x 的值赋予 candidate，随后我们判断 x：</p>\n<p>​\t如果 x 与 candidate 相等，那么计数器 count 的值增加 1；</p>\n<p>​\t如果 x 与 candidate 不等，那么计数器 count 的值减少 1。</p>\n<p>在遍历完成后，candidate 即为整个数组的众数。</p>\n<pre><code class=\"plain\">class Solution &#123;\n     public int majorityElement(int[] nums) &#123;\n         int count = 0;\n         Integer candidate = null;\n         for (int num : nums) &#123;\n             if (count == 0) &#123;\n                 candidate = num;\n             &#125;\n             count += (num == candidate) ? 1 : -1;\n         &#125;\n         return candidate;\n     &#125;\n &#125;\n</code></pre>\n<h2 id=\"搜索二维矩阵（Z查找）（√）\"><a href=\"#搜索二维矩阵（Z查找）（√）\" class=\"headerlink\" title=\"搜索二维矩阵（Z查找）（√）\"></a>搜索二维矩阵（Z查找）（√）</h2><p>编写一个高效的算法来搜索 m x n 矩阵 matrix 中的一个目标值 target 。该矩阵具有以下特性：</p>\n<p>每行的元素从左到右升序排列。 每列的元素从上到下升序排列。</p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/searchgrid2.jpg\" alt=\"img\"></p>\n<p><strong>方法一</strong></p>\n<p>直接查找 复杂度O（mn）</p>\n<pre><code class=\"plain\">class Solution &#123;\n     public boolean searchMatrix(int[][] matrix, int target) &#123;\n         for (int[] row : matrix) &#123;\n             for (int element : row) &#123;\n                 if (element == target) &#123;\n                     return true;\n                 &#125;\n             &#125;\n         &#125;\n         return false;\n     &#125;\n &#125;\n</code></pre>\n<p><strong>方法二：</strong></p>\n<p>二分</p>\n<pre><code class=\"plain\">class Solution &#123;\n     public boolean searchMatrix(int[][] matrix, int target) &#123;\n         for (int[] row : matrix) &#123;\n             int index = search(row, target);\n             if (index &gt;= 0) &#123;\n                 return true;\n             &#125;\n         &#125;\n         return false;\n     &#125;\n \n     public int search(int[] nums, int target) &#123;\n         int low = 0, high = nums.length - 1;\n         while (low &lt;= high) &#123;\n             int mid = (high - low) / 2 + low;\n             int num = nums[mid];\n             if (num == target) &#123;\n                 return mid;\n             &#125; else if (num &gt; target) &#123;\n                 high = mid - 1;\n             &#125; else &#123;\n                 low = mid + 1;\n             &#125;\n         &#125;\n         return -1;\n     &#125;\n &#125;\n</code></pre>\n<p><strong>方法三（掌握这个）</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/image-20220921123558099.png\" alt=\"img\"></p>\n<p>我的理解：必须从右上角开始搜索，保证我搜索到的元素在行是最大值，在列是小值，因此如果我元素大于target，则列的最小值大于target（整个列都大于target），列–；小于target，则列的最大值小于target(整个行小于target)，行++</p>\n<pre><code class=\"plain\">class Solution &#123;\n     public boolean searchMatrix(int[][] matrix, int target) &#123;\n         int m = matrix.length, n = matrix[0].length;\n         int x = 0, y = n - 1;\n         while (x &lt; m &amp;&amp; y &gt;= 0) &#123;\n             if (matrix[x][y] == target) &#123;\n                 return true;\n             &#125;\n             if (matrix[x][y] &gt; target) &#123;\n                 --y;\n             &#125; else &#123;\n                 ++x;\n             &#125;\n         &#125;\n         return false;\n     &#125;\n &#125;\n</code></pre>\n<h2 id=\"空间时间复杂度\"><a href=\"#空间时间复杂度\" class=\"headerlink\" title=\"空间时间复杂度\"></a>空间时间复杂度</h2><p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/image-20221001122257963.png\" alt=\"img\"></p>\n<h2 id=\"有多少小于当前数字的数字\"><a href=\"#有多少小于当前数字的数字\" class=\"headerlink\" title=\"有多少小于当前数字的数字\"></a>有多少小于当前数字的数字</h2><p>给你一个数组 nums，对于其中每个元素 nums[i]，请你统计数组中比它小的所有数字的数目。</p>\n<p>换而言之，对于每个 nums[i] 你必须计算出有效的 j 的数量，其中 j 满足 j !&#x3D; i<strong>且</strong>nums[j] &lt; nums[i] 。</p>\n<p>以数组形式返回答案。</p>\n<p>题解：</p>\n<pre><code class=\"plain\">class Solution &#123;\n     public int[] smallerNumbersThanCurrent(int[] nums) &#123;\n         [8,1,2,2,3]\n         Map&lt;Integer,Integer&gt; map=new HashMap&lt;&gt;();\n         //copy nums的值到res\n         int[] res=Arrays.copyOf(nums,nums.length);//[I@7e774085 不能这样(int[] res=nums)拷贝数据  只是一个引用\n         Arrays.sort(res); //1，2，2，3，8\n         for(int i=0;i&lt;res.length;i++)&#123;\n             if(!map.containsKey(res[i]))&#123;\n                 map.put(res[i],i);  (1,0)  (2,1)  (3,3)  (8,4)\n             &#125;\n         &#125;\n         for(int i=0;i&lt;nums.length;i++)&#123;\n             res[i]=map.get(nums[i]);\n             4 0 1 1 3\n         &#125;\n         return res;\n     &#125;\n &#125;\n</code></pre>\n<h2 id=\"有效的山脉数组\"><a href=\"#有效的山脉数组\" class=\"headerlink\" title=\"有效的山脉数组\"></a>有效的山脉数组</h2><p>给定一个整数数组 arr，如果它是有效的山脉数组就返回 true，否则返回 false。</p>\n<p>让我们回顾一下，如果 arr 满足下述条件，那么它是一个山脉数组</p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/hint_valid_mountain_array.png\" alt=\"img\"></p>\n<p><strong>思路</strong></p>\n<p>判断是山峰，主要就是要严格的保存左边到中间，和右边到中间是递增的。</p>\n<p>这样可以使用两个指针，left和right，让其按照如下规则移动，如图：</p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/941.%E6%9C%89%E6%95%88%E7%9A%84%E5%B1%B1%E8%84%89%E6%95%B0%E7%BB%84.png\" alt=\"img\"></p>\n<p><strong>注意这里还是有一些细节，例如如下两点：</strong></p>\n<ul>\n<li>因为left和right是数组下标，移动的过程中注意不要数组越界</li>\n<li>如果left或者right没有移动，说明是一个单调递增或者递减的数组，依然不是山峰</li>\n</ul>\n<pre><code class=\"plain\">class Solution &#123;\n     public boolean validMountainArray(int[] arr) &#123;\n         // 双指针\n         int n=arr.length;\n         int left=0,right=n-1;\n         while(left+1&lt;n&amp;&amp;arr[left]&lt;arr[left+1])&#123;\n             left++;\n         &#125;\n         while(right-1&gt;=0&amp;&amp;arr[right]&lt;arr[right-1])&#123;\n             right--;\n         &#125;\n         if(right==left&amp;&amp;right!=n-1&amp;&amp;left!=0)&#123;\n             return true;\n         &#125;       \n         return false;\n     &#125;\n &#125;\n</code></pre>\n<h2 id=\"独一无二的出现次数\"><a href=\"#独一无二的出现次数\" class=\"headerlink\" title=\"独一无二的出现次数\"></a>独一无二的出现次数</h2><p>给你一个整数数组 arr，请你帮忙统计数组中每个数的出现次数。</p>\n<p>如果每个数的出现次数都是独一无二的，就返回 true；否则返回 false。</p>\n<pre><code class=\"plain\">class Solution &#123;\n     public boolean uniqueOccurrences(int[] arr) &#123;   \n         Set&lt;Integer&gt; set=new HashSet&lt;&gt;();\n         Map&lt;Integer,Integer&gt; map=new HashMap&lt;&gt;();\n         //统计一下\n         for(int a:arr)&#123;\n             map.put(a,map.getOrDefault(a,0)+1);\n         &#125;  \n         //验证value是否重复    values()是所有value的集合\n         for(int b:map.values())&#123;\n             if(!set.add(b)) return false;\n         &#125;\n         return true;\n \n     &#125;\n &#125;\n</code></pre>\n<h2 id=\"轮转数组\"><a href=\"#轮转数组\" class=\"headerlink\" title=\"轮转数组\"></a>轮转数组</h2><p>给你一个数组，将数组中的元素向右轮转 k 个位置，其中 k 是非负数。</p>\n<pre><code class=\"plain\">输入: nums = [1,2,3,4,5,6,7], k = 3\n 输出: [5,6,7,1,2,3,4]\n 解释:\n 向右轮转 1 步: [7,1,2,3,4,5,6]\n 向右轮转 2 步: [6,7,1,2,3,4,5]\n 向右轮转 3 步: [5,6,7,1,2,3,4]\n</code></pre>\n<p>我的思路</p>\n<pre><code class=\"plain\">class Solution &#123;\n     public void rotate(int[] nums, int k) &#123;\n         int n=nums.length;\n         //不是原地操作\n         int[] value=Arrays.copyOf(nums,n);\n         for(int i=0;i&lt;n;i++)&#123;\n             nums[i]=value[(n-k%n+i)%n];\n         &#125;\n     &#125;\n &#125;\n</code></pre>\n<p>原地操作</p>\n<p><strong>双指针</strong></p>\n<ol>\n<li>反转整个字符串</li>\n<li>反转区间为前k的子串</li>\n<li>反转区间为k到末尾的子串</li>\n</ol>\n<p><strong>如果k大于nums.size了应该怎么办？其实就是右移 k % nums.size() 次，即：15 % 7 &#x3D; 1</strong></p>\n<pre><code class=\"plain\">class Solution &#123;\n     public void rotate(int[] nums, int k) &#123;\n         int n=nums.length;\n         k%=n;\n         reverse(nums,0,n-1);\n         reverse(nums,0,k-1);\n         reverse(nums,k,n-1);\n     &#125;\n     public void reverse(int[] nums,int left,int right)&#123;\n         for(int i=left,j=right;i&lt;j;i++,j--)&#123;\n             int temp=nums[i];\n             nums[i]=nums[j];\n             nums[j]=temp;\n         &#125;\n     &#125;\n &#125;\n</code></pre>\n<h2 id=\"寻找数组的中心下标\"><a href=\"#寻找数组的中心下标\" class=\"headerlink\" title=\"寻找数组的中心下标\"></a>寻找数组的中心下标</h2><p>给你一个整数数组 nums ，请计算数组的 <strong>中心下标</strong> 。</p>\n<p>数组 <strong>中心下标</strong> 是数组的一个下标，其左侧所有元素相加的和等于右侧所有元素相加的和。</p>\n<p>如果中心下标位于数组最左端，那么左侧数之和视为 0 ，因为在下标的左侧不存在元素。这一点对于中心下标位于数组最右端同样适用。</p>\n<p>如果数组有多个中心下标，应该返回 <strong>最靠近左边</strong> 的那一个。如果数组不存在中心下标，返回 -1 。</p>\n<pre><code class=\"plain\">class Solution &#123;\n     public int pivotIndex(int[] nums) &#123;\n         int n=nums.length;\n         int sum=0;\n         //计算总和\n         for(int i=0;i&lt;n;i++)&#123;\n             sum+=nums[i];\n         &#125;\n         //左总和\n         int sum_left=0;\n         for(int i=0;i&lt;n;i++)&#123;\n             //sum-当前元素值等于2倍的左总和  那么找到\n             if(sum-nums[i]==2*sum_left)&#123;\n                 return i;\n             &#125;\n             sum_left+=nums[i];\n         &#125;\n         return -1;\n     &#125;\n &#125;\n</code></pre>\n<h2 id=\"在排序数组中查找元素的第一个和最后一个位置\"><a href=\"#在排序数组中查找元素的第一个和最后一个位置\" class=\"headerlink\" title=\"在排序数组中查找元素的第一个和最后一个位置\"></a>在排序数组中查找元素的第一个和最后一个位置</h2><p>给你一个按照非递减顺序排列的整数数组 nums，和一个目标值 target。请你找出给定目标值在数组中的开始位置和结束位置。</p>\n<p>如果数组中不存在目标值 target，返回 [-1, -1]。</p>\n<p>你必须设计并实现时间复杂度为 O(log n) 的算法解决此问题。</p>\n<pre><code class=\"plain\">class Solution &#123;\n         public int[] searchRange(int[] nums, int target) &#123;\n             int l = searh(nums, target);\n             int r = searh(nums, target + 1);//很妙\n             //if语句第一个边界条件是空数组 第二个是数组无target\n             if (l == nums.length || nums[l] != target) &#123;\n                 return new int[]&#123;-1,-1&#125;;\n             &#125; else &#123;\n                 return new int[]&#123;l,r-1&#125;;\n             &#125;\n         &#125;\n         public int searh(int[] nums, int target) &#123;\n             int l = 0, r = nums.length - 1, ans = nums.length;\n             while (l &lt;= r) &#123;\n                 int mid = (l + r) / 2;\n                 if (nums[mid] &gt;= target) &#123;\n                     r = mid - 1;\n                 &#125; else &#123;\n                     l = mid + 1;\n                 &#125;\n                 ans = l;\n             &#125;\n             return ans;\n         &#125;\n \n     &#125;\n</code></pre>\n<h2 id=\"按奇偶排序数组-II\"><a href=\"#按奇偶排序数组-II\" class=\"headerlink\" title=\"按奇偶排序数组 II\"></a>按奇偶排序数组 II</h2><p>给定一个非负整数数组 nums， nums 中一半整数是 <strong>奇数</strong> ，一半整数是 <strong>偶数</strong> 。</p>\n<p>对数组进行排序，以便当 nums[i] 为奇数时，i 也是 <strong>奇数</strong> ；当 nums[i] 为偶数时， i 也是 <strong>偶数</strong> 。</p>\n<p>你可以返回 <em>任何满足上述条件的数组作为答案</em></p>\n<pre><code class=\"plain\">//方法一：采用额外的数组空间\n class Solution &#123;\n     public int[] sortArrayByParityII(int[] nums) &#123;\n         //定义结果数组 result\n         int[] result = new int[nums.length];\n         int even = 0, odd = 1;\n         for(int i = 0; i &lt; nums.length; i++)&#123;\n             //如果为偶数\n             if(nums[i] % 2 == 0)&#123;\n                 result[even] = nums[i];\n                 even += 2;\n             &#125;else&#123;\n                 result[odd] = nums[i];\n                 odd += 2;\n             &#125;\n         &#125;\n         return result;\n     &#125;\n &#125;\n</code></pre>\n<h2 id=\"搜索插入位置\"><a href=\"#搜索插入位置\" class=\"headerlink\" title=\"搜索插入位置\"></a>搜索插入位置</h2><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p>\n<p>请必须使用时间复杂度为 O(log n) 的算法。</p>\n<p><strong>题解:</strong></p>\n<p>只要看到面试题里给出的数组是有序数组，都可以想一想是否可以使用二分法。</p>\n<pre><code class=\"plain\">class Solution &#123;\n     public int searchInsert(int[] nums, int target) &#123;\n         int l=0,r=nums.length-1;\n         while(l&lt;=r)&#123;\n             int mid=l+(r-l)/2;\n             if(nums[mid]&gt;target)&#123;\n                 r=mid-1;\n             &#125;else if(nums[mid]&lt;target)&#123;\n                 l=mid+1;\n             &#125;else&#123;\n                 return mid;\n             &#125;\n         &#125;\n         return r+1;\n     &#125;\n &#125;\n</code></pre>\n","categories":["八股"]},{"title":"模拟","url":"/2023/06/04/%E6%A8%A1%E6%8B%9F/","content":"<h2 id=\"任务调度器\"><a href=\"#任务调度器\" class=\"headerlink\" title=\"任务调度器\"></a>任务调度器</h2><h2 id=\"方法一：模拟\"><a href=\"#方法一：模拟\" class=\"headerlink\" title=\"方法一：模拟\"></a>方法一：模拟</h2><p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/image-20221012192843953.png\" alt=\"img\"></p>\n<span id=\"more\"></span>\n\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/image-20221012192916861.png\" alt=\"img\"></p>\n<p>此处对于”我们应当选择剩余执行次数最多的那个任务“的证明忽略</p>\n<pre><code class=\"plain\">class Solution &#123;\n          public int leastInterval(char[] tasks, int n) &#123;\n              Map&lt;Character, Integer&gt; freq = new HashMap&lt;Character, Integer&gt;();\n              for (char ch : tasks) &#123;\n                  freq.put(ch, freq.getOrDefault(ch, 0) + 1);\n              &#125;\n\n              // 任务总数\n              int m = freq.size();\n              //最早有效时间\n              List&lt;Integer&gt; nextValid = new ArrayList&lt;Integer&gt;();\n              List&lt;Integer&gt; rest = new ArrayList&lt;Integer&gt;();\n              Set&lt;Map.Entry&lt;Character, Integer&gt;&gt; entrySet = freq.entrySet();\n              for (Map.Entry&lt;Character, Integer&gt; entry : entrySet) &#123;\n                  int value = entry.getValue();\n                  //初始为1\n                  nextValid.add(1);\n                  rest.add(value);\n              &#125;\n\n              int time = 0;\n              for (int i = 0; i &lt; tasks.length; ++i) &#123;\n                  ++time;\n//                  将 time更新为所有nextValid中的最小值，直接「跳过」待命状态  最小值代表最早有效时间，前面肯定是冷却时间\n                  int minNextValid = Integer.MAX_VALUE;\n                  for (int j = 0; j &lt; m; ++j) &#123;\n                      //剩余任务不为0时\n                      if (rest.get(j) != 0) &#123;\n                          minNextValid = Math.min(minNextValid, nextValid.get(j));\n                      &#125;\n                  &#125;\n                  time = Math.max(time, minNextValid);\n                  //寻找不在冷却中的，剩余执行次数最多的任务\n                  int best = -1;\n                  for (int j = 0; j &lt; m; ++j) &#123;\n                      if (rest.get(j) != 0 &amp;&amp; nextValid.get(j) &lt;= time) &#123;\n                          if (best == -1 || rest.get(j) &gt; rest.get(best)) &#123;\n                              best = j;\n                          &#125;\n                      &#125;\n                  &#125;\n                  //赋值z\n                  nextValid.set(best, time + n + 1);\n                  rest.set(best, rest.get(best) - 1);\n              &#125;\n\n              return time;\n          &#125;\n      &#125;\n</code></pre>\n<p>方法一代码量太多 不想写</p>\n<h2 id=\"方法二：构造\"><a href=\"#方法二：构造\" class=\"headerlink\" title=\"方法二：构造\"></a>方法二：构造</h2><p>构造n+1列矩阵，每个格子代表一个时间，行优先，也就是先第一行再第二行，记需要执行maxExec次(任务数最多的任务的数量)任务数量为maxCount,如图，maxExec就是5，maxCount为3，因此总时间为(maxExec−1)(n+1)+maxCount</p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/image-20221012195808588.png\" alt=\"img\"></p>\n<p>对于小于maxExec的任务如下图：</p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/image-20221012200212774.png\" alt=\"img\"></p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/image-20221012200347122.png\" alt=\"img\"></p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/image-20221012200357248.png\" alt=\"img\"></p>\n<pre><code class=\"plain\">class Solution &#123;\n    public int leastInterval(char[] tasks, int n) &#123;\n        Map&lt;Character, Integer&gt; freq = new HashMap&lt;Character, Integer&gt;();\n        // 最多的执行次数\n        int maxExec = 0;\n        for (char ch : tasks) &#123;\n            int exec = freq.getOrDefault(ch, 0) + 1;\n            freq.put(ch, exec);\n            maxExec = Math.max(maxExec, exec);\n        &#125;\n\n        // 具有最多执行次数的任务数量\n        int maxCount = 0;\n        //这一句可以不要\n        //Set&lt;Map.Entry&lt;Character, Integer&gt;&gt; entrySet = freq.entrySet();\n        for (Map.Entry&lt;Character, Integer&gt; entry : entrySet) &#123;\n            int value = entry.getValue();\n            if (value == maxExec) &#123;\n                ++maxCount;\n            &#125;\n        &#125;\n\n        return Math.max((maxExec - 1) * (n + 1) + maxCount, tasks.length);\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"机器人能否返回原点\"><a href=\"#机器人能否返回原点\" class=\"headerlink\" title=\"机器人能否返回原点\"></a>机器人能否返回原点</h2><p>在二维平面上，有一个机器人从原点 (0, 0) 开始。给出它的移动顺序，判断这个机器人在完成移动后是否在 <strong>(0, 0)</strong> <strong>处结束</strong>。</p>\n<p>移动顺序由字符串 moves 表示。字符 move[i] 表示其第 i 次移动。机器人的有效动作有 R（右），L（左），U（上）和 D（下）。</p>\n<p>如果机器人在完成所有动作后返回原点，则返回 true。否则，返回 false。</p>\n<p><strong>注意：</strong>机器人“面朝”的方向无关紧要。 “R” 将始终使机器人向右移动一次，“L” 将始终向左移动等。此外，假设每次移动机器人的移动幅度相同。</p>\n<p>自己写的</p>\n<pre><code class=\"plain\">class Solution &#123;\n    public boolean judgeCircle(String moves) &#123;\n        int x=0,y=0;\n        for(int i=0;i&lt;moves.length();i++)&#123;\n            switch(moves.charAt(i))&#123;\n                case &#39;R&#39;:\n                x++;\n                break;\n\n                case &#39;L&#39;:\n                x--;\n                break;\n\n                case &#39;U&#39;:\n                y++;\n                break;\n\n                case &#39;D&#39;:\n                y--;\n                break;   \n\n                default:             \n            &#125;\n        &#125;\n        return (x==0&amp;&amp;y==0);\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"下一个排列\"><a href=\"#下一个排列\" class=\"headerlink\" title=\"下一个排列\"></a>下一个排列</h2><p>整数数组的一个 <strong>排列</strong> 就是将其所有成员以序列或线性顺序排列。</p>\n<ul>\n<li>例如，arr &#x3D; [1,2,3] ，以下这些都可以视作 arr 的排列：[1,2,3]、[1,3,2]、[3,1,2]、[2,3,1] 。</li>\n</ul>\n<p>整数数组的 <strong>下一个排列</strong> 是指其整数的下一个字典序更大的排列。更正式地，如果数组的所有排列根据其字典顺序从小到大排列在一个容器中，那么数组的 <strong>下一个排列</strong> 就是在这个有序容器中排在它后面的那个排列。如果不存在下一个更大的排列，那么这个数组必须重排为字典序最小的排列（即，其元素按升序排列）。</p>\n<ul>\n<li>例如，arr &#x3D; [1,2,3] 的下一个排列是 [1,3,2] 。</li>\n<li>类似地，arr &#x3D; [2,3,1] 的下一个排列是 [3,1,2] 。</li>\n<li>而 arr &#x3D; [3,2,1] 的下一个排列是 [1,2,3] ，因为 [3,2,1] 不存在一个字典序更大的排列。</li>\n</ul>\n<p>给你一个整数数组 nums ，找出 nums 的下一个排列。</p>\n<p>必须<a href=\"https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95\">原地</a>修改，只允许使用额外常数空间。</p>\n<p>题解：下一个更大排列就是从后往前找比当前小的那个元素 交换 然后后面升序排列</p>\n<pre><code class=\"plain\">1 2 3 4\n1 2 4 3\n1 3 2 4\n1 3 4 2\nclass Solution &#123;\n    public void nextPermutation(int[] nums) &#123;\n        for (int i = nums.length - 1; i &gt;= 0; i--) &#123;\n            for (int j = nums.length - 1; j &gt; i; j--) &#123;\n                //后面要比前面大\n                if (nums[j] &gt; nums[i]) &#123;\n                    // 交换\n                    int temp = nums[i];\n                    nums[i] = nums[j];\n                    nums[j] = temp;\n                    // [i + 1, nums.length) 内元素升序排序\n                    Arrays.sort(nums, i + 1, nums.length);\n                    return;\n                &#125;\n            &#125;\n        &#125;\n        Arrays.sort(nums); // 不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。\n    &#125;\n&#125;\n</code></pre>\n<p>岛屿的周长</p>\n<p>给定一个 row x col 的二维网格地图 grid ，其中：grid[i][j] &#x3D; 1 表示陆地， grid[i][j] &#x3D; 0 表示水域。</p>\n<p>网格中的格子 <strong>水平和垂直</strong> 方向相连（对角线方向不相连）。整个网格被水完全包围，但其中恰好有一个岛屿（或者说，一个或多个表示陆地的格子相连组成的岛屿）。</p>\n<p>岛屿中没有“湖”（“湖” 指水域在岛屿内部且不和岛屿周围的水相连）。格子是边长为 1 的正方形。网格为长方形，且宽度和高度均不超过 100 。计算这个岛屿的周长。</p>\n<p>题解：</p>\n<p>遍历每一个空格，遇到岛屿，计算其上下左右的情况，遇到水域或者出界的情况，周长+1</p>\n<pre><code class=\"plain\">class Solution &#123;\n    // 上下左右 4 个方向\n    int[] dirx = &#123;-1, 1, 0, 0&#125;;\n    int[] diry = &#123;0, 0, -1, 1&#125;;\n\n    public int islandPerimeter(int[][] grid) &#123;\n        int m = grid.length;\n        int n = grid[0].length;\n        int res = 0; // 岛屿周长\n        for (int i = 0; i &lt; m; i++) &#123;\n            for (int j = 0; j &lt; n; j++) &#123;\n                if (grid[i][j] == 1) &#123;\n                    for (int k = 0; k &lt; 4; k++) &#123;\n                        int x = i + dirx[k];\n                        int y = j + diry[k];\n                        // 当前位置是陆地，并且从当前位置4个方向扩展的“新位置”是“水域”或“新位置“越界，则会为周长贡献一条边\n                        if (x &lt; 0 || x &gt;= m || y &lt; 0 || y &gt;= n || grid[x][y] == 0) &#123;\n                            res++;\n                            continue;\n                        &#125;\n                    &#125;\n                &#125;\n            &#125;\n        &#125;\n        return res;\n    &#125;\n&#125;\n</code></pre>\n","categories":["算法"]},{"title":"测开","url":"/2023/06/04/%E6%B5%8B%E5%BC%80/","content":"<h3 id=\"1-测试开发本质\"><a href=\"#1-测试开发本质\" class=\"headerlink\" title=\"1.测试开发本质\"></a>1.测试开发本质</h3><p>测试开发的本质是助力业务成功<span id=\"more\"></span></p>\n<h3 id=\"2-软件测试存在的意义\"><a href=\"#2-软件测试存在的意义\" class=\"headerlink\" title=\"2.软件测试存在的意义\"></a>2.软件测试存在的意义</h3><p>提前发现和定位错误。</p>\n<p>提前发现和定位错误之后呢？</p>\n<p>可以促进开发人员修正错误，从而保证交付的软件质量满足客户需求。</p>\n<p>提前发现和定位错误的重要性？</p>\n<p>越早发现软件中存在的问题，开发费用就越低，软件质量越高，维护费用越低。</p>\n<p>提前测试可以使得在需求分析时期就可发现的错误，不必等到开发完成后才被发现</p>\n<h3 id=\"3-高频-测试开发与测试的区别？\"><a href=\"#3-高频-测试开发与测试的区别？\" class=\"headerlink\" title=\"3.(高频)测试开发与测试的区别？\"></a>3.(高频)测试开发与测试的区别？</h3><p>软件测试是什么</p>\n<p>在规定的条件下对一个产品或者程序进行操作，以发现<strong>程序错误</strong>，<strong>衡量软件质量</strong>，并对其是<strong>否能满足设计要求</strong>进行评估的过程。</p>\n<p>软件测试工程师的任务</p>\n<p>软件测试工程师主要工作是检查软件<strong>是否有bug</strong>、是否具<strong>有稳定性</strong>，</p>\n<p>写出相应的<strong>测试计划、测试规范、测试用例、测试数据、测试报告</strong>，</p>\n<p>在项目中担任类似“质量管理的角色”，及时纠错及时更正，<strong>确保产品的正常运转</strong>。</p>\n<p>测试开发工程师的任务</p>\n<p>测试开发的核心职能依然是测试。</p>\n<p>只是工程师在具备测试经验、熟练使用测试工具并有一定开发能力的前提下，可以<strong>自主开发平台，</strong>或对现有的开源工具进行二次开发</p>\n<p>最<strong>终目的是提升产品的测试效率</strong>。</p>\n<p>测试开发与开发的联系</p>\n<p>测试开发是测试岗位衍生的一个分支，利用开发能力解决测试工作中的问题，</p>\n<p>小到生成数据、并发模拟等工具的开发，大到整个自动化测试平台的设计与实现，</p>\n<p>旨在提高效率，降低成本。</p>\n<h3 id=\"4-高频-为什么选择测试开发？\"><a href=\"#4-高频-为什么选择测试开发？\" class=\"headerlink\" title=\"4.(高频)为什么选择测试开发？\"></a>4.(高频)为什么选择测试开发？</h3><p>【岗位角度来说】</p>\n<p>从用户角度来说，现在的软件产品种类多样，已经可以满足用户大部分的基本需求了，对于同类产品，用户会更加关注产品的<strong>质量和服务</strong>，所以测试的发展前景是非常好的</p>\n<p>在产品研发中，提前发现和定位问题，对整个产品和质量和公司的成本都是非常重要的，测试人员的责任非常大。是非常重要的一个岗位</p>\n<p>【自己角度来说】(你的经历都是开发为什么会想到做测试？)</p>\n<p><strong>测开还有一部分开发工作，</strong>无论是自动化脚本还是测试工具或框架，都提高了测试的效率，为质量效率保证工作提供了有力的保障。</p>\n<p><strong>所以测开的所需技术广度也是很高，会激发我持续学习的态度。</strong></p>\n<p>并且来说，我目前<strong>具备了一些测开所必备的理论知识和技能并且还在不断地学习中，我认为我可以较快的胜任这个岗位</strong></p>\n<h3 id=\"5-中频-测试开发需要哪些知识和能力？\"><a href=\"#5-中频-测试开发需要哪些知识和能力？\" class=\"headerlink\" title=\"5.(中频)测试开发需要哪些知识和能力？\"></a>5.(中频)测试开发需要哪些知识和能力？</h3><p><strong>需要的知识：</strong></p>\n<p>软件测试基础理论知识，如黑盒测试、白盒测试等</p>\n<p>编程语言基础，如C&#x2F;C ++、java、python等</p>\n<p>自动化测试工具，如Selenium、Appium、Robotium等</p>\n<p>计算机基础知识，如数据库、Linux、计算机网络等</p>\n<p>测试框架，如JUnit等</p>\n<p><strong>需要具备的能力：</strong></p>\n<p>测试能力</p>\n<p>业务分析能力，分析被测系统<strong>架构</strong>、分析被测业务<strong>模块</strong>、分析整体业务<strong>流程</strong>、分析被测业务<strong>数据</strong>、分析测试所需资源、分析测试<strong>完成目标</strong>；</p>\n<p>缺陷洞察能力，<strong>一般缺陷</strong>的发现能力、<strong>隐形问题</strong>的发现能力、<strong>发现连带问题</strong>的能力、<strong>发现问题隐患</strong>的能力、<strong>尽早</strong>发现问题的能力、发现问题<strong>根源</strong>的能力</p>\n<p>宏观把控能力，有效制定测试<strong>计划</strong>、有效进行<strong>风险评估</strong>、有效控制测试<strong>时间</strong>、有效控制测试<strong>成本</strong>、有效控制<strong>测试方向。</strong></p>\n<p>个人能力</p>\n<p>专业技术能力，掌握测试基础知识、掌握计算机知识、熟练运用测试工具；</p>\n<p>逻辑思考能力，判断逻辑的正确性、对可行性逻辑分析、站在客观角度思考</p>\n<p>问题解决能力，技术上的问题、工作中的问题、沟通问题</p>\n<p>和团队</p>\n<p>沟通表达能力，和技术人员、产品人员、上下级的沟通</p>\n<p>团队协作能力，合理进行人员分工、协助组原解决问题、配合完成测试任务、配合开发重现缺陷、督促项目整体进度、出现问题勇于承担</p>\n<h3 id=\"6-软件测试的核心竞争力？\"><a href=\"#6-软件测试的核心竞争力？\" class=\"headerlink\" title=\"6.软件测试的核心竞争力？\"></a>6.软件测试的核心竞争力？</h3><p>测试人员的核心竞争力在于提早发现问题，并能够发现别人无法发现的问题。</p>\n<p>1.<strong>早发现问题</strong>：问题发现的越早，解决的成本越低。如果一个需求在还未实现的时候就能发现需求的漏洞，那么这种问题的价值是最高的</p>\n<p>2**.发现别人发现不了的问题**：所有人都能发现的问题，你发现了，那就证明你是可以被替代的。别人发现不了，而你可以发现，那么你就是无法被替代的</p>\n<h3 id=\"7-测试和开发如何结合才能使软件质量得到更好保障？\"><a href=\"#7-测试和开发如何结合才能使软件质量得到更好保障？\" class=\"headerlink\" title=\"7.测试和开发如何结合才能使软件质量得到更好保障？\"></a>7.测试和开发如何结合才能使软件质量得到更好保障？</h3><p>测试和开发应该按照W模型的方式进行结合，测试和开发同步进行，能够尽早发现软件缺陷，降低软件开发的成本。</p>\n<p><img src=\"https://pic3.zhimg.com/80/v2-cc8c88211b354ee21e531a93d5f05466_720w.webp\" alt=\"img\"></p>\n<p>什么是w模型</p>\n<p>测试伴随着整个软件开发周期，而且测试的对象不仅仅是程序，需求、设计等同样要测试，也就是说，测试与开发是同步进行的。</p>\n<p>w模型的优点</p>\n<p>W模型有利于尽早地全面的发现问题。例如，需求分析完成后，测试人员就应该参与到对需求的验证和确认活动中，以尽早地找出缺陷所在。同时，对需求的测试也有利于及时了解项目难度和测试风险，及早制定应对措施，这将显著减少总体测试时间，加快项目进度。</p>\n<p>w模型的缺点</p>\n<p>但W模型也存在局限性。在W模型中，需求、设计、编码等活动被视为串行的，</p>\n<p>测试和开发活动也保持着一种线性的前后关系，上一阶段完全结束，才可正式开始下一个阶段工作。</p>\n<p>这样就无法支持<a href=\"https://link.zhihu.com/?target=https://baike.baidu.com/item/%E8%BF%AD%E4%BB%A3/8415523\">迭代</a>的开发模型。对于当前软件开发复杂多变的情况，W模型并不能解除测试管理面临的困惑。</p>\n<h3 id=\"8-怎么看待软件测试的潜力和挑战？\"><a href=\"#8-怎么看待软件测试的潜力和挑战？\" class=\"headerlink\" title=\"8.怎么看待软件测试的潜力和挑战？\"></a>8.怎么看待软件测试的潜力和挑战？</h3><p>软件测试是正在快速发展、充满挑战的领域。</p>\n<p>尽管现在许多自动化测试软件的出现使得传统手工测试的方式被代替，但自动化测试工具的开发、安全测试、测试建模、精准测试、性能测试、可靠性测试等专项测试中仍然需要大量具有专业技能与专业素养的测试人员。</p>\n<p>并且随着云计算、物联网、大数据的发展，传统的测试技术可能不再适用，测试人员也因此面临着挑战，需要深入了解新场景并针对不同场景尝试新的测试方法，同时敏捷测试、Devops的出现也显示了软件测试的潜力</p>\n<h3 id=\"9-高频-一个完整的测试流程，要干什么？\"><a href=\"#9-高频-一个完整的测试流程，要干什么？\" class=\"headerlink\" title=\"9.(高频)一个完整的测试流程，要干什么？\"></a>9.(高频)一个完整的测试流程，要干什么？</h3><p>测试工作需要贯穿整个软件的生命周期</p>\n<p><strong>需求分析阶段</strong></p>\n<ul>\n<li>测试人员会进行需求评审，对产品的功能进行整体把握，根据需求写用例</li>\n</ul>\n<p><strong>写测试计划</strong></p>\n<ul>\n<li>根据开发计划制定具体的测试时间计划</li>\n</ul>\n<p><strong>撰写测试用例：</strong></p>\n<ul>\n<li><p>根据详细的需求文档，进行用例的编写</p>\n</li>\n<li><p>使用思维导图列举测试大纲，尽量发散，想到什么就写什么。先放后收，对知识点进行总结和归纳，标记重点测试模块，删除冗余及重复测试点</p>\n</li>\n<li><p>可使用边界值法、等价类划分法、错误推测法、因果图法等设计案例</p>\n</li>\n<li><p>根据测试大纲制定测试用例，需包含模块名、测试优先级、操作步骤、期望结果、测试结果、备注</p>\n</li>\n</ul>\n<p><strong>用例评审：</strong></p>\n<ul>\n<li><p>测试作为主导，联合开发、项目经理、PM进行测试用例评审</p>\n</li>\n<li><p>可先讲解测试大纲，让开发、项目经理对测试用例有个大概后再详细测试用例讲解</p>\n</li>\n</ul>\n<p><strong>执行测试用例：</strong></p>\n<ul>\n<li><p>根据测试用例执行测试</p>\n</li>\n<li><p>发现问题保留现场，记录测试方法，通知开发解决问题</p>\n</li>\n<li><p>覆盖测试用例之外若有时间可进行探索性测试</p>\n</li>\n</ul>\n<p><strong>缺陷报告编写及提交</strong></p>\n<ul>\n<li>将发现的缺陷编写成正式的缺陷报告，提交给开发人员进行缺陷的确认和修复</li>\n</ul>\n<p><strong>跟踪BUG修改情况</strong></p>\n<p><strong>执行自动化测试，编写脚本，执行，分析，报告</strong></p>\n<p><strong>进行性能测试，压力测试等其他测试，执行，分析，调优，报告</strong></p>\n<h3 id=\"10-一条缺陷都记录哪些内容\"><a href=\"#10-一条缺陷都记录哪些内容\" class=\"headerlink\" title=\"10.一条缺陷都记录哪些内容\"></a>10.一条缺陷都记录哪些内容</h3><p>缺陷内容包括：缺陷的标题、缺陷类型、详细步骤、期望结果、缺陷等级、优先级、截图、日志信息等。</p>\n<p>怎样提交一个高质量的缺陷：</p>\n<p>1）缺陷的标题尽量简单、明确、完整</p>\n<p>2）尽量使用惯用的表达术语和表达方法，保证表达准确专业</p>\n<p>3）一个缺陷报告只包括一个缺陷，复现步骤描述清楚</p>\n<p>4）是UI问题的话，尽量配上截图标注好有问题的地方；功能问题，尽量配上视频；闪退一类的Bug配上Log日志等</p>\n<p>5）一些特殊数据出现的bug,需要备注好数据信息</p>\n<p>6）一些非必现的问题，多测试几遍，然后备注清楚bug的复现率</p>\n<p>7）兼容性问题需要备注好设备型号、操作系统及浏览器版本信息</p>\n<p>8）缺陷尽量保证不重复提交</p>\n<h2 id=\"二、测试基本流程和方法\"><a href=\"#二、测试基本流程和方法\" class=\"headerlink\" title=\"二、测试基本流程和方法\"></a>二、测试基本流程和方法</h2><h3 id=\"测试伴随着软件开发模型的演进\"><a href=\"#测试伴随着软件开发模型的演进\" class=\"headerlink\" title=\"测试伴随着软件开发模型的演进\"></a>测试伴随着软件开发模型的演进</h3><p>开发模型，从软件发展来看，比较典型的有瀑布模型，V模型和W模型以及敏捷开发模型。</p>\n<p><strong>瀑布模型</strong></p>\n<p>瀑布模型的主要<strong>特征</strong>在于项目完全按照阶段划分，只有前一阶段完成，才能开始下一阶段。</p>\n<p>具体到<strong>测试活动</strong>，则只能在全部编码完成后、发布之前执行，</p>\n<p>在这种开发模型中，测试活动被完全后置了，测试仅仅是编码后的一个活动阶段，测试的<strong>重要性</strong>没有被凸显出来</p>\n<p><strong>V模型</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/v2-160001540463468a4720448342d6705c_720w.webp\" alt=\"img\"></p>\n<p>V模型不仅相对<strong>清晰地划分了测试活动的不同级别</strong>，还将其不同级别的测试活动与软件开发各阶段清晰地对应起来，强调了测试在整个开发过程中的重要性。</p>\n<p>但在V模型中，<strong>测试依旧是编码之后才开始的，测试介入时间还是太晚。比如，需求分析阶段出现的问题，要等到系统测试阶段才能发现</strong></p>\n<p><strong>W模型</strong></p>\n<p><img src=\"https://pic4.zhimg.com/80/v2-40a8fa51c8939898b5217d6c6f78340f_720w.webp\" alt=\"img\"></p>\n<p>为了弥补V模型的缺点，出现了W模型，把V模型左边的每一个活动都加了一个测试设计活动，尽早和不断地进行测试</p>\n<p>W模型认为测试伴随着整个软件开发周期，而且测试的对象不仅仅是程序，需求、设计等同样要测试。</p>\n<p><strong>优点：</strong>测试的活动与软件开发同步进行，而且测试的对象不仅仅是程序，还包括需求和设计。这样可以尽早发现软件缺陷可降低软件开发的成本</p>\n<p><strong>缺点</strong>：开发和测试依然是线性的关系，需求的变更和调整，依然不方便，而且如果没有文档，根本无法执行W模型，使用W模型对于项目组成员的技术也很高。</p>\n<p><strong>H模型</strong></p>\n<p>相对于V模型和W模型，H模型将测试活动完全独立出来，形成了一个完全独立的流程，将测试准备活动和测试执行活动清晰地体现出来</p>\n<p><img src=\"https://pic4.zhimg.com/80/v2-f685dee9b555f1bc5e46fa2eb44b35db_720w.webp\" alt=\"img\"></p>\n<p>这个示意图仅仅演示了在整个生产周期中某个层次上的一次测试“微循环”。图中标注的其他流程可以是任意的开发流程，例如，设计流程或编码流程。只要测试条件成熟了，测试准备活动完成了，测试执行活动就可以进行了。</p>\n<p>H模型中包含了如下概念：</p>\n<ul>\n<li><p>测试准备：所有测试活动的准备判断是否到测试就绪点</p>\n</li>\n<li><p>测试就绪点：测试准入准则，即是否可以开始执行测试的条件</p>\n</li>\n<li><p>测试执行：具体的执行测试的程序</p>\n</li>\n<li><p>其他流程：设计流程或编码流程</p>\n</li>\n</ul>\n<p><strong>优点：</strong>让测试活动完全独立贯穿整个生命周期与其他流程并发进行。在H模型中，软件测试活动可以尽早准备尽早执行，具有很强的灵活性。而且软件测试可以根据被测对象的不同而分层次、分阶段、分次序的执行，同时也是可以被迭代的。</p>\n<p><strong>缺点：</strong>对于管理要求很高，需要定义清晰的规则和管理制度，否则测试过程将很难管理和控制，而且对于技能要求也很高。因为H模型要求能够很好的定义每个迭代的规模，不能太大也不能太小。在H模型中，测试就绪点的分析也比较困难。因为测试过程中，并不知道测试准备到什么时候是合适的，就绪点在哪，就绪点标准是什么，这就对后续的测试执行启动带来很大的困难。</p>\n<p><strong>敏捷模型</strong></p>\n<p>按一个短的迭代周期工作，强调“快”，每次迭代交付一些成果（或者说先做出一个不完美但能实现一定的功能的版本）；让客户参与进来，有新需求就，快速响应变化，迭代产生新版本，缩短软件版本的周期。</p>\n<p>强调软件开发软件而不是文档。</p>\n<p>特点：让客户参与进来，客户需求的变动和软件有些不符合需求的地方可以第一时间进行了解和改动；缩短版本周期；每隔一段时间，团队可以在工作方面进行反省和改进，调整自己的行为</p>\n<p>敏捷测试：</p>\n<p>以用户需求为中心，在每一个迭代周期都需要进行测试</p>\n<p>基于自动化测试-》速度快、敏捷</p>\n<p>更强调测试的速度和适应性，侧重计划的不断调整以使用需求的变化</p>\n<p>强调面对面的沟通、协作，强调团队的责任，不太关注对缺陷的记录与跟踪。<strong>缺陷修复的成本也比较低</strong></p>\n<h3 id=\"1-测试的相关流程\"><a href=\"#1-测试的相关流程\" class=\"headerlink\" title=\"1.测试的相关流程\"></a>1.测试的相关流程</h3><p>需求测试-&gt;概要设计测试-&gt;详细设计测试-&gt;单元测试-&gt;集成测试-&gt;系统测试-&gt;验收测试</p>\n<p><strong>1)单元测试(模块测试)：</strong></p>\n<p>什么是单元测试</p>\n<p>完成最小的软件设计单元(模块)的验证工作，目标是确保模块被正确的编码，对代码风格和规则、程序设计和结构、业务逻辑等进行静态测试，<strong>及早的发现</strong>和解决不易显现的错误</p>\n<p>单元测试方法</p>\n<p>通常情况下是<strong>白盒</strong>的，</p>\n<p>单元测试的依据</p>\n<p>代码、注释、详细设计文档LLD</p>\n<p>单元测试的测试重点：</p>\n<ul>\n<li><p>模块接口：数据能否正确进出，检查参数的数目、次序、属性，全局变量的定义和用法在各个模块中是否一致</p>\n</li>\n<li><p>局部数据结构：局部数据说明、初始化、默认值等方面的错误</p>\n</li>\n<li><p>重要执行通路：选择具有<strong>代表性</strong>、最可能发现错误的执行通路进行测试</p>\n</li>\n<li><p>出错处理通路：应该能<strong>预见出错的条件</strong>，并且设置适当的处理错误的通路</p>\n</li>\n<li><p><strong>边界条件</strong>：对于刚好小于、等于、大于最大值或小于最小值的数据结构、控制量和数据值进行测试</p>\n</li>\n</ul>\n<p><strong>2)集成测试：</strong></p>\n<p>什么是集成测试</p>\n<p>通过测试发现与模块接口有关的问题。目标是把通过了单元测试的模块拿来，构造一个在设计中所描述的程序结构。</p>\n<p>集成测试方法</p>\n<p>黑盒和白盒结合</p>\n<p>集成测试的依据</p>\n<p>单元测试模块、概要设计文档HLD</p>\n<p>集成测试的两种方法</p>\n<p>一种方法是先分别测试每个模块，再把所有模块设计要求放在一起<strong>组合</strong>成所要的程序，称为<strong>非渐增式测试方法</strong>；</p>\n<p>另一种方法是要把下一个测试的模块同已经测试好的模块结合起来进行测试，称为<strong>渐增式测试</strong>。</p>\n<p><strong>应当避免一次性的集成(除非软件规模很小)，而采用增量集成。</strong>非渐增式测试一下子把所有模块放在一起，情况复杂，会遇到很多错误，改正错误更是极端困难。</p>\n<p>使用渐增式方法有<strong>自顶向下和自底向</strong>上两种集成策略</p>\n<table>\n<thead>\n<tr>\n<th>渐增式方法</th>\n<th>概述</th>\n<th>流程</th>\n<th>优点</th>\n<th>缺点</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>自顶向下集成</td>\n<td>首先集成主模块，然后按照控制层次结构向下进行集成，隶属于主模块的模块按照深度优先或广度优先的方式集成到整个结构中去</td>\n<td>1.对主控制模块进行测试，测试时用存根程序代替所有直接附属于主控制模块的模块2.根据选定的结合策略（DFS BFS）每次用一个实际模块代换一个存根程序3.在结合进一个模块的同时进行测试4.为了保证加入模块没有引进新的错误，可能需要进行回归测试（全部或部分重复以前做过的测试）5.直到构造起完整的软件结构</td>\n<td>能够在测试早期对主要的控制或关键的抉择进行检验，在一个分解的好的软件结构中，关键抉择位于层次系统的较上层，因此首先碰到，早期认识主要控制里的问题是有好处的</td>\n<td>实际使用会遇到逻辑上的问题。为了充分地测试软件系统的较高层次，需要在较低层次上的处理。然而存根程序代替了低层次的模块，没有重要的数据自下往上流，为了解决这个问题：把许多测试推迟到用真实模块代替了存根程序后再进行从层次系统的底部向上组装</td>\n</tr>\n<tr>\n<td>自底向上集成</td>\n<td>从原子模块开始来进行构造和测试</td>\n<td>1.把底层模块组合成实现某个特定的软件子功能的族2.写一个驱动程序，协调测试数据的输入输出3.对由模块组成的子功能族进行测试4.去掉驱动程序，沿软件结构自下向上移动，把子功能族组合起来形成更大的子功能族</td>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<p><strong>3)系统测试：</strong></p>\n<p>什么是系统测试</p>\n<p>系统测试是对已经集成好的软件系统进行彻底的测试，以验证软件系统的正确性和性能等是否满足其规约所指定的要求。</p>\n<p>系统测试方法</p>\n<p>黑盒测试</p>\n<p>系统测试依据</p>\n<p>需求测试文档SRS</p>\n<p>系统测试的种类</p>\n<p><strong>功能</strong>测试：对产品的各功能进行验证，以检查是否满足需求的要求</p>\n<p><strong>性能</strong>测试：通过自动化测试工具模拟多种正常、峰值以及异常负载条件来对系统的各项性能指标进行测试</p>\n<p><strong>安全</strong>测试：检查系统对非法入侵的防范能力</p>\n<p><strong>兼容</strong>测试：测试系统在不同的软硬件环境下是否能够正常的运行</p>\n<p><strong>4)回归测试：</strong></p>\n<p>回归测试是指在发生修改之后重新测试先前的测试用例以保证修改的正确性。理论上，软件产生新版本，都需要进行回归测试，验证以前发现和修复的错误是否在新软件版本上再次出现</p>\n<p><strong>5)验收测试：</strong></p>\n<p>验收测试是部署软件之前的最后一个测试操作。目的是确保软件准备就绪，展示该系统满足用户的需求</p>\n<p>测试方法：黑盒</p>\n<p>验收测试包括Alpha测试和Beta测试</p>\n<p>Alpaha测试：是由用户在开发者的场所来进行的，开发者对用户的指导下进行测试，开发者负责记录发现的错误和使用中的问题，<strong>内测版本</strong></p>\n<p>Beta测试：由软件的最终用户在一个或多个用户场所来进行的，开发者通常不在现场，用户记录测试中遇到的问题并报告给开发者，开发者对系统进行最后的修改，并开始准备发布最终的软件，<strong>公测版本</strong></p>\n<p><strong>那一步最重要</strong></p>\n<p>这些测试步骤分别在软件开发的不同阶段对软件进行测试，我认为对软件完整功能进行测试的<strong>系统测试</strong>很重要，</p>\n<p>因为此时单元测试和集成测试已经完成，能够对软件所有功能进行功能测试，能够覆盖系统所有联合的部件，是针对整个产品系统进行的测试，能够验证系统是否满足了需求规格的定义，因此我认为系统测试很重要。</p>\n<p><strong>你觉得单元测试可行吗</strong></p>\n<p>可行，单元测试可以有效地测试某个程序模块的行为，是未来重构代码的信心保证。</p>\n<p>事前可以保证质量，事后可以快速复现问题，并在修改代码后做回归自测</p>\n<p>可行性考虑的是要用一些可行的方法做到关键的代码可测试，如通过边界条件、等价类划分、错误、因果，设计测试用例要覆盖常用的输入组合、边界条件和异常。</p>\n<p><strong>集成测试和系统测试的区别和应用场景</strong></p>\n<p>1.<strong>计划和用例编制的先后顺序</strong>：从V模型来讲，在需求阶段就要制定系统测试计划和用例，HLD(概要设计)的时候做集成测试计划和用例，有些公司的具体实践不一样，但是顺序肯定是<strong>先做系统测试计划用例，再做集成</strong></p>\n<p>2.<strong>用例的粒度</strong>：系统测试用例相对很接近用户接受测试用例，<strong>集成测试用例比系统测试用例更详细</strong>，而且对于接口部分要重点写，毕竟要集成各个模块或者子系统</p>\n<p><strong>集成测试：</strong></p>\n<ul>\n<li><p>时间：完成单元测试后，各模块联调测试；</p>\n</li>\n<li><p>测试目标：各模块的接口是否一致，各模块间的数据流和控制流是否按照设计实现功能、以及结果的正确性验证等等；可以是整个产品的集成测试，也可以是大模块的集成测试；</p>\n</li>\n<li><p>测试重点：集成测试主要是针对程序内部结构进行测试，特别是对程序之间的接口进行测试。集成测试对测试人员的编写脚本能力要求比较高。</p>\n</li>\n<li><p>测试方式：一般选用<strong>黑盒测试和白盒测试相结合。</strong></p>\n</li>\n</ul>\n<p><strong>系统测试</strong>：</p>\n<ul>\n<li><p>时间：集成测试之后，针对整个产品的全面测试</p>\n</li>\n<li><p>测试目标：《需求规格说明书》中提到的功能是否有遗漏，是否正确的实现。</p>\n</li>\n<li><p>测试重点：既包含各模块的验证性测试（验证前两个阶段测试的正确性）和功能性（产品提交给用户的功能）测试，又包括对整个产品的健壮性、安全性、可维护性及各种性能参数的测试。</p>\n</li>\n<li><p>测试方法：一般都使用<strong>黑盒测试法。</strong></p>\n</li>\n</ul>\n<h3 id=\"2-高频-黑盒测试和白盒测试\"><a href=\"#2-高频-黑盒测试和白盒测试\" class=\"headerlink\" title=\"2.(高频)黑盒测试和白盒测试\"></a>2.(高频)黑盒测试和白盒测试</h3><p><strong>什么是黑盒测试</strong></p>\n<p>主要是检查软件的每一个功能<strong>是否能够正常使用</strong>，检查程序功能是否按照设计需求以及说明书的规定能够正常使用。在测试过程中，<strong>不考虑程序内部结构和特性的基础上通过程序接口进行测试</strong></p>\n<h4 id=\"黑盒测试常用方法并举例\"><a href=\"#黑盒测试常用方法并举例\" class=\"headerlink\" title=\"**黑盒测试常用方法并举例\"></a>**黑盒测试常用方法并举例</h4><p><strong>等价类划分法</strong></p>\n<p>什么是等价类划分</p>\n<p>等价类划分是将系统的输入域划分为若干部分，则可以合理做出下述假定：<strong>每类中的一个典型值在测试中的作用与这一类中其他值的作用相同</strong>。然后从每个部分选取少量代表性数据进行测试。一个理想的测试用例能独自发现一类错误。</p>\n<p>研究程序的功能说明，从而确定输入数据的有效等价类和无效等价类，在确定输入数据的等价类时常常<strong>还需要分析输出数据的等价类</strong>，<strong>以便根据输出数据的等价类导出对应的输入数据等价类</strong></p>\n<p>下述几条启发式规则可能有助于等价类的划分：</p>\n<p>（1）如果规定了输入值的范围，则可划分出一个有效的等价类和两个无效的等价类</p>\n<p>（2）如果规定了输入数据的个数，则类似地也可以划分出一个有效等价类和两个无效等价类</p>\n<p>（3）如果规定了输入数据的一组值，并且程序对不同输入值做不同处理，则每个允许的输入值是一个有效等价类，还有一个无效等价类（<strong>任意一个不允许的输入值）</strong></p>\n<p>（4）如果规定了输入数据必须遵循的规则，则可以划分出一个有效的等价类和若干个无效的等价类</p>\n<p>（5）如果规定了输入数据为整形，则可以划分出<strong>正整数、零和负整数3个有效类</strong></p>\n<p>（6）如果程序的处理对象是表格，<strong>则应该使用空表，以及含一项或多项的表</strong></p>\n<p>划分出等价类以后，设计测试方案：</p>\n<p>（1）设计一个新的测试方案以<strong>尽可能多地覆盖</strong>尚未被覆盖的有效等价类，重复这一步骤直到所有有效等价类都被覆盖位置</p>\n<p>（2）设计一个新的测试方案，使他<strong>覆盖一个</strong>而且只覆盖一个尚未被覆盖的无效等价类，重复这一步骤直到所有无效等价类都被覆盖为止</p>\n<p><strong>边界值分析法</strong></p>\n<p>什么是边界值分析法</p>\n<p>边界值分析法是对等价类划分的一种补充，<strong>因为大多数错误都在输入输出的边界上。如果边界附近取值不会导致程序出错，那么其他取值出错的可能性也就很小。</strong></p>\n<p>边界值分析法是通过优先选择不同等价类间的边界值覆盖有效等价类和无效等价类来<strong>更有效</strong>的进行测试，因此该方法要和等价类划分法结合使用。<strong>选取的测试数据应该刚好等于、刚刚小于和刚刚大于边界值</strong></p>\n<p><strong>判定表法</strong></p>\n<ul>\n<li>判定表驱动法是分析和表达多逻辑条件下执行不同操作的情况的工具。</li>\n</ul>\n<p>（1）条件桩：列出了问题的所有条件</p>\n<p>（2）动作桩：列出了问题规定可能采取的操作</p>\n<p>（3）条件项：列出针对它所列条件的取值，在所有可能情况下的真假值</p>\n<p>（4）动作项：列出在条件项的各种取值情况下应该采取的动作</p>\n<p><strong>错误分析法</strong></p>\n<p>错误推测法是<strong>基于以往的经验和直觉</strong>，参照以往的软件系统出现的错误，推测当前被测程序中可能存在的缺陷和错误，有针对性地设计测试用例。</p>\n<p><strong>什么是白盒测试</strong></p>\n<p>它根据程序的控制结构设计测试用例，白盒测试法检查程序内部逻辑结构，对所有的逻辑路径进行测试，是一种<strong>穷举路径</strong>的测试方法，</p>\n<h4 id=\"白盒测试常用方法并举例：\"><a href=\"#白盒测试常用方法并举例：\" class=\"headerlink\" title=\"白盒测试常用方法并举例：\"></a><strong>白盒测试常用方法并举例：</strong></h4><p>强度由低到高：</p>\n<ul>\n<li><p>语句覆盖：所有的“语句”都要覆盖一遍。就是设计若干个测试用例，运行被测程序，使得每一个执行语句至少执行一次。</p>\n</li>\n<li><p>判定覆盖：包含语句覆盖，每个判断T、F各一次。使设计的测试用例保证程序中每个判断的<strong>每个取值分支</strong>至少经历一次。</p>\n</li>\n<li><p>条件覆盖：包含语句覆盖，每个条件T、F各一次是指选择足够的测试用例，使得运行这些测试用例时，判定中每个条件的<strong>所有可能结果</strong>至少出现一次，但未必能覆盖全部分支。</p>\n</li>\n<li><p>判定条件覆盖：包含判定覆盖、条件覆盖。说白了就是我们设计的测试用例可以使得<strong>判断中每个条件所有的可能取值至少执行一次（</strong>条件覆盖），<strong>同时每个判断本身所有的结果，也要至少执行一次</strong>（判定覆盖）。不难发现判定条件覆盖同时满足判定覆盖和条件覆盖，弥补了两者各自的不足，<strong>但是判定条件覆盖并未考虑条件的组合情况。</strong></p>\n</li>\n<li><p>条件组合覆盖：每个条件的每种组合。在白盒测试法中，选择足够的测试用例，使所有判定中各条件判断结果的所有组合至少出现一次，满足这种覆盖标准成为条件组合覆盖。意思是说我们设计的测试用例应该使得<strong>每个判定中的各个条件的各种可能组合都至少出现一次</strong>。显然，满足条件组合覆盖的测试用例一定是满足判定覆盖、条件覆盖和判定条件覆盖的。</p>\n</li>\n<li><p>路径覆盖：所有路径至少执行一次。</p>\n</li>\n</ul>\n<p><strong>黑盒和白盒测试的区别和关系</strong></p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>黑盒测试</th>\n<th>白盒测试</th>\n</tr>\n</thead>\n<tbody><tr>\n<td></td>\n<td>不查看内部代码结构</td>\n<td>了解程序内部的代码结构</td>\n</tr>\n<tr>\n<td></td>\n<td>根据软件需求和规范设计</td>\n<td>按照程序内部逻辑设计</td>\n</tr>\n<tr>\n<td></td>\n<td>涉及到单元、集成、系统和验收测试</td>\n<td>涉及到单元、集成测试</td>\n</tr>\n<tr>\n<td></td>\n<td>测试人员不需要程序经验</td>\n<td>需要有一定的程序经验</td>\n</tr>\n<tr>\n<td></td>\n<td>可以手动或自动化测试</td>\n<td>可以手动或自动化测试</td>\n</tr>\n<tr>\n<td>缺点</td>\n<td>覆盖率低</td>\n<td>穷举路径不太可能，只能测试开发人员做的对不对，不知道需求是否正确满足</td>\n</tr>\n</tbody></table>\n<h3 id=\"3-自动化测试\"><a href=\"#3-自动化测试\" class=\"headerlink\" title=\"3.自动化测试\"></a>3.自动化测试</h3><p>自动化测试把以人为驱动的测试行为转化为机器执行的一种过程。在预设条件下运行系统或应用程序，评估运行结果，预先条件应包括正常条件和异常条件。</p>\n<p><strong>自动化测试的前提条件</strong></p>\n<p>1）需求变动不频繁</p>\n<p>2）项目周期足够长：自动化测试需求的确定、框架的设计、测试脚本的编写与调试均需要相当长的时间来完成，</p>\n<p>3）自动化测试脚本可重复使用</p>\n<p><strong>你觉得自动化测试由什么意义，都需要做什么</strong></p>\n<p>1.可以对程序的新版本自动执行回归测试</p>\n<p>2.可以执行手工测试困难或者不可能实现的测试，如<strong>压力测试，并发测试</strong></p>\n<p>3.能够更好的利用资源，<strong>节省时间和人力</strong></p>\n<p>执行自动化测试之前首先判断这个项目<strong>适不适合</strong>推广自动化测试，然后对项目做需求分析，指定测试计划，搭建自动化测试框架，设计测试用例，执行测试，评估。</p>\n<p><strong>手动测试与自动化测试的优缺点</strong></p>\n<p>手动测试：</p>\n<p>优点：</p>\n<p>1.测试人员具有经验和对错误的猜测能力</p>\n<p>2.测试人员具有审美能力和心理体验</p>\n<p>3.测试人员具有是非判断和逻辑推理能力</p>\n<p>缺点：</p>\n<p>1.重复的手工回归测试，代价昂贵、容易出错</p>\n<p>2.依赖于软件测试人员的能力</p>\n<p>自动化测试：</p>\n<p><strong>优点</strong></p>\n<p>1.对程序的回归测试更方便。这可能是自动化测试最主要的任务，特别是在程序修改比较频繁时，效果使非常明显的。由于回归测试的动作和用例是完全设计好的，测试期望的结果也是完全可以预料的，将<strong>回归测试自动运行</strong>，可以极大提高测试效率，缩短回归测试时间。</p>\n<p>2.可以运行更多更繁琐的测试。自动化的一个明显的好处是可以在较少的时间内运行更多的测试</p>\n<p>3.可以执行一些手工测试困难或不可能进行的测试。比如，对于大量用户的测试，不可能同时让足够多的测试人员同时进行测试，但是却可以通过自动化测试模拟同时有许多用户，从而达到测试的目的</p>\n<p>4.更好地利用资源。将繁琐的任务自动化，可以提高准确性和测试人员的积极性，将测试技术人员解脱出来投入<strong>更多精力设计更好的测试用例</strong>。有些测试不适合于自动测试，仅适合于手工测试，将可自动测试的测试自动化后，可以让测试人员专注于手工测试部分，提高手工测试的效率</p>\n<p>5.测试具有一致性和可重复性。由于测试是自动执行的，这样就可能只需要做少量的甚至不做修改，实现在不同的测试过程中使用相同的用例</p>\n<p>6.测试的复用性：由于自动测试通常采用脚本技术，这样就有可能只需要做少量的甚至不做修改，实现在不同的测试过程中使用相同的用例</p>\n<p>7.增加软件信任度：由于测试是自动执行的，所以不存在执行过程中的疏忽和错误，完全取决于测试的设计质量。一旦软件通过了强有力的自动测试后，软件的信任度自然会增加</p>\n<p><strong>缺点：</strong></p>\n<p>1.不能取代手工测试</p>\n<p>2.手工测试比自动测试发现的缺陷更多</p>\n<p>3.对测试质量的依赖性极大</p>\n<p>4.测试自动化不能提高有效性</p>\n<p>5.测试自动化可能会制约软件开发。由于自动化测试比手动测试更脆弱，维护会受到限制，从而制约软件的开发</p>\n<p>6.工具本身并无想象力。</p>\n<h3 id=\"4-Bug\"><a href=\"#4-Bug\" class=\"headerlink\" title=\"4.Bug\"></a>4.Bug</h3><p><strong>Bug的周期？以及不同类别的Bug?</strong></p>\n<p><strong>1) New:(新的)</strong></p>\n<p>当某个bug 被第一次发现的时候，测试人员需要与项目负责人沟通以确认发现的的确是一个bug，如果被确认是一个bug，就将其记录下来。并将bug的状态设为new</p>\n<p><strong>2）Assigned(已指派的)</strong></p>\n<p>当一个Bug被指认为New之后，将其反馈给开发人员，开发人员将确认这是否是一个Bug,如果是，开发组的负责人就将这个bug指定给某位开发人员处理，并将bug的状态设定为assigned</p>\n<p><strong>3）Open 打开的</strong></p>\n<p>一旦开发人员开始处理bug的时候，他就将这个bug的状态设置为Open,表示开发人员正在处理这个Bug</p>\n<p><strong>4)Fixed 已修复的</strong></p>\n<p>当开发人员进行处理（并认为已经解决）之后，他就可以将这个bug的状态设置为fixed并将其提交给开发组的负责人，然后开发组的负责人将这个Bug返还给测试组</p>\n<p><strong>5）Pending Reset 待在测试的</strong></p>\n<p>当bug被返还给测试组后，状态设为这个</p>\n<p><strong>6）Reset 再测试</strong></p>\n<p>测试组的负责人将Bug指定给某位测试人员进行再测试，并将Bug的状态设置为Reset</p>\n<p><strong>7）closed 已关闭的</strong></p>\n<p>如果测试人员经过再次测试之后确认bug已经被解决之后，就将状态设置为closed</p>\n<p><strong>8）Reopen 再次打开的</strong></p>\n<p>如果经过再次测试发现bug仍然存在的话（指bug本身而不是包括因修复而引发的新bug），测试人员将bug再次传递给开发组，并将bug的状态设置为Reopen</p>\n<p><strong>9) pending reject 拒绝中</strong></p>\n<p>如果测试人员传递到开发组的bug 被开发人员认为是正常行为而不是Bug时，这种情况下开发人员可以拒绝，并将Bug的状态设置为pending reject</p>\n<p><strong>10）rejected 被拒绝的</strong></p>\n<p>测试组的负责人接到上述bug的时候，如果他发现这是产品说明书中定义的正常行为或者经过与开发人员的讨论之后认为这并不能算作Bug的时候，开发组负责人就将这个Bug的状态设置为rejected</p>\n<p><strong>11）postponed 延期</strong></p>\n<p>对于一些特殊的Bug的测试需要搁置一段时间，比如无效的测试数据，一些特殊的无效的功能等等，在这种情况下，Bug的状态就被设置为postponed</p>\n<p><strong>Bug类型</strong></p>\n<p>代码错误</p>\n<p>界面优化</p>\n<p>设计缺陷</p>\n<p>配置相关</p>\n<p>安装部署</p>\n<p>安全相关</p>\n<p>性能问题</p>\n<p>标准规范</p>\n<p>测试脚本</p>\n<p>其他</p>\n<p><strong>如何进行Bug测评</strong></p>\n<p>Bug的priority() 和 severity() 是两个重要属性，通常人员在提交bug的时候，只定义severity ,将priority交给leader定义，通常bug管理中，severtity 分为四个等级blocker&#x2F;critical&#x2F;major&#x2F;minor(trivial)，而priority分为五个等级 immediate urgent high normal low</p>\n<p>Severity:</p>\n<p>1)blocker:即系统无法执行，崩溃，或严重资源不足，应用模块无法启动或异常退出，无法测试，造成系统不稳定。 常见的有严重花屏、内存泄漏、用户数据丢失或破坏、系统崩溃&#x2F;死机&#x2F;冻结、模块无法启动或异常退出、严重的数值计算错误、功能设计与需求严重不符、其他导致无法测试的错误，如服务器500错误</p>\n<p>2)critical: 即映像系统功能或操作，主要功能存在严重缺陷，但不会映像到系统稳定性。常见的有：功能未实现、功能错误、系统刷新错误、数据通讯错误、轻微的数值计算错误、影响功能及界面的错误字或拼写错误。</p>\n<p>3)major: 即界面、性能缺陷、兼容性，常见的有：操作界面错误，边界条件错误，提示信息错误，长时间操作无进度提示，系统未优化，兼容性问题</p>\n<p>4)minor&#x2F;trivial:即易用性及建议性问题</p>\n<p>Priority:</p>\n<ol>\n<li>immediate : 即马上解决</li>\n</ol>\n<p>2）urgent: 急需解决</p>\n<p>3）high:高度重视，有时间要马上解决</p>\n<p>4）low:在系统发布前解决，或确认可以不用解决</p>\n<h3 id=\"5-APP性能\"><a href=\"#5-APP性能\" class=\"headerlink\" title=\"5. APP性能\"></a>5. APP性能</h3><p><strong>软件质量的六个特征</strong></p>\n<p>按照软件质量国家标准GB-T8566–2001G，软件质量可以用下列特征来评价：</p>\n<p>a.功能特征：与一组功能及其指定性质有关的一组属性，这里的功能是满足明确或隐含的需求的那些功能</p>\n<p>b.可靠特征：在规定的一段时间和条件下，与软件维持其性能水平的能力有关的一组属性</p>\n<p>c.易用特征：由一组规定或潜在的用户为使用软件所需作的努力和所作的评价有关的一组属性</p>\n<p>d.效率特征：与在规定条件下软件的性能水平与所使用资源量之间关系有关的一组属性</p>\n<p>e.可维护特征：与进行指定的修改所需的努力有关的一组属性</p>\n<p>f.可移植特征：与软件从一个环境转移到另一个环境的能力有关的一组属性</p>\n<p><strong>测试的类型？</strong></p>\n<p>测试分为功能测试和非功能测试，非功能测试又可分为性能测试、压力测试、容量测试、健壮性测试、安全性测试、可靠性测试、恢复性测试、备份测试、协议测试、兼容性测试、可用性测试、配置测试、GUI测试。</p>\n<p><strong>APP性能测试的指标</strong></p>\n<p>1）内存：</p>\n<p>内存消耗测试节点的设计目标是为了让应用不占用过多的系统资源，且及时释放内存，保障整个系统的稳定性。当然关于内存测试，需要引入几个概念：空闲状态、中等规格、满规格。</p>\n<ul>\n<li><p><strong>空闲状态指打开应用后</strong>，点击home键让应用后台运行，此时应用处于的状态叫做空闲；</p>\n</li>\n<li><p>中等规格和满规格指的是对应用的操作时间的间隔长短不一，<strong>中等规格时间较长，满规格时间较短</strong>。</p>\n</li>\n</ul>\n<p>内存测试中存在很多测试子项，清单如下：</p>\n<ul>\n<li><p>空闲状态下的应用内存消耗；</p>\n</li>\n<li><p>中等规格状态下的应用内存消耗；</p>\n</li>\n<li><p>满规格状态下的应用内存消耗；</p>\n</li>\n<li><p>应用内存峰值；</p>\n</li>\n<li><p>应用内存泄漏；</p>\n</li>\n<li><p>应用是否常驻内存</p>\n</li>\n<li><p>压力测试后的内存使用</p>\n</li>\n</ul>\n<p>2）CPU</p>\n<p>使用Android 提供的view plaincopy 在CODE上查看代码片派生到我的代码片</p>\n<p>adbshell dumpsys CPUinfo | grep packagename &gt;&#x2F;address&#x2F;CPU.txt 来获取</p>\n<p>使用top命令view plaincopy 在CODE上查看代码片派生到我的代码片</p>\n<p>adbshell top | grep packagename &gt;&#x2F;address&#x2F;CPU.txt 来获取</p>\n<p>3）流量</p>\n<p>网络流量测试是针对大部分应用而言的，可能还有部分应用会关注网速、弱网之类的测试。</p>\n<p>流量测试包括以下测试项：</p>\n<p>应用首次启动流量提示；</p>\n<p>应用后台连续运行2小时的流量值；</p>\n<p>应用高负荷运行的流量峰值</p>\n<p>4）电量：</p>\n<p>测试手机安装目标APK前后待机功耗无明显差异</p>\n<p>常见使用场景中能够正常进入待机，待机电流在正常范围内</p>\n<p>长时间连续使用应用无异常耗电现象。</p>\n<p>5）启动速度</p>\n<p>第一次：<strong>首次启动</strong>–应用首次启动所花费的时间</p>\n<p>第二次：<strong>非首次启动</strong>-应用非首次启动所花费的时间</p>\n<p>第三类：<strong>应用界面切换-</strong>-应用界面内切换所花费的时间</p>\n<p>6）滑动速度、界面切换速度</p>\n<p>7）与服务器交互的网络速度</p>\n<p><strong>APP测试工具</strong></p>\n<p>功能测试自动化：</p>\n<p>a) 轻量接口自动化测试：jmeter</p>\n<p>b) APP UI 层面的自动化：</p>\n<p>android: UI Automator Viewer,Android Junit, Instrumentation, UIAutomator,</p>\n<p>IOS :基于Instrument 的 IOS UI自动化</p>\n<p>性能测试：</p>\n<p>a)Web前端性能测试</p>\n<p>网络抓包工具：Wireshark</p>\n<p>网页文件大小：webpagetest pagespeed insight chrome adb</p>\n<p>b) APP端性能测试</p>\n<p>Android内存占用分析：MAT</p>\n<p>IOS内存问题分析：ARC模式</p>\n<p>Android WebView性能分析：</p>\n<p>IOS WebView 性能分析</p>\n<p>c)后台服务性能测试</p>\n<p>负载、压力、耐久性、可扩展性、基准</p>\n<p>工具：apacheAB , Jmeter, LoadRunner</p>\n<p>专项测试</p>\n<p>a)兼容性测试</p>\n<p>手工测试：操作系统、分辨率、rom、网络类型</p>\n<p>云平台：testin 脚本编写 Android</p>\n<p>b)流量测试</p>\n<p>Android自带的流量管理</p>\n<p>IOS自带的Network</p>\n<p>tcpdump抓包</p>\n<p>WIFI代理抓包：Fiddler</p>\n<p>流量节省方法：压缩数据，json优于xml; WebP优于传统的JPG，PNG；控制访问的频次；只获取必要的数据；缓存</p>\n<p>c)电量测试</p>\n<p>基于测试设备的方法，购买电量表进行测试</p>\n<p>GSam Battery Monitoe Pro</p>\n<p>IOS 基于Instrument Energy工具</p>\n<p>d)弱网络测试</p>\n<p>手机自带的网络状况模拟工具</p>\n<p>基于代理的弱网络的模拟</p>\n<p>工具：</p>\n<p>Windows: Network Delay Simulator</p>\n<p>Mac: Network Link Conditioner</p>\n<h3 id=\"6-性能、压力测试\"><a href=\"#6-性能、压力测试\" class=\"headerlink\" title=\"6.性能、压力测试\"></a>6.性能、压力测试</h3><p>性能测试是通过自动化的测试工具模拟多种<strong>正常、峰值以及异常负载</strong>条件来对系统的各项性能指标进行测试。</p>\n<p>负载测试和压力测试都属于性能测试，两者可以结合进行。通过负载测试，确定在各种工作负载下系统的性能，目标是测试当负载逐渐增加时，系统各项性能指标的变化情况。压力测试是通过<strong>确定一个系统的瓶颈或者不能接受的性能点，来获得系统能提供的最大服务级别的测试。</strong></p>\n<p><strong>性能测试关注什么</strong></p>\n<p>性能测试概括为三个方面：应用在<a href=\"https://link.zhihu.com/?target=https://baike.baidu.com/item/%E5%AE%A2%E6%88%B7%E7%AB%AF?fromModule=lemma_inlink\">客户端</a>性能的测试、应用在<strong>网络</strong>上性能的测试和应用在<strong>服务器</strong>端性能的测试。</p>\n<p>应用在<a href=\"https://link.zhihu.com/?target=https://baike.baidu.com/item/%E5%AE%A2%E6%88%B7%E7%AB%AF?fromModule=lemma_inlink\">客户端</a>性能测试的目的是考察客户端应用的性能，测试的入口是客户端。它主要包括并发性能测试、疲劳<a href=\"https://link.zhihu.com/?target=https://baike.baidu.com/item/%E5%BC%BA%E5%BA%A6%E6%B5%8B%E8%AF%95?fromModule=lemma_inlink\">强度测试</a>、大数据量测试和速度测试等，其中<strong>并发性能测试</strong>是重点。</p>\n<p>应用在网络上性能的测试重点是利用成熟先进的自动化技术进行网络应用性能监控、网络应用<a href=\"https://link.zhihu.com/?target=https://baike.baidu.com/item/%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90?fromModule=lemma_inlink\">性能分析</a>和网络预测。</p>\n<p>对于应用在服务器上性能的测试，可以采用工具监控，也可以使用系统本身的监控命令，实施测试的目的是实现服务器设备、<a href=\"https://link.zhihu.com/?target=https://baike.baidu.com/item/%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F?fromModule=lemma_inlink\">服务器操作系统</a>、<a href=\"https://link.zhihu.com/?target=https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F?fromModule=lemma_inlink\">数据库系统</a>、应用在服务器上性能的全面监控</p>\n<p>响应时间RT</p>\n<p>每秒能完成的响应数TPS</p>\n<p>CPU利用率</p>\n<p>内存占用</p>\n<p>网络（带宽使用率）</p>\n<p>手机APP要考虑耗电量</p>\n<p>负载大时，各项指标如何变化</p>\n<p>联网的话要考虑不同网络环境（正常网、超快网、网速慢、断网）时指标的变化</p>\n<p><strong>并发用户数和在线用户数的区别</strong></p>\n<p>在线用户数：用户同时在一定时间段的在线数量</p>\n<p>并发用户数：某一时刻同时向服务器发送请求的用户数</p>\n<p><strong>QPS（每秒查询率）</strong></p>\n<p>每秒查询率是对一个特定的查询服务器在规定时间内所处理流量多少的衡量标准，用来衡量服务器的机器性能</p>\n<p><strong>QPS和TPS的区别</strong></p>\n<p>TPS：Transactions Per Second(每秒传输的事物处理个数)，即服务器每秒处理的<strong>事务数</strong></p>\n<p>TPS包括一条消息入和一条消息出，加上一次用户数据库访问，是软件测试结果的测量单位</p>\n<h2 id=\"三、故障排除类题目\"><a href=\"#三、故障排除类题目\" class=\"headerlink\" title=\"三、故障排除类题目\"></a>三、故障排除类题目</h2><h3 id=\"1-PC网络故障，以及如何排除障碍\"><a href=\"#1-PC网络故障，以及如何排除障碍\" class=\"headerlink\" title=\"1.PC网络故障，以及如何排除障碍\"></a>1.PC网络故障，以及如何排除障碍</h3><p>1）首先排除接触故障，即确保你的网线是可以正常使用的。然后禁用网卡后再启用，排除偶然故障。打开网络和共享中心，单击窗口左上侧“更改适配器设置”，右击其中的“本地连接”或“无线网络连接”，单击快捷菜单中的“禁用”命令，即可禁用所选网络。接下来重启网络，只需右击后单击启用即可。</p>\n<p>2）使用ipconfig 查看计算机的上网参数</p>\n<p>单击“开始-所有程序-附件-命令提示符”，打开命令提示符窗口</p>\n<p>输入Ipconfig，按enter确认，可以看到机器的配置信息，输入ipconfig&#x2F;all 可以看到IP地址和网卡物理地址等相关网络详细信息</p>\n<p>3）使用Ping命令测试网络的连通性，定位故障范围</p>\n<p>在命令提示符窗口中输入“ping 127.0.0.1” 数据显示本机分别发送和接受了4个数据包，丢包率为零，可以判断本机网络协议工作正常，如显示“请求超时”则表明本机网卡的安装或TCP&#x2F;IP 协议有问题，接下来就应该检查<strong>网卡</strong>和TCP&#x2F;IP 协议，卸载后重装即可</p>\n<p>4）ping本机IP</p>\n<p>在确认127.0.0.1 地址能被Ping通的情况下，继续使用Ping命令测试本机IP地址能否被Ping通，如不能，说明本机的网卡驱动程序不正确，或者网卡与网线之间连接有故障，也有可能是本地的路由表面受到了破坏，此时应检查本机网卡的状态是否为已连接，网络参数是否设置正确，如果正确可是不能Ping通，就应该重新安装<strong>网卡驱动程序</strong>。丢失率为0，可以判断网卡安装配置没有问题，工作正常。</p>\n<p>5）ping网关</p>\n<p>网关地址能被Ping通的话，表明本机网络连接以及 正常，如果命令不成功，可能是<strong>网关设备</strong>自身存在问题，也可能是本机上网参数设置有误，检查网络参数</p>\n<h3 id=\"2-请问你怎么测试网络协议\"><a href=\"#2-请问你怎么测试网络协议\" class=\"headerlink\" title=\"2.请问你怎么测试网络协议\"></a>2.请问你怎么测试网络协议</h3><p>协议测试包括四种类型的测试</p>\n<p>1.一致性测试：检测协议实现本身与协议规范的符合程度</p>\n<p>2.互操作性测试：基于某一协议检测不同协议实现间互操作互通信的能力</p>\n<p>3.性能测试：检测协议实现的性能指标，比如数据传输速度，连接时间，执行速度，吞吐量，并发度</p>\n<p>并发数：指系统同时能处理的请求数量，同样反应了系统的负载能力。这个数值可以分析机器1s内的访问日志数量来得到、<br>吞吐量：是指系统在单位时间内处理请求的数量，TPS、QPS都是吞吐量的常用量化指标。</p>\n<p>4.健壮性测试：检测协议在各种恶劣环境下运行的能力，比如注入干扰报文、通信故障、信道被切断</p>\n<h2 id=\"四、设计测试用例\"><a href=\"#四、设计测试用例\" class=\"headerlink\" title=\"四、设计测试用例\"></a>四、设计测试用例</h2><h3 id=\"测试用例的组成元素\"><a href=\"#测试用例的组成元素\" class=\"headerlink\" title=\"测试用例的组成元素\"></a>测试用例的组成元素</h3><p>内容包括<strong>测试目标、测试环境、输入数据、测试步骤、预期结果、测试脚本</strong>等</p>\n<p>简单地认为，测试用例是为某个特殊目标而编制的一组测试输入、执行条件以及预期结果，用于核实是否满足某个特定软件需求。</p>\n<p>测试用例主要包含四个内容：</p>\n<p>用例标题-主要描述测试某项功能；</p>\n<p>前置条件-用例标题需要满足该条件</p>\n<p>测试步骤-描述用例的操作步骤</p>\n<p>预期结果-符合预期需求（开发规格书、需求文档、用户需求等）</p>\n<h3 id=\"如何写测试用例\"><a href=\"#如何写测试用例\" class=\"headerlink\" title=\"如何写测试用例\"></a>如何写测试用例</h3><p>1.测试人员<strong>尽早介入</strong>，彻底理解清楚需求，这个是写好测试用例的基础</p>\n<p>2.如果以前有类似的需求，可以<strong>参考类似需求的测试用例</strong>，然后还需要看类似需求的bug情况</p>\n<p>3.清楚输入、输出的<strong>各种可能性</strong>，以及各种输入的之间的关联关系，理解清楚需求的执行逻辑，通过等价类、边界值、判定表等方法找出大部分用例</p>\n<p>4.找到需求相关的一些特性，补充测试用例</p>\n<p>5.根据自己的经验分析遗漏的测试场景</p>\n<p>6.多总结类似功能点的测试点，才能够写出质量越来越高的测试用例</p>\n<p>7.书写格式一定要清晰(测试用例编号、测试标题、重要级别、测试输入、操作步骤、预期结果)</p>\n<h3 id=\"测试用例的重要级别是怎么分的\"><a href=\"#测试用例的重要级别是怎么分的\" class=\"headerlink\" title=\"测试用例的重要级别是怎么分的\"></a>测试用例的重要级别是怎么分的</h3><p>1）特高用例</p>\n<p>划分原则：特高用例主要是<strong>核心功能的主流程</strong>，基本业务流，保证功能的完整性，特高用例失败会导致其他多处功能无法正常使用。</p>\n<p>用例设计常用思想&amp;方法：场景法</p>\n<p>参考比例：10%左右</p>\n<p>（2）高等级</p>\n<p>划分原则：核心功能的正向业务流，覆盖平台功能的所有重要业务流</p>\n<p>参考比例： 15%左右</p>\n<p>特高及高等级用例要覆盖所有功能的正向业务流，能够保证软件功能稳定使用。包含<strong>功能交互、使用场景、使用频率较高</strong>的正常功能用例；</p>\n<p>（3）中等级</p>\n<p>划分原则：重要功能的正向业务流、核心&amp;重要功能的异常业务流</p>\n<p>参考比例：30%左右</p>\n<p>常见输入框、字符等正向用例，常见异常场景的业务流，常见的失败类场景；</p>\n<p>（4）低等级</p>\n<p>划分原则：其他异常用例、UI&#x2F;UE相关用例等</p>\n<p>用例设计常用思想&amp;方法<strong>：边界值、无效等价类等</strong></p>\n<p>参考比例：45%左右</p>\n<p>常见的输入框异常用例，包括一些异常的触发条件</p>\n<h3 id=\"1-微信红包设计\"><a href=\"#1-微信红包设计\" class=\"headerlink\" title=\"1.微信红包设计\"></a>1.微信红包设计</h3><p><strong>单个红包的功能上：</strong></p>\n<p>发送方：</p>\n<p><strong>输入红包金额</strong>：红包金额为0、0.01 200.00 200.01 199.99 20</p>\n<p><strong>输入留言：</strong>留言输入数字、字母、汉字、特殊字符；留言长度；留言复制粘贴</p>\n<p><strong>选择表情</strong>：表情-选择收藏的表情、其他表情； 删除表情、选择新的表情</p>\n<p><strong>选择红包封面</strong>：封面选择</p>\n<p><strong>选择支付方法</strong>：（零钱、零钱通、银行卡、添加新卡支付）判断里面钱数与红包钱数的关系；使用指纹、面部识别、密码支付（正确输入、错误输入的情况）</p>\n<p><strong>钱财金额：</strong>红包发送成功后，钱包金额减少对应数值</p>\n<p>接收方：</p>\n<p><strong>接收方收到红包</strong>：接受者对红包封面、留言、表情、金额均能正确了解</p>\n<p><strong>接收方的金额</strong>：被领取后显示已领取，领取者钱包增加相应金额，再次点开红包只能显示红包信息</p>\n<p><strong>只有接收方可以点开</strong>：发送方点开不能领取，只显示相关信息</p>\n<p><strong>未领取</strong>：24小时后未领取显示退回，钱包金额增加，对方不能再领取</p>\n<p><strong>群发红包功能：</strong></p>\n<p><strong>红包个数</strong>：红包个数为空、0、001、100、99、101</p>\n<p><strong>红包金额</strong>：红包拆开每个金额一样，均为发红包时设置的单个金额对应的钱数</p>\n<p><strong>红包被拆提示</strong>：红包被拆时，有相应提示</p>\n<p><strong>退回</strong>：红包24小时内未被拆完，剩余钱被退回，相应支付方式中钱数增加</p>\n<p><strong>群发红包-拼手气红包功能</strong></p>\n<p>每个人拆开数额不同，总金额等于红包总额；24小时内领完显示最佳手气，否则不显示</p>\n<p><strong>兼容性测试</strong></p>\n<p>测试安卓、ios不同型号收集</p>\n<p>UI测试：显示无错误，风格样式统一</p>\n<p>中断测试：不同应用间切换、没电、没网、来电话、短信</p>\n<p>网络测试：2g、3g、4g、5g、wifi、移动联通电信、弱网、没网</p>\n<h3 id=\"2-用户登录过程需要做哪些分析？\"><a href=\"#2-用户登录过程需要做哪些分析？\" class=\"headerlink\" title=\"2.用户登录过程需要做哪些分析？\"></a>2.用户登录过程需要做哪些分析？</h3><p><strong>功能测试：</strong></p>\n<p><strong>输入用户名和密码：</strong></p>\n<ul>\n<li><p>用户名和密码，太短或太长的处理（边界值法）</p>\n</li>\n<li><p>用户名和密码，有特殊字符(比如空格)及其他非英文的情况</p>\n</li>\n<li><p>记住用户名，记住密码</p>\n</li>\n<li><p>登录失败后，不记录密码</p>\n</li>\n<li><p>用户名和密码前后有空格的处理</p>\n</li>\n<li><p>密码是否是密文显示，使用*号或圆点等符号代替</p>\n</li>\n<li><p>验证码的辨认难度，考虑颜色（色盲使用者），刷新或换一个按钮是否好用</p>\n</li>\n<li><p>输入密码时，大写键盘开启时是否有提示信息</p>\n</li>\n<li><p>什么都不输入，点击提交按钮，检查提示信息</p>\n</li>\n</ul>\n<p><strong>登录流程：</strong></p>\n<ul>\n<li><p>正常流程（正确账号密码，点击提交，验证能否正确登录）</p>\n</li>\n<li><p>异常流程（错误的账号密码，点击提交，验证登录失败，并提示相应错误信息）</p>\n</li>\n<li><p>登录成功后能否正确跳转</p>\n</li>\n<li><p>登录token测试</p>\n</li>\n</ul>\n<p><strong>界面测试：</strong></p>\n<ul>\n<li><p>布局是否合理，按钮和表单是否整齐</p>\n</li>\n<li><p>按钮和表单高度和长度是否符合要求</p>\n</li>\n<li><p>界面风格是否符合UI设计稿</p>\n</li>\n<li><p>文字有无错别字</p>\n</li>\n</ul>\n<p><strong>性能测试：</strong></p>\n<ul>\n<li><p>打开登录界面，需要的时间是否在需求要求的时间内</p>\n</li>\n<li><p>输入正确的账号密码，点击登录，是否在需求时间内跳转成功</p>\n</li>\n<li><p>模拟大量用户同时登录，检查一定压力下能否正常跳转</p>\n</li>\n</ul>\n<p><strong>安全性测试</strong>：</p>\n<ul>\n<li><p>用户名或密码是否通过加密方式，发送给后端服务器</p>\n</li>\n<li><p>用户名和密码应该在前端和后端做双重验证</p>\n</li>\n<li><p>用户名和密码的输入框，应该屏蔽SQL注入攻击</p>\n</li>\n<li><p>用户名和密码的输入框，应该禁止输入脚本（防止XSS攻击）</p>\n</li>\n<li><p>防止暴力破解，检测是否有错误登录的次数限制</p>\n</li>\n<li><p>是否支持多用户在同一机器上登录</p>\n</li>\n<li><p>同一用户能否在多台机器上登录</p>\n</li>\n</ul>\n<p><strong>可用性测试：</strong></p>\n<ul>\n<li><p>是否可以用全键盘操作，是否有快捷键</p>\n</li>\n<li><p>输入用户名，密码后按回车，是否可以登录</p>\n</li>\n<li><p>输入框是否可以Tab切换</p>\n</li>\n</ul>\n<p><strong>兼容性测试</strong>：</p>\n<ul>\n<li><p>不同浏览器下能否显示正常，且功能正常</p>\n</li>\n<li><p>同种浏览器下不同版本能否显示正常且功能正常</p>\n</li>\n<li><p>不同的操作系统是否能正常工作</p>\n</li>\n<li><p>移动设备上是否正常工作</p>\n</li>\n</ul>\n<h3 id=\"3-如何对短视频APP-抖音-进行测试\"><a href=\"#3-如何对短视频APP-抖音-进行测试\" class=\"headerlink\" title=\"3.如何对短视频APP(抖音)进行测试\"></a>3.如何对短视频APP(抖音)进行测试</h3><p><strong>功能测试：</strong></p>\n<p><strong>刷抖音</strong>：</p>\n<ul>\n<li><p>视频清晰度</p>\n</li>\n<li><p>视频暂停、播放功能</p>\n</li>\n<li><p>视频信息（标题、描述、音乐、标签）</p>\n</li>\n<li><p>点赞数、双击点赞功能</p>\n</li>\n<li><p>评论功能（评论数、查看评论、发表评论）</p>\n</li>\n<li><p>分享转发</p>\n</li>\n<li><p>同款音乐</p>\n</li>\n<li><p>用户个人主页</p>\n</li>\n<li><p>搜索测试（热搜、话题功能）</p>\n</li>\n</ul>\n<p><strong>拍抖音</strong></p>\n<ul>\n<li><p>调起摄像头</p>\n</li>\n<li><p>视频拍摄、本地视频</p>\n</li>\n<li><p>视频剪辑功能测试</p>\n</li>\n<li><p>选择音乐功能测试</p>\n</li>\n<li><p>道具、表情、滤镜</p>\n</li>\n<li><p>发布短视频测试</p>\n</li>\n</ul>\n<p><strong>商业化</strong></p>\n<ul>\n<li><p>广告植入（跳过广告）</p>\n</li>\n<li><p>抖音商城</p>\n</li>\n</ul>\n<p><strong>性能测试：</strong></p>\n<ul>\n<li><p>视频质量（码流、帧率、不卡帧）</p>\n</li>\n<li><p>网络测试（wifi&#x2F;5G&#x2F;4G&#x2F;3G&#x2F;弱网、断网）</p>\n</li>\n<li><p>服务器负载测试</p>\n</li>\n<li><p>服务器压力测试</p>\n</li>\n<li><p>长时间运行</p>\n</li>\n<li><p>耗电量</p>\n</li>\n<li><p>内存是否泄漏</p>\n</li>\n<li><p>CPU状况</p>\n</li>\n</ul>\n<p><strong>安全测试：</strong></p>\n<ul>\n<li><p>视频链接加密</p>\n</li>\n<li><p>视频防止去水印</p>\n</li>\n<li><p>视频反爬</p>\n</li>\n</ul>\n<p><strong>异常测试</strong></p>\n<ul>\n<li><p>弱网、断网等异常测试</p>\n</li>\n<li><p>码率切换测试</p>\n</li>\n<li><p>破坏性点击（疯狂点赞、取消点赞）</p>\n</li>\n<li><p>切换前后台</p>\n</li>\n</ul>\n<p><strong>兼容性测试</strong></p>\n<ul>\n<li><p>移动端系统兼容性</p>\n</li>\n<li><p>应用权限测试</p>\n</li>\n</ul>\n<p><strong>安装、卸载测试</strong></p>\n<h3 id=\"4-如何对聊天系统（偏客服系统）进行测试\"><a href=\"#4-如何对聊天系统（偏客服系统）进行测试\" class=\"headerlink\" title=\"4.如何对聊天系统（偏客服系统）进行测试\"></a>4.如何对聊天系统（偏客服系统）进行测试</h3><p><strong>功能测试：</strong></p>\n<p>用户端：</p>\n<ul>\n<li><p>登陆状态下正常发送消息</p>\n</li>\n<li><p>未登录状态下发送消息，会提示去登陆</p>\n</li>\n<li><p>输入框发消息测试（过长、过短、表情、图片、视频、语音、英文、数字、url、卡片、红包、位置等）</p>\n</li>\n<li><p>接收消息测试</p>\n</li>\n<li><p>消息顺序（不乱序、不重复、不错误、不丢失）</p>\n</li>\n<li><p>历史消息</p>\n</li>\n<li><p>未读消息提醒（小红点显示隐藏、未读消息数）</p>\n</li>\n<li><p>用户头像点击</p>\n</li>\n<li><p>自动回复选项点击</p>\n</li>\n<li><p>长按消息（复制&#x2F;转发&#x2F;删除&#x2F;撤回&#x2F;引用）</p>\n</li>\n<li><p>一键跳转到最新消息</p>\n</li>\n</ul>\n<p>客服端：</p>\n<ul>\n<li><p>正常回复消息</p>\n</li>\n<li><p>输入框发消息测试（过长、过短、表情、图片、视频、语音、英文、数字、url、卡片、红包、位置等）</p>\n</li>\n<li><p>接收消息测试</p>\n</li>\n<li><p>消息顺序（不乱序、不重复、不错误、不丢失）</p>\n</li>\n<li><p>历史消息</p>\n</li>\n<li><p>未读消息提醒</p>\n</li>\n<li><p>自动回复设置</p>\n</li>\n<li><p>用户头像点击，用户信息采集</p>\n</li>\n<li><p>长按消息（复制&#x2F;转发&#x2F;删除&#x2F;撤回&#x2F;引用）</p>\n</li>\n<li><p>一键跳转到最新消息</p>\n</li>\n<li><p>消息群发（有可能也没有此功能）</p>\n</li>\n</ul>\n<p>接口测试：</p>\n<ul>\n<li><p>发送消息接口(msg_type&#x2F;msg_content&#x2F;埋点测试&#x2F;extra_content)</p>\n</li>\n<li><p>RPC接口调用</p>\n</li>\n<li><p>消息队列（排序、队列长度、数据格式）</p>\n</li>\n</ul>\n<p>性能测试：</p>\n<ul>\n<li><p>模拟多用户同时向单用户发送消息</p>\n</li>\n<li><p>模拟单用户同时向多用户发送消息</p>\n</li>\n<li><p>1s内发送多条消息</p>\n</li>\n<li><p>同一聊天室内，1s内接收多条消息，端上应有消息延迟展示策略</p>\n</li>\n</ul>\n<p>兼容性测试：</p>\n<ul>\n<li><p>跨平台跨系统登陆接收消息并展示</p>\n</li>\n<li><p>多端登陆同一个账号，接收别人发来的消息（若支持多端登录）</p>\n</li>\n<li><p>多端登录同一个账号，一端发送消息，自己的消息在别的端的展示情况（若支持多端登录）</p>\n</li>\n</ul>\n<p>异常测试：</p>\n<ul>\n<li><p>断网&#x2F;弱网情况下发送消息</p>\n</li>\n<li><p>输入框输入sql、脚本等</p>\n</li>\n</ul>\n<h3 id=\"5-如何对长视频APP（优酷）进行测试\"><a href=\"#5-如何对长视频APP（优酷）进行测试\" class=\"headerlink\" title=\"5.如何对长视频APP（优酷）进行测试\"></a>5.如何对长视频APP（优酷）进行测试</h3><p>1.功能测试：</p>\n<ul>\n<li><p>视频能够正常播放</p>\n</li>\n<li><p>会员特权（购买、有效期、行使特权）</p>\n</li>\n<li><p>播放组件（点播播放器、直播播放器、缓存视频播放器）</p>\n</li>\n<li><p>视频清晰度转换（手动、自动）</p>\n</li>\n<li><p>全屏&#x2F;缩放； 横屏&#x2F;竖屏；锁屏</p>\n</li>\n<li><p>播放&#x2F;暂停&#x2F;下一集</p>\n</li>\n<li><p>进度条（快进、快退、锚点播放）</p>\n</li>\n<li><p>亮度</p>\n</li>\n<li><p>声音</p>\n</li>\n<li><p>弹幕</p>\n</li>\n<li><p>缓存</p>\n</li>\n<li><p>投屏</p>\n</li>\n<li><p>选集</p>\n</li>\n<li><p>倍速</p>\n</li>\n<li><p>断点续播</p>\n</li>\n<li><p>视频水印</p>\n</li>\n<li><p>返回键</p>\n</li>\n<li><p>分享&#x2F;收藏</p>\n</li>\n<li><p>睡眠模式</p>\n</li>\n<li><p>商业化（广告）</p>\n</li>\n<li><p>片前广告&#x2F;片中广告&#x2F;片尾广告</p>\n</li>\n<li><p>暂停广告弹窗</p>\n</li>\n<li><p>VIP跳过广告</p>\n</li>\n<li><p>广告倒计时自动关闭</p>\n</li>\n</ul>\n<p>2.性能测试</p>\n<ul>\n<li><p>清晰度测试（4K、蓝光、超清、高清、标清、流畅），测试固定码率播放以及切换码率播放</p>\n</li>\n<li><p>负载测试（最大同时拉流数）</p>\n</li>\n<li><p>网络测试（wifi&#x2F;5G &#x2F;4G&#x2F;3G&#x2F;弱网、断网）</p>\n</li>\n<li><p>首屏加载时间</p>\n</li>\n<li><p>长时间运行</p>\n</li>\n<li><p>耗电量</p>\n</li>\n<li><p>内存泄漏</p>\n</li>\n<li><p>CPU状况</p>\n</li>\n<li><p>是否有丢帧</p>\n</li>\n</ul>\n<p>3.安全测试：</p>\n<ul>\n<li><p>视频流地址加密</p>\n</li>\n<li><p>会员接口不对外暴露</p>\n</li>\n<li><p>防止去广告脚本攻击</p>\n</li>\n<li><p>缓存视频加密</p>\n</li>\n</ul>\n<p>4.异常测试：</p>\n<ul>\n<li><p>弱网、断网等异常测试</p>\n</li>\n<li><p>码率切换测试</p>\n</li>\n<li><p>频繁切换前后台</p>\n</li>\n</ul>\n<p>5.兼容性测试</p>\n<ul>\n<li><p>移动端兼容性</p>\n</li>\n<li><p>PC端兼容性</p>\n</li>\n<li><p>浏览器兼容性</p>\n</li>\n<li><p>TV端</p>\n</li>\n</ul>\n<h3 id=\"6-如何对列表页（贝壳找房）进行测试\"><a href=\"#6-如何对列表页（贝壳找房）进行测试\" class=\"headerlink\" title=\"6.如何对列表页（贝壳找房）进行测试\"></a>6.如何对列表页（贝壳找房）进行测试</h3><p>1.功能测试</p>\n<ul>\n<li><p>列表排序</p>\n</li>\n<li><p>列表翻页</p>\n</li>\n<li><p>列表筛选</p>\n</li>\n<li><p>列表少结果、无结果、多结果的页面展示</p>\n</li>\n<li><p>检索系统、推荐系统、商业化（广告）测试</p>\n</li>\n<li><p>回到顶端浮标</p>\n</li>\n<li><p>列表卡片跳转</p>\n</li>\n<li><p>列表卡片UI展示（价格、标题、描述、标签等）</p>\n</li>\n<li><p>上滑加载更多</p>\n</li>\n<li><p>下拉刷新列表</p>\n</li>\n<li><p>其他（浮标按钮等）</p>\n</li>\n</ul>\n<p>2.性能测试</p>\n<ul>\n<li><p>压力测试</p>\n</li>\n<li><p>负载测试</p>\n</li>\n<li><p>大数据量返回的表现（一般后端会做翻页）</p>\n</li>\n<li><p>页面响应时间测试</p>\n</li>\n</ul>\n<p>3.兼容性</p>\n<ul>\n<li><p>浏览器兼容性</p>\n</li>\n<li><p>PC端操作系统兼容性</p>\n</li>\n<li><p>移动端操作系统兼容性</p>\n</li>\n<li><p>弱网&#x2F;无网显示</p>\n</li>\n</ul>\n<p>4.埋点测试</p>\n<ul>\n<li><p>曝光埋点</p>\n</li>\n<li><p>点击埋点</p>\n</li>\n<li><p>PV&#x2F;uv统计</p>\n</li>\n</ul>\n<h3 id=\"7-如何对搜索框（贝壳找房）进行测试\"><a href=\"#7-如何对搜索框（贝壳找房）进行测试\" class=\"headerlink\" title=\"7.如何对搜索框（贝壳找房）进行测试\"></a>7.如何对搜索框（贝壳找房）进行测试</h3><p>1.功能测试</p>\n<ul>\n<li><p>输入关键字，查看返回结果是否准确</p>\n</li>\n<li><p>查询有结果的显示</p>\n</li>\n<li><p>查询无结果的显示</p>\n</li>\n<li><p>查询少结果的显示</p>\n</li>\n<li><p>输入框测试：输入特殊内容，过长&#x2F;过短的关键词，关键词输入</p>\n</li>\n<li><p>正常：楼盘、地区、街道、公司、城市、地铁沿线、商圈等关键词</p>\n</li>\n<li><p>异常：空格及其他特殊字符、代码等。</p>\n</li>\n<li><p>热门关键词搜索测试（需要结合CMS后台测试）</p>\n</li>\n<li><p>sug动态搜索测试</p>\n</li>\n<li><p>商业化（广告）相关测试</p>\n</li>\n<li><p>搜索出来的楼盘结果列表：排序、翻页、是否列表去重</p>\n</li>\n<li><p>搜索历史功能测试</p>\n</li>\n<li><p>检索系统和推荐系统的测试</p>\n</li>\n<li><p>结果跳转（跳转到详情页、跳转到列表页）</p>\n</li>\n</ul>\n<p>2.性能测试</p>\n<ul>\n<li><p>sug耗时</p>\n</li>\n<li><p>点击搜索结果，渲染结果列表耗时</p>\n</li>\n<li><p>压力测试，不同用户数压力下的表现</p>\n</li>\n<li><p>负载测试，看极限能承受多大的用户量同时正常使用</p>\n</li>\n<li><p>大数据量返回的表现</p>\n</li>\n</ul>\n<p>3.易用性</p>\n<ul>\n<li><p>功能是否易用，输入法调起是否正常，按钮可点击区域是否满足易用性</p>\n</li>\n<li><p>针对不同，是否有友好的提醒</p>\n</li>\n<li><p>搜索结果的楼盘卡片是否显示合理（价格、标题、描述等）</p>\n</li>\n<li><p>搜索结果是否准确，排序是否合理</p>\n</li>\n<li><p>控件设计是否符合APP整体设计风格</p>\n</li>\n</ul>\n<p>4.兼容性</p>\n<ul>\n<li><p>浏览器兼容性</p>\n</li>\n<li><p>PC端操作系统兼容性</p>\n</li>\n<li><p>移动端操作系统兼容性</p>\n</li>\n<li><p>杀毒软件、防火墙、不同输入法等工具共同使用，是否适配</p>\n</li>\n</ul>\n<p>5.安全性</p>\n<ul>\n<li><p>表单不允许被SQL注入（录入一些数据库查询的保留字符，如单引号，%等）</p>\n</li>\n<li><p>是否有反爬策略</p>\n</li>\n<li><p>是否有黄反策略或对涉及国家安全、法律禁止的内容是否进行过滤和控制</p>\n</li>\n</ul>\n<h3 id=\"8-测试一瓶矿泉水\"><a href=\"#8-测试一瓶矿泉水\" class=\"headerlink\" title=\"8.测试一瓶矿泉水\"></a>8.测试一瓶矿泉水</h3><p>1.功能测试</p>\n<p>水瓶漏不漏、瓶中的水能不能被喝到</p>\n<p>2.界面测试</p>\n<p>外观是否没管</p>\n<p>3.安全性：瓶子的材质有没有毒或者细菌</p>\n<p>4.可靠性：从不同高度落下的损坏程度</p>\n<p>5.可移植性：在不同的地方、温度等环境下是否都可以正常使用</p>\n<p>6.兼容性：是否能够容纳果汁、白水、酒精、汽油等</p>\n<p>7.易用性：是否烫手、是否有防滑措施，是否方便饮用</p>\n<p>8.用户文档：使用手册是否对用法、限制、使用条件等有详细描述</p>\n<p>疲劳测试：将盛上水放24小时检查泄漏时间和情况；盛上汽油放24小时检查泄漏时间和情况等</p>\n<p>压力测试：用根针并在针上面不断加重量，看压强多大时会穿透</p>\n<p>跌落测试：测试在何种高度跌落会破坏水瓶</p>\n<h3 id=\"9-测试朋友圈点赞功能\"><a href=\"#9-测试朋友圈点赞功能\" class=\"headerlink\" title=\"9.测试朋友圈点赞功能\"></a>9.测试朋友圈点赞功能</h3><p>功能测试：</p>\n<p>1.是否可以正常点赞和取消</p>\n<p>2.点赞的人是否在可见分组里</p>\n<p>3.点赞状态是否能即时更新显示</p>\n<p>4.点赞状态，共同好友是否可见</p>\n<p>5.点赞显示的是否正确，一行几个</p>\n<p>6.点赞是否按时间进行排序，头像对应的是否正确</p>\n<p>7.是否能在消息列表中显示点赞人的昵称</p>\n<p>接口测试：点赞朋友圈，验证朋友能否收到提示消息</p>\n<p>性能测试：点赞朋友圈，是否在规定时间显示结果，是否在规定时间在朋友手机上进行提示</p>\n<p>兼容性测试：在不同的终端上点赞，验证是否成功</p>\n<h3 id=\"答题角度总结\"><a href=\"#答题角度总结\" class=\"headerlink\" title=\"答题角度总结\"></a>答题角度总结</h3><p><strong>日常物品</strong></p>\n<p>功能测试：等价类划分+边界值分析。</p>\n<p>外观测试：外观完整、美观；尺寸大小&#x2F;材质；外部说明清晰；舒适度</p>\n<p>性能测试：使用寿命、响应时间、长时间使用情况、负载情况、压力情况</p>\n<p>安全测试：材质毒性</p>\n<p>兼容测试：</p>\n<p>易用测试：使用方便、携带方便、操作简单、防护措施</p>\n<p>异常测试：耐破坏性、异常情况的响应、应急情况</p>\n<p>可维护性：配件更换、维修、拆除</p>\n<p><strong>文本框&#x2F;登录&#x2F;聊天&#x2F;查找类</strong></p>\n<p>功能测试：太短&#x2F;太长(边界值分析)&#x2F;特殊字符&#x2F;输入为空、正常流程、异常流程、选中、复制粘贴、光标位置</p>\n<p>性能测试：响应时间、压力测试、负载测试、单人聊天、多人聊天</p>\n<p>易用&#x2F;界面：输入法调起、按钮点击区域、提醒到位、搜索结果、展示结果是否合理、设计风格、快捷键</p>\n<p>兼容性：浏览器、PC端、移动端、杀毒软件、防火墙、不同输入法、不同版本、</p>\n<p>安全性：异常测试（弱网、断网）、反爬策略、内容审核、不允许SQL注入、加密传输、防止暴力破解、多端登录</p>\n<p><strong>支付交易类</strong></p>\n<p>功能测试：支付方式、余额充足或不足、密码输入正确或错误、验证码、金额校验(空值、负值、最小金额、最大金额、消费上限)、取消支付</p>\n<p>性能测试：页面跳转时间、耗电量和流量、更换支付方式响应时间、并发情况下、多端登录</p>\n<p>外观测试：页面美观、布局合理、信息提示正确、字体清晰</p>\n<p>安全测试：密码暗纹、支付金额过大、对面账户异常、新设备授权、</p>\n<p>易用测试：操作简单快捷、提示信息到位</p>\n<p>兼容性测试：不同系统、不同版本、不同网络、不同浏览器、</p>\n<p>异常测试：断网、弱网、关机、刷新页面、退出程序</p>\n<p><strong>人工智能类</strong></p>\n<p>功能测试：不说话&#x2F;声音小&#x2F;错别字&#x2F;文字长度限制&#x2F;语音时间限制&#x2F;不同语言&#x2F;不同物种语音&#x2F;多语音&#x2F;敏感词处理&#x2F;断句功能&#x2F;识别数字</p>\n<p>性能测试：响应时间、耗电量、资源占用</p>\n<p>外观测试：界面设计、布局合理、信息提示正确</p>\n<p>易用测试：操作简单快捷、提示信息到位</p>\n<p>兼容性测试：不同系统、不同版本、不同网络、不同浏览器</p>\n<p>异常测试：断网、弱网发送顺序、关机</p>\n<p><strong>视频类</strong></p>\n<p>功能测试：清晰度、暂停播放、视频信息、互动功能、分享转发、个人主页、广告植入、会员特权、播放组件（弹幕、进度条、声音、投屏、小屏幕、）断点续播</p>\n<p>性能测试：负载测试、压力测试、资源消耗、视频质量（帧率、码流）</p>\n<p>安全测试：视频链接加密、反爬、防止去水印、脚本攻击</p>\n<p>异常测试：弱网、断网、码率切换测试、破坏性点击、切换前后台</p>\n<p>兼容性测试：不同设备、不同网络、不同操作系统</p>\n","categories":["八股"]},{"title":"设计模式","url":"/2023/06/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/","content":"<h2 id=\"面向对象设计原则\"><a href=\"#面向对象设计原则\" class=\"headerlink\" title=\"面向对象设计原则\"></a>面向对象设计原则</h2><ul>\n<li><p>1、单一职责（Single Responsibility Principle）</p>\n</li>\n<li><ul>\n<li>定义：一个类只负责一个功能另有中的相应职责———-就一个类而言，应该只有一个引起它变化的原因；<span id=\"more\"></span></li>\n<li>优点：实现高内聚，低耦合；</li>\n<li>应用场景：</li>\n</ul>\n</li>\n<li><ul>\n<li><ul>\n<li>也就是说一个类里最好是放一种类型的方法；比如：DAO：只放操作数据库的方法；Util：只放某个工具的方法；</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>2、开闭原则（Open Close Principle）</p>\n</li>\n<li><ul>\n<li>定义：当有新的需求的时候，我们不用修改现在的代码，只需要添加新的代码就可以</li>\n<li>优点：对拓展开放，对内修改关闭。</li>\n</ul>\n</li>\n<li><p>3、里氏替换原则（Liskov Substitution Principle）</p>\n</li>\n<li><ul>\n<li>定义：所有引用基类的地方必须能透明地使用其子类的对象，也就是说子类对象可以替换其父类对象，而程序执行效果不变。</li>\n<li>里氏替换原则是使代码符合开闭原则的一个重要保证；</li>\n<li>优点：</li>\n</ul>\n</li>\n<li><ul>\n<li><ul>\n<li>约束继承泛滥，是开闭原则的一种体现；</li>\n<li>加强程序的健壮性，同时变更时也可以做到非常好的提高程序的维护性、扩展性。降低需求变更时引入的风险；</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><ul>\n<li>要求：</li>\n</ul>\n</li>\n<li><ul>\n<li><ul>\n<li>○ 子类可以扩展父类的功能，但不能改变父类原有的功能</li>\n<li>○ 子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法；</li>\n<li>○ 子类可以增加自己特有的方法；</li>\n<li>○ 当子类单独的方法重载父类的方法时，方法的前置条件（即方法的输入&#x2F;入参）要比父类方法的输入参数更宽松；</li>\n<li>○ 当子类的方法实现父类的方法时（重载&#x2F;重写或实现抽象方法）的后置条件（即方法的输出&#x2F;返回值）要比父类更严格或者相等；</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>4、接口隔离原则（Interface Segregation Principle）</p>\n</li>\n<li><ul>\n<li>定义：不能强迫用户去依赖那些他们不使用的接口。即：使用多个专门的接口会比使用单一的总接口好；</li>\n<li>优点：避免同一个接口里面包含不同类职责的方法，接口责任划分更加明确，符合高内聚低耦合的思想。</li>\n<li>接口分隔原则：</li>\n</ul>\n</li>\n<li><ul>\n<li><ul>\n<li>1、一个类对一个类的依赖应该建立在最小的接口上</li>\n<li>2、建立单一接口，不要建立庞大臃肿的接口</li>\n<li>3、尽量细化接口，接口中的方法尽量少</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>5、依赖倒置原则（Dependency Inversion Principle）</p>\n</li>\n<li><ul>\n<li>定义：抽象不应该不依赖于细节，细节应该依赖于抽象；即：针对接口编程，而不是针对实现编程。</li>\n<li>优点：可以减少类间的耦合性、提高系统的稳定性，提高代码可读性和可维护性，可降低修改程序所造成的的风险。</li>\n<li>要求：</li>\n</ul>\n</li>\n<li><ul>\n<li><ul>\n<li>依赖抽象，而不是依赖实现。</li>\n<li>抽象不应该依赖细节；细节应该依赖抽象。</li>\n<li>高层模块不能依赖低层模块，二者都应该依赖抽象。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>6、迪米特原则（Law of Demeter 又名Least Knowledge Principle）</p>\n</li>\n<li><ul>\n<li>定义：一个对象应该对尽可能少的对象有接触，也就是只接触那些真正需要接触的对象。</li>\n<li>优点：降低类与类之间的耦合</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Spring-使⽤了哪些设计模式？\"><a href=\"#Spring-使⽤了哪些设计模式？\" class=\"headerlink\" title=\"Spring 使⽤了哪些设计模式？\"></a>Spring 使⽤了哪些设计模式？</h2><p>Spring 框架中⽤到了哪些设计模式？⼯⼚设计模式 : Spring 使⽤⼯⼚模式通过BeanFactory 、 ApplicationContext 创建 bean 对象。代理设计模式 : Spring AOP 功能的实现。单例设计模式 : Spring 中的 Bean 默认都是单例的。模板⽅法模式 : Spring 中 jdbcTemplate 、 hibernateTemplate 等以Template 结尾的对数据库操作的类，它们就使⽤到了模板模式。包装器设计模式 : 我们的项⽬需要连接多个数据库，⽽且不同的客户在每次访问中根据需要会去访问不同的数据库。这种模式让我们可以根据客户的需求能够动态切换不同的数据源。观察者模式: Spring 事件驱动模型就是观察者模式很经典的⼀个应⽤。适配器模式 :Spring AOP 的增强或通知(Advice)使⽤到了适配器模式、spring MVC 中也是⽤到了适配器模式适配 Controller 。 </p>\n<h2 id=\"stream流和for的区别？\"><a href=\"#stream流和for的区别？\" class=\"headerlink\" title=\"stream流和for的区别？\"></a>stream流和for的区别？</h2><h2 id=\"jdk1-8的新特性有哪些？\"><a href=\"#jdk1-8的新特性有哪些？\" class=\"headerlink\" title=\"jdk1.8的新特性有哪些？\"></a>jdk1.8的新特性有哪些？</h2><p>lamad表达式，stream流，localDate和localDateTime日期类</p>\n<table>\n<thead>\n<tr>\n<th><strong>特征</strong></th>\n<th><strong>jdk17</strong></th>\n<th><strong>jdk8</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>垃圾收集器</td>\n<td>ZGC（jdk11提出）（新型垃圾收集器）</td>\n<td>G1收集器</td>\n</tr>\n<tr>\n<td>新特性</td>\n<td>Record类、引入了C++风格的内存管理</td>\n<td>Lambda表达式、Stream API、函数式接口</td>\n</tr>\n<tr>\n<td>性能比较</td>\n<td>改进了JIT编译器、垃圾回收器，提升了性能和响应速度</td>\n<td>不如17</td>\n</tr>\n<tr>\n<td>适用场景</td>\n<td>Java 17则更适合用于开发大型应用程序和高性能应用程序，例如高性能计算、云计算、大数据处理等。</td>\n<td>Java 8适用于开发中小型应用程序和Web应用程序，例如Web服务、企业级应用程序和桌面应用程序等。</td>\n</tr>\n</tbody></table>\n<p>ZGC优化在哪</p>\n<ul>\n<li>支持 JVM 选项 -XX:+UseDynamicNumberOfGCThreads。此功能默认启用，并告诉 ZGC 对其使用的 GC 线程数保持智能，这通常会导致 Java 应用程序级别的更高吞吐量和更低延迟。</li>\n<li>使用了ZGC的JVM在停止运行时， 基本上是实时的，而之前版本花费的时间更多。</li>\n<li>标记算法现在通常使用更少的内存，并且不再容易出现过多的内存使用。</li>\n<li>ZGC 现在可以在 macOS&#x2F;Aarch64 上运行。</li>\n<li>ZGC 现在发布了两个 GarbageCollectorMXBean，以提供有关 GC 周期和 GC 暂停的信息。</li>\n</ul>\n","categories":["八股"]},{"title":"计算机网络","url":"/2023/06/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/","content":"<h2 id=\"计算机网络的各层协议及作用？\"><a href=\"#计算机网络的各层协议及作用？\" class=\"headerlink\" title=\"计算机网络的各层协议及作用？\"></a>计算机网络的各层协议及作用？</h2><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/image-20230318181257136.png\" alt=\"img\" style=\"zoom:50%;\">\n\n\n\n<span id=\"more\"></span>应用层：**应用进程之间交互**   DNS（域名系统）  HTTP（超文本传输协议）  SMTP（电子邮件）\n\n\n\n<p>表示层：<strong>数据格式的转换</strong>，如加密解密、转换翻译、压缩解压缩等。</p>\n<p>会话层：网络中的两节点之间建立、维持和终止通信，如<strong>服务器验证用户登录</strong></p>\n<p>运输层：为应用层提供通用数据传输服务 TCP（面向连接 可靠） UDP（⽆连接  不保证数据传输的可靠性  ）</p>\n<p>网络层：选择合适路由节点  确保数据及时发送  IP协议</p>\n<p>数据链路层：把网络层交付下来的ip数据报组装为帧 在两个相邻节点间链路传送帧（发数据）  帧包括数据＋控制信息（同步信息、地址信息、差错控制–丢失帧）</p>\n<p>物理层：数据单位bt  实现相邻节点<strong>比特流</strong>的透明传输 尽量屏蔽传输介质和物理设备差异</p>\n<h2 id=\"为什么分层？\"><a href=\"#为什么分层？\" class=\"headerlink\" title=\"为什么分层？\"></a>为什么分层？</h2><p>1、易于实现和标准化各层独立，就可以把大问题分割成多个小问题，利于实现；</p>\n<p>2、灵活性好：如果某一层发生变化，只要接口不变，不会影响其他层；</p>\n<p>3、分层后，用户只关心用到的应用层，其他层用户可以复用；<br>4、各层之间相互独立：高层不需要知道底层的功能是采取硬件来实现的，只需要知道通过底层的接口来获得所需要的服务。</p>\n<h3 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h3><p>三层架构和MVC</p>\n<h2 id=\"三次握手-（建立连接）\"><a href=\"#三次握手-（建立连接）\" class=\"headerlink\" title=\"三次握手 （建立连接）\"></a>三次握手 （建立连接）</h2><p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/image-20210520161056918.png\" alt=\"img\"></p>\n<p>三次握手机制：</p>\n<ul>\n<li>第一次握手：客户端请求建立连接，向服务端发送一个<strong>同步报文</strong>（SYN&#x3D;1），同时选择一个随机数 seq &#x3D; x 作为<strong>初始序列号</strong>，并进入SYN_SENT状态，等待服务器确认。</li>\n<li>第二次握手：：服务端收到连接请求报文后，如果同意建立连接，则向客户端发送<strong>同步确认报文</strong>（SYN&#x3D;1，ACK&#x3D;1），确认号为 ack &#x3D; x + 1，同时选择一个随机数 seq &#x3D; y 作为初始序列号，此时服务器进入SYN_RECV状态。</li>\n<li>第三次握手：客户端收到服务端的确认后，向服务端发送一个<strong>确认报文</strong>（ACK&#x3D;1），确认号为 ack &#x3D; y + 1，序列号为 seq &#x3D; x + 1，客户端和服务器进入ESTABLISHED状态，完成三次握手。</li>\n</ul>\n<p>理想状态下，TCP连接一旦建立，在通信双方中的任何一方主动关闭连接之前，TCP 连接都将被一直保持下去。</p>\n<p>确认号&#x3D;序列号+1;</p>\n<p>总结：</p>\n<p>1、客户端发送带有syn(请求同步)的数据包到服务端  选择一个随机数seq&#x3D;x</p>\n<p>服务端发送带有syn+ack的数据包</p>\n<p>客户端发送带有ack标志数据包</p>\n<p>目的：建立可靠传输，双方确认自己与对方的发送接受都正常</p>\n<p>确保双方都是能发能接</p>\n<h2 id=\"为什么需要三次握手，而不是两次？\"><a href=\"#为什么需要三次握手，而不是两次？\" class=\"headerlink\" title=\"为什么需要三次握手，而不是两次？\"></a><a href=\"https://www.javalearn.cn/#/doc/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%9D%A2%E8%AF%95%E9%A2%98?id=_5-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%EF%BC%8C%E8%80%8C%E4%B8%8D%E6%98%AF%E4%B8%A4%E6%AC%A1%EF%BC%9F\">为什么需要三次握手，而不是两次？</a></h2><p>主要有三个原因：</p>\n<ol>\n<li>防止已过期的连接请求报文突然又传送到服务器，因而产生错误和资源浪费。<br>   在双方两次握手即可建立连接的情况下，假设客户端发送 A 报文段请求建立连接，由于网络原因造成 A 暂时无法到达服务器，服务器接收不到请求报文段就不会返回确认报文段。<br>   客户端在长时间得不到应答的情况下重新发送请求报文段 B，这次 B 顺利到达服务器，服务器随即返回确认报文并进入 ESTABLISHED 状态，客户端在收到 确认报文后也进入 ESTABLISHED 状态，双方建立连接并传输数据，之后正常断开连接。<br>   此时姗姗来迟的 A 报文段才到达服务器，服务器随即返回确认报文并进入 ESTABLISHED 状态，但是已经进入 CLOSED 状态的客户端无法再接受确认报文段，更无法进入 ESTABLISHED 状态，这将导致服务器长时间单方面等待，造成资源浪费。 </li>\n<li>三次握手才能让双方均确认自己和对方的发送和接收能力都正常。<br>   第一次握手：客户端只是发送处请求报文段，<strong>什么都无法确认</strong>，而服务器可以确认自己的接收能力和对方的发送能力正常；<br>   第二次握手：客户端可以确认自己发送能力和接收能力正常，对方发送能力和接收能力正常；<br>   第三次握手：服务器可以确认自己发送能力和接收能力正常，对方发送能力和接收能力正常；<br>   可见三次握手才能让双方都确认自己和对方的发送和接收能力全部正常，这样就可以愉快地进行通信了。 </li>\n<li>告知对方自己的初始序号值，并确认收到对方的初始序号值。<br>   TCP 实现了可靠的数据传输，原因之一就是 TCP 报文段中维护了序号字段和确认序号字段，通过这两个字段双方都可以知道在自己发出的数据中，哪些是已经被对方确认接收的。这两个字段的值会在初始序号值得基础递增，<strong>如果是两次握手，只有发起方的初始序号可以得到确认，而另一方的初始序号则得不到确认。</strong></li>\n</ol>\n<h2 id=\"为什么要三次握手，而不是四次？\"><a href=\"#为什么要三次握手，而不是四次？\" class=\"headerlink\" title=\"为什么要三次握手，而不是四次？\"></a><a href=\"https://www.javalearn.cn/#/doc/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%9D%A2%E8%AF%95%E9%A2%98?id=_6-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%EF%BC%8C%E8%80%8C%E4%B8%8D%E6%98%AF%E5%9B%9B%E6%AC%A1%EF%BC%9F\">为什么要三次握手，而不是四次？</a></h2><p>因为<strong>三次握手已经可以确认双方的发送接收能力正常</strong>，双方都知道彼此已经准备好，而且也可以完成对双方初始序号值得确认，也就无需再第四次握手了。</p>\n<ul>\n<li>第一次握手：服务端确认“自己收、客户端发”报文功能正常。</li>\n<li>第二次握手：客户端确认“自己发、自己收、服务端收、客户端发”报文功能正常，客户端认为连接已建立。</li>\n<li>第三次握手：服务端确认“自己发、客户端收”报文功能正常，此时双方均建立连接，可以正常通信。</li>\n</ul>\n<h2 id=\"什么是-SYN洪泛攻击？如何防范？\"><a href=\"#什么是-SYN洪泛攻击？如何防范？\" class=\"headerlink\" title=\"什么是 SYN洪泛攻击？如何防范？\"></a><a href=\"https://www.javalearn.cn/#/doc/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%9D%A2%E8%AF%95%E9%A2%98?id=_7-%E4%BB%80%E4%B9%88%E6%98%AF-syn%E6%B4%AA%E6%B3%9B%E6%94%BB%E5%87%BB%EF%BC%9F%E5%A6%82%E4%BD%95%E9%98%B2%E8%8C%83%EF%BC%9F\">什么是 SYN洪泛攻击？如何防范？</a></h2><p>SYN洪泛攻击属于 DOS 攻击的一种，它利用 TCP 协议缺陷，通过发送大量的半连接请求，耗费 CPU 和内存资源。</p>\n<p>原理：</p>\n<ul>\n<li>在三次握手过程中，服务器发送 <code>[SYN/ACK]</code> 包（第二个包）之后、收到客户端的 <code>[ACK]</code> 包（第三个包）之前的 TCP 连接称为半连接（half-open connect），此时服务器处于 <code>SYN_RECV</code>（等待客户端响应）状态。如果接收到客户端的 <code>[ACK]</code>，则 TCP 连接成功，如果未接受到，则会<strong>不断重发请求</strong>直至成功。</li>\n<li>SYN 攻击的攻击者在短时间内<strong>伪造大量不存在的 IP 地址</strong>，向服务器不断地发送 <code>[SYN]</code> 包，服务器回复 <code>[SYN/ACK]</code> 包，并等待客户的确认。由于源地址是不存在的，服务器需要不断的重发直至超时。</li>\n<li>这些伪造的 <code>[SYN]</code> 包将长时间占用未连接队列，影响了正常的 SYN，导致目标系统运行缓慢、网络堵塞甚至系统瘫痪。</li>\n</ul>\n<p>总结，不存在Ip发syn包，让服务器一直等待</p>\n<p>检测：当在服务器上看到大量的半连接状态时，特别是源 IP 地址是随机的，基本上可以断定这是一次 SYN 攻击。</p>\n<p>防范：</p>\n<ul>\n<li>通过防火墙、路由器等过滤网关防护。</li>\n<li>通过加固 TCP&#x2F;IP 协议栈防范，如增加最大半连接数，缩短超时时间。</li>\n<li>SYN cookies技术。SYN Cookies 是对 TCP 服务器端的三次握手做一些修改，专门用来防范 SYN 洪泛攻击的一种手段。</li>\n</ul>\n<h2 id=\"三次握手连接阶段，最后一次ACK包丢失，会发生什么？\"><a href=\"#三次握手连接阶段，最后一次ACK包丢失，会发生什么？\" class=\"headerlink\" title=\"三次握手连接阶段，最后一次ACK包丢失，会发生什么？\"></a><a href=\"https://www.javalearn.cn/#/doc/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%9D%A2%E8%AF%95%E9%A2%98?id=_8-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E8%BF%9E%E6%8E%A5%E9%98%B6%E6%AE%B5%EF%BC%8C%E6%9C%80%E5%90%8E%E4%B8%80%E6%AC%A1ack%E5%8C%85%E4%B8%A2%E5%A4%B1%EF%BC%8C%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%EF%BC%9F\">三次握手连接阶段，最后一次ACK包丢失，会发生什么？</a></h2><p><strong>服务端：</strong></p>\n<p>（服务端超时重传 重传指定次数后 服务器自动关连接）</p>\n<ul>\n<li>第三次的ACK在网络中丢失，那么服务端该TCP连接的状态为SYN_RECV,并且会根据 TCP的超时重传机制，会等待3秒、6秒、12秒后重新发送SYN+ACK包，以便客户端重新发送ACK包。</li>\n<li>如果重发指定次数之后，仍然未收到 客户端的ACK应答，那么一段时间后，服务端自动关闭这个连接。</li>\n</ul>\n<p><strong>客户端：</strong></p>\n<p>(后面发数据 会发现三次握手失败)</p>\n<p>客户端认为这个连接已经建立，如果客户端向服务端发送数据，服务端将以RST包（Reset，标示复位，用于异常的关闭连接）响应。此时，客户端知道第三次握手失败。</p>\n<h2 id=\"四次挥手（断开连接）\"><a href=\"#四次挥手（断开连接）\" class=\"headerlink\" title=\"四次挥手（断开连接）\"></a>四次挥手（断开连接）</h2><p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/image-20210520180127547.png\" alt=\"img\"></p>\n<ul>\n<li><p>第一次挥手：客户端向服务端发送连接释放报文（FIN&#x3D;1，ACK&#x3D;1），主动关闭连接，同时等待服务端的确认。 </p>\n</li>\n<li><ul>\n<li>序列号 seq &#x3D; u，即客户端上次发送的报文的最后一个字节的序号 + 1</li>\n<li>确认号 ack &#x3D; k, 即服务端上次发送的报文的最后一个字节的序号 + 1</li>\n</ul>\n</li>\n<li><p>第二次挥手：服务端收到连接释放报文后，立即发出<strong>确认报文</strong>（ACK&#x3D;1）（序列号 seq &#x3D; k，确认号 ack &#x3D; u + 1）。<br>  这时 TCP 连接处于半关闭状态，即客户端到服务端的连接已经释放了，但是服务端到客户端的连接还未释放。这表示客户端已经没有数据发送了，但是服务端可能还要给客户端发送数据。 </p>\n</li>\n<li><p>第三次挥手：服务端向客户端发送连接释放报文（FIN&#x3D;1，ACK&#x3D;1），主动关闭连接，同时等待 A 的确认。 </p>\n</li>\n<li><ul>\n<li>序列号 seq &#x3D; w，即服务端上次发送的报文的最后一个字节的序号 + 1。</li>\n<li>确认号 ack &#x3D; u + 1，与第二次挥手相同，因为这段时间客户端没有发送数据</li>\n</ul>\n</li>\n<li><p>第四次挥手：客户端收到服务端的连接释放报文后，立即发出<strong>确认报文</strong>（ACK&#x3D;1）（序列号 seq &#x3D; u + 1，确认号为 ack &#x3D; w + 1）。<br>  此时，客户端就进入了 <code>TIME-WAIT</code> 状态。注意此时客户端到 TCP 连接还没有释放，必须经过 2*MSL（最长报文段寿命）的时间后，才进入 <code>CLOSED</code> 状态。而服务端只要收到客户端发出的确认，就立即进入 <code>CLOSED</code> 状态。可以看到，服务端结束 TCP 连接的时间要比客户端早一些。</p>\n</li>\n</ul>\n<p>总结：</p>\n<p>客户端发送一个fin，服务端回一个ack，然后客户端到服务端的数据传送关闭</p>\n<p>服务端发送一个fin，客户端回一个ack，然后服务端到客户端的数据传送关闭</p>\n<p>目的  ：两边确认对方没有要发送的数据</p>\n<h2 id=\"为什么连接的时候是三次握手，关闭的时候却是四次握手？\"><a href=\"#为什么连接的时候是三次握手，关闭的时候却是四次握手？\" class=\"headerlink\" title=\"为什么连接的时候是三次握手，关闭的时候却是四次握手？\"></a><a href=\"https://www.javalearn.cn/#/doc/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%9D%A2%E8%AF%95%E9%A2%98?id=_10-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%9E%E6%8E%A5%E7%9A%84%E6%97%B6%E5%80%99%E6%98%AF%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%EF%BC%8C%E5%85%B3%E9%97%AD%E7%9A%84%E6%97%B6%E5%80%99%E5%8D%B4%E6%98%AF%E5%9B%9B%E6%AC%A1%E6%8F%A1%E6%89%8B%EF%BC%9F\">为什么连接的时候是三次握手，关闭的时候却是四次握手？</a></h2><p>服务器在收到客户端的 FIN 报文段后，可能还有一些数据要传输，所以不能马上关闭连接，但是会做出应答，返回 ACK 报文段.</p>\n<p>接下来可能会继续发送数据，在数据发送完后，服务器会向客户单发送 FIN 报文，表示数据已经发送完毕，请求关闭连接。服务器的<strong>ACK和FIN一般都会分开发送</strong>，从而导致多了一次，因此一共需要四次挥手。</p>\n<h2 id=\"为什么客户端的-TIME-WAIT-状态必须等待-2MSL-？\"><a href=\"#为什么客户端的-TIME-WAIT-状态必须等待-2MSL-？\" class=\"headerlink\" title=\"为什么客户端的 TIME-WAIT 状态必须等待 2MSL ？\"></a><a href=\"https://www.javalearn.cn/#/doc/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%9D%A2%E8%AF%95%E9%A2%98?id=_11-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84-time-wait-%E7%8A%B6%E6%80%81%E5%BF%85%E9%A1%BB%E7%AD%89%E5%BE%85-2msl-%EF%BC%9F\">为什么客户端的 TIME-WAIT 状态必须等待 2MSL ？</a></h2><p>主要有两个原因：</p>\n<ol>\n<li>确保 ACK 报文能够到达服务端，从而使服务端正常关闭连接。<br>   第四次挥手时，客户端第四次挥手的 ACK 报文不一定会到达服务端。服务端会超时重传 FIN&#x2F;ACK 报文，此时如果客户端已经断开了连接，那么就无法响应服务端的二次请求，这样服务端迟迟收不到 FIN&#x2F;ACK 报文的确认，就无法正常断开连接。<br>   MSL 是报文段在网络上存活的最长时间。客户端等待 2MSL 时间，即「客户端 ACK 报文 1MSL 超时 + 服务端 FIN 报文 1MSL 传输」，就能够收到服务端重传的 FIN&#x2F;ACK 报文，然后客户端重传一次 ACK 报文，并重新启动 2MSL 计时器。如此保证服务端能够正常关闭。<br>   如果服务端重发的 FIN 没有成功地在 2MSL 时间里传给客户端，服务端则会继续超时重试直到断开连接。 </li>\n<li>防止已失效的连接请求报文段出现在之后的连接中。<br>   TCP 要求在 2MSL 内不使用相同的序列号。客户端在发送完最后一个 ACK 报文段后，再经过时间 2MSL，就可以保证本连接持续的时间内产生的所有报文段都从网络中消失。这样就可以使下一个连接中不会出现这种旧的连接请求报文段。或者即使收到这些过时的报文，也可以不处理它。</li>\n</ol>\n<h2 id=\"如果已经建立了连接，但是客户端出现故障了怎么办？\"><a href=\"#如果已经建立了连接，但是客户端出现故障了怎么办？\" class=\"headerlink\" title=\"如果已经建立了连接，但是客户端出现故障了怎么办？\"></a><a href=\"https://www.javalearn.cn/#/doc/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%9D%A2%E8%AF%95%E9%A2%98?id=_12-%E5%A6%82%E6%9E%9C%E5%B7%B2%E7%BB%8F%E5%BB%BA%E7%AB%8B%E4%BA%86%E8%BF%9E%E6%8E%A5%EF%BC%8C%E4%BD%86%E6%98%AF%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%87%BA%E7%8E%B0%E6%95%85%E9%9A%9C%E4%BA%86%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F\">如果已经建立了连接，但是客户端出现故障了怎么办？</a></h2><p>或者说，如果三次握手阶段、四次挥手阶段的包丢失了怎么办？如“服务端重发 FIN丢失”的问题。</p>\n<p>简而言之，通过<strong>定时器 + 超时重试机制</strong>，尝试获取确认，直到最后会自动断开连接。</p>\n<p>具体而言，TCP 设有一个保活计时器。服务器每收到一次客户端的数据，都会重新复位这个计时器，以Linux服务器为例，时间通常是设置为 2 小时。若 2 小时还没有收到客户端的任何数据，服务器就开始重试：每隔 75 秒（默认）发送一个探测报文段，若一共发送 10 个探测报文后客户端依然没有回应，那么服务器就认为连接已经断开了。</p>\n<p>附：Linux服务器系统内核参数配置</p>\n<ol>\n<li>tcp_keepalive_time，在TCP保活打开的情况下，最后一次数据交换到TCP发送第一个保活探测包的间隔，即允许的持续空闲时长，或者说每次正常发送心跳的周期，默认值为7200s（2h）。</li>\n<li>tcp_keepalive_probes 在tcp_keepalive_time之后，没有接收到对方确认，<strong>继续发送保活探测包次数，默认值为9（次）</strong>。</li>\n<li>tcp_keepalive_intvl，在tcp_keepalive_time之后，没有接收到对方确认，继续发送保活探测包的发送频率，默认值为75s。 发送频率tcp_keepalive_intvl乘以发送次数tcp_keepalive_probes，就得到了从开始探测到放弃探测确定连接断开的时间； 举例：若设置，服务器在客户端连接空闲的时候，每90秒发送一次保活探测包到客户端，若没有及时收到客户端的TCP Keepalive ACK确认，将继续等待15秒*2&#x3D;30秒。总之可以在90s+30s&#x3D;120秒（两分钟）时间内可检测到连接失效与否。</li>\n</ol>\n<h2 id=\"TIME-WAIT-状态过多会产生什么后果？怎样处理？\"><a href=\"#TIME-WAIT-状态过多会产生什么后果？怎样处理？\" class=\"headerlink\" title=\"TIME-WAIT 状态过多会产生什么后果？怎样处理？\"></a><a href=\"https://www.javalearn.cn/#/doc/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%9D%A2%E8%AF%95%E9%A2%98?id=_13-time-wait-%E7%8A%B6%E6%80%81%E8%BF%87%E5%A4%9A%E4%BC%9A%E4%BA%A7%E7%94%9F%E4%BB%80%E4%B9%88%E5%90%8E%E6%9E%9C%EF%BC%9F%E6%80%8E%E6%A0%B7%E5%A4%84%E7%90%86%EF%BC%9F\">TIME-WAIT 状态过多会产生什么后果？怎样处理？</a></h2><p>从服务器来讲，短时间内关闭了大量的Client连接，就会造成服务器上出现大量的TIME_WAIT连接，严重消耗着服务器的资源，此时部分客户端就会显示连接不上。</p>\n<p>从客户端来讲，客户端TIME_WAIT过多，就会导致端口资源被占用，因为端口就65536个，被占满就会导致无法创建新的连接。</p>\n<p><strong>解决办法：</strong></p>\n<ul>\n<li>服务器可以设置 SO_REUSEADDR 套接字选项来避免 TIME_WAIT状态，此套接字选项告诉内核，即使此端口正忙（处于 TIME_WAIT状态），也请继续并重用它。</li>\n<li>调整系统内核参数，修改&#x2F;etc&#x2F;sysctl.conf文件，即修改<code>net.ipv4.tcp_tw_reuse 和 tcp_timestamps</code></li>\n<li>强制关闭，发送 RST 包越过TIME_WAIT状态，直接进入CLOSED状态。</li>\n</ul>\n<h2 id=\"TIME-WAIT-是服务器端的状态-还是客户端的状态\"><a href=\"#TIME-WAIT-是服务器端的状态-还是客户端的状态\" class=\"headerlink\" title=\"TIME_WAIT 是服务器端的状态?还是客户端的状态?\"></a><a href=\"https://www.javalearn.cn/#/doc/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%9D%A2%E8%AF%95%E9%A2%98?id=_14-time_wait-%E6%98%AF%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E7%9A%84%E7%8A%B6%E6%80%81%E8%BF%98%E6%98%AF%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84%E7%8A%B6%E6%80%81\">TIME_WAIT 是服务器端的状态?还是客户端的状态?</a></h2><p>TIME_WAIT 是主动断开连接的一方会进入的状态，一般情况下，都是客户端所处的状态;服务器端一般设置不主动关闭连接。</p>\n<p>TIME_WAIT 需要等待 2MSL，在大量短连接的情况下，TIME_WAIT会太多，这也会消耗很多系统资源。对于服务器来说，在 HTTP 协议里指定 KeepAlive（浏览器重用一个 TCP 连接来处理多个 HTTP 请求），由浏览器来主动断开连接，可以一定程度上减少服务器的这个问题</p>\n<h2 id=\"详细讲一下TCP的滑动窗口？\"><a href=\"#详细讲一下TCP的滑动窗口？\" class=\"headerlink\" title=\"详细讲一下TCP的滑动窗口？\"></a><a href=\"https://www.javalearn.cn/#/doc/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%9D%A2%E8%AF%95%E9%A2%98?id=_16-%E8%AF%A6%E7%BB%86%E8%AE%B2%E4%B8%80%E4%B8%8Btcp%E7%9A%84%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%EF%BC%9F\">详细讲一下TCP的滑动窗口？</a></h2><p>在进行数据传输时，如果传输的数据比较大，就需要拆分为多个数据包进行发送。TCP 协议需要对数据进行确认后，才可以发送下一个数据包。这样一来，就会在等待确认应答包环节浪费时间。</p>\n<p>为了避免这种情况，TCP引入了窗口概念。窗口大小指的是不需要等待确认应答包而可以继续发送数据包的最大值。</p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/image-20210520214432214.png\" alt=\"img\"></p>\n<p>从上面的图可以看到滑动窗口左边的是已发送并且被确认的分组，滑动窗口右边是还没有轮到的分组。</p>\n<p>滑动窗口里面也分为两块，一块是已经发送但是未被确认的分组，另一块是窗口内等待发送的分组。随着已发送的分组不断被确认，窗口内等待发送的分组也会不断被发送。整个窗口就会往右移动，让还没轮到的分组进入窗口内。</p>\n<p>可以看到滑动窗口起到了一个限流的作用，也就是说当前滑动窗口的大小决定了当前 TCP 发送包的速率，而滑动窗口的大小取决于拥塞控制窗口和流量控制窗口的两者间的最小值。</p>\n<h2 id=\"TCP-VS-UD\"><a href=\"#TCP-VS-UD\" class=\"headerlink\" title=\"TCP VS UD\"></a>TCP VS UD</h2><p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/image-20230318181625164.png\" alt=\"img\"></p>\n<p>TCP 用于在传输层有必要实现可靠传输的情况，UDP 用于对高速传输和实时性有较高要求的通信。TCP 和 UDP 应该根据应用目的按需使用。</p>\n<h2 id=\"UDP-和-TCP-对应的应用场景是什么？\"><a href=\"#UDP-和-TCP-对应的应用场景是什么？\" class=\"headerlink\" title=\"UDP 和 TCP 对应的应用场景是什么？\"></a><a href=\"https://www.javalearn.cn/#/doc/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%9D%A2%E8%AF%95%E9%A2%98?id=_3-udp-%E5%92%8C-tcp-%E5%AF%B9%E5%BA%94%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F\">UDP 和 TCP 对应的应用场景是什么？</a></h2><p>TCP 是面向连接，能保证数据的可靠性交付，因此经常用于：</p>\n<ul>\n<li>FTP文件传输</li>\n<li>HTTP &#x2F; HTTPS</li>\n</ul>\n<p>UDP 面向无连接，它可以随时发送数据，再加上UDP本身的处理既简单又高效，因此经常用于：</p>\n<ul>\n<li>包总量较少的通信，如 DNS 、SNMP等</li>\n<li>视频、音频等多媒体通信</li>\n<li>广播通信</li>\n</ul>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/image-20210519180008296.png\" alt=\"img\"></p>\n<h2 id=\"TCP-协议如何保证可靠传输\"><a href=\"#TCP-协议如何保证可靠传输\" class=\"headerlink\" title=\"TCP 协议如何保证可靠传输\"></a>TCP 协议如何保证可靠传输</h2><p>重传、流量控制、拥塞控制、序列号与确认应达号、校验和</p>\n<p>1、合适地分割数据变成数据块</p>\n<p>2、给包编号</p>\n<p>3、校验和： 通过检验和的方式，接收端可以检测出来数据是否有差错和异常，假如有差错就会直接丢弃TCP段，重新发送。</p>\n<p>4、丢失重复</p>\n<p>5、流量控制 （缓冲空间 利用滑动窗口实现）：</p>\n<p>如果主机A 一直向主机B发送数据，不考虑主机B的接受能力，则可能导致主机B的接受缓冲区满了而无法再接受数据，从而会导致大量的数据丢包，引发重传机制。而在重传的过程中，若主机B的接收缓冲区情况仍未好转，则会将大量的时间浪费在重传数据上，降低传送数据的效率。所以引入流量控制机制，主机B通过告诉主机A自己接收缓冲区的大小，来使主机A控制发送的数据量。流量控制与TCP协议报头中的窗口大小有关。</p>\n<p>6、拥塞控制（拥塞时减少发送）：</p>\n<p>在数据传输过程中，可能由于网络状态的问题，造成网络拥堵，此时引入拥塞控制机制，在保证TCP可靠性的同时，提高性能。</p>\n<p>7、ARQ</p>\n<p>8、超时重传（有个定时器，等待接收端发ack，等不到就重发）：</p>\n<p>超时重传是指发送出去的数据包到接收到确认包之间的时间，如果超过了这个时间会被认为是丢包了，需要重传。最大超时时间是动态计算的。</p>\n<p>9、滑动窗口：</p>\n<p>滑动窗口既提高了报文传输的效率，也避免了发送方发送过多的数据而导致接收方无法正常处理的异常。</p>\n<p>10、序列号&#x2F;确认应答：</p>\n<p>序列号的作用不仅仅是应答的作用，有了序列号能够将接收到的数据根据序列号排序，并且去掉重复序列号的数据。</p>\n<p>TCP传输的过程中，每次接收方收到数据后，都会对传输方进行确认应答。也就是发送ACK报文，这个ACK报文当中带有对应的确认序列号，告诉发送方，接收到了哪些数据，下一次的数据从哪里发。</p>\n<h2 id=\"ARQ\"><a href=\"#ARQ\" class=\"headerlink\" title=\"ARQ\"></a>ARQ</h2><p>⾃动重传请求，它通过使⽤确认和超时这两个机制，在不可靠服务的基础上实现可靠的信息传输。如果发送⽅在发送后⼀段时间之内没有收到确认帧，它通常会重新发送。</p>\n<p>ARQ包括停⽌等待ARQ协议和连续ARQ协议</p>\n<h3 id=\"停⽌等待ARQ协议\"><a href=\"#停⽌等待ARQ协议\" class=\"headerlink\" title=\"停⽌等待ARQ协议\"></a>停⽌等待ARQ协议</h3><p>优点： 简单<br>缺点： 信道利⽤率低，等待时间⻓</p>\n<p>1、⽆差错情况:<br>发送⽅发送分组,接收⽅在规定时间内收到,并且回复确认.发送⽅再次发送。</p>\n<p>2、出现差错情况（超时重传） :<br>停⽌等待协议中超时重传是指只要超过⼀段时间仍然没有收到确认，就重传前⾯发送过的分组（认为刚才发送过的分组丢失了）。因此每发送完⼀个分组需要设置⼀个超时计时器。</p>\n<p>3、确认丢失和确认迟到<br>确认丢失 ：syn  –ack丢失  客户端没收到ack  超时计时后  再syn</p>\n<p>因此服务端收到俩syn，处理有2种：丢弃这个重复的syn和向A发送<br>确认消息。</p>\n<h3 id=\"连续ARQ协议\"><a href=\"#连续ARQ协议\" class=\"headerlink\" title=\"连续ARQ协议\"></a>连续ARQ协议</h3><p>连续 ARQ 协议可提⾼信道利⽤率。发送⽅维持⼀个发送窗⼝，位于窗口内的分组可以连续发送，接受端对到达的最后⼀个分组发送确认，表明所有分组都已经正确收到了。</p>\n<p>优点： 信道利⽤率⾼，容易实现，即使确认丢失，也不必重传。</p>\n<p>缺点： 不能向发送⽅反映出接收⽅已经正确收到的所有分组的信息。 ⽐如：发送⽅发送了 5条消息，中间第三条丢失（3号），这时接收⽅只能对前两个发送确认。发送⽅⽆法知道后三个分组的下落，⽽只好把后三个全部重传⼀次。这也叫 Go-Back-N</p>\n<h2 id=\"滑动窗⼝和流量控制\"><a href=\"#滑动窗⼝和流量控制\" class=\"headerlink\" title=\"滑动窗⼝和流量控制\"></a>滑动窗⼝和流量控制</h2><p>TCP 利⽤滑动窗⼝实现流量控制。流量控制是为了控制发送⽅发送速率，保证接收⽅来得及接收。</p>\n<h2 id=\"拥塞控制\"><a href=\"#拥塞控制\" class=\"headerlink\" title=\"拥塞控制\"></a>拥塞控制</h2><p>拥塞：某段时间，若对⽹络中某⼀资源的需求超过了该资源所能提供的可⽤部分，⽹络的性能就要变坏。这种情况就叫拥塞。</p>\n<p>拥塞控制：拥塞控制就是为了防⽌过多的数据注⼊到⽹络中，这样就可以使⽹络中的路由器或链路不致过载。</p>\n<p>vs流量控制：拥塞是全局（涉及到所有主机路由器  ）流量是端到端</p>\n<p>实操：维持⼀个 拥塞窗⼝</p>\n<p>TCP 一共使用了四种算法来实现拥塞控制：</p>\n<ul>\n<li>慢开始 (slow-start)；</li>\n<li>拥塞避免 (congestion avoidance)；</li>\n<li>快速重传 (fast retransmit)；</li>\n<li>快速恢复 (fast recovery)。</li>\n</ul>\n<p><strong>慢开始</strong>：不要一开始就发送大量的数据，由小到大逐渐增加拥塞窗口的大小。（每一个传播轮次加倍）</p>\n<p><strong>拥塞避免</strong>：拥塞避免算法让拥塞窗口缓慢增长，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1而不是加倍。这样拥塞窗口按线性规律缓慢增长。一个RTT  cwnd+1）</p>\n<p><strong>快重传：</strong>我们可以剔除一些不必要的拥塞报文，提高网络吞吐量。比如接收方在<strong>收到一个失序的报文段后就立即发出重复确认，而不要等到自己发送数据时捎带确认。</strong>快重传规定：发送方只要<strong>一连收到三个</strong>重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期。</p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/image-20210520214123058.png\" alt=\"img\"></p>\n<p><strong>快恢复：</strong>主要是配合快重传。当发送方连续收到三个重复确认时，就执行“乘法减小”算法，把ssthresh门限减半（为了预防网络发生拥塞），但<strong>接下来并不执行慢开始算法</strong>，因为如果网络出现拥塞的话就不会收到好几个重复的确认，收到三个重复确认说明网络状况还可以。</p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/image-20210520214146324.png\" alt=\"img\"></p>\n<p><strong>快重传与快恢复</strong>：</p>\n<p>之前的重传是数据丢失导致接收端收不到数据导致发送端收不到ack，然后超时就会重新发syn，耗时且中间不能发其他数据了</p>\n<p>但是有了FRR ，当接收端收到不按序的数据段 连发三个确认 那么发送端就立即重发 不等计时器</p>\n<h2 id=\"HTTP常见的状态码有哪些？\"><a href=\"#HTTP常见的状态码有哪些？\" class=\"headerlink\" title=\"HTTP常见的状态码有哪些？\"></a><a href=\"https://www.javalearn.cn/#/doc/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%9D%A2%E8%AF%95%E9%A2%98?id=_18-http%E5%B8%B8%E8%A7%81%E7%9A%84%E7%8A%B6%E6%80%81%E7%A0%81%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F\">HTTP常见的状态码有哪些？</a></h2><p>常见状态码：</p>\n<ul>\n<li>200：服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页。</li>\n<li>301 ： (永久移动) 请求的网页已永久移动到新位置。 服务器返回此响应(对 GET 或 HEAD 请求的响应)时，会自动将请求者转到新位置。</li>\n<li>302：(临时移动) 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。</li>\n<li>400 ：客户端请求有语法错误，不能被服务器所理解。</li>\n<li>403 ：服务器收到请求，但是拒绝提供服务。</li>\n<li>404 ：(未找到) 服务器找不到请求的网页。</li>\n<li>500： (服务器内部错误) 服务器遇到错误，无法完成请求。</li>\n</ul>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/image-20210525114439748.png\" alt=\"img\"></p>\n<h2 id=\"状态码301和302的区别是什么？\"><a href=\"#状态码301和302的区别是什么？\" class=\"headerlink\" title=\"状态码301和302的区别是什么？\"></a><a href=\"https://www.javalearn.cn/#/doc/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%9D%A2%E8%AF%95%E9%A2%98?id=_19-%E7%8A%B6%E6%80%81%E7%A0%81301%E5%92%8C302%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F\">状态码301和302的区别是什么？</a></h2><p><strong>共同点</strong>：301和302状态码都表示重定向，就是说浏览器在拿到服务器返回的这个状态码后会自动跳转到一个新的URL地址，这个地址可以从响应的Location首部中获取（<strong>用户看到的效果就是他输入的地址A瞬间变成了另一个地址B</strong>）。</p>\n<p><strong>不同点</strong>：</p>\n<p>301表示旧地址A的资源已经被永久地移除了(这个资源不可访问了)，搜索引擎在抓取新内容的同时也将旧的网址交换为重定向之后的网址；</p>\n<p>302表示旧地址A的资源还在（仍然可以访问），这个重定向只是临时地从旧地址A跳转到地址B，搜索引擎会抓取新的内容而保存旧的网址。 SEO中302好于301。</p>\n<p><strong>补充，重定向原因</strong>：</p>\n<ol>\n<li>网站调整（如改变网页目录结构）；</li>\n<li>网页被移到一个新地址；</li>\n<li>网页扩展名改变(如应用需要把.php改成.Html或.shtml)。</li>\n</ol>\n<h2 id=\"HTTP-常用的请求方式？\"><a href=\"#HTTP-常用的请求方式？\" class=\"headerlink\" title=\"HTTP 常用的请求方式？\"></a><a href=\"https://www.javalearn.cn/#/doc/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%9D%A2%E8%AF%95%E9%A2%98?id=_20-http-%E5%B8%B8%E7%94%A8%E7%9A%84%E8%AF%B7%E6%B1%82%E6%96%B9%E5%BC%8F%EF%BC%9F\">HTTP 常用的请求方式？</a></h2><ul>\n<li>PUT：上传文件，向服务器添加数据，可以看作增</li>\n<li>DELETE：删除文件</li>\n<li>POST：传输数据，向服务器提交数据，对服务器数据进行更新。</li>\n<li>GET：获取资源，查询服务器资源</li>\n</ul>\n<h2 id=\"GET请求和POST请求的区别？\"><a href=\"#GET请求和POST请求的区别？\" class=\"headerlink\" title=\"GET请求和POST请求的区别？\"></a><a href=\"https://www.javalearn.cn/#/doc/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%9D%A2%E8%AF%95%E9%A2%98?id=_21-get%E8%AF%B7%E6%B1%82%E5%92%8Cpost%E8%AF%B7%E6%B1%82%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F\">GET请求和POST请求的区别？</a></h2><p><strong>使用上的区别</strong>：</p>\n<ul>\n<li>GET使用URL或Cookie传参，而POST将数据放在BODY中，这个是因为HTTP协议用法的约定。</li>\n<li>GET方式提交的数据有长度限制，则POST的数据则可以非常大”，这个是因为它们使用的操作系统和浏览器设置的不同引起的区别。</li>\n<li>POST比GET安全，因为数据在地址栏上不可见”，这个说法没毛病，但依然不是GET和POST本身的区别。</li>\n</ul>\n<p><strong>本质区别</strong></p>\n<p>GET和POST最大的区别主要是GET请求是幂等性的，POST请求不是。这个是它们本质区别。</p>\n<p>幂等性是指一次和多次请求某一个资源应该具有同样的副作用。简单来说意味着对同一URL的多个请求应该返回同样的结果。</p>\n<h2 id=\"在浏览器中输⼊url地址-gt-gt-显示主⻚的过程\"><a href=\"#在浏览器中输⼊url地址-gt-gt-显示主⻚的过程\" class=\"headerlink\" title=\"在浏览器中输⼊url地址 -&gt;&gt; 显示主⻚的过程\"></a>在浏览器中输⼊url地址 -&gt;&gt; 显示主⻚的过程</h2><ol>\n<li>DNS解析（<strong>浏览器搜索自己的DNS缓存</strong>（维护一张域名与IP的对应表）；若没有，则搜索<strong>操作系统的DNS缓存</strong>（维护一张域名与IP的对应表）；若没有，则搜索操作系统的<strong>hosts文件</strong>（维护一张域名与IP的对应表）。<br>   若都没有，则找 tcp&#x2F;ip 参数中设置的首选 dns 服务器，即<strong>本地 dns 服务器</strong>（递归查询），<strong>本地域名服务器查询自己的dns缓存</strong>，如果没有，则进行迭代查询。将本地dns服务器将IP返回给操作系统，同时缓存IP。） </li>\n<li>TCP连接（发起 tcp 的三次握手，建立 tcp 连接。浏览器会以一个随机端口（1024-65535）向服务端的 web 程序 80 端口发起 tcp 的连接。） </li>\n<li>发送HTTP请求。 </li>\n<li>服务器处理，客户端得到 html 代码。服务器 web 应用程序收到 http 请求后，就开始处理请求，处理之后就返回给浏览器 html 文件。 </li>\n<li>浏览器解析，解析 html 代码，并请求 html 中的资源。浏览器对页面进行渲染，并呈现给用户 </li>\n<li>连接结束</li>\n</ol>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/image-20230313160513726.png\" alt=\"img\"></p>\n<h2 id=\"各种协议与HTTP协议之间的关系\"><a href=\"#各种协议与HTTP协议之间的关系\" class=\"headerlink\" title=\"各种协议与HTTP协议之间的关系\"></a>各种协议与HTTP协议之间的关系</h2><p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/image-20230313160546396.png\" alt=\"img\"></p>\n<h2 id=\"HTTP⻓连接-短连接\"><a href=\"#HTTP⻓连接-短连接\" class=\"headerlink\" title=\"HTTP⻓连接,短连接\"></a>HTTP⻓连接,短连接</h2><p><strong>HTTP&#x2F;1.0中默认使⽤短连接</strong>  ，每次建立连接之后都中断</p>\n<p>HTTP&#x2F;1.1里面默认使⽤⻓连接 ， 响应头加入Connection:keep-alive  ，再次访问这个服务器会继续使用已经建立的连接，但有时间限制，且客户端服务端都要支持长连接</p>\n<p>HTTP协议的⻓连接和短连接，实质上是TCP协议的⻓连接和短连接。</p>\n<h2 id=\"HTTP请求报文和响应报文的格式？\"><a href=\"#HTTP请求报文和响应报文的格式？\" class=\"headerlink\" title=\"HTTP请求报文和响应报文的格式？\"></a><a href=\"https://www.javalearn.cn/#/doc/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%9D%A2%E8%AF%95%E9%A2%98?id=_23-http%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87%E5%92%8C%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87%E7%9A%84%E6%A0%BC%E5%BC%8F%EF%BC%9F\">HTTP请求报文和响应报文的格式？</a></h2><p><strong>请求报文格式</strong>：</p>\n<ol>\n<li>请求行（请求方法+URI协议+版本）</li>\n<li>请求头部</li>\n<li>空行</li>\n<li>请求主体</li>\n</ol>\n<pre><code class=\"html\">GET/sample.jspHTTP/1.1 请求行\nAccept:image/gif.image/jpeg, 请求头部\nAccept-Language:zh-cn\nConnection:Keep-Alive\nHost:localhost\nUser-Agent:Mozila/4.0(compatible;MSIE5.01;Window NT5.0)\nAccept-Encoding:gzip,deflate\nusername=jinqiao&amp;password=1234 请求主体\n</code></pre>\n<p><strong>响应报文</strong>：</p>\n<ol>\n<li>状态行（版本+状态码+原因短语）</li>\n<li>响应首部</li>\n<li>空行</li>\n<li>响应主体</li>\n</ol>\n<pre><code class=\"html\">HTTP/1.1 200 OK\nServer:Apache Tomcat/5.0.12\nDate:Mon,6Oct2003 13:23:42 GMT\nContent-Length:112\n\n&lt;html&gt;\n    &lt;head&gt;\n        &lt;title&gt;HTTP响应示例&lt;title&gt;\n    &lt;/head&gt;\n    &lt;body&gt;\n        Hello HTTP!\n    &lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<h2 id=\"HTTP是不保存状态的协议-如何保存⽤户状态\"><a href=\"#HTTP是不保存状态的协议-如何保存⽤户状态\" class=\"headerlink\" title=\"HTTP是不保存状态的协议,如何保存⽤户状态?\"></a>HTTP是不保存状态的协议,如何保存⽤户状态?</h2><p>服务端放一个session记录用户状态，客户端我们通过在 Cookie 中附加⼀个 Session ID 来⽅式来跟踪。</p>\n<h2 id=\"Cookie-被禁⽤怎么办\"><a href=\"#Cookie-被禁⽤怎么办\" class=\"headerlink\" title=\"Cookie 被禁⽤怎么办?\"></a>Cookie 被禁⽤怎么办?</h2><p>最常⽤的就是利⽤ URL 重写把 Session ID 直接附加在URL路径的后⾯  <a href=\"https://javaguide.cn/?Session_id=xxx\">https://javaguide.cn/?Session_id=xxx</a></p>\n<h2 id=\"什么是-Cookie-和-Session\"><a href=\"#什么是-Cookie-和-Session\" class=\"headerlink\" title=\"什么是 Cookie 和 Session ?\"></a><a href=\"https://www.javalearn.cn/#/doc/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%9D%A2%E8%AF%95%E9%A2%98?id=_30-%E4%BB%80%E4%B9%88%E6%98%AF-cookie-%E5%92%8C-session-\">什么是 Cookie 和 Session ?</a></h2><p><strong>什么是 Cookie</strong></p>\n<p>HTTP Cookie（也叫 Web Cookie或浏览器 Cookie）是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。通常，它用于告知服务端两个请求是否来自同一浏览器，如保持用户的登录状态。Cookie 使基于无状态的 HTTP 协议记录稳定的状态信息成为了可能。</p>\n<p>Cookie 主要用于以下三个方面：</p>\n<ul>\n<li>会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）</li>\n<li>个性化设置（如用户自定义设置、主题等）</li>\n<li>浏览器行为跟踪（如跟踪分析用户行为等）</li>\n</ul>\n<p><strong>什么是 Session</strong></p>\n<p>Session 代表着服务器和客户端一次会话的过程。Session 对象存储特定用户会话所需的属性及配置信息。这样，当用户在应用程序的 Web 页之间跳转时，存储在 Session 对象中的变量将不会丢失，而是在整个用户会话中一直存在下去。当客户端关闭会话，或者 Session 超时失效时会话结束。</p>\n<p><strong>总结</strong></p>\n<p>作用：保存⽤户信息  ，帮你登录的⼀些基本信息给填了  ，cookie里面存放了⼀个Token  ，下次登录的时候只需要根据 Token 值来查找⽤户即可</p>\n<p>区别：Cookie 数据保存在客户端(浏览器端)， Session 数据保存在服务器端。  session安全些</p>\n<h2 id=\"Cookie-和-Session-是如何配合的呢？\"><a href=\"#Cookie-和-Session-是如何配合的呢？\" class=\"headerlink\" title=\"Cookie 和 Session 是如何配合的呢？\"></a><a href=\"https://www.javalearn.cn/#/doc/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%9D%A2%E8%AF%95%E9%A2%98?id=_31-cookie-%E5%92%8C-session-%E6%98%AF%E5%A6%82%E4%BD%95%E9%85%8D%E5%90%88%E7%9A%84%E5%91%A2%EF%BC%9F\">Cookie 和 Session 是如何配合的呢？</a></h2><p>用户第一次请求服务器的时候，服务器根据用户提交的相关信息，创建对应的 Session ，请求返回时将此 Session 的唯一标识信息 SessionID 返回给浏览器，浏览器接收到服务器返回的 SessionID 信息后，会将此信息存入到 Cookie 中，同时 Cookie 记录此 SessionID 属于哪个域名。</p>\n<p>当用户第二次访问服务器的时候，请求会自动判断此域名下是否存在 Cookie 信息，如果存在自动将 Cookie 信息也发送给服务端，服务端会从 Cookie 中获取 SessionID，再根据 SessionID 查找对应的 Session 信息，如果没有找到说明用户没有登录或者登录失效，如果找到 Session 证明用户已经登录可执行后面操作。</p>\n<p>根据以上流程可知，SessionID 是连接 Cookie 和 Session 的一道桥梁，大部分系统也是根据此原理来验证用户登录状态。</p>\n<h2 id=\"Cookie和Session的区别？\"><a href=\"#Cookie和Session的区别？\" class=\"headerlink\" title=\"Cookie和Session的区别？\"></a><a href=\"https://www.javalearn.cn/#/doc/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%9D%A2%E8%AF%95%E9%A2%98?id=_32-cookie%E5%92%8Csession%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F\">Cookie和Session的区别？</a></h2><ul>\n<li><strong>作用范围</strong>不同，Cookie 保存在客户端（浏览器），Session 保存在服务器端。</li>\n<li><strong>存取方式</strong>的不同，Cookie 只能保存 ASCII，Session 可以存任意数据类型，一般情况下我们可以在 Session 中保持一些常用变量信息，比如说 UserId 等。</li>\n<li><strong>有效期</strong>不同，Cookie 可设置为长时间保持，比如我们经常使用的默认登录功能，Session 一般失效时间较短，客户端关闭或者 Session 超时都会失效。</li>\n<li><strong>隐私策略</strong>不同，Cookie 存储在客户端，比较容易遭到不法获取，早期有人将用户的登录名和密码存储在 Cookie 中导致信息被窃取；Session 存储在服务端，<strong>安全性相对 Cookie 要好一些。</strong></li>\n<li><strong>存储大小不同，</strong> 单个 Cookie 保存的数据不能超过 4K，Session 可存储数据远高于 Cookie。</li>\n</ul>\n<h2 id=\"如何考虑分布式-Session-问题？\"><a href=\"#如何考虑分布式-Session-问题？\" class=\"headerlink\" title=\"如何考虑分布式 Session 问题？\"></a><a href=\"https://www.javalearn.cn/#/doc/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%9D%A2%E8%AF%95%E9%A2%98?id=_33-%E5%A6%82%E4%BD%95%E8%80%83%E8%99%91%E5%88%86%E5%B8%83%E5%BC%8F-session-%E9%97%AE%E9%A2%98%EF%BC%9F\">如何考虑分布式 Session 问题？</a></h2><p>在互联网公司为了可以支撑更大的流量，后端往往需要多台服务器共同来支撑前端用户请求，那如果用户在 A 服务器登录了，第二次请求跑到服务 B 就会出现登录失效问题。</p>\n<p>分布式 Session 一般会有以下几种解决方案：</p>\n<ul>\n<li><strong>客户端存储</strong>：直接将信息存储在cookie中，cookie是存储在客户端上的一小段数据，客户端通过http协议和服务器进行cookie交互，通常用来存储一些不敏感信息 </li>\n<li><strong>Nginx ip_hash 策略</strong>：服务端使用 Nginx 代理，每个请求按访问 IP 的 hash 分配，这样来自同一 IP 固定访问一个后台服务器，避免了在服务器 A 创建 Session，第二次分发到服务器 B 的现象。 </li>\n<li><strong>Session 复制</strong>：任何一个服务器上的 Session 发生改变（增删改），该节点会把这个 Session 的所有内容序列化，然后广播给所有其它节点。 </li>\n<li><strong>共享 Session</strong>（√）：服务端无状态话，将用户的 Session 等信息使用缓存中间件（如Redis）来统一管理，保障分发到每一个服务器的响应结果都一致。</li>\n</ul>\n<p>建议采用共享 Session的方案。</p>\n<h2 id=\"为什么-Cookie-无法防止-CSRF-攻击，而-Token-可以？\"><a href=\"#为什么-Cookie-无法防止-CSRF-攻击，而-Token-可以？\" class=\"headerlink\" title=\"为什么 Cookie 无法防止 CSRF 攻击，而 Token 可以？\"></a>为什么 Cookie 无法防止 CSRF 攻击，而 Token 可以？</h2><p><strong>跨站请求伪造</strong>：黑客在链接中藏了一个请求，这个请求直接利用小壮的身份给银行发送了一个转账请求,也就是通过你的 Cookie 向银行发出请求。</p>\n<p>但是使用Token的话 即使有个你点击了非法链接发送了请求到服务端，这个非法请求是不会携带 <code>Token</code> 的，所以这个请求将是非法的。</p>\n<p>需要注意的是：不论是 <code>Cookie</code> 还是 <code>Token</code> 都无法避免 <strong>跨站脚本攻击（Cross Site Scripting）XSS</strong> 。</p>\n<h2 id=\"什么是DDos攻击？\"><a href=\"#什么是DDos攻击？\" class=\"headerlink\" title=\"什么是DDos攻击？\"></a><a href=\"https://www.javalearn.cn/#/doc/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%9D%A2%E8%AF%95%E9%A2%98?id=_34-%E4%BB%80%E4%B9%88%E6%98%AFddos%E6%94%BB%E5%87%BB%EF%BC%9F\">什么是DDos攻击？</a></h2><p><strong>和syn区别：syn洪泛是那些不存在的ip，DDos是存在而且是第三次握手客户端不确认</strong></p>\n<p>DDos全称Distributed Denial of Service，分布式拒绝服务攻击。最基本的DOS攻击过程如下：</p>\n<ol>\n<li>客户端向服务端发送请求链接数据包。</li>\n<li>服务端向客户端发送确认数据包。</li>\n<li>客户端不向服务端发送确认数据包，服务器一直等待来自客户端的确认</li>\n</ol>\n<p>DDoS则是采用分布式的方法，通过在网络上占领多台“肉鸡”，用多台计算机发起攻击。</p>\n<p>DOS攻击现在基本没啥作用了，因为服务器的性能都很好，而且是多台服务器共同作用，1V1的模式黑客无法占上风。对于DDOS攻击，预防方法有：</p>\n<ul>\n<li><strong>减少SYN timeout时间</strong>。在握手的第三步，服务器会等待30秒-120秒的时间，减少这个等待时间就能释放更多的资源。</li>\n<li><strong>限制同时打开的SYN半连接数目。</strong></li>\n</ul>\n<h2 id=\"什么是XSS攻击？\"><a href=\"#什么是XSS攻击？\" class=\"headerlink\" title=\"什么是XSS攻击？\"></a><a href=\"https://www.javalearn.cn/#/doc/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%9D%A2%E8%AF%95%E9%A2%98?id=_35-%E4%BB%80%E4%B9%88%E6%98%AFxss%E6%94%BB%E5%87%BB%EF%BC%9F\">什么是XSS攻击？</a></h2><p>XSS也称 cross-site scripting，<strong>跨站脚本</strong>。这种攻击是<strong>由于服务器将攻击者存储的数据原原本本地显示给其他用户所致的</strong>。比如一个存在XSS漏洞的论坛，用户发帖时就可以引入<strong>带有＜script＞标签的代码</strong>，导致恶意代码的执行。</p>\n<p>预防措施有：</p>\n<ul>\n<li>前端：过滤。</li>\n<li>后端：转义，比如go自带的处理器就具有转义功能。</li>\n</ul>\n<h2 id=\"SQL注入是什么，如何避免SQL注入？\"><a href=\"#SQL注入是什么，如何避免SQL注入？\" class=\"headerlink\" title=\"SQL注入是什么，如何避免SQL注入？\"></a><a href=\"https://www.javalearn.cn/#/doc/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%9D%A2%E8%AF%95%E9%A2%98?id=_36-sql%E6%B3%A8%E5%85%A5%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8Dsql%E6%B3%A8%E5%85%A5%EF%BC%9F\">SQL注入是什么，如何避免SQL注入？</a></h2><pre><code class=\"sql\">select distinct * from company where id=&#39;1&#39; OR &#39;1&#39; = &#39;1&#39;\n</code></pre>\n<p>SQL 注入就是在用户输入的字符串中加入 SQL 语句，如果在设计不良的程序中忽略了检查，那么这些注入进去的 SQL 语句就会被数据库服务器误认为是正常的 SQL 语句而运行，<strong>攻击者就可以执行计划外的命令或访问未被授权的数据。</strong></p>\n<p><strong>SQL注入的原理主要有以下 4 点</strong></p>\n<ul>\n<li>恶意拼接查询</li>\n<li>利用注释执行非法命令</li>\n<li>传入非法参数</li>\n<li>添加额外条件</li>\n</ul>\n<p><strong>避免SQL注入的一些方法</strong>：</p>\n<ul>\n<li><strong>限制数据库权限</strong>，给用户提供仅仅能够满足其工作的最低权限。</li>\n<li>对进入数据库的特殊字符（’”\\尖括号&amp;*;等）<strong>转义处理</strong>。</li>\n<li>提供参数化查询接口，不要直接使用原生SQL。</li>\n</ul>\n<h2 id=\"负载均衡算法有哪些？\"><a href=\"#负载均衡算法有哪些？\" class=\"headerlink\" title=\"负载均衡算法有哪些？\"></a><a href=\"https://www.javalearn.cn/#/doc/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%9D%A2%E8%AF%95%E9%A2%98?id=_37-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AE%97%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F\">负载均衡算法有哪些？</a></h2><p>多台服务器以对称的方式组成一个服务器集合，每台服务器都具有等价的地位，能互相分担负载。</p>\n<ul>\n<li>轮询法：将请求按照顺序轮流的分配到服务器上。大锅饭，不能发挥某些高性能服务器的优势。</li>\n<li>随机法：随机获取一台，和轮询类似。</li>\n<li>哈希法：通过ip地址哈希化（我客户端的Ip地址 也就是每个客户端请求到的服务器固定）来确定要选择的服务器编号。好处是,每次客户端访问的服务器都是同一个服务器，能很好地利用session或者cookie。</li>\n<li>加权轮询：根据服务器性能不同加权。</li>\n</ul>\n<h2 id=\"HTTP-1-0和HTTP-1-1的主要-区别\"><a href=\"#HTTP-1-0和HTTP-1-1的主要-区别\" class=\"headerlink\" title=\"HTTP 1.0和HTTP 1.1的主要 区别\"></a>HTTP 1.0和HTTP 1.1的主要 区别</h2><p>1、长连接</p>\n<p>在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，在HTTP1.1中默认开启<code>Connection： keep-alive</code>，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点。</p>\n<p>2、错误状态响应码多了</p>\n<p>新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。</p>\n<p>3、缓存策略多了</p>\n<p>4、只请求资源一部分，优化带宽</p>\n<p>5、Host头处理：在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）。</p>\n<h2 id=\"HTTP1-1和-HTTP2-0的区别？\"><a href=\"#HTTP1-1和-HTTP2-0的区别？\" class=\"headerlink\" title=\"HTTP1.1和 HTTP2.0的区别？\"></a><a href=\"https://www.javalearn.cn/#/doc/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%9D%A2%E8%AF%95%E9%A2%98?id=_25-http11%E5%92%8C-http20%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F\">HTTP1.1和 HTTP2.0的区别？</a></h2><p>HTTP2.0相比HTTP1.1支持的特性：</p>\n<ul>\n<li><strong>新的二进制格式</strong>：HTTP1.1的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合。基于这种考虑HTTP2.0的协议解析决定采用二进制格式，实现方便且健壮。</li>\n<li><strong>多路复用</strong>，即连接共享，即每一个request都是用作连接共享机制的。一个request对应一个id，这样一个连接上可以有多个request，每个连接的request可以随机的混杂在一起，接收方可以根据request的 id将request再归属到各自不同的服务端请求里面。</li>\n<li><strong>头部压缩</strong>，HTTP1.1的头部（header）带有大量信息，而且每次都要重复发送；HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小。</li>\n<li><strong>服务端推送</strong>：服务器除了对最初请求的响应外，服务器还可以额外的向客户端推送资源，而无需客户端明确的请求。</li>\n</ul>\n<h2 id=\"URI和URL的区别是什么\"><a href=\"#URI和URL的区别是什么\" class=\"headerlink\" title=\"URI和URL的区别是什么?\"></a>URI和URL的区别是什么?</h2><p>都可以标识一个资源 但URL可以定位到这个资源</p>\n<h2 id=\"HTTP-和-HTTPS-的区别？\"><a href=\"#HTTP-和-HTTPS-的区别？\" class=\"headerlink\" title=\"HTTP 和 HTTPS 的区别？\"></a>HTTP 和 HTTPS 的区别？</h2><p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/image-20230404211801661.png\" alt=\"img\"></p>\n<p>1、端口  80-443  <a href=\"http://---&gt;https//\">http://---&gt;https://</a></p>\n<p>2、安全性和资源消耗：HTTP协议运⾏在TCP之上，所有传输的内容都是明⽂，客户端和服务器端都⽆法验证对⽅的身份。 HTTPS是运⾏在SSL&#x2F;TLS之上的HTTP协议， SSL&#x2F;TLS 运⾏在TCP之上。所有传输的内容都经过加密，加密采⽤对称加密，但对称加密的密钥⽤服务器⽅的证书进⾏了⾮对称加密。所以说， HTTP 安全性没有 HTTPS⾼，但是 HTTPS ⽐HTTP耗费更多服务器资源</p>\n<p>对称加密：密钥只有⼀个，加密解密为同⼀个密码   DES、 AES等；<br>⾮对称加密：密钥成对出现，加密解密使⽤不同密钥（公钥加密需要私钥解密，私钥加密需要公钥解密），相对对称加密速度较慢，典型的⾮对称加密算法有RSA、 DSA等</p>\n<h2 id=\"HTTPS-的优缺点\"><a href=\"#HTTPS-的优缺点\" class=\"headerlink\" title=\"HTTPS 的优缺点?\"></a><a href=\"https://www.javalearn.cn/#/doc/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%9D%A2%E8%AF%95%E9%A2%98?id=_27-https-%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9\">HTTPS 的优缺点?</a></h2><p><strong>优点</strong>：</p>\n<ul>\n<li><p>安全性： </p>\n</li>\n<li><ul>\n<li>使用HTTPS协议可认证用户和服务器，确保数据发送到正确的客户机和服务器；</li>\n<li>HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全，可防止数据在传输过程中不被窃取、改变，确保数据的完整性。</li>\n<li>HTTPS是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本。</li>\n</ul>\n</li>\n<li><p>SEO方面：谷歌曾在2014年8月份调整搜索引擎算法，并称“比起同等HTTP网站，采用HTTPS加密的网站在搜索结果中的排名将会更高”。</p>\n</li>\n</ul>\n<p><strong>缺点</strong>：</p>\n<ul>\n<li>在相同网络环境中，HTTPS 相比 HTTP 无论是响应时间还是耗电量都有大幅度上升。</li>\n<li>HTTPS 的安全是有范围的，在黑客攻击、服务器劫持等情况下几乎起不到作用。</li>\n<li>在现有的证书机制下，中间人攻击依然有可能发生。</li>\n<li>HTTPS 需要更多的服务器资源，也会导致成本的升高。</li>\n</ul>\n<h2 id=\"讲一讲HTTPS-的原理？\"><a href=\"#讲一讲HTTPS-的原理？\" class=\"headerlink\" title=\"讲一讲HTTPS 的原理？\"></a><a href=\"https://www.javalearn.cn/#/doc/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%9D%A2%E8%AF%95%E9%A2%98?id=_28-%E8%AE%B2%E4%B8%80%E8%AE%B2https-%E7%9A%84%E5%8E%9F%E7%90%86%EF%BC%9F\">讲一讲HTTPS 的原理？</a></h2><p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/image-20210525160006424.png\" alt=\"img\"></p>\n<p>图片来源：<a href=\"https://segmentfault.com/a/1190000021494676\">https://segmentfault.com/a/1190000021494676</a></p>\n<p>加密流程按图中的序号分为：</p>\n<ol>\n<li>客户端请求 HTTPS 网址，然后连接到 server 的 443 端口 (HTTPS 默认端口，类似于 HTTP 的80端口)。 </li>\n<li>采用 HTTPS 协议的服务器必须要有一套数字 CA (Certification Authority)证书。颁发证书的同时会产生一个私钥和公钥。私钥由服务端自己保存，不可泄漏。公钥则是附带在证书的信息中，可以公开的。证书本身也附带一个证书电子签名，这个签名用来验证证书的完整性和真实性，可以防止证书被篡改。 </li>\n<li>服务器响应客户端请求，将证书传递给客户端，证书包含公钥和大量其他信息，比如证书颁发机构信息，公司信息和证书有效期等。 </li>\n<li>客户端解析证书并对其进行验证。如果证书不是可信机构颁布，或者证书中的域名与实际域名不一致，或者证书已经过期，就会向访问者显示一个警告，由其选择是否还要继续通信。<br>   如果证书没有问题，客户端就会从服务器证书中取出服务器的公钥A。然后客户端还会生成一个随机码 KEY，并使用公钥A将其加密。 </li>\n<li>客户端把加密后的随机码 KEY 发送给服务器，作为后面对称加密的密钥。 </li>\n<li>服务器在收到随机码 KEY 之后会使用私钥B将其解密。经过以上这些步骤，客户端和服务器终于建立了安全连接，完美解决了对称加密的密钥泄露问题，接下来就可以用对称加密愉快地进行通信了。 </li>\n<li>服务器使用密钥 (随机码 KEY)对数据进行对称加密并发送给客户端，客户端使用相同的密钥 (随机码 KEY)解密数据。 </li>\n<li>双方使用对称加密愉快地传输所有数据。</li>\n</ol>\n<h2 id=\"校验和\"><a href=\"#校验和\" class=\"headerlink\" title=\"校验和\"></a>校验和</h2><h3 id=\"常用校验算法简单说明：\"><a href=\"#常用校验算法简单说明：\" class=\"headerlink\" title=\"常用校验算法简单说明：\"></a>常用校验算法简单说明：</h3><p>1：<strong>校验和</strong>：按每个字节，计算累加和，</p>\n<p>2：<strong>异或校验</strong>：定义初值，按每个字节异或，求结果。</p>\n<p>3：<strong>CRC校验</strong>：已有很多的标准及计算方式，可以返回8字节，16字节，32字节的结果。</p>\n<p>所谓校验和，就是将被校验数据进行累加，并舍弃累加溢出的位，最终得到的1个或多个字节的结果。验证数据的准确性</p>\n","categories":["八股"]},{"title":"贪心","url":"/2023/06/04/%E8%B4%AA%E5%BF%83/","content":"<ol>\n<li>贪心本来就没有套路，也没有框架，所以各种常规解法需要多接触多练习，自然而然才会想到。</li>\n<li>局部最优可以推出全局最优，如果找不出局部最优，那可能就是一道模拟题。</li>\n<li>在出现两个维度相互影响的情况时，两边一起考虑一定会顾此失彼，要先确定一个维度，再确定另一个一个维度。<span id=\"more\"></span></li>\n<li>股票问题用dp</li>\n<li>题目不要做一遍，要多练！</li>\n<li>区间问题，各种覆盖各种去重。</li>\n</ol>\n<h2 id=\"分发饼干\"><a href=\"#分发饼干\" class=\"headerlink\" title=\"分发饼干\"></a>分发饼干</h2><p>假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。</p>\n<p>对每个孩子 i，都有一个胃口值 g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 s[j] 。如果 s[j] &gt;&#x3D; g[i]，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。</p>\n<p><strong>贪心策略：这里的局部最优就是小饼干喂给胃口小的，充分利用饼干尺寸喂饱一个，全局最优就是喂饱尽可能多的小孩</strong>。</p>\n<pre><code class=\"plain\">class Solution &#123;\n     public int findContentChildren(int[] g, int[] s) &#123;\n         //先排序\n         Arrays.sort(g);\n         Arrays.sort(s);\n         int start=0,count=0;\n         //遍历饼干尺寸\n         for(int i=0;i&lt;s.length&amp;&amp;start&lt;g.length;i++)&#123;\n             //找到第一个大于等于g数组的s值\n             if(s[i]&gt;=g[start])&#123;\n                 start++;\n                 count++;\n             &#125;\n         &#125;\n         return count;\n     &#125;   \n &#125;\n</code></pre>\n<h2 id=\"摆动序列\"><a href=\"#摆动序列\" class=\"headerlink\" title=\"摆动序列\"></a>摆动序列</h2><p>如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为 <strong>摆动序列 。</strong>第一个差（如果存在的话）可能是正数或负数。仅有一个元素或者含两个不等元素的序列也视作摆动序列。</p>\n<ul>\n<li>例如， [1, 7, 4, 9, 2, 5] 是一个 <strong>摆动序列</strong> ，因为差值 (6, -3, 5, -7, 3) 是正负交替出现的。</li>\n<li>相反，[1, 4, 7, 2, 5] 和 [1, 7, 4, 5, 5] 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。</li>\n</ul>\n<p><strong>子序列</strong> 可以通过从原始序列中删除一些（也可以不删除）元素来获得，剩下的元素保持其原始顺序。</p>\n<p>给你一个整数数组 nums ，返回 nums 中作为 <strong>摆动序列</strong> 的 <strong>最长子序列的长度</strong> 。</p>\n<p>贪心策略:局部最优,删除单调坡度上的节点（不包括单调坡度两端的节点），那么这个坡度就可以有两个局部峰值。</p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/20201124174327597.png\" alt=\"img\"></p>\n<pre><code class=\"plain\">class Solution &#123;\n     public int wiggleMaxLength(int[] nums) &#123;\n         int n=nums.length;\n         if(n&lt;2) return n;\n         int pre=nums[1]-nums[0];\n         int count=pre!=0?2:1;\n         for(int i=2;i&lt;nums.length;i++)&#123;\n             int cur=nums[i]-nums[i-1];\n             //前面差值可以为0 但当前不可\n             if((cur&gt;0&amp;&amp;pre&lt;=0)||(cur&lt;0&amp;&amp;pre&gt;=0))&#123;\n                 count++;\n                 pre=cur;\n             &#125;\n         &#125;\n         return count;\n     &#125;\n &#125;\n</code></pre>\n<h2 id=\"最大子数组和\"><a href=\"#最大子数组和\" class=\"headerlink\" title=\"最大子数组和\"></a>最大子数组和</h2><p>给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>\n<p><strong>子数组</strong> 是数组中的一个连续部分。</p>\n<p><strong>方法一</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/image-20221120103615752.png\" alt=\"img\"></p>\n<pre><code class=\"plain\">fi表示以第 i个数结尾的「连续子数组的最大和」\n class Solution &#123;\n     public int maxSubArray(int[] nums) &#123;\n         int maxAns=nums[0],pre=0;\n         for(int x:nums)&#123;\n             //求出每个位置的fi\n             //加入前一段还是单独成一段\n             pre=Math.max(pre+x,x);\n             //维护一个最大值\n             maxAns=Math.max(maxAns,pre);\n         &#125;\n         return maxAns;\n \n     &#125;\n &#125;\n //我觉得这道题目的思想是： 走完这一生 如果我和你在一起会变得更好，那我们就在一起，否则我就丢下你。 我回顾我最光辉的时刻就是和不同人在一起，变得更好的最长连续时刻\n</code></pre>\n<p><strong>方法二</strong></p>\n<p>当前“连续和”为负数的时候立刻放弃，从下一个元素重新计算“连续和”，因为负数加上下一个元素 “连续和”只会越来越小。<strong>局部最优的情况下，并记录最大的“连续和”，可以推出全局最优</strong>。<strong>这相当于是暴力解法中的不断调整最大子序和区间的起始位置</strong>。</p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/53.%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C.gif\" alt=\"img\"></p>\n<pre><code class=\"plain\">class Solution &#123;\n     public int maxSubArray(int[] nums) &#123;\n         int sum=Integer.MIN_VALUE;\n         int count=0;\n         for(int i=0;i&lt;nums.length;i++)&#123;\n             //当前连续子数组和\n             count+=nums[i];\n             //维护结果\n             sum=Math.max(sum,count);\n             //当前连续子数组和&lt;0.置为0\n             if(count&lt;0) count=0;\n         &#125;\n         return sum;\n     &#125;\n &#125;\n</code></pre>\n<h2 id=\"买卖股票的最佳时机-II\"><a href=\"#买卖股票的最佳时机-II\" class=\"headerlink\" title=\"买卖股票的最佳时机 II\"></a>买卖股票的最佳时机 II</h2><p>给你一个整数数组 prices ，其中 prices[i] 表示某支股票第 i 天的价格。</p>\n<p>在每一天，你可以决定是否购买和&#x2F;或出售股票。你在任何时候 <strong>最多</strong> 只能持有 <strong>一股</strong> 股票。你也可以先购买，然后在 <strong>同一天</strong> 出售。</p>\n<p>返回 <em>你能获得的</em> *<strong>最大*</strong> <em>利润</em> 。</p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/2020112917480858.png\" alt=\"img\"></p>\n<p>从图中可以发现，其实我们需要收集每天的正利润就可以，<strong>收集正利润的区间，就是股票买卖的区间，而我们只需要关注最终利润，不需要记录区间</strong>。</p>\n<p><strong>局部最优：收集每天的正利润，全局最优：求得最大利润</strong>。</p>\n<pre><code class=\"plain\">class Solution &#123;\n         public int maxProfit(int[] prices) &#123;\n             int ans=0;\n             for(int i=1;i&lt;prices.length;i++)&#123;\n                 ans+=Math.max(prices[i]-prices[i-1],0);\n             &#125;\n             return ans;\n         &#125;\n     &#125;\n</code></pre>\n<h2 id=\"跳跃游戏\"><a href=\"#跳跃游戏\" class=\"headerlink\" title=\"跳跃游戏\"></a>跳跃游戏</h2><p>给定一个非负整数数组 nums ，你最初位于数组的 <strong>第一个下标</strong> 。</p>\n<p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p>\n<p><strong>判断</strong>你是否能够到达最后一个下标。</p>\n<p><strong>贪心算法局部最优解：每次取最大跳跃步数（取最大覆盖范围），整体最优解：最后得到整体最大覆盖范围，看是否能到终点</strong>。</p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/20201124154758229.png\" alt=\"img\"></p>\n<pre><code class=\"plain\">class Solution &#123;\n     public boolean canJump(int[] nums) &#123;\n         int coverRange=0;\n         \n        //在覆盖范围内寻找最大覆盖范围\n         //覆盖范围指的是最远到达下标 只要最远到达下标大于集合长度 就返回true\n         for(int i=0;i&lt;=coverRange;i++)&#123;\n             coverRange=Math.max(coverRange,i+nums[i]);\n             if(coverRange&gt;=nums.length-1) return true;\n         &#125;\n         return false;\n     &#125;\n &#125;\n</code></pre>\n<h2 id=\"跳跃游戏-1\"><a href=\"#跳跃游戏-1\" class=\"headerlink\" title=\"跳跃游戏\"></a>跳跃游戏</h2><p>给定一个非负整数数组，你最初位于数组的第一个位置。数组中的每个元素代表你在该位置可以跳跃的最大长度。</p>\n<p>你的目标是<strong>使用最少的跳跃次数</strong>到达数组的最后一个位置。</p>\n<p><strong>贪心策略</strong>：当前可移动距离尽可能多走，如果还没到终点，步数再加一。整体最优：一步尽可能多走，从而达到最小步数。</p>\n<p>我的理解：</p>\n<p>当前覆盖的最大区域：下一步可达的最大区域 </p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/20201201232309103.png\" alt=\"img\"></p>\n<pre><code class=\"plain\">class Solution &#123;\n     public int jump(int[] nums) &#123;\n         if (nums == null || nums.length == 0 || nums.length == 1) &#123;\n             return 0;\n         &#125;\n         //记录跳跃的次数\n         int count=0;\n         //当前的覆盖最大区域\n         int curDistance = 0;\n         //最大的覆盖区域\n         int maxDistance = 0;\n         for (int i = 0; i &lt; nums.length; i++) &#123;\n             //在可覆盖区域内更新最大的覆盖区域\n             maxDistance = Math.max(maxDistance,i+nums[i]);\n             //说明当前一步，再跳一步就到达了末尾\n             if (maxDistance&gt;=nums.length-1)&#123;\n                 count++;\n                 break;\n             &#125;\n             //走到当前覆盖的最大区域时，更新下一步可达的最大区域  说明此时还没有跳到最后一个位置，那么步数需要+1\n             if (i==curDistance)&#123;\n                 curDistance = maxDistance;\n                 count++;\n             &#125;\n         &#125;\n         return count;\n     &#125;\n &#125;\n</code></pre>\n<h2 id=\"K-次取反后最大化的数组和\"><a href=\"#K-次取反后最大化的数组和\" class=\"headerlink\" title=\"K 次取反后最大化的数组和\"></a>K 次取反后最大化的数组和</h2><p>给你一个整数数组 nums 和一个整数 k ，按以下方法修改该数组：</p>\n<p>选择某个下标 i 并将 nums[i] 替换为 -nums[i] 。重复这个过程恰好 k 次。可以多次选择同一个下标 i 。以这种方式修改数组后，返回数组 <strong>可能的最大和</strong> 。</p>\n<p><strong>题解：</strong></p>\n<ul>\n<li>第一步：将数组按照绝对值大小从大到小排序，<strong>注意要按照绝对值的大小</strong></li>\n<li>第二步：从前向后遍历，遇到负数将其变为正数，同时K–</li>\n<li>第三步：如果K还大于0，那么反复转变数值最小的元素，将K用完</li>\n<li>第四步：求和</li>\n</ul>\n<pre><code class=\"plain\">class Solution &#123;\n     public int largestSumAfterKNegations(int[] nums, int k) &#123;\n         //将数组按照绝对值大小从大到小排序，注意要按照绝对值的大小\n         nums = IntStream.of(nums)\n              .boxed()\n              .sorted((o1, o2) -&gt; Math.abs(o2) - Math.abs(o1))\n              .mapToInt(Integer::intValue).toArray();\n         //从前向后遍历，遇到负数将其变为正数，同时K--\n         for(int i=0;i&lt;nums.length;i++)&#123;\n             if(nums[i]&lt;0&amp;&amp;k&gt;0) &#123;\n                 nums[i]*=-1;\n                 k--;\n             &#125;\n         &#125;\n         // 如果K还大于0，那么反复转变数值最小的元素，将K用完\n         if(k%2==1) nums[nums.length-1]*=-1;\n         int ans=0;\n         for(int num:nums)&#123;\n             ans+=num;\n         &#125;\n         return ans;\n     &#125;\n &#125;\n</code></pre>\n<h2 id=\"加油站\"><a href=\"#加油站\" class=\"headerlink\" title=\"加油站\"></a>加油站</h2><p>在一条环路上有 n 个加油站，其中第 i 个加油站有汽油 gas[i] 升。</p>\n<p>你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。</p>\n<p>给定两个整数数组 gas 和 cost ，如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1 。如果存在解，则 <strong>保证</strong> 它是 <strong>唯一</strong> 的。</p>\n<p><strong>思路：</strong></p>\n<p>如果总油量减去总消耗大于等于零那么一定可以跑完一圈，说明 各个站点的加油站 剩油量rest[i]相加一定是大于等于零的。</p>\n<p>每个加油站的剩余量rest[i]为gas[i] - cost[i]。</p>\n<p>i从0开始累加rest[i]，和记为curSum，一旦curSum小于零，说明[0, i]区间都不能作为起始位置，起始位置从i+1算起，再从0计算curSum。</p>\n<p>为什么[0, i]区间都不能作为起始位置？我的理解：首先0肯定是不能作为起始位置的，假设存在0&lt;j&lt;i，使得j可以作为起始位置，那么[j,i]的curSum肯定大于0，又[0,i]curSum小于0，则[0,j]的curSum必小于0，与第一次出现小于01矛盾，所以不存在0&lt;j&lt;i，使得j可以作为起始位置</p>\n<pre><code class=\"plain\">class Solution &#123;\n     public int canCompleteCircuit(int[] gas, int[] cost) &#123;\n         //当rest累加为负数，就从i+1重新开始，cur归0 最后判断总油是不是小于0\n         int curgas=0,sumgas=0,index=0;\n         for(int i=0;i&lt;gas.length;i++)&#123;\n             curgas+=gas[i]-cost[i];\n             sumgas+=gas[i]-cost[i];\n             if(curgas&lt;0)&#123;\n                 index=(i+1)%gas.length;\n                 curgas=0;\n             &#125;\n         &#125;\n         if(sumgas&lt;0)&#123;\n             return -1;\n         &#125;else&#123;\n             return index;\n         &#125;\n     &#125;\n &#125;\n</code></pre>\n<h2 id=\"分发糖果\"><a href=\"#分发糖果\" class=\"headerlink\" title=\"分发糖果\"></a>分发糖果</h2><p>n 个孩子站成一排。给你一个整数数组 ratings 表示每个孩子的评分。</p>\n<p>你需要按照以下要求，给这些孩子分发糖果：</p>\n<ul>\n<li>每个孩子至少分配到 1 个糖果。</li>\n<li>相邻两个孩子评分更高的孩子会获得更多的糖果。</li>\n</ul>\n<p>请你给每个孩子分发糖果，计算并返回需要准备的 <strong>最少糖果数目</strong> 。</p>\n<p><strong>题解：</strong></p>\n<p><strong>遇到两个维度权衡的时候，一定要先确定一个维度，再确定另一个维度。</strong></p>\n<p><strong>右边评分大于左边的情况（从前向后遍历）</strong></p>\n<p>局部最优：只要右边评分比左边大，右边的孩子就多一个糖果，全局最优：相邻的孩子中，评分高的右孩子获得比左边孩子更多的糖果</p>\n<p>局部最优可以推出全局最优。</p>\n<p>如果ratings[i] &gt; ratings[i - 1] 那么[i]的糖 一定要比[i - 1]的糖多一个，所以贪心：candyVec[i] &#x3D; candyVec[i - 1] + 1</p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/20201117114916878.png\" alt=\"img\"></p>\n<p><strong>左孩子大于右孩子的情况（从后向前遍历）</strong></p>\n<p>局部最优：如果 ratings[i] &gt; ratings[i + 1]，取candyVec[i + 1] + 1 （从右边这个加1得到的糖果数量）和 candyVec[i] （之前比较右孩子大于左孩子得到的糖果数量）。最大的糖果数量，保证第i个小孩的糖果数量即大于左边的也大于右边的。全局最优：相邻的孩子中，评分高的孩子获得更多的糖果。</p>\n<p>局部最优可以推出全局最优。</p>\n<p>所以就取candyVec[i + 1] + 1 和 candyVec[i] 最大的糖果数量，<strong>candyVec[i]只有取最大的才能既保持对左边candyVec[i - 1]的糖果多，也比右边candyVec[i + 1]的糖果多</strong>。</p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/20201117115658791.png\" alt=\"img\"></p>\n<pre><code class=\"plain\">class Solution &#123;\n     public int candy(int[] ratings) &#123;\n         int n=ratings.length;\n         int[] candyVec=new int[n];\n         candyVec[0]=1;\n         for(int i=1;i&lt;n;i++)&#123;\n             candyVec[i]=(ratings[i]&gt;ratings[i-1])?candyVec[i-1]+1:1;\n         &#125;\n         // for(int i=0;i&lt;n;i++)&#123;\n         //     if(ratings[i]&gt;ratings[i+1])&#123;\n         //         //这就是为什么比较左大于右情况时不能从前往后的原因，因为用到的candyVec[i+1]不是最新的\n         //         candyVec[i]=Math.max(candyVec[i],candyVec[i+1]+1);\n         //     &#125;\n         // &#125;\n         for(int i=n-2;i&gt;=0;i--)&#123;\n             if(ratings[i]&gt;ratings[i+1])&#123;\n                 candyVec[i]=Math.max(candyVec[i],candyVec[i+1]+1);\n             &#125;\n         &#125;\n         int ans=0;\n         for(int candy:candyVec)&#123;\n             ans+=candy;\n         &#125;\n         return ans;\n     &#125;\n &#125;\n</code></pre>\n<h2 id=\"柠檬水找零\"><a href=\"#柠檬水找零\" class=\"headerlink\" title=\"柠檬水找零\"></a>柠檬水找零</h2><p>在柠檬水摊上，每一杯柠檬水的售价为 5 美元。顾客排队购买你的产品，（按账单 bills 支付的顺序）一次购买一杯。</p>\n<p>每位顾客只买一杯柠檬水，然后向你付 5 美元、10 美元或 20 美元。你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付 5 美元。</p>\n<p>注意，一开始你手头没有任何零钱。</p>\n<p>给你一个整数数组 bills ，其中 bills[i] 是第 i 位顾客付的账。如果你能给每位顾客正确找零，返回 true ，否则返回 false 。</p>\n<pre><code class=\"plain\">/**\n 题解：\n 贪心策略：20美元情况优先找一个10元和5元 switch和if else都可 \n 我最开始还定义一个num_20 后来发现这个变量只有增加，所以可以去掉\n **/\n class Solution &#123;\n     public boolean lemonadeChange(int[] bills) &#123;\n         int num_5=0,num_10=0;\n         for(int i=0;i&lt;bills.length;i++)&#123;\n             switch(bills[i])&#123;\n                 case 5:\n                 num_5++;\n                 break;\n \n                 case 10:\n                 num_5--;\n                 num_10++;\n                 break;\n \n                 case 20:\n                 if(num_10&gt;=1)&#123;\n                     num_10--;\n                     num_5--;\n                 &#125;else&#123;\n                     num_5-=3;\n                 &#125;;\n                 break;\n                 default:\n             &#125;\n             if(num_10&lt;0||num_5&lt;0) return false;\n         &#125;\n         return true;\n     &#125;\n &#125;\n</code></pre>\n<h2 id=\"根据身高重建队列\"><a href=\"#根据身高重建队列\" class=\"headerlink\" title=\"根据身高重建队列\"></a>根据身高重建队列</h2><p>排序里面做过</p>\n<h2 id=\"用最少数量的箭引爆气球\"><a href=\"#用最少数量的箭引爆气球\" class=\"headerlink\" title=\"用最少数量的箭引爆气球\"></a>用最少数量的箭引爆气球</h2><p>有一些球形气球贴在一堵用 XY 平面表示的墙面上。墙面上的气球记录在整数数组 points ，其中points[i] &#x3D; [xstart, xend] 表示水平直径在 xstart 和 xend之间的气球。你不知道气球的确切 y 坐标。</p>\n<p>一支弓箭可以沿着 x 轴从不同点 <strong>完全垂直</strong> 地射出。在坐标 x 处射出一支箭，若有一个气球的直径的开始和结束坐标为 x<code>start，x</code>end， 且满足 xstart ≤ x ≤ x&#96;&#96;end，则该气球会被 <strong>引爆</strong> 。可以射出的弓箭的数量 <strong>没有限制</strong> 。 弓箭一旦被射出之后，可以无限地前进。</p>\n<p>给你一个数组 points ，<em>返回引爆所有气球所必须射出的</em> *<strong>最小*</strong> <em>弓箭数</em> 。</p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/20201123101929791.png\" alt=\"img\"></p>\n<pre><code class=\"plain\">class Solution &#123;\n     public int findMinArrowShots(int[][] points) &#123;\n         Arrays.sort(points,new Comparator&lt;int[]&gt;()&#123;\n             public int compare(int[] point1,int[] point2)&#123;\n                 //按照左边界排序就行\n                 //这里这么写 是为了防止溢出，做减法可能导致数值溢出 要直接比较\n                 return point1[0]&gt;point2[0]?1:-1;\n             &#125;\n         &#125;);\n         //需要箭个数\n         int count=0;\n         int i=0;\n         while(i&lt;points.length)&#123;\n             int index=1;\n             int minright=points[i][1];\n             //因为已经保证了左边界有序，因此只需要下一个int[]0位置要小于等于最小右边界就可以放在一起被引爆\n             while(i+index&lt;points.length&amp;&amp;minright&gt;=points[i+index][0])&#123;\n                 minright=Math.min(minright, points[i+index][1]);//维护有边界最小值               \n                 index++;\n             &#125;\n             i=i+index;\n             count++;\n         &#125;\n         return count;\n     &#125;\n &#125;\n //代码随想录\n class Solution &#123;\n     public int findMinArrowShots(int[][] points) &#123;\n         // 根据气球直径的开始坐标从小到大排序\n         // 使用Integer内置比较方法，不会溢出\n         Arrays.sort(points, (a, b) -&gt; Integer.compare(a[0], b[0]));\n         int count = 1;  // points 不为空至少需要一支箭\n         for (int i = 1; i &lt; points.length; i++) &#123;\n             if (points[i][0] &gt; points[i - 1][1]) &#123;  // 气球i和气球i-1不挨着，注意这里不是&gt;=\n                 count++; // 需要一支箭\n             &#125; else &#123;  // 气球i和气球i-1挨着、\n                 //points[i][1] 存的是i及之前的最小右边界\n                 points[i][1] = Math.min(points[i][1], points[i - 1][1]); // 更新重叠气球最小右边界\n             &#125;\n         &#125;\n         return count;\n     &#125;\n &#125;\n</code></pre>\n<h2 id=\"无重叠区间\"><a href=\"#无重叠区间\" class=\"headerlink\" title=\"无重叠区间\"></a>无重叠区间</h2><p>给定一个区间的集合 intervals ，其中 intervals[i] &#x3D; [starti, endi] 。返回 <em>需要移除区间的最小数量，使剩余区间互不重叠</em> 。</p>\n<p>题解：和上一题很像</p>\n<p>右边界排序之后，局部最优：优先选右边界小的区间，所以从左向右遍历，留给下一个区间的空间大一些，从而尽量避免交叉。全局最优：选取最多的非交叉区间。</p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/20201221201553618.png\" alt=\"img\"></p>\n<pre><code class=\"plain\">class Solution &#123;\n     public int eraseOverlapIntervals(int[][] intervals) &#123;\n         //按照右边界排序  升序排\n         Arrays.sort(intervals,(a,b)-&gt;Integer.compare(a[1],b[1]));\n         //需要移除区间的最小数量\n         int count=0;\n         int minRight=Integer.MIN_VALUE;\n         for(int i=0;i&lt;intervals.length;i++)&#123;\n             //后一个的左边界如果大于前一个右边界  更新minright   \n             if(minRight&lt;=intervals[i][0])&#123;\n                 minRight=intervals[i][1];\n             &#125;else&#123;\n                 //需要移除重叠的区域,为了保证更多不相交区间,右边界尽量小\n                 count++;\n             &#125;\n         &#125;\n         return count;\n     &#125;\n &#125;\n</code></pre>\n<h2 id=\"划分字母区间\"><a href=\"#划分字母区间\" class=\"headerlink\" title=\"划分字母区间\"></a>划分字母区间</h2><p>字符串 S 由小写字母组成。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。返回一个表示每个字符串片段的长度的列表。</p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/20201222191924417.png\" alt=\"img\"></p>\n<pre><code class=\"plain\">class Solution &#123;\n     public List&lt;Integer&gt; partitionLabels(String s) &#123;\n         // 统计每一个字符最后出现的位置  因为是26个字母 所以长度26 位置0对应就是a字符出现最远位置\n         int[] hash=new int[26];\n         for(int i=0;i&lt;s.length();i++)&#123;\n             //更新最远距离 可以覆盖的\n             hash[s.charAt(i)-&#39;a&#39;]=i;\n         &#125;\n         int start=0,end=0;//左右边界\n         List&lt;Integer&gt; ans=new ArrayList&lt;&gt;();\n         for(int i=0;i&lt;s.length();i++)&#123;\n             // 更新当前出现的最远出现下标\n             end=Math.max(end,hash[s.charAt(i)-&#39;a&#39;]);\n             // 如果找到字符最远出现位置下标和当前下标相等了，则找到了分割点\n             if(end==i)&#123;\n                 ans.add(end-start+1);\n                 // 调整start\n                 start=i+1;\n             &#125;\n         &#125;\n         return ans;\n \n     &#125;\n &#125;\n</code></pre>\n<h2 id=\"合并区间\"><a href=\"#合并区间\" class=\"headerlink\" title=\"合并区间\"></a>合并区间</h2><p>以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] &#x3D; [starti, endi] 。请你合并所有重叠的区间，并返回 <em>一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间</em> 。</p>\n<p>题解：</p>\n<pre><code class=\"plain\">class Solution &#123;\n     public int[][] merge(int[][] intervals) &#123;\n         List&lt;int[]&gt; res = new LinkedList&lt;&gt;();\n         //按照左边界排序\n         Arrays.sort(intervals, (x, y) -&gt; Integer.compare(x[0], y[0]));\n         //initial start 是最小左边界\n         int start = intervals[0][0];\n         int rightmostRightBound = intervals[0][1];\n         for (int i = 1; i &lt; intervals.length; i++) &#123;\n             //如果左边界大于最大右边界\n             if (intervals[i][0] &gt; rightmostRightBound) &#123;\n                 //加入区间 并且更新start\n                 res.add(new int[]&#123;start, rightmostRightBound&#125;);\n                 start = intervals[i][0];\n                 rightmostRightBound = intervals[i][1];\n             &#125; else &#123;\n                 //更新最大右边界\n                 rightmostRightBound = Math.max(rightmostRightBound, intervals[i][1]);\n             &#125;\n         &#125;\n         res.add(new int[]&#123;start, rightmostRightBound&#125;);\n         return res.toArray(new int[res.size()][]);\n     &#125;\n &#125;\n &#125;\n//相当简洁\n class Solution &#123;\n     public int[][] merge(int[][] intervals) &#123;\n         Arrays.sort(intervals, (x, y) -&gt; Integer.compare(x[0], y[0]));\n         List&lt;int[]&gt; ans=new ArrayList&lt;&gt;();\n         int n=intervals.length;\n         for(int i=0;i&lt;n;i++)&#123;\n             // 第一次加入或者区间不相交，直接加入集合\n             if(ans.size()==0||intervals[i][0]&gt;ans.get(ans.size()-1)[1])&#123;\n                 ans.add(intervals[i]);\n             &#125;else&#123;\n                 // 否则更改前一个元素的右边界，注意这里直接修改，也就避免再添加了\n                 ans.get(ans.size()-1)[1]=Math.max(intervals[i][1],ans.get(ans.size()-1)[1]);\n             &#125;\n         &#125;\n         return ans.toArray(new int[ans.size()][]);//转成数组要指定大小\n \n     &#125;\n &#125;\n</code></pre>\n<h2 id=\"单调递增的数字\"><a href=\"#单调递增的数字\" class=\"headerlink\" title=\"单调递增的数字\"></a>单调递增的数字</h2><p>当且仅当每个相邻位数上的数字 x 和 y 满足 x &lt;&#x3D; y 时，我们称这个整数是<strong>单调递增</strong>的。</p>\n<p>给定一个整数 n ，返回 <em>小于或等于</em> <em>n</em> <em>的最大数字，且数字呈</em> *<strong>单调递增*</strong> 。</p>\n<p>题解：</p>\n<p><strong>局部最优：遇到strNum[i - 1] &gt; strNum[i]的情况，让strNum[i - 1]–，然后strNum[i]给为9，可以保证这两位变成最大单调递增整数</strong>。</p>\n<p><strong>但这里局部最优推出全局最优，还需要其他条件，即遍历顺序，和标记从哪一位开始统一改成9</strong>。</p>\n<p><strong>又因为从前后向遍历会改变已经遍历过的结果，所以从后往前遍历</strong></p>\n<pre><code class=\"plain\">class Solution &#123;\n     public int monotoneIncreasingDigits(int n) &#123;\n         char[] chars = Integer.toString(n).toCharArray();\n         // start用来标记赋值9从哪里开始\n         // 设置为这个默认值，为了防止第二个for循环在start没有被赋值的情况下执行\n         //初始化 ，start 表示要开始填充&#39;9&#39;的位置\n         int start=chars.length;\n         for(int i=chars.length-1;i&gt;0;i--)&#123;\n             if(chars[i-1]&gt;chars[i])&#123;\n                 chars[i-1]--;\n                 start=i;\n             &#125;\n         &#125;\n         // 从start开始一直往后填充&#39;9&#39;\n         for(int i=start;i&lt;chars.length;i++)&#123;\n             chars[i]=&#39;9&#39;;\n         &#125;\n         // 类型转换\n         return Integer.parseInt(String.valueOf(chars));\n     &#125;\n &#125;\n</code></pre>\n<h2 id=\"监控二叉树\"><a href=\"#监控二叉树\" class=\"headerlink\" title=\"监控二叉树\"></a>监控二叉树</h2><p>给定一个二叉树，我们在树的节点上安装摄像头。</p>\n<p>节点上的每个摄影头都可以监视<strong>其父对象、自身及其直接子对象。</strong></p>\n<p>计算监控树的所有节点所需的最小摄像头数量。</p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/bst_cameras_01.png\" alt=\"img\"></p>\n<p><strong>后序遍历</strong>：叶子节点放不放摄像头省下了的摄像头数量是指数阶别的,所以让叶子节点的父节点安摄像头，所用摄像头最少，选择后序遍历</p>\n<p><strong>如何隔两个节点放一个摄像头</strong> ：状态转移</p>\n<ul>\n<li>0：该节点无覆盖</li>\n<li>1：本节点有摄像头</li>\n<li>2：本节点有覆盖</li>\n</ul>\n<ol>\n<li>情况一：左孩子有覆盖，右孩子有覆盖，那么此时中间节点应该就是无覆盖的状态了。</li>\n<li>情况2：左右节点至少有一个无覆盖的情况，如果是以下情况，此时摄像头的数量要加一，并且return 1，代表中间节点放摄像头。</li>\n<li>情况3：左右节点至少有一个有摄像头，其父节点就应该是2</li>\n</ol>\n<pre><code class=\"plain\">class Solution &#123;\n     int count=0;\n     public int minCameraCover(TreeNode root) &#123;\n     //     0 表示无覆盖 \n     //    1 表示 有摄像头\n     //    2 表示有覆盖       \n         if(mincame(root)==0) count++;\n         return count;\n     &#125;\n     public int mincame(TreeNode root)&#123;\n         //空节点默认为 有覆盖状态，避免在叶子节点上放摄像头 \n         if(root==null) return 2;\n         // 优先遍历叶子结点  因为让叶子节点的父节点安摄像头，所用摄像头最少  用后序遍历\n         int left=mincame(root.left);\n         int right=mincame(root.right);\n         if(left==2&amp;&amp;right==2)&#123;\n             return 0;\n         &#125;else if(left==0||right==0)&#123;\n             count++;\n             return 1;\n         &#125;else&#123;\n             return 2;\n         &#125;\n     &#125;\n &#125;\n</code></pre>\n<h2 id=\"最长递增子序列（也可dp）\"><a href=\"#最长递增子序列（也可dp）\" class=\"headerlink\" title=\"最长递增子序列（也可dp）\"></a>最长递增子序列（也可dp）</h2><p>考虑一个简单的贪心，如果我们要使上升子序列尽可能的长，则我们需要让序列上升得尽可能慢，因此我们希望每次在上升子序列最后加上的那个数尽可能的小。</p>\n<p>基于上面的贪心思路，我们维护一个数组 d[i]，表示长度为 i的最长上升子序列的末尾元素的最小值，用 len记录目前最长上升子序列的长度，起始时 len 为 1，d[1]&#x3D;nums[0]</p>\n<p>同时我们可以注意到 d[i] 是关于 i 单调递增的。（显而易见）根据 ddd 数组的单调性，我们可以使用二分查找寻找下标 i，优化时间复杂度。</p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/image-20220924191640236.png\" alt=\"img\"></p>\n<pre><code class=\"plain\">class Solution &#123;\n     public int lengthOfLIS(int[] nums) &#123;\n         int len = 1, n = nums.length;\n         if (n == 0) &#123;\n             return 0;\n         &#125;\n         //细节 d代表长度为i的最长上升子序列的末尾元素的最小值，d[0……n]因此共n+1个数 所以是new int[n + 1]\n         int[] d = new int[n + 1];\n         d[len] = nums[0];\n         for (int i = 1; i &lt; n; ++i) &#123;\n             if (nums[i] &gt; d[len]) &#123;\n                 d[++len] = nums[i];//先++\n             &#125; else &#123;\n                 int l = 1, r = len, pos = 0; // 如果找不到说明所有的数都比 nums[i] 大，此时要更新 d[1]，所以这里将 pos 设为 0  \n                 while (l &lt;= r) &#123;\n                     int mid = (l + r) &gt;&gt; 1;\n                     //目的是找到第一个比num[i]小的数字，也就是小于nums[i]的数字里面最接近nums[i]的数字\n                     if (d[mid] &lt; nums[i]) &#123;\n                         pos = mid;//更新pos\n                         l = mid + 1;\n                     &#125; else &#123;\n                         r = mid - 1;\n                     &#125;\n                 &#125;\n                 d[pos + 1] = nums[i];//更新 \n             &#125;\n         &#125;\n         return len;\n     &#125;\n &#125;\n</code></pre>\n<h2 id=\"Dota2-参议院\"><a href=\"#Dota2-参议院\" class=\"headerlink\" title=\"Dota2 参议院\"></a>Dota2 参议院</h2><p>Dota2 的世界里有两个阵营：Radiant（天辉）和 Dire（夜魇）</p>\n<p>Dota2 参议院由来自两派的参议员组成。现在参议院希望对一个 Dota2 游戏里的改变作出决定。他们以一个基于轮为过程的投票进行。在每一轮中，每一位参议员都可以行使两项权利中的 <strong>一</strong> 项：</p>\n<ul>\n<li><strong>禁止一名参议员的权利</strong>：参议员可以让另一位参议员在这一轮和随后的几轮中丧失 <strong>所有的权利</strong> 。</li>\n<li><strong>宣布胜利</strong>：如果参议员发现有权利投票的参议员都是 <strong>同一个阵营的</strong> ，他可以宣布胜利并决定在游戏中的有关变化。</li>\n</ul>\n<p>给你一个字符串 senate 代表每个参议员的阵营。字母 ‘R’ 和 ‘D’分别代表了 Radiant（天辉）和 Dire（夜魇）。然后，如果有 n 个参议员，给定字符串的大小将是 n。</p>\n<p>以轮为基础的过程从给定顺序的第一个参议员开始到最后一个参议员结束。这一过程将持续到投票结束。所有失去权利的参议员将在过程中被跳过。</p>\n<p>假设每一位参议员都足够聪明，会为自己的政党做出最好的策略，你需要预测哪一方最终会宣布胜利并在 Dota2 游戏中决定改变。输出应该是 “Radiant” 或 “Dire” 。</p>\n<p>题解：</p>\n<p>例如：RDDRD</p>\n<p>第一轮：senate[0]的R消灭senate[1]的D，那么senate[2]的D，是消灭senate[0]的R还是消灭senate[3]的R呢？</p>\n<p>当然是消灭senate[3]的R，因为当轮到这个R的时候，它可以消灭senate[4]的D。</p>\n<p><strong>所以消灭的策略是，尽量消灭自己后面的对手，因为前面的对手已经使用过权利了，而后序的对手依然可以使用权利消灭自己的同伴！</strong></p>\n<pre><code class=\"plain\">class Solution &#123;\n     public String predictPartyVictory(String senateStr) &#123;\n         // R = true表示本轮循环结束后，字符串里依然有R。D同理\n         Boolean R = true, D = true;\n         // 当flag大于0时，R在D前出现，R可以消灭D。当flag小于0时，D在R前出现，D可以消灭R\n         int flag = 0;\n         byte[] senate =  senateStr.getBytes();\n         while (R &amp;&amp; D) &#123; // 一旦R或者D为false，就结束循环，说明本轮结束后只剩下R或者D了\n             R = false;\n             D = false;\n             for (int i = 0; i &lt; senate.length; i++) &#123;\n                 if (senate[i] == &#39;R&#39;) &#123;\n                     if (flag &lt; 0) senate[i] = 0; // 消灭R，R此时为false\n                     else R = true; // 如果没被消灭，本轮循环结束有R\n                     flag++;\n                 &#125;\n                 if (senate[i] == &#39;D&#39;) &#123;\n                     if (flag &gt; 0) senate[i] = 0;\n                     else D = true;\n                     flag--;\n                 &#125;\n             &#125;\n         &#125;\n         // 循环结束之后，R和D只能有一个为true\n         return R == true ? &quot;Radiant&quot; : &quot;Dire&quot;;\n     &#125;\n &#125;\n</code></pre>\n<h2 id=\"分割平衡字符串\"><a href=\"#分割平衡字符串\" class=\"headerlink\" title=\"分割平衡字符串\"></a>分割平衡字符串</h2><p><strong>平衡字符串</strong> 中，’L’ 和 ‘R’ 字符的数量是相同的。</p>\n<p>给你一个平衡字符串 s，请你将它分割成尽可能多的子字符串，并满足：</p>\n<ul>\n<li>每个子字符串都是平衡字符串。</li>\n</ul>\n<p>返回可以通过分割得到的平衡字符串的 <strong>最大数量****。</strong></p>\n<p>简单 直接做出来</p>\n<pre><code class=\"plain\">class Solution &#123;\n     int count=0;\n     public int balancedStringSplit(String s) &#123;\n         int Lcount=0,Rcount=0;\n         for(int i=0;i&lt;s.length();i++)&#123;\n             if(s.charAt(i)==&#39;L&#39;)&#123;\n                 Lcount++;\n             &#125;\n             if(s.charAt(i)==&#39;R&#39;)&#123;\n                 Rcount++;\n             &#125;\n             if(Lcount==Rcount)&#123;\n                 count++;\n             &#125;\n         &#125; \n         return count;\n     &#125;\n &#125;\n</code></pre>\n","categories":["算法"]},{"title":"识菇","url":"/2023/06/04/%E8%AF%86%E8%8F%87/","content":"<h1 id=\"后端\"><a href=\"#后端\" class=\"headerlink\" title=\"后端\"></a>后端</h1><p><strong>idea 调用Python命令Runtime.getRuntime().exec总是空</strong></p>\n<p>在调用含第三方库的时候，需要指定第三方库的所在 String[] aaa &#x3D; new String[]{“D:\\Anaconda3\\python.exe”, “D:\\Pythonworkspace\\Python_Class\\aaa.py”}; proc &#x3D; Runtime.getRuntime().exec(aaa);&#x2F;&#x2F; 执行py文件<span id=\"more\"></span></p>\n<p><strong>为什么运行后inputimage会被删？</strong></p>\n<p>因为后面有</p>\n<p>if (!imageFile.delete())</p>\n<p>这段代码运行，会删除文件</p>\n<p><strong>为什么python命令command String不能用 String[]可以用?</strong>\t</p>\n<h1 id=\"前端taro\"><a href=\"#前端taro\" class=\"headerlink\" title=\"前端taro\"></a>前端taro</h1><h2 id=\"taro框架安装\"><a href=\"#taro框架安装\" class=\"headerlink\" title=\"taro框架安装\"></a>taro框架安装</h2><p>先查看Node版本，确认安装最新版本</p>\n<pre><code class=\"plain\">npm config set registry http://registry.npm.taobao.org/   第一个命令是使用npm的淘宝镜像，\nnpm config set sass_binary_site https://npm.taobao.org/mirrors/node-sass/   配置node-sass为淘宝镜像\ncnpm install -g @tarojs/cli   使用cnpm全局安装taro，将会生成一个taro 命令。taro-cli 包位于 Taro 工程的 packages 目录下，主要负责项目初始化、编译、构建等\n</code></pre>\n<p>查看taro是否安装完毕</p>\n<p>taro -V</p>\n<p><strong>报错</strong>WARN node unsupported “node**@v6.11.2” is incompatible with electron@^7.1.9, expected node@&gt;&#x3D; 8.6**</p>\n<p>解决：升级node 到官网下载最新版本Msi 无脑下一步即可</p>\n<p><strong>关于node</strong></p>\n<ol>\n<li>开源跨平台的JavaScript运行时环境。它几乎是任何类型项目的流行工具！</li>\n<li>浏览器之外运行V8 JavaScript引擎（Google Chrome的内核）。这使得Node.js的性能非常好。</li>\n<li>Node.js应用程序在单个程序中运行，无需为每个请求创建新的线程。Node.js在其标准库中提供了一组异步的I&#x2F;O原语，以防JavaScript代码阻塞，通常，Node.js中的库是使用非阻塞范式编写的，使得阻塞行为成为异常而不是常态。</li>\n<li>Node.js具有独特的优势，因为数百万为浏览器编写的JavaScript的前端开发者现在无需学习完全不同的语言，就可以编写除客户端代码之外的服务器端代码。</li>\n</ol>\n<p><strong>报错npm WARN config global –global, –local are deprecated. Use –location&#x3D;global instead.</strong></p>\n<p>npm install –global –production npm-windows-upgrade</p>\n<p>上述方案只是解决node 16版本的, 切换到node18, 此时还会有上述问题:</p>\n<p>解决：</p>\n<pre><code class=\"plain\">npm install -g npm-windows-upgrade\n npm-windows-upgrade\n and select version 8.12.1 for installation.(然后选择下载8.12.1的版本。)\n</code></pre>\n<p>（还未解决 代办）</p>\n<h2 id=\"搭建项目\"><a href=\"#搭建项目\" class=\"headerlink\" title=\"搭建项目\"></a><strong>搭建项目</strong></h2><p>taro init taro-dome</p>\n<p>一路默认：</p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/202306022256299.png\" alt=\"img\"></p>\n<p>切换到项目路径</p>\n<p>执行命令</p>\n<p>npm run dev:h5</p>\n<p>然后网页出来helloworld</p>\n<h2 id=\"Taro生成小程序代码并预览\"><a href=\"#Taro生成小程序代码并预览\" class=\"headerlink\" title=\"Taro生成小程序代码并预览\"></a>Taro生成小程序代码并预览</h2><p>taro可以生成多端代码，在上一节只生成了h5的显示，这次我们就先来进行生成小程序代码，并进行预览。</p>\n<p>npm run dev:weapp</p>\n<p>然后打开微信开发者工具导入项目的dist目录<strong>注意</strong></p>\n<p>千万不要在微信开发者工具中修改dist目录，因为这个文件是由taro编译而来的；如果要修改在taro的原项目修改，然后通过编译将修改的内容编译到dist文件中。</p>\n<p>哈哈哈哈哈哈哈哈哈哈 笑死 千万别在webstrom打开 报那文件目录错误 用vscode就没问题（但是需要管理员打开）</p>\n<h1 id=\"算法\"><a href=\"#算法\" class=\"headerlink\" title=\"算法\"></a>算法</h1><h2 id=\"运行\"><a href=\"#运行\" class=\"headerlink\" title=\"运行\"></a>运行</h2><p>想运行identify.py 在terminal里面输入python .\\identify.py inputImage&#x2F;tum.jpg</p>\n<h2 id=\"moileNet\"><a href=\"#moileNet\" class=\"headerlink\" title=\"moileNet\"></a>moileNet</h2><h3 id=\"V1\"><a href=\"#V1\" class=\"headerlink\" title=\"V1\"></a>V1</h3><p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/202306022256572.png\" alt=\"img\"></p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/202306022256388.png\" alt=\"img\"></p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/202306022256246.png\" alt=\"img\"></p>\n<p>dw不改变深度 但在此之前是降维的</p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/202306022256871.png\" alt=\"img\"></p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/202306022257167.png\" alt=\"img\"></p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/202306022257016.png\" alt=\"img\"></p>\n<h3 id=\"V2\"><a href=\"#V2\" class=\"headerlink\" title=\"V2\"></a>V2</h3><p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/202306022257934.png\" alt=\"img\"></p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/202306022257498.png\" alt=\"img\"></p>\n<p>卷积核个数就是输出层深度 比如这里卷积核个数就是tk</p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/202306022257792.png\" alt=\"img\"></p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/202306022257692.png\" alt=\"img\"></p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/202306022257827.png\" alt=\"img\"></p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/202306022258379.png\" alt=\"img\"></p>\n<h1 id=\"项目部署\"><a href=\"#项目部署\" class=\"headerlink\" title=\"项目部署\"></a>项目部署</h1><h3 id=\"服务器安装conda\"><a href=\"#服务器安装conda\" class=\"headerlink\" title=\"服务器安装conda\"></a>服务器安装conda</h3><p><a href=\"https://blog.csdn.net/wyf2017/article/details/118676765\">https://blog.csdn.net/wyf2017/article/details/118676765</a></p>\n<p><a href=\"https://blog.csdn.net/zhou_438/article/details/102483103\">https://blog.csdn.net/zhou_438/article/details/102483103</a></p>\n<h3 id=\"服务器tensorflow\"><a href=\"#服务器tensorflow\" class=\"headerlink\" title=\"服务器tensorflow\"></a>服务器tensorflow</h3><pre><code class=\"plain\">conda create -n tensorflow pip python=3.7//安装虚拟环境tensorflow\nactivate tensorflow//激活环境   \n如果是服务器的话就是 因为权限不够需要 source activate tensorflow//激活环境 \npip install tensorflow-cpu==2.10.0 -i http://pypi.douban.com/simple --trusted-host pypi.douban.com\n conda info --envs\n</code></pre>\n<h2 id=\"数据库部署\"><a href=\"#数据库部署\" class=\"headerlink\" title=\"数据库部署\"></a>数据库部署</h2><p>通过Navicat把表放上去就行 记得 docker inspect 容器名 看下ip 填到后端yaml里面</p>\n<h2 id=\"后端部署\"><a href=\"#后端部署\" class=\"headerlink\" title=\"后端部署\"></a>后端部署</h2><p>任意目录 上传jar包 新建dockerfile </p>\n<pre><code class=\"plain\">FROM java:8\nEXPOSE 8888\nADD ./blog_api.jar /api.jar\nRUN bash -c &#39;touch /api.jar&#39;\nENTRYPOINT [&quot;java&quot;,&quot;-jar&quot;,&quot;/api.jar&quot;,&quot;--spring.profiles.active=prod&quot;]\n</code></pre>\n<p>docker build -f .&#x2F;blog_dockerfile -t app .&#x2F;&#x2F;通过这个构建镜像 f是文件 t tagdocker run –name mushroom_app -p 8800:8800 mushroom_app&#x2F;&#x2F;通过这个启动</p>\n<p>然后记得阿里云开放端口</p>\n<p>docker logs mushroom_app 查看日志</p>\n<h2 id=\"微信小程序\"><a href=\"#微信小程序\" class=\"headerlink\" title=\"微信小程序\"></a>微信小程序</h2><p>npm run dev:weapp 可以打包dist目录</p>\n<p>放到vx微信开发者工具里面，但是微信这傻逼尼玛的还只能访问域名，劳资有是有，但是得续费3个月服务器才行哦</p>\n<p><a href=\"https://developers.weixin.qq.com/miniprogram/dev/framework/ability/network.html\">https://developers.weixin.qq.com/miniprogram/dev/framework/ability/network.html</a></p>\n<h2 id=\"xshell连接阿里云\"><a href=\"#xshell连接阿里云\" class=\"headerlink\" title=\"xshell连接阿里云\"></a>xshell连接阿里云</h2><p>1.申请阿里云服务器，下载xshell2.在git里面输入如下命令，然后设置permitrootlogin yes 和 passwordAuthentication yes</p>\n<p>vi &#x2F;etc&#x2F;ssh&#x2F;sshd_config</p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/202306022258413.png\" alt=\"img\"></p>\n<p>退出的时候进行如下操作：</p>\n<pre><code class=\"plain\">1、按Esc \n 2、输入：set noreadonly  \n 3、即可按正常途径保存:wq\n</code></pre>\n<p>3.记得修改实例密码，然后xshell登录</p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/202306022300375.png\" alt=\"img\"></p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/202306022301893.png\" alt=\"img\"></p>\n<h2 id=\"服务器环境配置的一些坑\"><a href=\"#服务器环境配置的一些坑\" class=\"headerlink\" title=\"服务器环境配置的一些坑\"></a>服务器环境配置的一些坑</h2><p>原文链接<a href=\"https://blog.csdn.net/Elon15/article/details/124516929\">https://blog.csdn.net/Elon15/article/details/124516929</a></p>\n<p><strong>3.7 那一步是source &#x2F;etc&#x2F;profile</strong></p>\n<p><strong>4.2 下载yum源的时候出现Unable to establish SSL connection，在命令后面跟上–no-check-certificat</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/202306022301950.png\" alt=\"img\"></p>\n<p><strong>4.5 yum install -y mysql-community-server报错</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/202306022309394.png\" alt=\"img\"></p>\n<p>rpm –import <a href=\"https://repo.mysql.com/RPM-GPG-KEY-mysql-2022\">https://repo.mysql.com/RPM-GPG-KEY-mysql-2022</a></p>\n<p><strong>4.7 登录数据库改密码执行改密码出错的解决办法：</strong></p>\n<pre><code class=\"plain\">mysql&gt; set global validate_password_policy=low;             //将密码级别改为弱\nmysql&gt; set global validate_password_length=6;               //将密码长度改为6\n然后输入命令ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED WITH mysql_native_password BY &#39;123456&#39;; （注意末尾要有分号）\n</code></pre>\n<h1 id=\"代办\"><a href=\"#代办\" class=\"headerlink\" title=\"代办\"></a>代办</h1><p><strong>4.10 阿里云连接Mysql, 在确保端口开放的情况下，如果出现错误代码1130- Host xxx is not allowed to connect to this MariaDb server，说明是权限问题。如图：</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/202306022314137.png\" alt=\"img\"></p>\n<p>1.授权法</p>\n<pre><code class=\"plain\">GRANT ALL PRIVILEGES ON *.* TO &#39;user&#39;@&#39;%&#39; IDENTIFIED BY &#39;password&#39; WITH GRANT OPTION; // %:表示从任何主机连接到mysql服务器\n\nFLUSH  PRIVILEGES;\n</code></pre>\n<p>实测好用，原文链接<a href=\"https://blog.csdn.net/qq_35396905/article/details/82972618%EF%BC%88%E5%85%B6%E4%BB%96%E6%96%B9%E6%B3%95%E5%BE%85%E9%AA%8C%E8%AF%81%EF%BC%89\">https://blog.csdn.net/qq_35396905/article/details/82972618（其他方法待验证）</a></p>\n<h4 id=\"1、postman文件云服务上传路径问题！！！！！！！！\"><a href=\"#1、postman文件云服务上传路径问题！！！！！！！！\" class=\"headerlink\" title=\"1、postman文件云服务上传路径问题！！！！！！！！\"></a>1、postman文件云服务上传路径问题！！！！！！！！</h4><h2 id=\"2022-9-13-想法\"><a href=\"#2022-9-13-想法\" class=\"headerlink\" title=\"2022 9.13 想法\"></a>2022 9.13 想法</h2><p>前端：微信开发者工具，小程序框架快速入门</p>\n<p>后端功能调整：设定一个百分比，如果低于这个百分比视为不是蘑菇，数据库需要扩大（对应的算法代码也要调整，自己电脑训练不了）问题：其他地方训练好的数据模型，直接拿到本地用也可以吗？？</p>\n","categories":["项目"]},{"title":"软件配置","url":"/2023/06/04/%E8%BD%AF%E4%BB%B6%E9%85%8D%E7%BD%AE/","content":"<h1 id=\"Google\"><a href=\"#Google\" class=\"headerlink\" title=\"Google\"></a>Google</h1><h2 id=\"无法登录的问题\"><a href=\"#无法登录的问题\" class=\"headerlink\" title=\"无法登录的问题\"></a>无法登录的问题</h2><p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/image-20230525165941548.png\" alt=\"img\"></p>\n<span id=\"more\"></span>\n\n<h1 id=\"GitHub\"><a href=\"#GitHub\" class=\"headerlink\" title=\"GitHub\"></a>GitHub</h1><h2 id=\"怎样删除Github中的项目\"><a href=\"#怎样删除Github中的项目\" class=\"headerlink\" title=\"怎样删除Github中的项目\"></a>怎样删除Github中的项目</h2><p><a href=\"https://blog.csdn.net/A994958/article/details/118054176\">https://blog.csdn.net/A994958/article/details/118054176</a></p>\n<h1 id=\"电脑\"><a href=\"#电脑\" class=\"headerlink\" title=\"电脑\"></a>电脑</h1><h2 id=\"电脑管家桌面整理不错\"><a href=\"#电脑管家桌面整理不错\" class=\"headerlink\" title=\"电脑管家桌面整理不错\"></a>电脑管家桌面整理不错</h2><h2 id=\"快捷键\"><a href=\"#快捷键\" class=\"headerlink\" title=\"快捷键\"></a>快捷键</h2><p>ctrl + shift +F 切换繁体</p>\n<h1 id=\"typora\"><a href=\"#typora\" class=\"headerlink\" title=\"typora\"></a>typora</h1><h2 id=\"快捷键-1\"><a href=\"#快捷键-1\" class=\"headerlink\" title=\"快捷键\"></a>快捷键</h2><p>F11全屏</p>\n<h2 id=\"1、解决Typora笔记在另一台电脑上无法显示图片的问题\"><a href=\"#1、解决Typora笔记在另一台电脑上无法显示图片的问题\" class=\"headerlink\" title=\"1、解决Typora笔记在另一台电脑上无法显示图片的问题\"></a>1、解决Typora笔记在另一台电脑上无法显示图片的问题</h2><p>1.Typora里面，文件-&gt;偏好设置-&gt;图像，按照下图进行设置</p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/202306022219730.png\" alt=\"img\"></p>\n<p>2.然后随便找一个地方（别c盘）新建文件夹，文件夹里面有个.assets的文件夹，同级放md文件，.assets放图片的</p>\n<p>3.如果出现无法显示问题，使用全局替换</p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/202306022222190.png\" alt=\"img\"></p>\n<h2 id=\"2、高亮设置\"><a href=\"#2、高亮设置\" class=\"headerlink\" title=\"2、高亮设置\"></a>2、高亮设置</h2><p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/202306022222235.png\" alt=\"img\"></p>\n<p>注意缩进</p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/202306022223098.png\" alt=\"img\"></p>\n<p>我实验室电脑q必须大写不知为何</p>\n<h2 id=\"3、外链图片不显示\"><a href=\"#3、外链图片不显示\" class=\"headerlink\" title=\"3、外链图片不显示\"></a>3、外链图片不显示</h2><p>需要挂上vpn</p>\n<p>同样的还要Onedrive</p>\n<h1 id=\"word\"><a href=\"#word\" class=\"headerlink\" title=\"word\"></a>word</h1><h2 id=\"去掉非页眉线\"><a href=\"#去掉非页眉线\" class=\"headerlink\" title=\"去掉非页眉线\"></a><strong>去掉非页眉线</strong></h2><p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/202306022223619.png\" alt=\"img\"></p>\n<h2 id=\"去掉页眉线\"><a href=\"#去掉页眉线\" class=\"headerlink\" title=\"去掉页眉线\"></a><strong>去掉页眉线</strong></h2><p>双击 删除页眉</p>\n<h2 id=\"公式加标号\"><a href=\"#公式加标号\" class=\"headerlink\" title=\"公式加标号\"></a><strong>公式加标号</strong></h2><p>后面加#（序号数）然后回车</p>\n<h2 id=\"在word中如何将两张图片合在一起\"><a href=\"#在word中如何将两张图片合在一起\" class=\"headerlink\" title=\"在word中如何将两张图片合在一起\"></a><strong>在word中如何将两张图片合在一起</strong></h2><ul>\n<li>1、首先在第一张图片上【右键】-【设置图片格式】-【版式】-【衬于文字下方】-【确定】；然后在第二张照片中执行同样的操作；</li>\n<li>2、然后选取图片，点第一张图片，按住键盘的【ctrl】键，然后点击第二张图片，松开【ctrl】键 ；（全选操作）</li>\n<li>3、然后在照片上点击【右键】-【组合】。</li>\n<li>4、然后截图</li>\n</ul>\n<h2 id=\"word插入图片不显示\"><a href=\"#word插入图片不显示\" class=\"headerlink\" title=\"word插入图片不显示\"></a><strong>word插入图片不显示</strong></h2><p>段落单倍行距word段落最后一行字体间距太大的</p>\n<p>解决方法 ：第一种可能性是此段落的末尾缺少一个“回车符”，可以直接将光标定位在段落末尾，点击键盘“Enter”键即可。</p>\n<p>word-视图-单页多页</p>\n<p>doc文件不能用公式</p>\n<p><strong>页码：</strong>下一页–插入页码从1开始（设置页码格式）–设置页码格式底部–链接去掉–删前面页的页码目录–需要设置几级标题</p>\n<h2 id=\"word上有一条横线怎么删除\"><a href=\"#word上有一条横线怎么删除\" class=\"headerlink\" title=\"word上有一条横线怎么删除\"></a><strong>word上有一条横线怎么删除</strong></h2><p>—–&gt;取消格式</p>\n<p>word的帮助很有用00:36</p>\n<p><a href=\"http://www.baidu.com/link?url=mTUjo51DkMxoZAtBDlmboPMp3j2g9_ODKyGXIFPBwkf9mXGOKCj-2ESAFQYiULjYv9q9NVvCpnRNlOj2l6gd3NIGwSR4PIf28ROAcaMRfN_\">如何</a><a href=\"http://www.baidu.com/link?url=mTUjo51DkMxoZAtBDlmboPMp3j2g9_ODKyGXIFPBwkf9mXGOKCj-2ESAFQYiULjYv9q9NVvCpnRNlOj2l6gd3NIGwSR4PIf28ROAcaMRfN_\">删除Word</a><a href=\"http://www.baidu.com/link?url=mTUjo51DkMxoZAtBDlmboPMp3j2g9_ODKyGXIFPBwkf9mXGOKCj-2ESAFQYiULjYv9q9NVvCpnRNlOj2l6gd3NIGwSR4PIf28ROAcaMRfN_\">的</a><a href=\"http://www.baidu.com/link?url=mTUjo51DkMxoZAtBDlmboPMp3j2g9_ODKyGXIFPBwkf9mXGOKCj-2ESAFQYiULjYv9q9NVvCpnRNlOj2l6gd3NIGwSR4PIf28ROAcaMRfN_\">分隔符</a><a href=\"http://www.baidu.com/link?url=mTUjo51DkMxoZAtBDlmboPMp3j2g9_ODKyGXIFPBwkf9mXGOKCj-2ESAFQYiULjYv9q9NVvCpnRNlOj2l6gd3NIGwSR4PIf28ROAcaMRfN_\">？</a>1.打开需要处理的文档，在菜单栏中点击“文件”，在下方找到“选项”。2.在弹出的“选项”对话框中，切换到“显示”选项卡，勾选“显示所有格式标记”。3.这样就能看到分节符了，选中分节符，按下“Delete键”就可以删除了。</p>\n<h2 id=\"为什么word行距设为固定值，但行距看起来不一样\"><a href=\"#为什么word行距设为固定值，但行距看起来不一样\" class=\"headerlink\" title=\"为什么word行距设为固定值，但行距看起来不一样?\"></a><strong>为什么word行距设为固定值，但行距看起来不一样?</strong></h2><p>网格线取消掉</p>\n<p>ppt取消所有动画效果:<a href=\"https://zhidao.baidu.com/question/1672468635987877707.html%E5%8A%A8%E7%94%BB-&gt;%E5%8A%A8%E7%94%BB%E7%AA%97%E6%A0%BC\">https://zhidao.baidu.com/question/1672468635987877707.html动画-&gt;动画窗格</a></p>\n<h1 id=\"Ubuntu\"><a href=\"#Ubuntu\" class=\"headerlink\" title=\"Ubuntu\"></a>Ubuntu</h1><p>安装的时候记得版本问题 window默认安装的2.0 要么升级</p>\n<h1 id=\"DEEPL\"><a href=\"#DEEPL\" class=\"headerlink\" title=\"DEEPL\"></a>DEEPL</h1><p>问题描述：使用DeepL翻译出来的文档是只读模式，显示不订阅pro版本之前都是不能编辑。</p>\n<p>解决方法：将文档另存为.xml文档，然后右键用记事本打开，CTRL+F查找：w:documentProtection,，找到之后删除这一段完整标签&lt;，保存，之后修改文档后缀名为.doc，打开之后发现文档已经可以编辑了。</p>\n<h1 id=\"python\"><a href=\"#python\" class=\"headerlink\" title=\"python\"></a>python</h1><h2 id=\"环境变量\"><a href=\"#环境变量\" class=\"headerlink\" title=\"环境变量\"></a>环境变量</h2><p><strong>Anaconda安装路径</strong></p>\n<p><strong>Anaconda安装路径</strong>\\Scripts</p>\n<p><strong>Anaconda安装路径</strong>\\Library\\bin</p>\n<h1 id=\"mysql\"><a href=\"#mysql\" class=\"headerlink\" title=\"mysql\"></a>mysql</h1><p>免安装mysql教程:<a href=\"https://www.jb51.net/article/168321.htm%E7%99%BB%E5%BD%95mysql%E5%90%8E%EF%BC%8C%E4%BF%AE%E6%94%B9%E5%AF%86%E7%A0%81%EF%BC%88%E9%BB%98%E8%AE%A4%E5%AF%86%E7%A0%81%E4%B8%BA%E7%A9%BA%EF%BC%89\">https://www.jb51.net/article/168321.htm登录mysql后，修改密码（默认密码为空）</a></p>\n<p>原文链接：<a href=\"https://blog.csdn.net/dz77dz/article/details/117705850\">https://blog.csdn.net/dz77dz/article/details/117705850</a></p>\n<pre><code class=\"plain\">（1）以管理员身份打开“命令行窗口”，输入mysql -uroot -p并按下回车键\n（2）在弹出Enter password: 时，继续按下回车键，即可登录mysql\n（3）输入命令use mysql;\n（4）输入命令ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED WITH mysql_native_password BY &#39;123456&#39;; （注意末尾要有分号）\n（5）输入命令flush privileges;\n（6）输入命令exit;——————————————-原文链接：https://blog.csdn.net/dz77dz/article/details/117705850\n</code></pre>\n<p>linux安装的话有一些不一样</p>\n<pre><code class=\"plain\">mysql&gt; set global validate_password_policy=low;             //将密码级别改为弱\nmysql&gt; set global validate_password_length=6;               //将密码长度改为6\n\n/*\n    执行完之后,我们可以将刚才设置的混合密码\n    改为自己想要的数字密码或英文密码了\n*/\nmysql&gt; alter user  &#39;用户名&#39;@&#39;localhost&#39; identified by &#39;123456&#39;; //改密码方式一\nmysql&gt; alter user  USER()  identified by &#39;123456&#39;;              //改密码方式二\n</code></pre>\n<p><strong>mysq|安装出现应用程序无法正常启动(oxc000007b)的解决方案</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/202306022224373.png\" alt=\"img\"></p>\n<p>参考文章及软件下载链接<a href=\"https://blog.csdn.net/vbcom/article/details/7245186\">https://blog.csdn.net/vbcom/article/details/7245186</a></p>\n<p><a href=\"https://blog.csdn.net/qq_46093574/article/details/120351228\">https://blog.csdn.net/qq_46093574/article/details/120351228</a></p>\n<p>原因缺少C++库——成功！</p>\n<p><strong>navicate如何把sql文件导出?</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/202306022224428.png\" alt=\"img\"></p>\n<p><strong>navicat怎么导入sql数据库文件</strong></p>\n<ol>\n<li>打开Navicat，并连接数据库</li>\n<li>鼠标右键“localhost”，点击“新建数据库”。</li>\n<li>输入数据库名称，字符集选择“utf8”，排序规则选择“ utf8 general ci”，点击“确定”。</li>\n<li>双击新建好的“数据库”。右键点击“运行SQL文件”。</li>\n<li>导入SQL文件，点击开始。</li>\n<li>右击表点刷新。</li>\n</ol>\n<h2 id=\"1、navicat安装\"><a href=\"#1、navicat安装\" class=\"headerlink\" title=\"1、navicat安装\"></a>1、navicat安装</h2><p><a href=\"https://zhuanlan.zhihu.com/p/445988662\">https://zhuanlan.zhihu.com/p/445988662</a></p>\n<h1 id=\"nginx安装\"><a href=\"#nginx安装\" class=\"headerlink\" title=\"nginx安装\"></a>nginx安装</h1><p>参考文章：</p>\n<p><a href=\"https://blog.csdn.net/qq1198768105/article/details/122952639\">https://blog.csdn.net/qq1198768105/article/details/122952639</a></p>\n<p><a href=\"https://blog.csdn.net/roy8666/article/details/124504994\">https://blog.csdn.net/roy8666/article/details/124504994</a></p>\n<pre><code class=\"plain\">进入目录\ncd /usr/local\n新建nginx文件夹\nmkdir nginx\n进入Nginx\ncd /usr/local/nginx\n安装\n wget http://nginx.org/download/nginx-1.19.0.tar.gz\n解压\ntar -xvf nginx-1.19.0.tar.gz\n进入文件\ncd /nginx-1.10.2\n安装依赖\nyum -y install gcc zlib zlib-devel pcre-devel openssl openssl-devel\n添加模块\n./configure --with-http_stub_status_module --with-http_ssl_module\n//执行make命令\nmake\n//执行make install命令\nmake install\n后面一大堆不知道有没有用，先不写了吧\n……………………\n启动Nginx\n./nginx\n报端口占用错误\n**Nginx [emerg]: bind() to 0.0.0.0:80 failed (98: Address already in use)**\n干掉此程序\nsudo fuser -k 80/tcp\nfuser -k 80/tcp\n</code></pre>\n<p>正向：客户端到服务器；反向：服务器到客户端；</p>\n<p>正向代理：帮助客户端访问服务器；反向代理：帮助服务器提供服务；</p>\n<h1 id=\"vue项目创建\"><a href=\"#vue项目创建\" class=\"headerlink\" title=\"vue项目创建\"></a>vue项目创建</h1><h2 id=\"1、安装node-js\"><a href=\"#1、安装node-js\" class=\"headerlink\" title=\"1、安装node.js\"></a>1、安装node.js</h2><p><a href=\"https://blog.csdn.net/qq_57210034/article/details/124823972\">https://blog.csdn.net/qq_57210034/article/details/124823972</a></p>\n<p>官网安装16版本，在nodejs<a href=\"https://so.csdn.net/so/search?q=%E6%A0%B9%E7%9B%AE%E5%BD%95&spm=1001.2101.3001.7020\">根目录</a>,创建node_global，node_cache文件夹</p>\n<p>然后以-管理员身份- 打开cmd，配置路径：</p>\n<p>（步骤：win——输入框——cmd——右键——以管理员身份运行）</p>\n<pre><code class=\"plain\">npm config set prefix &quot;D:\\Program Files\\nodejs\\node_global&quot;\nnpm config set cache &quot;D:\\Program Files\\nodejs\\node_cache&quot;\n</code></pre>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/202306022225120.png\" alt=\"img\"> npm config set registry <a href=\"http://registry.npm.taobao.org/\">http://registry.npm.taobao.org/</a> 第一个命令是使用npm的淘宝镜像， npm config set sass_binary_site <a href=\"https://npm.taobao.org/mirrors/node-sass/\">https://npm.taobao.org/mirrors/node-sass/</a> 配置node-sass为淘宝镜像 cnpm install -g @tarojs&#x2F;cli 使用cnpm全局安装taro，将会生成一个taro 命令。taro-cli 包位于 Taro 工程的 packages 目录下，主要负责项目初始化、编译、构建等 查看taro是否安装完毕 taro -V</p>\n<p>安装vue脚手架，我也不知道怎么安装好的，最开始安装低版本的Node安装没问题，后来升级node之后，根据系统提示更新了cli，结果失败，一直没安装上，解决方法：按照如下文章，试试？然后卸载再安装，成功了！</p>\n<p><a href=\"https://blog.csdn.net/qq_43762239/article/details/120333879\">https://blog.csdn.net/qq_43762239/article/details/120333879</a></p>\n<pre><code class=\"plain\">npm install -g vue-cli\nnpm uninstall -g vue-cli\n</code></pre>\n<p>问题：最新版npm : 无法将“npm”项识别为 cmdlet、函数、脚本文件或可运行程序的名称。请检查</p>\n<p>vscode用管理员打开</p>\n<p>问题：npm ERR! missing script: dev</p>\n<p>npm install</p>\n<h1 id=\"java\"><a href=\"#java\" class=\"headerlink\" title=\"java\"></a>java</h1><h2 id=\"java环境配置\"><a href=\"#java环境配置\" class=\"headerlink\" title=\"java环境配置\"></a>java环境配置</h2><p>系统变量里面双击path，新建，浏览目录，找到自己jdk的安装路径下面的bin</p>\n<p>C:\\Program Files\\Java\\jdk1.8.0_231\\bin    &#x2F;&#x2F;举例</p>\n<p>再把配的环境放到移动到最上面</p>\n<p>然后使用cmd用java -version进行验证（必须version，v的话识别不到）</p>\n<h2 id=\"idea配置jdk\"><a href=\"#idea配置jdk\" class=\"headerlink\" title=\"idea配置jdk\"></a>idea配置jdk</h2><p>选中对应jdk即可  bin的上一级目录</p>\n<p>如果出现没有编译输出文件夹 那就新建一个 基本环境就好啦</p>\n<h1 id=\"maven\"><a href=\"#maven\" class=\"headerlink\" title=\"maven\"></a>maven</h1><p><a href=\"https://blog.csdn.net/l32273/article/details/123684435\">https://blog.csdn.net/l32273/article/details/123684435</a></p>\n<p>右侧边栏没有出现maven, 还有一种可能就是pom.xml文件没有识别, idea觉得这个项目就不是个maven项目，导致idea无法加载依赖包。因此上述三种方法都没有用， 解决办法: 右键pom.xml文件, 点击” add as maven project “</p>\n<p><strong>idea配置maven依赖下载路径（否则下载从中央仓库，白配了）</strong></p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/202306022225425.png\" alt=\"img\"></p>\n<h1 id=\"idea\"><a href=\"#idea\" class=\"headerlink\" title=\"idea\"></a>idea</h1><h2 id=\"translation插件\"><a href=\"#translation插件\" class=\"headerlink\" title=\"translation插件\"></a>translation插件</h2><p><a href=\"https://blog.csdn.net/Lin_1214/article/details/120323971\">https://blog.csdn.net/Lin_1214/article/details/120323971</a></p>\n<p>抽取方法快捷键</p>\n<p>ctrl+alt+m</p>\n<h2 id=\"Codelf\"><a href=\"#Codelf\" class=\"headerlink\" title=\"Codelf\"></a>Codelf</h2><p>变量命名神器</p>\n<p><a href=\"https://unbug.github.io/codelf/\">https://unbug.github.io/codelf/</a></p>\n<h1 id=\"Git\"><a href=\"#Git\" class=\"headerlink\" title=\"Git\"></a>Git</h1><h2 id=\"git安装\"><a href=\"#git安装\" class=\"headerlink\" title=\"git安装\"></a>git安装</h2><p>安装后配置下名字邮箱就行了</p>\n<h2 id=\"配置SSH\"><a href=\"#配置SSH\" class=\"headerlink\" title=\"配置SSH\"></a>配置SSH</h2><p>为了能上传到Github</p>\n<h2 id=\"项目上传到github\"><a href=\"#项目上传到github\" class=\"headerlink\" title=\"项目上传到github\"></a>项目上传到github</h2><p>b站视频</p>\n<p><a href=\"https://www.bilibili.com/video/BV1V54y1n7Wn/?spm_id_from=333.337.search-card.all.click&amp;vd_source=ef87b66d94d47349af5013c20ac7b73d\">https://www.bilibili.com/video/BV1V54y1n7Wn/?spm_id_from=333.337.search-card.all.click&amp;vd_source=ef87b66d94d47349af5013c20ac7b73d</a></p>\n<p>新建一个repository</p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/202306022225686.png\" alt=\"img\"></p>\n<p>按照安装命令进行操作，切换到对应项目路径，git add那里改成git add .</p>\n<p>不想上传的可以 gitignore</p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/202306022226550.png\" alt=\"img\"></p>\n<p>echo “# blog-project” &gt;&gt; README.md 这个可以不写 意思是追加到read.me上 建议自己建一个readme写内容</p>\n<p>如果要修改项目再上传 add commit push就行</p>\n<h2 id=\"实操\"><a href=\"#实操\" class=\"headerlink\" title=\"实操\"></a>实操</h2><h3 id=\"上传到一个新仓库\"><a href=\"#上传到一个新仓库\" class=\"headerlink\" title=\"上传到一个新仓库\"></a>上传到一个新仓库</h3><p>先github创一个仓库 respositorty</p>\n<p>在本地文件里面打开git bash 然后执行下面的命令</p>\n<pre><code class=\"plain\">echo &quot;# dqwd&quot; &gt;&gt; README.md  #创建readme文件\ngit init\ngit add .\ngit commit -m &quot;first commit&quot;\ngit branch -M main  //好像是和git checkout -b一样\n#直接复制新建仓库的地址\ngit remote add origin git@github.com:ResetDing/dqwd.git\ngit push -u origin main\n</code></pre>\n<h3 id=\"把新文件上传到已有仓库\"><a href=\"#把新文件上传到已有仓库\" class=\"headerlink\" title=\"把新文件上传到已有仓库\"></a>把新文件上传到已有仓库</h3><pre><code class=\"plain\">//master分支上\ngit init\ngit remote add origin git@github.com:ResetDing/test.git#直接github里面code下面ssh复制地址\ngit add .\ngit commit -m &quot;first commit&quot;\n//获取github的分支\ngit fetch\n//切换到远程你想切换的那个分支:（比如我想切换的是main分支为例 其他的你可以origin/XXX）\ngit checkout remotes/origin/main\n现在可以看到自己的分支是一串数字字母\n这时新建并切换到你想看的那个分支\ngit checkout main\n将master分支合并到main分支上\ngit merge master --allow-unrelated-histories\n//推送\ngit push -u origin main\n</code></pre>\n<h3 id=\"其他命令\"><a href=\"#其他命令\" class=\"headerlink\" title=\"其他命令\"></a>其他命令</h3><pre><code class=\"plain\">//新键分支并切换\ngit checkout -b\n</code></pre>\n<h1 id=\"idea-1\"><a href=\"#idea-1\" class=\"headerlink\" title=\"idea\"></a>idea</h1><p>新建一个idea页面 maven配置居然会变</p>\n<h1 id=\"python办公操作\"><a href=\"#python办公操作\" class=\"headerlink\" title=\"python办公操作\"></a>python办公操作</h1><h2 id=\"需求：csdn文章-gt-pdf\"><a href=\"#需求：csdn文章-gt-pdf\" class=\"headerlink\" title=\"需求：csdn文章-&gt;pdf\"></a>需求：csdn文章-&gt;pdf</h2><ul>\n<li>1 <strong>csdn文章转为markdown文件</strong></li>\n</ul>\n<p>具体操作见我的github</p>\n<p><a href=\"https://github.com/viacheung/csdn_article-to-markdown\">https://github.com/viacheung/csdn_article-to-markdown</a></p>\n<ul>\n<li>2 批量改名文件名（根据某一信息截断）</li>\n</ul>\n<p>所有文件都有juc三个字母 我只想要juc后面的信息作为我的文件名 </p>\n<p>也就是：XXXXjucXXX -&gt; jucXXX</p>\n<p>具体代码操作如下：</p>\n<pre><code class=\"plain\">import os\nimport re\n# 文件路径\nfilesDir = &quot;D:\\Desktop\\csdn-is---mark-down-master\\_posts&quot;\nfileNameList = os.listdir(filesDir)\nfor filename in fileNameList:\n    (name, suffix) = filename.split(&#39;Juc&#39;)\n    print(&quot;开始改名。。。&quot;)\n    newFilename = suffix\n    os.rename(os.path.join(filesDir, filename), os.path.join(filesDir, newFilename))\n    print(&quot;改名完毕！&quot;)\n    print(&quot;======================================================================================&quot;)\n</code></pre>\n<ul>\n<li>3 合并markdown为一个文件</li>\n</ul>\n<p>windows打开对应文件命令行 执行</p>\n<p>type *.markdown &gt; res.md</p>\n<p>参考 <a href=\"https://blog.csdn.net/qq_42532128/article/details/119411991\">https://blog.csdn.net/qq_42532128/article/details/119411991</a></p>\n<ul>\n<li>4 最后typora直接导出Pdf即可</li>\n</ul>\n<h1 id=\"finalshell\"><a href=\"#finalshell\" class=\"headerlink\" title=\"finalshell\"></a>finalshell</h1><h3 id=\"第一次连接时\"><a href=\"#第一次连接时\" class=\"headerlink\" title=\"第一次连接时\"></a>第一次连接时</h3><p><a href=\"https://blog.csdn.net/qq_44701472/article/details/107063368\">https://blog.csdn.net/qq_44701472/article/details/107063368</a></p>\n<p>先创建再连接 不要在之前的连接基础上改Ip</p>\n<h3 id=\"撤销代码运行\"><a href=\"#撤销代码运行\" class=\"headerlink\" title=\"撤销代码运行\"></a>撤销代码运行</h3><p>ctrl z</p>\n<h1 id=\"chatGbt配置\"><a href=\"#chatGbt配置\" class=\"headerlink\" title=\"chatGbt配置\"></a><strong>chatGbt配置</strong></h1><p><a href=\"https://new.oneok.store/#shop\">https://new.oneok.store/#shop</a></p>\n<p>直接付款 然后有个密钥 </p>\n<p>账号密码如下 直接进chargbt登录</p>\n<p><a href=\"mailto:nmvdjttwre@outlook.com\">nmvdjttwre@outlook.com</a>ZrS91VQL</p>\n<h1 id=\"zym梯子\"><a href=\"#zym梯子\" class=\"headerlink\" title=\"zym梯子\"></a>zym梯子</h1><p><a href=\"https://sockboom.tv/\">https://sockboom.tv</a></p>\n<p>基于这个教程完成</p>\n<h1 id=\"图床教程\"><a href=\"#图床教程\" class=\"headerlink\" title=\"图床教程\"></a>图床教程</h1><p><a href=\"https://blog.csdn.net/weixin_45260582/article/details/129152892\">https://blog.csdn.net/weixin_45260582/article/details/129152892</a></p>\n<p>中间的DSN加速可以不用管</p>\n<p>token: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</p>\n<h2 id=\"1-下载PicGo\"><a href=\"#1-下载PicGo\" class=\"headerlink\" title=\"1. 下载PicGo\"></a>1. 下载PicGo</h2><p>地址：<a href=\"https://github.com/Molunerfinn/PicGo/releases\">Molunerfinn&#x2F;PicGo</a>，往下滑（见下图），正常安装即可。</p>\n<p>setup-版本-x64.exe</p>\n<h2 id=\"2-GitHub步骤\"><a href=\"#2-GitHub步骤\" class=\"headerlink\" title=\"2. GitHub步骤\"></a>2. GitHub步骤</h2><ul>\n<li><strong>新建仓库</strong></li>\n</ul>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/95dcb922b85fb32f0a12d33fb143cbe3.png\" alt=\"img\"></p>\n<ul>\n<li><strong>填写相关信息</strong></li>\n</ul>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/33e060985e818ed68a0621337dde00b5.png\" alt=\"img\"></p>\n<ul>\n<li><strong>进入个人设置</strong></li>\n</ul>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/4b83e4a4f9d70275cd80d29a4793e202.png\" alt=\"img\"></p>\n<ul>\n<li><strong>选择开发者设置</strong><img src=\"https://cdn.nlark.com/yuque/0/2023/png/226907/1685716728321-f466943f-1891-4af2-9285-cdd7fb6c2b75.png\" alt=\"img\"></li>\n</ul>\n<hr>\n<ul>\n<li><strong>选择个人访问token，创建新的token</strong><img src=\"https://cdn.nlark.com/yuque/0/2023/png/226907/1685716728720-6fbe7ebc-2326-4544-b6a6-7375199ccac4.png\" alt=\"img\"></li>\n</ul>\n<hr>\n<ul>\n<li><strong>填写相关信息</strong><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/dfe94e7fe0e6aa0081651f80ebdeb0ee.png\" alt=\"img\"></li>\n</ul>\n<hr>\n<ul>\n<li><strong>复制密钥保存好</strong><img src=\"https://cdn.nlark.com/yuque/0/2023/png/226907/1685716728349-886006ff-3af9-4ac0-b214-6b526e0d1336.png\" alt=\"img\"></li>\n</ul>\n<h2 id=\"3-PicGo配置GitHub图床\"><a href=\"#3-PicGo配置GitHub图床\" class=\"headerlink\" title=\"3. PicGo配置GitHub图床\"></a>3. PicGo配置GitHub图床</h2><p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/56a6915b1968aaa30eff070b2e49994d.png\" alt=\"img\"></p>\n<h2 id=\"4-Typora配置PicGo\"><a href=\"#4-Typora配置PicGo\" class=\"headerlink\" title=\"4. Typora配置PicGo\"></a>4. Typora配置PicGo</h2><ul>\n<li><strong>进入偏好设置</strong><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/02c3e8b1eb022b19121ee9eb94e54fc3.png\" alt=\"img\"></li>\n</ul>\n<hr>\n<ul>\n<li><strong>选择图像配置PicGo</strong><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/82b020ba4d6d79376ba8f22ca21f14d7.png\" alt=\"img\"></li>\n</ul>\n<h2 id=\"5-验证成功\"><a href=\"#5-验证成功\" class=\"headerlink\" title=\"5. 验证成功\"></a>5. 验证成功</h2><p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/2a536172bbc202cc1f1885491b090a34.png\" alt=\"img\"></p>\n<h2 id=\"遇到问题\"><a href=\"#遇到问题\" class=\"headerlink\" title=\"遇到问题\"></a>遇到问题</h2><p>2021-08-17 19:29:25 [PicGo ERROR] ——Error Stack Begin—— StatusCodeError: 401 - {“message”:”Bad credentials”,”documentation_url”:”<a href=\"https://docs.github.com/rest&quot;%7D\">https://docs.github.com/rest&quot;}</a> at new StatusCodeError (D:\\PicGo\\resources\\app.asar\\node_modules\\request-promise-core\\lib\\errors.js:32:15) at Request.plumbing.callback (D:\\PicGo\\resources\\app.asar\\node_modules\\request-promise-core\\lib\\plumbing.js:104:33) at Request.RP$callback [as _callback] (D:\\PicGo\\resources\\app.asar\\node_modules\\request-promise-core\\lib\\plumbing.js:46:31) at Request.self.callback (D:\\PicGo\\resources\\app.asar\\node_modules\\request\\request.js:185:22) at Request.emit (events.js:200:13) at Request.<anonymous> (D:\\PicGo\\resources\\app.asar\\node_modules\\request\\request.js:1161:10) at Request.emit (events.js:200:13) at IncomingMessage.<anonymous> (D:\\PicGo\\resources\\app.asar\\node_modules\\request\\request.js:1083:12) at Object.onceWrapper (events.js:288:20) at IncomingMessage.emit (events.js:205:15) ——-Error Stack End——-</anonymous></anonymous></p>\n<p>解决：生成新token</p>\n<h1 id=\"linux\"><a href=\"#linux\" class=\"headerlink\" title=\"linux\"></a>linux</h1><h2 id=\"查找端口号8080占用情况\"><a href=\"#查找端口号8080占用情况\" class=\"headerlink\" title=\"查找端口号8080占用情况\"></a><strong>查找端口号8080占用情况</strong></h2><p>C:\\Users\\viacheung&gt;tasklist|findstr “8080“</p>\n<p>C:\\Users\\viacheung&gt;netstat -aon|findstr “8080” </p>\n<p>TCP 0.0.0.0:8080 0.0.0.0:0 LISTENING 14400 </p>\n<p>TCP 172.27.31.33:53144 157.255.192.102:8080 ESTABLISHED 20996 </p>\n<p>TCP [::]:8080 [::]:0 LISTENING 14400</p>\n<p><strong>找对应进程</strong></p>\n<p>C:\\Users\\viacheung&gt;tasklist|findstr “14400”</p>\n<p>java.exe 14400 Console 1 176,948 K</p>\n<p><strong>终止进程</strong></p>\n<p>C:\\Users\\viacheung&gt;taskkill &#x2F;f &#x2F;t &#x2F;im java.exe</p>\n<p>成功: 已终止 PID 18984 (属于 PID 14400 子进程)的进程。</p>\n<p>成功: 已终止 PID 14400 (属于 PID 30536 子进程)的进程。C:\\Users\\viacheung&gt;改设备时间是个好方法 删库的东西是个好东西</p>\n<h2 id=\"查找本机Ip地址\"><a href=\"#查找本机Ip地址\" class=\"headerlink\" title=\"查找本机Ip地址\"></a>查找本机Ip地址</h2><p>cmd输入ipconfig</p>\n<p>192.168.10.106</p>\n<h1 id=\"快捷键-2\"><a href=\"#快捷键-2\" class=\"headerlink\" title=\"快捷键\"></a>快捷键</h1><p>Ctrl+Tab 同一页面切换Alt+Tab 不同页面切换</p>\n<p>win+mspaint表示画图远程桌面连接-输入想连计算机端口号，再输入电脑账户密码即可连接win+s 打开搜索框Shutdown -s -t 3000定时关机快捷键：<a href=\"https://jingyan.baidu.com/article/6c67b1d6c533056787bb1ea7.html\">https://jingyan.baidu.com/article/6c67b1d6c533056787bb1ea7.html</a></p>\n<p>F11 全屏</p>\n<p>搜索计算器-&gt;程序员选项</p>\n<h1 id=\"matlab\"><a href=\"#matlab\" class=\"headerlink\" title=\"matlab\"></a>matlab</h1><pre><code class=\"plain\">矩阵分点乘\n先plot 后label什么的\n文件名不能和函数名重复\n主页-布局调整\n</code></pre>\n<h2 id=\"删文件\"><a href=\"#删文件\" class=\"headerlink\" title=\"删文件\"></a>删文件</h2><p>双击安装包删除 program Files x86programData里面也要删去文件夹NIMBUSROM字体不错啊</p>\n<p>vscode添加库：ctrl+&#96;调出终端，然后pip install 库名修改系统时间会导致打不开某些网页</p>\n<p>360网络修复很牛逼</p>\n<p>jdk版本免安装在系统变量里改%JAVA_HOME%文件路径即可idea打不开,双击没反应的解决方案—因为有中文路径git vi编辑器，进入后按i编辑，在esc，然后冒号，sq退出</p>\n<h1 id=\"前端\"><a href=\"#前端\" class=\"headerlink\" title=\"前端\"></a><strong>前端</strong></h1><p>在老的HTML版本，如果需要在HTML页面中声明一段js脚本，需要做<script type=\"text/javascript\">的声明，表明在</p>\n<script type=\"text/javascript\"></script>\n\n</p><p>中添加的文本是js脚本；document.form.action,表单分向提交,javascript提交表单同一个表单可以根据用户的选择，提交给不同的后台处理程序。即，表单的分向提交。如，在编写论坛程序时，如果我们希望实现用户在发送贴子的时候，既发送提交功能又有预览功能时，就会遇到上述问题。即，当用户点击提交按钮时，我们希望表单提交给\"提交\"处理程序；而当用户点击预览按钮时，我们希望表单提交给\"预览\"处理程序。那么，如何实现上述功能呢？下面代码可以很好的解决这个问题。</p>\n<p>confirm()方法用于显示一个带有指定消息和确认及取消按钮的对话框。如果访问者点击\"确定\"，此方法返回true，否则返回false</p>\n<p>getSession()参数为true时，若存在会话，则返回该会话，否则新建一个会话；actionaction规定了提交表单时发送表单数据的目的地,也即将数据发到哪里,例如action=\"login.php\".methodmethod规定了发送方式,常用的为get和post,涉及到用户隐私时,为了安全起见通常都采用post方式.namename表单的名字,如果是在js中想要获取form的dom对象,直接使用name属性值即可,例如</p>\n<!-- 和都 <%-- 表示注释getId() 方法的作用非常简单，就是取得正在运行线程的唯一标识。hidden隐藏域在页面中对于用户是不可见的，在表单插入中隐藏域的目的在于收集和发送信息，以利于被处理表单的程序所使用注：隐藏只是在网页页面上不显示输入框，但是虽然隐藏了，还是具有form传值功能。一般用来传值，而不必让用户看到href 属性规定链接的目标：onclick 事件会在元素被点击时发生。scope:colspan设置当前单元格横跨的列数。col 规定单元格是列的表头。row 规定单元格是行的表头。colgroup 规定单元格是列组的表头。rowgroup 规定单元格是行组的表头。\n\n\n  -->","categories":["教程"]},{"title":"链表","url":"/2023/06/04/%E9%93%BE%E8%A1%A8/","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>常用方法：dummyNode空结点 、双指针、快慢指针<span id=\"more\"></span></p>\n<p>链表好多都可以用递归或者迭代，递归简洁不好想，但迭代好理解</p>\n<p>ListNode是由自己定义的java中的链表对象</p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/image-20220915164549004.png\" alt=\"img\"></p>\n<p>类结构如下</p>\n<pre><code class=\"plain\">public class ListNode &#123;\n        int val;\n        ListNode next;\n        public ListNode(int x) &#123;\n             val = x;\n        &#125;\n &#125;\n</code></pre>\n<h2 id=\"删除链表结点\"><a href=\"#删除链表结点\" class=\"headerlink\" title=\"删除链表结点\"></a>删除链表结点</h2><pre><code class=\"plain\">class Solution &#123;\n     public ListNode removeElements(ListNode head, int val) &#123;\n         ListNode dumyNode=new ListNode();\n         dumyNode.next=head;\n         ListNode cur=dumyNode;\n         while(cur.next!=null)&#123;\n             if(cur.next.val==val)&#123;\n                 cur.next=cur.next.next;\n             &#125;else&#123;\n                 cur=cur.next;\n             &#125;\n         &#125;\n         return dumyNode.next;\n     &#125;\n &#125;\n</code></pre>\n<h2 id=\"删除链表的倒数第-N-个结点\"><a href=\"#删除链表的倒数第-N-个结点\" class=\"headerlink\" title=\"删除链表的倒数第 N 个结点\"></a>删除链表的倒数第 N 个结点</h2><p>给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。</p>\n<p>方法一：一种容易想到的方法是，我们首先从头节点开始对链表进行一次遍历，得到链表的长度 L。随后我们再从头节点开始对链表进行一次遍历，当遍历到第 L−n+1 个节点时，它就是我们需要删除的节点。</p>\n<p>方法二：我们也可以在遍历链表的同时将所有节点依次入栈。根据栈「先进后出」的原则，我们弹出栈的第 n 个节点就是需要删除的节点，并且目前栈顶的节点就是待删除节点的前驱节点。这样一来，删除操作就变得十分方便了。</p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/image-20221015173826107.png\" alt=\"img\"></p>\n<p> ListNode dummy &#x3D; new ListNode(0, head);&#x2F;&#x2F;val为0 下一个结点为head</p>\n<pre><code class=\"plain\">//我喜欢方法三\n class Solution &#123;\n     public ListNode removeNthFromEnd(ListNode head, int n) &#123;\n         // 双指针\n         ListNode dummyNode =new ListNode(0);\n         dummyNode.next=head;\n         //用dummyNode好删除\n         ListNode node1=dummyNode;\n         ListNode node2=dummyNode;\n         //Node1先往后移动n个位置\n         for(int i=0;i&lt;n;i++)&#123;\n              node1=node1.next;\n         &#125;\n         //这俩同时移动 node1.next!=null这个判断条件是为了到最后一个节点 而不是null节点\n         while(node1.next!=null)&#123;\n             node1=node1.next;\n             node2=node2.next;\n         &#125;\n         //删除\n         node2.next=node2.next.next;\n         return dummyNode.next;\n     &#125;\n &#125;\n</code></pre>\n<h2 id=\"两两交换链表中的节点24\"><a href=\"#两两交换链表中的节点24\" class=\"headerlink\" title=\"两两交换链表中的节点24\"></a>两两交换链表中的节点24</h2><p>给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。</p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/image-20221015163411413.png\" alt=\"img\"></p>\n<pre><code class=\"plain\">class Solution &#123;\n     public ListNode swapPairs(ListNode head) &#123;\n         if (head == null || head.next == null) &#123;\n             return head;\n         &#125;\n         ListNode newHead = head.next;\n         head.next = swapPairs(newHead.next);\n         newHead.next = head;\n         return newHead;\n     &#125;\n &#125;\n</code></pre>\n<p>选择迭代！</p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/image-20221015163434779.png\" alt=\"img\"></p>\n<pre><code class=\"plain\">class Solution &#123;\n     public ListNode swapPairs(ListNode head) &#123;\n         ListNode dummyNode=new ListNode(0);\n         dummyNode.next=head;\n         ListNode temp=dummyNode;\n         while(temp.next!=null&amp;&amp;temp.next.next!=null)&#123;\n            //存一下\n             ListNode node1=temp.next;\n             ListNode node2=temp.next.next;\n             //node1指向node2指向的\n             node1.next=node2.next;\n             //temp指向node2\n             temp.next=node2;\n             //node2--&gt;node1\n             node2.next=node1;\n             //移动temp\n             temp=node1;\n         &#125;\n         //返回头结点\n         return dummyNode.next;\n     &#125;\n &#125;\n</code></pre>\n<h2 id=\"移除链表元素203\"><a href=\"#移除链表元素203\" class=\"headerlink\" title=\"移除链表元素203\"></a>移除链表元素203</h2><p>优先迭代</p>\n<p>给你一个链表的头节点 head 和一个整数 val ，请你删除链表中所有满足 Node.val &#x3D;&#x3D; val 的节点，并返回 <strong>新的头节点</strong> 。</p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/image-20221014152913347.png\" alt=\"img\"></p>\n<p>要求返回头节点 最好的方法 用一个dumyNode！！！！</p>\n<pre><code class=\"plain\">class Solution &#123;\n     public ListNode removeElements(ListNode head, int val) &#123;\n         ListNode dumyNode=new ListNode();\n         dumyNode.next=head;\n         ListNode cur=dumyNode;\n         while(cur.next!=null)&#123;\n             if(cur.next.val==val)&#123;\n                 cur.next=cur.next.next;\n             &#125;else&#123;\n                 cur=cur.next;\n             &#125;\n         &#125;\n         return dumyNode.next;\n     &#125;\n &#125;\n</code></pre>\n<p>优先方法二，比较好理解。</p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/image-20221014152957745.png\" alt=\"img\"></p>\n<h2 id=\"设计链表\"><a href=\"#设计链表\" class=\"headerlink\" title=\"设计链表\"></a>设计链表</h2><p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/image-20221014160959772.png\" alt=\"img\"></p>\n<p><strong>单链表</strong></p>\n<pre><code class=\"plain\">class MyLinkedList &#123;\n     //用哨兵节点（值为0）当作头结点(但不是真的头结点)\n     int size;\n     ListNode head;\n     //初始化\n     public MyLinkedList() &#123;\n         size=0;\n         head=new ListNode(0);\n     &#125;\n     \n     public int get(int index) &#123;\n         if(index&lt;0||index&gt;=size)&#123;\n             return -1;\n         &#125;\n         ListNode cur=head;\n         for(int i=0;i&lt;=index;i++)&#123;\n             cur=cur.next;\n         &#125;\n         return cur.val;\n     &#125;\n     //操作某个结点 cur到它前面一个去\n     public void addAtHead(int val) &#123;\n         addAtIndex(0,val);\n     &#125;\n     \n     public void addAtTail(int val) &#123;\n         addAtIndex(size,val);\n     &#125;\n     \n     public void addAtIndex(int index, int val) &#123;\n         if(index&gt;size)&#123;\n             return;\n         &#125;\n         //小于0设为0\n         index=index&lt;0?0:index;\n         ListNode tar=new ListNode(val);\n         ListNode cur=head;\n         for(int i=0;i&lt;index;i++)&#123;\n             cur=cur.next;\n         &#125;\n         tar.next=cur.next;\n         cur.next=tar;\n         size++;\n     &#125;\n     \n     public void deleteAtIndex(int index) &#123;\n         if(index&lt;0||index&gt;=size)&#123;\n             return;\n         &#125;\n         ListNode cur=head;\n         for(int i=0;i&lt;index;i++)&#123;\n             cur=cur.next;\n         &#125;\n         cur.next=cur.next.next;\n         size--;\n     &#125;\n &#125;\n</code></pre>\n<p>双链表就不写辣</p>\n<h2 id=\"回文链表\"><a href=\"#回文链表\" class=\"headerlink\" title=\"回文链表\"></a>回文链表</h2><p><strong>方法一：将值复制到数组中后用双指针法</strong></p>\n<p>一共为两个步骤：</p>\n<ol>\n<li>复制链表值到数组列表中。</li>\n<li>使用双指针法判断是否为回文。node_1.val &#x3D;&#x3D; node_2.val</li>\n</ol>\n<p><strong>方法二：快慢指针</strong></p>\n<ol>\n<li>找到前半部分链表的尾节点。</li>\n<li>根据前半部分分链表尾结点，反转后半部分链表。</li>\n<li>判断是否回文。</li>\n<li>恢复链表（再把步骤二做一次）。</li>\n<li>返回结果。</li>\n</ol>\n<pre><code class=\"plain\">/**\n  * Definition for singly-linked list.\n  * public class ListNode &#123;\n  *     int val;\n  *     ListNode next;\n  *     ListNode() &#123;&#125;\n  *     ListNode(int val) &#123; this.val = val; &#125;\n  *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;\n  * &#125;\n  */\n class Solution &#123;\n     public boolean isPalindrome(ListNode head) &#123;\n         //方法一 辅助数组 双指针\n         // ListNode cur=head;\n         // int len=0;\n         // while(cur!=null)&#123;\n         //     len++;\n         //     cur=cur.next;\n         // &#125;\n         // int[] result=new int[len];\n         // cur=head;\n         // for(int i=0;i&lt;len;i++)&#123;\n         //     result[i]=cur.val;\n         //     cur=cur.next;\n         // &#125;\n         // int l=0,r=len-1;\n         // while(l&lt;r)&#123;\n         //     if(result[l]!=result[r]) return false;\n         //     l++;\n         //     r--;\n         // &#125;\n         // return true;\n         //方法二 快慢指针\n         ListNode slow=head,fast=head,pre=head;\n         while(fast!=null&amp;&amp;fast.next!=null)&#123;\n             pre=slow;\n             slow=slow.next;\n             fast=fast.next.next;\n         &#125;\n         pre.next=null;\n         ListNode node1=head;\n         ListNode node2=reverseList(slow);\n         while(node1!=null)&#123;\n             if(node1.val!=node2.val) return false;\n             node1=node1.next;\n             node2=node2.next;\n         &#125;\n         return true;\n \n     &#125;\n     //反转链表\n     public ListNode reverseList(ListNode head)&#123;\n         ListNode pre=null,temp=null,cur=head;\n         while(cur!=null)&#123;\n             //记录当前节点的下一个节点\n             temp=cur.next;\n             //然后将当前节点指向pre            \n             cur.next=pre;\n             //pre和cur节点都前进一位\n             pre=cur;\n             cur=temp;\n         &#125;\n         return pre;\n     &#125;\n &#125;\n</code></pre>\n<h2 id=\"反转链表\"><a href=\"#反转链表\" class=\"headerlink\" title=\"反转链表\"></a>反转链表</h2><p>最简单的不考虑复杂度的话，利用<strong>外部空间</strong></p>\n<p>先申请一个动态扩容的数组或者容器，比如 ArrayList 这样的。然后不断遍历链表，将链表中的元素添加到这个容器中。再利用容器自身的 API，反转整个容器，这样就达到反转的效果了。最后同时遍历容器和链表，将链表中的值改为容器中的值。因为此时容器的值是：</p>\n<p>5 4 3 2 1</p>\n<p>链表按这个顺序重新被设置一边，就达到要求啦。</p>\n<p><strong>一、迭代</strong>（好理解一点）</p>\n<p>两个指针，cur和pre，pre先指向Null，cur指向head，然后遍历cur，每次迭代到cur，用一个tmp存储cur的下一结点，然后cur的Next指向pre，pre前进一位（pre指向cur，cur指向tmp）</p>\n<p><strong>代码</strong></p>\n<pre><code class=\"plain\">class Solution &#123;\n     public ListNode reverseList(ListNode head) &#123;\n         //申请节点，pre和 cur，pre指向null\n         ListNode pre = null;\n         ListNode cur = head;\n         ListNode tmp = null;\n         while(cur!=null) &#123;\n             //记录当前节点的下一个节点\n             tmp = cur.next;\n             //然后将当前节点指向pre\n             cur.next = pre;\n             //pre和cur节点都前进一位\n             pre = cur;\n             cur = tmp;\n         &#125;\n         return pre;\n     &#125;\n &#125;\n</code></pre>\n<p><strong>二、递归（不好理解）</strong></p>\n<p>递归的两个条件：</p>\n<pre><code class=\"plain\">终止条件是当前节点或者下一个节点==null\n 在函数内部，改变节点的指向，也就是 head 的下一个节点指向 head 递归函数那句\n</code></pre>\n<p>head.next.next &#x3D; head</p>\n<p>很不好理解，其实就是 head 的下一个节点指向head。递归函数中每次返回的 cur 其实只最后一个节点，在递归函数内部，改变的是当前节点的指向。动画演示如下：</p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/dacd1bf55dec5c8b38d0904f26e472e2024fc8bee4ea46e3aa676f340ba1eb9d-%E9%80%92%E5%BD%92.gif\" alt=\"img\"></p>\n<p>我的理解：先一直执行ListNode cur &#x3D; reverseList(head.next)，一直到head为4的时候，if里面成立（head.next&#x3D;&#x3D;null），跳出，此时cur为5，但是是在4这个结点的递归里面，因此head为4，所以head.next.next 就是5-&gt;4；防止链表循环（因为已经形成了一个环了），需要将head.next设置为空，然后返回cur，因为每层递归函数都返回cur。</p>\n<pre><code class=\"plain\">class Solution &#123;\n     public ListNode reverseList(ListNode head) &#123;\n         //递归终止条件是当前为空，或者下一个节点为空\n         if(head==null || head.next==null) &#123;\n             return head;\n         &#125;\n         //这里的cur就是最后一个节点\n         ListNode cur = reverseList(head.next);\n         //这里请配合动画演示理解\n         //如果链表是 1-&gt;2-&gt;3-&gt;4-&gt;5，那么此时的cur就是5\n         //而head是4，head的下一个是5，下下一个是空\n         //所以head.next.next 就是5-&gt;4\n         head.next.next = head;\n         //防止链表循环，需要将head.next设置为空\n         head.next = null;\n         //每层递归函数都返回cur，也就是最后一个节点\n         return cur;\n     &#125;\n &#125;\n</code></pre>\n<h2 id=\"环形链表I\"><a href=\"#环形链表I\" class=\"headerlink\" title=\"环形链表I\"></a>环形链表I</h2><p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/image-20221015175612893.png\" alt=\"img\"></p>\n<p><strong>方法一：哈希表</strong></p>\n<p>最容易想到的方法是遍历所有节点，每次遍历到一个节点时，判断该节点此前是否被访问过。</p>\n<p>具体地，我们可以使用哈希表来存储所有已经访问过的节点。每次我们到达一个节点，如果该节点已经存在于哈希表中，则说明该链表是环形链表，否则就将该节点加入哈希表中。重复这一过程，直到我们遍历完整个链表即可。</p>\n<pre><code class=\"plain\">public class Solution &#123;\n     public boolean hasCycle(ListNode head) &#123;\n         Set&lt;ListNode&gt; seen = new HashSet&lt;ListNode&gt;();\n         while (head != null) &#123;\n             if (!seen.add(head)) &#123;\n                 return true;\n             &#125;\n             head = head.next;\n         &#125;\n         return false;\n     &#125;\n &#125;\n</code></pre>\n<p><strong>方法二：快慢指针</strong>（龟兔赛跑）</p>\n<p>本方法需要读者对「Floyd 判圈算法」（又称龟兔赛跑算法）有所了解。</p>\n<p>假想「乌龟」和「兔子」在链表上移动，「兔子」跑得快，「乌龟」跑得慢。当「乌龟」和「兔子」从链表上的同一个节点开始移动时，如果该链表中没有环，那么「兔子」将一直处于「乌龟」的前方；如果该链表中有环，那么「兔子」会先于「乌龟」进入环，并且一直在环内移动。等到「乌龟」进入环时，由于「兔子」的速度快，它一定会在某个时刻与乌龟相遇，即套了「乌龟」若干圈。</p>\n<p>我们可以根据上述思路来解决本题。具体地，我们定义两个指针，一快一慢。慢指针每次只移动一步，而快指针每次移动两步。初始时，慢指针在位置 head，而快指针在位置 head.next。这样一来，如果在移动的过程中，快指针反过来追上慢指针，就说明该链表为环形链表。否则快指针将到达链表尾部，该链表不为环形链表。</p>\n<p><strong>细节</strong></p>\n<p>为什么我们要规定初始时慢指针在位置 head，快指针在位置 head.next，而不是两个指针都在位置 head（即与「乌龟」和「兔子」中的叙述相同）？</p>\n<p>观察下面的代码，我们使用的是 while 循环，循环条件先于循环体。由于循环条件一定是判断快慢指针是否重合，如果我们将两个指针初始都置于 head，那么 while 循环就不会执行。因此，我们可以假想一个在 head 之前的虚拟节点，慢指针从虚拟节点移动一步到达 head，快指针从虚拟节点移动两步到达 head.next，这样我们就可以使用 while 循环了。</p>\n<p>当然，我们也可以使用 do-while 循环。此时，我们就可以把快慢指针的初始值都置为 head。</p>\n<pre><code class=\"plain\">public class Solution &#123;\n     public boolean hasCycle(ListNode head) &#123;\n         if (head == null || head.next == null) &#123;\n             return false;\n         &#125;\n         ListNode slow = head;\n         ListNode fast = head.next;\n         while (slow != fast) &#123;\n             if (fast == null || fast.next == null) &#123;\n                 return false;\n             &#125;\n             slow = slow.next;\n             fast = fast.next.next;\n         &#125;\n         return true;\n     &#125;\n &#125;\n</code></pre>\n<h2 id=\"环形链表II\"><a href=\"#环形链表II\" class=\"headerlink\" title=\"环形链表II\"></a>环形链表II</h2><p>给定一个链表的头节点 head ，返回链表开始入环的第一个节点。 <em>如果链表无环，则返回</em> <em>null**。</em></p>\n<p>方法一 哈希</p>\n<pre><code class=\"plain\">public class Solution &#123;\n     public ListNode detectCycle(ListNode head) &#123;\n         Set&lt;ListNode&gt; seen=new HashSet&lt;&gt;();\n         while(head!=null)&#123;\n             //用contains也可\n             if(seen.add(head))&#123;\n                 head=head.next;\n             &#125;else&#123;\n                 return head;\n             &#125;\n         &#125;\n         return null;\n     &#125;\n &#125;\n</code></pre>\n<p>方法二</p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/image-20221015181031942.png\" alt=\"img\"></p>\n<p>环形链表和龟兔赛跑很像，也是相遇后，再有一个指针从头开始和slow一起移动，最后相遇即为结果</p>\n<pre><code class=\"plain\">public class Solution &#123;\n     public ListNode detectCycle(ListNode head) &#123;\n         ListNode slow=head,fast=head;\n         while(fast!=null&amp;&amp;fast.next!=null)&#123;\n             slow=slow.next;\n             fast=fast.next.next;\n             if(slow==fast)&#123;\n                 ListNode node=head;\n                 while(node!=slow)&#123;\n                     slow=slow.next;\n                     node=node.next;\n                 &#125;\n                 return node;\n             &#125;\n         &#125;\n         return null;\n     &#125;\n &#125;\n</code></pre>\n<p>弗洛伊德循环查找算法结论：</p>\n<p>1、如果有环，兔子乌龟(兔子和乌龟可以不在一个位置出发，这个要看具体情况)必定会相遇（判断是否有环，循环问题，链表、快乐数）</p>\n<p>2、如果有环，兔子乌龟同时同位置出发，相遇后，再有一个指针从头开始和slow一起移动，最后在入环点相遇。</p>\n<h2 id=\"相交链表-√\"><a href=\"#相交链表-√\" class=\"headerlink\" title=\"相交链表(√)\"></a>相交链表(√)</h2><p>给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 null</p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/160_statement.png\" alt=\"img\"></p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/image-20220910174724580.png\" alt=\"img\"></p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/image-20221015175222441.png\" alt=\"img\"></p>\n<pre><code class=\"plain\">public ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123;\n     if (headA == null || headB == null) return null;\n     ListNode pA = headA, pB = headB;\n     while (pA != pB) &#123;\n         pA = pA == null ? headB : pA.next;\n         pB = pB == null ? headA : pB.next;\n     &#125;\n     return pA;\n &#125;\n 总结：当某个结点为空就去另一个链表的头节点（目的是缩短差距 慢慢的这俩就可以一起到达相交结点），直到两者相遇，管他为空还是在一个结点处\n</code></pre>\n<p>还有一种基本的方法，就是构造一个哈希表，先把A链表的结点都存进去，然后遍历B链表，当某个节点在A里面有则返回之；</p>\n<h2 id=\"两两交换链表中的节点\"><a href=\"#两两交换链表中的节点\" class=\"headerlink\" title=\"两两交换链表中的节点\"></a>两两交换链表中的节点</h2><p>给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。</p>\n<p>题解：</p>\n<p>模拟 娅结点 temp</p>\n<pre><code class=\"plain\">class Solution &#123;\n     public ListNode swapPairs(ListNode head) &#123;\n         ListNode dummyNode=new ListNode(0);\n         dummyNode.next=head;\n         ListNode temp=dummyNode;\n         while(temp.next!=null&amp;&amp;temp.next.next!=null)&#123;\n             ListNode node1=temp.next;\n             ListNode node2=temp.next.next;\n             temp.next=node2;\n             node1.next=node2.next;\n             node2.next=node1;\n             temp=node1;\n         &#125;\n         return dummyNode.next;\n     &#125;\n &#125;\n</code></pre>\n<h2 id=\"链表内指定区间反转\"><a href=\"#链表内指定区间反转\" class=\"headerlink\" title=\"链表内指定区间反转\"></a><strong>链表内指定区间反转</strong></h2><p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/image-20230402185058710.png\" alt=\"img\"></p>\n<p>题解：</p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/image-20230402185131136.png\" alt=\"img\"></p>\n<p>算法思路：</p>\n<p>1、设置一个dummyNode指向头节点 方便后面返回结果</p>\n<p>2、pre指到m位置前一个</p>\n<p>3、开始工作 for(m-&gt;n )每次把后面一个节点放到头节点位置</p>\n<p>4、返回结果</p>\n<pre><code class=\"plain\">public ListNode reverseBetween (ListNode head, int m, int n) &#123;\n         // write code here\n         ListNode dumyNode =new ListNode(-1);\n         dumyNode.next=head;\n         ListNode pre=dumyNode;\n         for(int i=0;i&lt;m-1;i++)&#123;\n             pre=pre.next;\n         &#125;\n         ListNode cur=pre.next;\n         for(int i=m;i&lt;n;i++)&#123;\n             ListNode curNext=cur.next;\n             cur.next=curNext.next;\n             curNext.next=pre.next;//这里我原本写的curNext.next=cur 这是不对的 这个算法思路就是每次把后面节点移动到最前面 如果我们在循环里面不改cur 那么此时cur并不是头节点  pre.next最保险；\n             pre.next=curNext;\n         &#125;\n         return dumyNode.next;\n     &#125;\n</code></pre>\n<h2 id=\"链表中的节点每k个一组翻转\"><a href=\"#链表中的节点每k个一组翻转\" class=\"headerlink\" title=\"链表中的节点每k个一组翻转\"></a><strong>链表中的节点每k个一组翻转</strong></h2><p>将给出的链表中的节点每 k 个一组翻转，返回翻转后的链表 如果链表中的节点数不是 k 的倍数，将最后剩下的节点保持原样 你不能更改节点中的值，只能更改节点本身。</p>\n<p>题解：</p>\n<p>须知：这个方法返回反转后的头节点</p>\n<p>1、遍历到下一组的头节点 记为tail 中间如果发现tail为null 直接返回head</p>\n<p>2、然后反转链表 此时pre为null 判断条件为cur!&#x3D;tail 平常反转链表条件为cur!&#x3D;null 有异曲同工之妙</p>\n<p>3、head.next&#x3D;reverseKGroup(tail,k); 此处为递归 tail正好也是下一组的头节点</p>\n<p>4、直接返回pre;</p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/D024AA6BA7A670402678A9ACAD54EB10\" alt=\"img\"></p>\n<pre><code class=\"plain\">public ListNode reverseKGroup (ListNode head, int k) &#123;\n         // write code here \n         // 这个方法返回的是反转后的头节点\n         ListNode tail=head;\n         // 此时tail为下一组的头节点\n         for(int i=0;i&lt;k;i++)&#123;\n             if(tail==null) return head;\n             tail=tail.next;\n         &#125;\n         ListNode pre=null;\n         ListNode cur=head;\n         while(cur!=tail)&#123;\n             ListNode curNext=cur.next;\n             cur.next=pre;\n             pre=cur;\n             cur=curNext;\n         &#125;\n         head.next=reverseKGroup(tail,k);\n         // 最后pre指向的是cur(tail的前一个 也就是本组的最后一个节点（现在变成头节点）)\n         return pre;\n     &#125;\n</code></pre>\n<h2 id=\"合并两个有序链表\"><a href=\"#合并两个有序链表\" class=\"headerlink\" title=\"合并两个有序链表\"></a>合并两个有序链表</h2><p>描述</p>\n<p>输入两个递增的链表，单个链表的长度为n，合并这两个链表并使新链表中的节点仍然是递增排序的。</p>\n<h3 id=\"递归\"><a href=\"#递归\" class=\"headerlink\" title=\"递归\"></a>递归</h3><p>1、如果有一个链表为空，返回另一个链表2、如果pHead1 节点值比小pHead2，下一个节点应该是 pHead1，应该return pHead1，在return之前，指定pHead1的下一个节点应该是pHead1.next和pHead2俩链表的合并后的头结点3、如果pHead1 节点值比pHead2大，下一个节点应该是pHead2，应该return pHead2，在return之前，指定pHead2的下一个节点应该是pHead1和pHead2.next俩链表的合并后的头结点</p>\n<pre><code class=\"plain\">public class Solution &#123;\n     public ListNode Merge(ListNode list1, ListNode list2) &#123;\n         if (list1 == null || list2 == null) return list1 == null ? list2 : list1;\n         if (list1.val &gt; list2.val) &#123;\n             list2.next = Merge(list2.next, list1);\n             return list2;\n         &#125; else &#123;\n             list1.next = Merge(list1.next, list2);\n             return list1;\n         &#125;\n     &#125;\n &#125;\n</code></pre>\n<h2 id=\"链表相加-二\"><a href=\"#链表相加-二\" class=\"headerlink\" title=\"链表相加(二)\"></a><strong>链表相加(二)</strong></h2><p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/image-20230403212432459.png\" alt=\"img\"></p>\n<p>题解：</p>\n<p>反转链表后进行相加，每次记录相加后的进位数字</p>\n<pre><code class=\"plain\">public ListNode addInList (ListNode head1, ListNode head2) &#123;\n         // 进行判空处理\n         if(head1 == null)\n             return head2;\n         if(head2 == null)&#123;\n             return head1;\n         &#125;\n         // 反转h1链表\n         head1 = reverse(head1);\n         // 反转h2链表\n         head2 = reverse(head2);\n         // 创建新的链表头节点\n         ListNode head = new ListNode(-1);\n         ListNode nHead = head;\n         // 记录进位的数值\n         int tmp = 0;\n         while(head1 != null || head2 != null)&#123;\n             // val用来累加此时的数值（加数+加数+上一位的进位=当前总的数值）\n             int val = tmp;\n             // 当节点不为空的时候，则需要加上当前节点的值\n             if (head1 != null) &#123;\n                 val += head1.val;\n                 head1 = head1.next;\n             &#125;\n             // 当节点不为空的时候，则需要加上当前节点的值\n             if (head2 != null) &#123;\n                 val += head2.val;\n                 head2 = head2.next;\n             &#125;\n             // 求出进位\n             tmp = val/10;\n             // 进位后剩下的数值即为当前节点的数值\n             nHead.next = new ListNode(val%10);\n             // 下一个节点\n             nHead = nHead.next;\n \n         &#125;\n         // 最后当两条链表都加完的时候，进位不为0的时候，则需要再加上这个进位\n         if(tmp &gt; 0)&#123;\n             nHead.next = new ListNode(tmp);\n         &#125;\n         // 重新反转回来返回\n         return reverse(head.next);\n     &#125;\n \n     // 反转链表\n     public ListNode reverse(ListNode head)&#123;\n         ListNode pre=null;\n         ListNode cur=head;\n         while(cur!=null)&#123;\n             ListNode curNext=cur.next;\n             cur.next=pre;\n             pre=cur;\n             cur=curNext;\n         &#125;\n         return pre;\n     &#125;\n</code></pre>\n<h2 id=\"单链表的排序\"><a href=\"#单链表的排序\" class=\"headerlink\" title=\"单链表的排序\"></a><strong>单链表的排序</strong></h2><p>给定一个节点数为n的无序单链表，对其按升序排序</p>\n<ul>\n<li>step 1：遍历链表，将节点值加入数组。</li>\n<li>step 2：使用内置的排序函数对数组进行排序。</li>\n<li>step 3：依次遍历数组和链表，按照位置将链表中的节点值修改为排序后的数组值。</li>\n</ul>\n<pre><code class=\"plain\">public class Solution &#123;\n     /**\n      * \n      * @param head ListNode类 the head node\n      * @return ListNode类\n      */\n     public ListNode sortInList (ListNode head) &#123;\n         // write code here\n         /**\n         1、复制到数组\n         2、sort\n         3、转为链表\n          */\n         List&lt;Integer&gt; list=new ArrayList&lt;&gt;();\n         ListNode p=head;\n         while(p!=null)&#123;\n             list.add(p.val);\n             p=p.next;\n         &#125;\n         p=head;\n         Collections.sort(list);\n         for(int num:list)&#123;\n             p.val=num;\n             p=p.next;\n         &#125;\n         return head;\n     &#125;\n</code></pre>\n<h2 id=\"判断一个链表是否为回文结构\"><a href=\"#判断一个链表是否为回文结构\" class=\"headerlink\" title=\"判断一个链表是否为回文结构\"></a><strong>判断一个链表是否为回文结构</strong></h2><h3 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h3><p>因为需要判断是否为回文结构，所以要比较头尾的数据，而链表无法随机查询数据，所以可以先将链表转换成list。</p>\n<h3 id=\"具体步骤\"><a href=\"#具体步骤\" class=\"headerlink\" title=\"具体步骤\"></a>具体步骤</h3><ul>\n<li>首先初始化一个list列表；</li>\n<li>遍历链表，将链表中的值转移至list中；</li>\n<li>在list中通过比较头尾的值来判断链表是否为回文结构。</li>\n<li>代码如下：</li>\n</ul>\n<pre><code class=\"plain\">import java.util.*;\n /*\n * public class ListNode &#123;\n *   int val;\n *   ListNode next = null;\n * &#125;\n */\n public class Solution &#123;\n   /**\n    * \n    * @param head ListNode类 the head\n    * @return bool布尔型\n    */\n   public boolean isPail (ListNode head) &#123;\n       // write code here\n       // n==1，返回true\n       if (head.next == null)&#123;\n           return true;\n       &#125;\n       List&lt;Integer&gt; nums = new ArrayList&lt;Integer&gt;();\n       // 将链表转换成list\n       while(head!=null)&#123;\n           nums.add(head.val);\n           head = head.next;\n       &#125;\n       int i = 0;\n       int j = nums.size()-1;\n       while(i&lt;j)&#123;\n           // 不等则返回false\n           // 这边有一个坑，如果不适用equals而使用!=的话，在牛客上对于有负数的测试用例可能会无法通过。\n           if (!nums.get(i).equals(nums.get(j)))&#123;\n               return false;\n           &#125;\n           ++i;\n           --j;\n       &#125;\n       return true;\n   &#125;\n &#125;\n</code></pre>\n<h2 id=\"旋转链表\"><a href=\"#旋转链表\" class=\"headerlink\" title=\"旋转链表\"></a>旋转链表</h2><p>给你一个链表的头节点 head ，旋转链表，将链表每个节点向右移动 k 个位置。</p>\n<p>记给定链表的长度为 ，注意到当向右移动的次数 k≥n 时，我们仅需要向右移动 k mod n次即可。因为每 n 次移动都会让链表变为原状。这样我们可以知道，新链表的最后一个节点为原链表的第 (n−1)−(k mod n)个节点（从 0 开始计数）。</p>\n<p>这样，我们可以先将给定的链表连接成环，然后将指定位置断开。</p>\n<p>具体代码中，我们首先计算出链表的长度 n，并找到该链表的末尾节点，将其与头节点相连。这样就得到了闭合为环的链表。然后我们找到新链表的最后一个节点（即原链表的第 (n−1)−(k mod n)个节点），将当前闭合为环的链表断开，即可得到我们所需要的结果。</p>\n<p>特别地，当链表长度不大于 1，或者 k 为 n 的倍数时，新链表将与原链表相同，我们无需进行任何处理。</p>\n<pre><code class=\"plain\">class Solution &#123;\n     public ListNode rotateRight(ListNode head, int k) &#123;\n         \n         if (k == 0 || head == null || head.next == null) &#123;\n             return head;\n         &#125;\n         // 初始链表长度\n         int n = 1;\n         ListNode iter = head;\n         // 到最后一个结点\n         while (iter.next != null) &#123;\n             iter = iter.next;\n             n++;\n         &#125;\n         // 计算旧头节点和新头节点偏移量\n         int add = n - k % n;\n         if (add == n) &#123;\n             return head;\n         &#125;\n         // 连接为环\n         iter.next = head;\n         // 移动到新头结点\n         while (add-- &gt; 0) &#123;\n             iter = iter.next;\n         &#125;\n         // 断开即可\n         ListNode ret = iter.next;\n         iter.next = null;\n         // 返回\n         return ret;\n     &#125;\n &#125;\n</code></pre>\n<h2 id=\"重排链表\"><a href=\"#重排链表\" class=\"headerlink\" title=\"重排链表\"></a>重排链表</h2><p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/image-20230406191651380.png\" alt=\"img\"></p>\n<ol>\n<li>创建一个队列</li>\n<li>除了head 其他入队</li>\n<li>维护一个count 根据count值奇偶连接链表</li>\n</ol>\n<pre><code class=\"plain\">class Solution &#123;\n     public void reorderList(ListNode head) &#123;\n         // 使用双端队列的方法来解决\n         Deque&lt;ListNode&gt; de = new LinkedList&lt;&gt;();\n         // 这里是取head的下一个节点，head不需要再入队了，避免造成重复\n         ListNode cur = head.next;  \n         while (cur != null)&#123;\n             de.offer(cur);\n             cur = cur.next;\n         &#125;\n         cur = head;  // 回到头部\n \n         int count = 0;\n         while (!de.isEmpty())&#123;\n             if (count % 2 == 0)&#123;\n                 // 偶数，取出队列右边尾部的值\n                 cur.next = de.pollLast();\n             &#125;else &#123;\n                 // 奇数，取出队列左边头部的值\n                 cur.next = de.poll();\n             &#125;\n             cur  = cur.next;\n             count++;\n         &#125;\n         cur.next = null;\n     &#125;\n &#125;\n</code></pre>\n","categories":["算法"]},{"title":"面试算法","url":"/2023/06/04/%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95/","content":"<h1 id=\"十三、算法：\"><a href=\"#十三、算法：\" class=\"headerlink\" title=\"十三、算法：\"></a>十三、算法：</h1><h2 id=\"13-1-堆排序\"><a href=\"#13-1-堆排序\" class=\"headerlink\" title=\"13.1 堆排序\"></a>13.1 堆排序<span id=\"more\"></span></h2><pre><code class=\"java\">public class heapSort &#123;\n    public static void main(String[] args) &#123;\n        Scanner sc=new Scanner(System.in);\n        int n=sc.nextInt();\n        int[] nums=new int[n];\n        for(int i=0;i&lt;n;i++)&#123;\n            nums[i]= sc.nextInt();\n        &#125;\n        //第一步是将得到的数组构建成大顶堆\n        bulidHeap(nums);\n        for(int i=n-1;i&gt;0;i--)&#123;\n            swap(nums,0,i);\n            // bulidHeap后，最后一个节点此时已经到大顶堆了，所以i从n-1开始\n            adjustHeap(nums,0,i);\n        &#125;\n        System.out.println(Arrays.toString(nums));\n    &#125;\n//heapsize ：排序区间   i:需要调整的节点\n    private static void adjustHeap(int[] nums, int i, int heapSize) &#123;\n        int l=2*i+1;\n        int r=l+1;\n        int largest_i=i;\n        if(l&lt;heapSize&amp;&amp;nums[l]&gt;nums[largest_i])&#123;\n            largest_i=l;\n        &#125;\n        if(r&lt;heapSize&amp;&amp;nums[r]&gt;nums[largest_i])&#123;\n            largest_i=l;\n        &#125;\n        if(largest_i!=i)&#123;\n            swap(nums,largest_i,i);\n            //交换之后，将父节点下放一级，就有可能会破坏下一层结构，所以，递归调用adjustHeap.\n            adjustHeap(nums,largest_i,heapSize);\n        &#125;\n    &#125;\n\n    private static void swap(int[] nums, int i, int j) &#123;\n        int temp=nums[i];\n        nums[i]=nums[j];\n        nums[j]=temp;\n    &#125;\n\n    private static void bulidHeap(int[] nums) &#123;\n//        n-1=2x+1或者n-1=2x+2算出来  x=n/2-1\n        for(int i=nums.length/2-1;i&gt;=0;i--)&#123;\n            adjustHeap(nums,i, nums.length);\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<p><a href=\"https://www.bilibili.com/video/BV1fp4y1D7cj/?spm_id_from=333.337.search-card.all.click&vd_source=a94c87b379edd5a7d7d8b35d15935c0f\">这个视频不错</a><br><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/202306041747125.png\" alt=\"img\"></p>\n<h2 id=\"13-2-快排\"><a href=\"#13-2-快排\" class=\"headerlink\" title=\"13.2 快排\"></a>13.2 快排</h2><pre><code class=\"java\">package face.sort;\n\nimport java.util.Arrays;\n\npublic class quickSort &#123;\n    public static void main(String[] args) &#123;\n        int[] a=new int[]&#123;1,3,5,-1,0&#125;;\n        sort(a,0,a.length-1);\n        System.out.println(Arrays.toString(a));\n    &#125;\n    public static void sort(int[] a, int low, int hight) &#123;\n        int i, j, index;\n        if (low &gt; hight) &#123;\n            return;\n        &#125;//每一趟结束的条件\n        i = low;\n        j = hight;\n        index = a[i]; // 第一个记录做基准元素\n        while (i &lt; j) &#123;\n            //先从右边进行扫描，找到小于基准值的元素\n            while (i &lt; j &amp;&amp; a[j] &gt;= index) j--;\n            //找到之后交换\n            if (i &lt; j) a[i++] = a[j];\n            //然后从左边扫描，找到大于基准值的元素\n            while (i &lt; j &amp;&amp; a[i] &lt; index) i++;\n            //找到之后交换\n            if (i &lt; j) a[j--] = a[i];\n        &#125;\n        a[i] = index;\n        sort(a, low, i - 1); // 对低子表进行递归排序\n        sort(a, i + 1, hight); // 对高子表进行递归排序\n    &#125;\n&#125;\n</code></pre>\n<p><img src=\"/.io//Users\\50537\\OneDrive\\blog\\source_posts\\面试算法.assets\\image-20230413010108052.png\" alt=\"img\"></p>\n<p>经过上述一趟快速排序，我们只确定了一个元素的最终位置，我们最终需要经过n趟快速排序才能将一个含有 n 个数据元素的序列排好序，下面我们来分析其时间复杂度</p>\n<p><img src=\"/.io//Users\\50537\\OneDrive\\blog\\source_posts\\面试算法.assets\\image-20230413010655673.png\" alt=\"img\"></p>\n<p><img src=\"/.io//Users\\50537\\OneDrive\\blog\\source_posts\\面试算法.assets\\image-20230413010725385.png\" alt=\"img\"></p>\n<h2 id=\"其他排序\"><a href=\"#其他排序\" class=\"headerlink\" title=\"其他排序\"></a>其他排序</h2><p><img src=\"https://img-blog.csdnimg.cn/a22a2fd0a078461f9d3a03ae06adc9ba.png\" alt=\"img\"></p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/202306041747055.png\" alt=\"img\"></p>\n<p><img src=\"https://img-blog.csdnimg.cn/e8fc01ed77b1487c80522e394a510807.png\" alt=\"img\"></p>\n<p><img src=\"https://img-blog.csdnimg.cn/5d95acc392874064825ef3398f5429ba.png\" alt=\"img\"></p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/202306041747083.png\" alt=\"img\"></p>\n<h2 id=\"13-3-二分法\"><a href=\"#13-3-二分法\" class=\"headerlink\" title=\"13.3 二分法\"></a>13.3 二分法</h2><pre><code class=\"java\">class Solution &#123;\n//左闭右闭\n    public int search(int[] nums, int target) &#123;\n        // 避免当 target 小于nums[0] nums[nums.length - 1]时多次循环运算\n        if (target &lt; nums[0] || target &gt; nums[nums.length - 1]) &#123;\n            return -1;\n        &#125;\n        int left = 0, right = nums.length - 1;\n        while (left &lt;= right) &#123;\n            int mid = left + ((right - left) &gt;&gt; 1);\n            if (nums[mid] == target)\n                return mid;\n            else if (nums[mid] &lt; target)\n                left = mid + 1;\n            else if (nums[mid] &gt; target)\n                right = mid - 1;\n        &#125;\n        return -1;\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"13-4-单例模式\"><a href=\"#13-4-单例模式\" class=\"headerlink\" title=\"13.4 单例模式\"></a>13.4 单例模式</h2><p><strong>单例模式（Singleton）：</strong> 保证整个系统中一个类仅有一个对象实例，并提供一个可以访问它的全局访问点。</p>\n<p><code>**饿汉式**</code><strong>：</strong> 在类加载的时候就创建好单例对象（预先加载）</p>\n<ul>\n<li><p><strong>优点：</strong> 实现简单、线程安全</p>\n</li>\n<li><p><strong>缺点：</strong> 可能会造成系统资源浪费（初始化了一些根本用不到的对象）；增加服务启动的耗时</p>\n</li>\n</ul>\n<p><code>**懒汉式**</code><strong>：</strong> 在需要使用时才创建单例对象（延迟初始化）</p>\n<ul>\n<li><p><strong>优点：</strong> 资源利用率高（只生成需要使用到的实例对象）</p>\n</li>\n<li><p><strong>缺点：</strong> 第一次加载时会比较慢；稍不注意容易写出<strong>线程不安全</strong>的代码</p>\n</li>\n</ul>\n<p>饿汉式</p>\n<pre><code class=\"java\">问题1：为什么加 final，防止子类继承后更改\n\npublic final class Singleton implements Serializable &#123;\n    问题3：为什么设置为私有? 防止其它类中使用new生成新的实例，是否能防止反射创建新的实例?不能，反射private也没用\n    private Singleton() &#123;&#125;\n    问题4：这样初始化是否能保证单例对象创建时的线程安全?没有，这是类变量，是jvm在类加载阶段就进行了初始化，jvm保证了此操作的线程安全性\n    private static final Singleton INSTANCE = new Singleton();\n    问题5：为什么提供静态方法而不是直接将 INSTANCE 设置为 public, 说出你知道的理由。\n    //1.提供更好的封装性；2.提供范型的支持\n    public static Singleton getInstance() &#123;\n        return INSTANCE;\n    &#125;\n    public Object readResolve() &#123;\n        return INSTANCE;\n    &#125;\n&#125;\n</code></pre>\n<p>对上面五个问题的回答：<br>1.final防止子类继承，子类不适当覆盖一些东西，破坏其单例<br>2.反序列化也会生出新的对象，所以增加一个方法readResolve，返回该单例，就可以了<br>3.设为public别的类都可以创建它的对象，显然就不行。不能防止反射，反射private也没用<br>4.静态成员变量的初始化操作，是在类加载阶段完成的，类加载阶段由jvm保证线程安全性<br>5.实现懒惰；  可以有更多的控制；  可以增加泛型的控制</p>\n<p>懒汉式</p>\n<pre><code class=\"java\">public final class Singleton &#123;\n    private Singleton() &#123; &#125;\n    private static Singleton INSTANCE = null;\n    // 分析这里的线程安全, 并说明有什么缺点：synchronized加载静态方法上，可以保证线程安全。缺点就是锁的范围过大，每次访问都会加锁，性能比较低。\n    public static synchronized Singleton getInstance() &#123;\n        if( INSTANCE == null )&#123;\n           INSTANCE = new Singleton();\n        &#125;\n        return INSTANCE;\n    &#125;\n&#125;\n</code></pre>\n<p>DCL懒汉式，不过无法防止反射</p>\n<p>这种方式是对懒汉式的改进，只有当 INSTANCE &#x3D;&#x3D; null 时，才会进入同步代码块，且在同步代码块也做了一次空检查，就可以保证线程安全。</p>\n<h3 id=\"为什么要使用-volatile\"><a href=\"#为什么要使用-volatile\" class=\"headerlink\" title=\"为什么要使用 volatile?\"></a>为什么要使用 <code>volatile</code>?</h3><p>为了解决多线程环境下<code>重排序</code>带来的问题。</p>\n<p>创建对象会经过三个步骤（不是原子性）：</p>\n<ol>\n<li><p>创建空的对象（分配内存）</p>\n</li>\n<li><p>调用构造方法（对象初始化）</p>\n</li>\n<li><p>将构造好的实例地址赋值给引用</p>\n</li>\n</ol>\n<p><strong>模拟下出问题的流程（假设不加volatile关键字）：</strong></p>\n<ul>\n<li><p>当 线程1 判断 INSTANCE 为空，进入同步逻辑，继续检查为空，则创建对象</p>\n</li>\n<li><p>如果此时发生指令重排序，执行 1-&gt;3-&gt;2 步骤，先创建了空对象，然后赋值给引用，此时还没来得及调用构造方法</p>\n</li>\n<li><p>其他线程此时判断 INSTANCE 不为 null，则直接返回 INSTANCE，但是此时对象并没有初始化完毕，就被其他线程使用，可能导致<strong>空指针</strong>异常</p>\n</li>\n</ul>\n<pre><code class=\"plain\"> 依然每次都会有锁。而现在，我们将锁的位置变了，并且多加了一个检查。 也就是，先判断实例是否已经存在，若已经存在了，\n* 则不会执行判断方法内的有锁方法了。 而如果，还没有实例化的时候，多个线程进去了，也没有事，因为里面的方法有锁，\n* 只会让一个线程进入最内层方法并实例化实例。如此一来，最多最多，也就是第一次实例化的时候，会有线程阻塞的情况，后续便不会再有线程阻塞的问题。\n</code></pre>\n<pre><code class=\"java\">public class Singleton &#123;\n\n    private volatile static Singleton INSTANCE;\n\n    private Singleton() &#123;&#125;\n\n    public static Singleton getInstance() &#123;\n        //此处依然会有多线程进去的问题\n        if (INSTANCE == null) &#123;\n            synchronized (Singleton.class) &#123;\n                //为什么还要在这里加为空判断, 之前不是判断过了吗？这是为了第一次判断时的并发问题。\n                if (INSTANCE == null) &#123;\n                    INSTANCE = new Singleton();\n                &#125;\n            &#125;\n        &#125;\n        return INSTANCE;\n    &#125;\n\n&#125;\n</code></pre>\n<p>防止反射的单例模式（不是懒汉式）</p>\n<p>枚举</p>\n<pre><code class=\"java\">public enum SingletonEnum &#123;\n    INSTANCE;\n&#125;\n</code></pre>\n<h2 id=\"13-5-LRU\"><a href=\"#13-5-LRU\" class=\"headerlink\" title=\"13.5 LRU\"></a>13.5 LRU</h2><p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/202306041747284.png\" alt=\"img\"><br>实现本题的两种操作，需要用到一个哈希表和一个双向链表。在面试中，面试官一般会期望读者能够自己实现一个简单的双向链表，而不是使用语言自带的、封装好的数据结构。在 Java 语言中，有数据结构 LinkedHashMap。这样的做法不符合面试官的要求，因此下面只给出使用封装好的数据结构实现的代码，而不多做任何阐述。</p>\n<pre><code class=\"java\">class LRUCache extends LinkedHashMap&lt;Integer, Integer&gt;&#123;\n    private int capacity;\n    \n    public LRUCache(int capacity) &#123;\n        super(capacity, 0.75F, true);\n        this.capacity = capacity;\n    &#125;\n\n    public int get(int key) &#123;\n        return super.getOrDefault(key, -1);\n    &#125;\n\n    public void put(int key, int value) &#123;\n        super.put(key, value);\n    &#125;\n\n    @Override\n    protected boolean removeEldestEntry(Map.Entry&lt;Integer, Integer&gt; eldest) &#123;\n        return size() &gt; capacity; \n    &#125;\n&#125;\n</code></pre>\n<p>方法：哈希表 + 双向链表</p>\n<p>双向链表只是为了方便获取前后节点，节省时间<br><img src=\"https://img-blog.csdnimg.cn/70aa9a0566e744908a4662746efdc258.png\" alt=\"img\"></p>\n<pre><code class=\"java\">class LRUCache &#123;\n     class DlinkedNode&#123;\n         int key;\n         int value;\n         DlinkedNode prev;\n         DlinkedNode next;\n         public DlinkedNode() &#123;\n         &#125;\n         public DlinkedNode(int key, int value) &#123;\n             this.key = key;\n             this.value = value;\n         &#125;\n     &#125;\n     private Map&lt;Integer,DlinkedNode&gt; cache=new HashMap&lt;&gt;();\n     private int size;\n     private int capacity;\n     private DlinkedNode head;\n     private DlinkedNode tail;\n\n    public LRUCache(int capacity) &#123;\n        this.size=size;\n        this.capacity=capacity;\n         // 使用伪头部和伪尾部节点\n        head=new DlinkedNode();\n        tail=new DlinkedNode();\n        head.next=tail;\n        tail.prev=head;\n    &#125;\n    \n    public int get(int key) &#123;\n//        通过哈希表定位\n        DlinkedNode node=cache.get(key);\n        if(node==null)&#123;\n            return -1;\n        &#125;else&#123;\n            // 如果 key 存在，先通过哈希表定位，再移到头部\n            moveToHead(node);\n            return node.value;\n        &#125;\n    &#125;\n    public void put(int key, int value) &#123;\n        DlinkedNode node=cache.get(key);\n        if(node==null)&#123;\n             // 如果 key 不存在，创建一个新的节点\n            DlinkedNode newNode = new DlinkedNode(key,value);//建一个新的node\n            // 添加进哈希表\n            cache.put(key,newNode);\n            // 添加至双向链表的头部\n            addToHead(newNode);\n            size++;\n            if(size&gt;capacity)&#123;\n                // 如果超出容量，删除双向链表的尾部节点\n                DlinkedNode tail=removeTail();\n                // 删除哈希表中对应的项\n                cache.remove(tail.key);\n                --size;\n            &#125;\n        &#125;else&#123;\n            // 如果 key 存在，先通过哈希表定位，再修改 value，并移到头部\n            node.value=value;\n            moveToHead(node);\n        &#125;\n\n    &#125;\n    // 删除并移动到伪头节点的后面\n    public void moveToHead(DlinkedNode node)&#123;\n        //1、删除\n          removeNode(node);\n          //2、移动\n          addToHead(node);\n      &#125;\n    //插入到伪头节点的后面\n    public void addToHead(DlinkedNode node)&#123;\n        node.prev=head;\n        node.next=head.next;\n        node.next.prev=node;\n        head.next=node;\n    &#125;\n    // 删除结点\n    public void removeNode(DlinkedNode node)&#123;\n        node.prev.next=node.next;\n        node.next.prev=node.prev;\n    &#125;\n//去除尾部的结点\n    public DlinkedNode removeTail()&#123;\n        DlinkedNode res=tail.prev;\n        removeNode(res);\n        return res;\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"13-6-手写hashMap\"><a href=\"#13-6-手写hashMap\" class=\"headerlink\" title=\"13.6 手写hashMap\"></a>13.6 手写hashMap</h2><p><a href=\"https://blog.csdn.net/TheCalm/article/details/119811706\">好文章</a></p>\n<h2 id=\"13-7-邻接矩阵\"><a href=\"#13-7-邻接矩阵\" class=\"headerlink\" title=\"13.7 邻接矩阵\"></a>13.7 邻接矩阵</h2><pre><code class=\"java\">public class MGraph01 &#123;\n    public int numNodes;      //图的顶点数目\n    public int numEdges;      //图的边数\n    public Object[] vexs;     //一维顶点数组\n    public int[][] arcs;      //二维边数组\n    public static final int INF = Integer.MAX_VALUE; //无穷大\n \n    /**\n     * 创建无向图的邻接矩阵\n     */\n    public void createUDG() &#123;\n        Scanner sc = null;\n        try &#123;\n            sc = new Scanner(System.in);\n            System.out.println(&quot;请输入图的顶点数、图的边数：&quot;);\n            numNodes = Integer.parseInt(sc.nextLine());\n            numEdges = Integer.parseInt(sc.nextLine());\n            vexs = new Object[numNodes];\n            //录入顶点信息\n            System.out.println(&quot;请输入图中的顶点：&quot;);\n            vexs = sc.nextLine().split(&quot; &quot;);\n            //录入边的信息\n            arcs = new int[numNodes][numNodes];\n            for (int i = 0; i &lt; numEdges; i++) &#123;\n                System.out.println(&quot;请输入第&quot; + (i + 1) + &quot;条边上的一个顶点：&quot;);\n                //locate方法用来定位某个顶点在数组中的索引\n                int index1 = locate(sc.nextLine());\n                System.out.println(&quot;请输入第&quot; + (i + 1) + &quot;条边上的另一个顶点：&quot;);\n                int index2 = locate(sc.nextLine());\n                //无向图是个对称矩阵\n                arcs[index1][index2] = arcs[index2][index1] = 1;\n            &#125;\n        &#125; catch (Exception e) &#123;\n            e.printStackTrace();\n        &#125; finally &#123;\n            sc.close();\n        &#125;\n    &#125;\n \n    /**\n     * 创建有向图的邻接矩阵\n     */\n    public void createDG() &#123;\n        Scanner sc = null;\n        try &#123;\n            sc = new Scanner(System.in);\n            System.out.println(&quot;请输入图的顶点数、图的边数：&quot;);\n            numNodes = Integer.parseInt(sc.nextLine());\n            numEdges = Integer.parseInt(sc.nextLine());\n            vexs = new Object[numNodes];\n            //录入顶点信息\n            System.out.println(&quot;请输入图中的顶点：&quot;);\n            String str = sc.nextLine();\n            vexs = str.split(&quot; &quot;);\n            //录入边的信息\n            arcs = new int[numNodes][numNodes];\n            for (int i = 0; i &lt; numEdges; i++) &#123;\n                System.out.println(&quot;请输入第&quot; + (i + 1) + &quot;条弧上的弧尾：&quot;);\n                int index1 = locate(sc.nextLine());\n                System.out.println(&quot;请输入第&quot; + (i + 1) + &quot;条弧上的弧头：&quot;);\n                int index2 = locate(sc.nextLine());\n                arcs[index1][index2] = 1;\n            &#125;\n        &#125; catch (Exception e) &#123;\n            e.printStackTrace();\n        &#125; finally &#123;\n            sc.close();\n        &#125;\n    &#125;\n \n    /**\n     * 创建无向网的邻接矩阵\n     */\n    public void createUDN() &#123;\n        Scanner sc = null;\n        try &#123;\n            sc = new Scanner(System.in);\n            System.out.println(&quot;请输入图的顶点数、图的边数：&quot;);\n            numNodes = Integer.parseInt(sc.nextLine());\n            numEdges = Integer.parseInt(sc.nextLine());\n            vexs = new Object[numNodes];\n            //录入顶点信息\n            System.out.println(&quot;请输入图中的顶点：&quot;);\n            String str = sc.nextLine();\n            vexs = str.split(&quot; &quot;);\n            //矩阵初始化，有向网中\n            arcs = new int[numNodes][numNodes];\n            for (int i = 0; i &lt; numNodes; i++) &#123;\n                for (int j = 0; j &lt; numNodes; j++) &#123;\n                    arcs[i][j] = INF;\n                &#125;\n            &#125;\n            //录入边的信息\n            for (int i = 0; i &lt; numEdges; i++) &#123;\n                System.out.println(&quot;请输入第&quot; + (i + 1) + &quot;条边上的一个顶点：&quot;);\n                int index1 = locate(sc.nextLine());\n                System.out.println(&quot;请输入第&quot; + (i + 1) + &quot;条边上的另一个顶点：&quot;);\n                int index2 = locate(sc.nextLine());\n                System.out.println(&quot;请输入第&quot; + (i + 1) + &quot;条边上的权值：&quot;);\n                arcs[index1][index2] = arcs[index2][index1] = Integer.parseInt(sc.nextLine());\n            &#125;\n        &#125; catch (Exception e) &#123;\n            e.printStackTrace();\n        &#125; finally &#123;\n            sc.close();\n        &#125;\n    &#125;\n \n    /**\n     * 创建有向网的邻接矩阵\n     */\n    public void createDN() &#123;\n        Scanner sc = null;\n        try &#123;\n            sc = new Scanner(System.in);\n            System.out.println(&quot;请输入图的顶点数、图的边数：&quot;);\n            numNodes = Integer.parseInt(sc.nextLine());\n            numEdges = Integer.parseInt(sc.nextLine());\n            vexs = new Object[numNodes];\n            //录入顶点信息\n            System.out.println(&quot;请输入图中的顶点：&quot;);\n            String str = sc.nextLine();\n            vexs = str.split(&quot; &quot;);\n            //录入边的信息\n            arcs = new int[numNodes][numNodes];\n            for (int i = 0; i &lt; numEdges; i++) &#123;\n                System.out.println(&quot;请输入第&quot; + (i + 1) + &quot;条弧上的弧尾：&quot;);\n                int index1 = locate(sc.nextLine());\n                System.out.println(&quot;请输入第&quot; + (i + 1) + &quot;条弧上的弧头：&quot;);\n                int index2 = locate(sc.nextLine());\n                System.out.println(&quot;请输入第&quot; + (i + 1) + &quot;条弧上的权值：&quot;);\n                arcs[index1][index2] = Integer.parseInt(sc.nextLine());\n            &#125;\n        &#125; catch (Exception e) &#123;\n            e.printStackTrace();\n        &#125; finally &#123;\n            sc.close();\n        &#125;\n    &#125;\n \n    /**\n     * 通过顶点信息来定位其在顶点数组中的索引\n     *\n     * @param s\n     * @return\n     */\n    public int locate(Object s) &#123;\n        for (int i = 0; i &lt; vexs.length; i++) &#123;\n            if (s.equals(vexs[i])) &#123;\n                return i;\n            &#125;\n        &#125;\n        return -1;\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"前缀树\"><a href=\"#前缀树\" class=\"headerlink\" title=\"前缀树\"></a>前缀树</h2><pre><code class=\"java\">package com.nowcoder.community.util;\n\nimport org.apache.commons.lang3.CharUtils;\nimport org.apache.commons.lang3.StringUtils;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.stereotype.Component;\n\nimport javax.annotation.PostConstruct;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.HashMap;\nimport java.util.Map;\n\n@Component\npublic class SensitiveFilter &#123;\n\n    private static final Logger logger = LoggerFactory.getLogger(SensitiveFilter.class);\n\n    // 替换符\n    private static final String REPLACEMENT = &quot;***&quot;;\n\n    // 根节点\n    private TrieNode rootNode = new TrieNode();\n\n\n    //3.1第二步：根据敏感词，初始化前缀树\n    //@PostConstruct代表是初始化方法，SensitiveFilter容器一构造，它就开始\n    @PostConstruct\n    public void init() &#123;\n        try (\n                InputStream is = this.getClass().getClassLoader().getResourceAsStream(&quot;sensitive-words.txt&quot;);\n                //把is先转为字符流，再转为缓冲流\n                BufferedReader reader = new BufferedReader(new InputStreamReader(is));\n        ) &#123;\n            String keyword;\n            while ((keyword = reader.readLine()) != null) &#123;\n                // 添加到前缀树\n                this.addKeyword(keyword);\n            &#125;\n        &#125; catch (IOException e) &#123;\n            logger.error(&quot;加载敏感词文件失败: &quot; + e.getMessage());\n        &#125;\n    &#125;\n    //也算3.1第二步：根据敏感词，初始化前缀树\n    // 将一个敏感词添加到前缀树中\n    private void addKeyword(String keyword) &#123;\n        TrieNode tempNode = rootNode;\n        for (int i = 0; i &lt; keyword.length(); i++) &#123;\n            char c = keyword.charAt(i);\n            //找一下当前节点有没有这个子节点，有的话就不再挂了\n            TrieNode subNode = tempNode.getSubNode(c);\n\n            if (subNode == null) &#123;\n                // 初始化子节点\n                subNode = new TrieNode();\n                tempNode.addSubNode(c, subNode);\n            &#125;\n\n            // 指向子节点,进入下一轮循环\n            tempNode = subNode;\n\n            // 设置结束标识\n            if (i == keyword.length() - 1) &#123;\n                tempNode.setKeywordEnd(true);\n            &#125;\n        &#125;\n    &#125;\n//3.1第三步：过滤敏感词\n    /**\n     * 过滤敏感词\n     *\n     * @param text 待过滤的文本\n     * @return 过滤后的文本\n     */\n    public String filter(String text) &#123;\n        if (StringUtils.isBlank(text)) &#123;\n            return null;\n        &#125;\n\n        // 指针1\n        TrieNode tempNode = rootNode;\n        // 指针2\n        int begin = 0;\n        // 指针3\n        int position = 0;\n        // 结果\n        StringBuilder sb = new StringBuilder();\n\n        //用指针3效率稍微更高一点\n        while (begin &lt; text.length()) &#123;\n            if (position &lt; text.length()) &#123;\n                char c = text.charAt(position);\n                //例如 ⭐政⭐府⭐  就检测不到，需要跳过符号\n                // 跳过符号\n                if (isSymbol(c)) &#123; //倘若字符c是符号\n                    // 若指针1处于根节点,将此符号计入结果,让指针2向下走一步\n                    if (tempNode == rootNode) &#123;\n                        sb.append(c);\n                        begin++;\n                    &#125;\n                    // 无论符号在开头或中间,指针3都向下走一步\n                    position++;\n                    continue;\n                &#125;\n\n                // 检查下级节点\n                tempNode = tempNode.getSubNode(c);\n                if (tempNode == null) &#123;\n                    // 以begin开头的字符串不是敏感词\n                    sb.append(text.charAt(begin));\n                    // 进入下一个位置\n                    position = ++begin;\n                    // 重新指向根节点\n                    tempNode = rootNode;\n                &#125; else if (tempNode.isKeywordEnd()) &#123;\n                    // 发现敏感词,将begin~position字符串替换掉\n                    sb.append(REPLACEMENT);\n                    // 进入下一个位置\n                    begin = ++position;\n                    // 重新指向根节点\n                    tempNode = rootNode;\n                &#125; else &#123;\n                    // 检查下一个字符\n                    position++;\n                &#125;\n            &#125;\n            // position遍历越界仍未匹配到敏感词\n            else &#123;\n                sb.append(text.charAt(begin));\n                position = ++begin;\n                tempNode = rootNode;\n            &#125;\n        &#125;\n        return sb.toString();\n    &#125;\n\n    // 判断是否为符号\n    private boolean isSymbol(Character c) &#123;\n        // 0x2E80~0x9FFF 是东亚文字范围\n        return !CharUtils.isAsciiAlphanumeric(c) &amp;&amp; (c &lt; 0x2E80 || c &gt; 0x9FFF);\n    &#125;\n\n\n    //这个结构只在这个工具里用，所以定义一个内部类\n    // 3.1小节的第一步：定义前缀树\n    private class TrieNode &#123;\n\n        // 关键词结束标识\n        private boolean isKeywordEnd = false;\n\n        // 一个节点的子节点可能是多个，因此用map来进行封装\n        // 子节点(key是下级字符,value是下级节点)\n        private Map&lt;Character, TrieNode&gt; subNodes = new HashMap&lt;&gt;();\n\n        public boolean isKeywordEnd() &#123;\n            return isKeywordEnd;\n        &#125;\n\n        public void setKeywordEnd(boolean keywordEnd) &#123;\n            isKeywordEnd = keywordEnd;\n        &#125;\n\n        // 添加子节点\n        public void addSubNode(Character c, TrieNode node) &#123;\n            subNodes.put(c, node);\n        &#125;\n\n        // 获取子节点\n        public TrieNode getSubNode(Character c) &#123;\n            return subNodes.get(c);\n        &#125;\n\n    &#125;\n\n&#125;\n</code></pre>\n","categories":["算法"]},{"title":"防雷防电检测系统","url":"/2023/06/04/%E9%98%B2%E9%9B%B7%E9%98%B2%E7%94%B5%E6%A3%80%E6%B5%8B%E7%B3%BB%E7%BB%9F/","content":"<h3 id=\"项目概要\"><a href=\"#项目概要\" class=\"headerlink\" title=\"项目概要\"></a>项目概要</h3><p>港口油罐区硬件设备通过双绞线布设周围，然后底部通过光纤连，每个区域连一个串口服务器，然后通过交换机连到中控室和服务器；</p>\n<p>研究生期间，主要参与了与江苏科源公司合作的一个港口油罐区防雷防爆防雷电监测预警系统的开发，现在系统部署于辽宁营口市两处港口现场，运行状态稳定。<span id=\"more\"></span></p>\n<p>前端5s轮询一次，1h是持久化到数据库</p>\n<p>redis存的是 key：设备（40） map&lt;类型：值&gt; ip端口 </p>\n<p>这个项目是基于Springboot开发的web项目，在研一入学前开始对系统进行设计和开发，并部署于港口现场，后续对系统持续进行迭代升级。系统主要用于与港口油罐区布设的电压，电阻，温度等监测设备交互，通过modbus协议向设备发送请求获取设备返回的数据。在系统后端对数据进行解析并展示于前端。</p>\n<ol>\n<li>根据modbus协议，构建请求帧，生成CRC校验码，通过串口或串口服务器发送至设备，获取返回帧</li>\n<li>根据具体设备（每个硬件不同）解析协议配置解析流程，根据协议对返回帧进行解析，返回的是一个16进制字符串，校验CRC编码，以及数据长度，判断返回数据是否有效</li>\n<li>在redis中维护产品信息，记录每个产品的相关信息以及当前状态，设备状态变化时予以更新</li>\n<li>定义全局变量DataDisplays，将解析好的设备数据存入其中。</li>\n<li>解析时根据配置好的设备阈值判定是否达到预警条件，捕捉预警数据，前端轮询异常设备信息进行报警</li>\n<li>配置一个定时线程，每隔一个小时从缓存中读取设备数据写入mysql进行持久化</li>\n</ol>\n<h3 id=\"系统流程\"><a href=\"#系统流程\" class=\"headerlink\" title=\"系统流程\"></a>系统流程</h3><ol>\n<li>在系统启动时，通过一个监听器来监听web应用，在web应用启动时，对系统进行初始化</li>\n</ol>\n<ul>\n<li><ul>\n<li>清空redis，从mysql中读取各个设备报警阈值配置，写入redis</li>\n<li>初始化全局变量DataDisplays，读取区域，到区域内产品类别，到具体产品，到产品解析协议的继承关系。将各设备展示数据赋null，写入全局变量</li>\n<li>启动轮询线程，进行数据读取和解析</li>\n</ul>\n</li>\n</ul>\n<ol>\n<li>获取产品和解析协议的继承关系，逐个轮询设备，调用readData方法获取设备返回的字节流，以map的形式存储</li>\n<li>在readData中调用getReturnData，根据解析协议，为设备构建请求帧，生成CRC校验码，通过串口或串口服务器发送至设备</li>\n</ol>\n<ul>\n<li><ul>\n<li>串口服务器方式通过与串口服务器ip建立socket连接，以字节缓冲输入输出流的形式发送和读取数据</li>\n<li>串口方式根据端口名打开端口，配置串口参数，发送和读取数据</li>\n</ul>\n</li>\n</ul>\n<ol>\n<li>对返回数据进行判定，校验CRC编码，以及数据长度，判断返回数据是否有效</li>\n</ol>\n<ul>\n<li><ul>\n<li>当返回数据为空时，根据配置好的重试次数进行重新读取，若重试次数达到上限依旧没有读取到有效数据从redis中读取对应设备的字节缓存信息</li>\n<li>当返回数据不为空时，更新缓存状态，将数据更新时间写入redis。</li>\n</ul>\n</li>\n</ul>\n<ol>\n<li>将字节数据以map的形式返回给readData</li>\n</ol>\n<ul>\n<li><ul>\n<li>若返回数据为空，从redis中读取，否则，记录设备当前字节流，写入redis</li>\n</ul>\n</li>\n</ul>\n<ol>\n<li>对返回的字节数据进行解析，封装成用于展示的数据</li>\n</ol>\n<ul>\n<li><ul>\n<li>在解析过程中对报警数据进行捕捉，如果解析到当前数据为报警数据，将该报警数据写入mysql。</li>\n</ul>\n</li>\n</ul>\n<ol>\n<li>如果解析数据不为空，更新全局变量DataDisplays中的数据</li>\n<li>在一类产品轮询结束后，统计解析数据中报警设备，更新redis设备信息中的状态</li>\n<li>通过一个可以周期性执行任务的单线程线程池执行该线程</li>\n<li>通过@Scheduled定义一个每小时执行一次的轮询任务，从全局变量中读取各个设备的数据写入mysql</li>\n<li>报警功能通过前端轮询向后端发送请求读取设备信息，设备从redis中读取每个设备的状态信息，统计状态异常的设备数量，如果数量不为零，前端进行报警</li>\n</ol>\n<h3 id=\"项目值得改进的地方\"><a href=\"#项目值得改进的地方\" class=\"headerlink\" title=\"项目值得改进的地方\"></a><strong>项目值得改进的地方</strong></h3><p><strong>数据实时显示：</strong></p>\n<p>现在是前端轮询调用后端接口，读取数据，效率不高</p>\n<p>改进：</p>\n<p>引入websocket：通过websocket在服务器和浏览器间建立持久性的连接</p>\n<p>协议有两部分：握手和数据传输。握手是基于http协议的。</p>\n<p>一旦WebSocket连接建立后，后续数据都以帧序列的形式传输。在客户端断开WebSocket连接或Server端中断连接前，不需要客户端和服务端重新发起连接请求。在海量并发及客户端与服务器交互负载流量大的情况下，极大的节省了网络带宽资源的消耗，有明显的性能优势，且客户端发送和接受消息是在同一个持久连接上发起，实现了“真·长链接”，实时性优势明显。</p>\n<p>WebSocket有以下特点：</p>\n<ul>\n<li>是真正的全双工方式，建立连接后客户端与服务器端是完全平等的，可以互相主动请求。而HTTP长连接基于HTTP，是传统的客户端对服务器发起请求的模式。</li>\n<li>HTTP长连接中，每次数据交换除了真正的数据部分外，服务器和客户端还要大量交换HTTP header，信息交换效率很低。WebSocket协议通过第一个request建立了TCP连接之后，之后交换的数据都不需要发送 HTTP header就能交换数据，这显然和原有的HTTP协议有区别所以它需要对服务器和客户端都进行升级才能实现（主流浏览器都已支持HTML5）</li>\n</ul>\n<h1 id><a href=\"#\" class=\"headerlink\" title></a></h1>","categories":["项目"]},{"title":"魔方天地","url":"/2023/06/04/%E9%AD%94%E6%96%B9%E5%A4%A9%E5%9C%B0/","content":"<h1 id=\"项目\"><a href=\"#项目\" class=\"headerlink\" title=\"项目\"></a>项目</h1><h2 id=\"魔方天地\"><a href=\"#魔方天地\" class=\"headerlink\" title=\"魔方天地\"></a>魔方天地</h2><h3 id=\"项目介绍\"><a href=\"#项目介绍\" class=\"headerlink\" title=\"项目介绍\"></a>项目介绍</h3><p>主要包括魔方教程的发布、展示、检索、评论，用户的登录注册等。 在这其中加入了一些中间件进行优化，最后做了上线部署。<span id=\"more\"></span></p>\n<p>以下是该项目的主要特点和功能：</p>\n<ol>\n<li>从用户系统：支持用户注册、登录，用户可以发布教程帖子、评论。</li>\n<li>帖子管理：支持帖子的发布、编辑和删除等操作，帖子内容可以包含图片（七牛云）。</li>\n<li>分类和标签：帖子可以被分配到不同的分类和标签，方便用户查找和阅读。</li>\n<li>搜索：支持关键词搜索功能。</li>\n</ol>\n<p>以上就是我项目的主要内容</p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/image-20230413011206981.png\" alt=\"img\"></p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/image-20230404225216774.png\" alt=\"img\"></p>\n<p><strong>服务器配置和QPS：</strong></p>\n<p>2核CPU&#x2F;4G内存&#x2F;3M公网宽带</p>\n<p>QPS： 600 cpu使用率 3%</p>\n<p>总结：服务器并发性能大部分情况受限于带宽，在带宽足够大的情况下，如果CPU使用达到50% - 80%以上，需要拓展服务器内存。</p>\n<p>挂了怎么办</p>\n<p>tomcat 默认连接数200改成800就没问题了</p>\n<p><strong>线上出现fullgc问题如何排查？</strong></p>\n<p>问题：线上出现fullgc报警，每5分钟一次</p>\n<p>原因：</p>\n<p>1、System.gc </p>\n<p>2、minnorGc时老年代可用空间小于新时代对象大小且没有开启空间分配担保策略，或者开启了但是老年代中最大连续可用空间是小于了历次晋升到老年代中的平均大小，就会fullGc</p>\n<p>3、大对象</p>\n<p>4、长期持有某个引用</p>\n<p>5、老年代、方法区爆</p>\n<p>排查：</p>\n<p>1、之前就设定好 -XX:HeapDumpBeforeFullGC（fullGc保存dump） -XX:HeapDumpPath&#x3D;保存dump文件的文件绝对路径</p>\n<p>2、导出dump文件，通过JDK自带的jvisualvm工具分析或者下载三方软件jprofiler来分析dump文件即可</p>\n<p>3、最重要的一点，要把fullgc发生时刻的dump文件和正常没有发生fullgc时间的dump文件都下载到本地，然后对比观察分析方便找到问题的原因 </p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/image-20230322004403008.png\" alt=\"img\"></p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/image-20230322005426563.png\" alt=\"img\"></p>\n<h3 id=\"1、JWT-token-redis\"><a href=\"#1、JWT-token-redis\" class=\"headerlink\" title=\"1、JWT+token+redis\"></a>1、JWT+token+redis</h3><h4 id=\"登录整体流程：\"><a href=\"#登录整体流程：\" class=\"headerlink\" title=\"登录整体流程：\"></a><strong>登录整体流程：</strong></h4><p>1、前端传入账密，检查参数是否合法，只要账密一个为空，报参数错误的信息</p>\n<p>2、用传入的用户密码（比如123）用一个加密盐（可以放数据库也可以写死，我这里是写死）做一个加密，目的为了不让数据库用户密码泄露，然后根据用户名和密码去user表中查询 是否存在</p>\n<p>3、如果不存在 报账户密码不存在错误</p>\n<p>4、如果存在 ，使用jwt 生成token 返回给前端</p>\n<p>​\t\tAB部分用A指定的HS256算法加一个随便指定密钥进行加密生成token</p>\n<p>5、token放入redis当中，redis（String，String，time，单位） token：（TOKEN_token，对象转为Json字符串，1，day ） redis操作：keys *</p>\n<h4 id=\"后续登录\"><a href=\"#后续登录\" class=\"headerlink\" title=\"后续登录\"></a><strong>后续登录</strong></h4><p>登录认证的时候 经过登录拦截器preHandle</p>\n<p>1、康康是不是访问controller的方法 不是的话就不用拦截了（访问静态资源 默认去classpath下的static目录去查询）</p>\n<p>2、Authorization拿到Token，先认证token字符串是否合法</p>\n<p>3、再去redis认证是否存在，过期了直接重新登录</p>\n<p>4、redis拿到的用户信息存到ThreadLocal，进行用户信息的缓存（比如写评论操作用到） </p>\n<p>5、最后remove()</p>\n<h4 id=\"用户jwt鉴权流程\"><a href=\"#用户jwt鉴权流程\" class=\"headerlink\" title=\"用户jwt鉴权流程\"></a>用户jwt鉴权流程</h4><p>(JSON WEB TOKEN)</p>\n<p><strong>签发</strong></p>\n<p>jwt 有三部分组成：A.B.C</p>\n<p>A：Header，{“type”:”JWT”,”alg”:”HS256”} 固定 <strong>定义生成签名算法以及Token的类型</strong> alg表示签名算法HS256</p>\n<p>B：playload，存放实际需要传递的信息，比如，用户id，过期时间等等，可以被解密，不能存放敏感信息（因为playload默认不加密）</p>\n<p>AB两部分都用Base64URL 算法转成字符串（ Base64 编码格式）</p>\n<p>C: 签证，对前面两部分的签名；</p>\n<p>首先，需要指定一个密钥（secret）。这个密钥只有服务器才知道，不能泄露给用户。然后，使用 Header 里面指定的签名算法（默认是 HMAC SHA256&#x3D;&#x3D; HS256），再加上一个密钥，secret（自己指定）按照下面的公式产生签名。</p>\n<p>token&#x3D;HMACSHA256( base64UrlEncode(header) + “.” + base64UrlEncode(payload), secret)算出签名以后，把 Header、Payload、Signature 三个部分拼成一个字符串，每个部分之间用”点”（ . ）分隔，就可以返回给用户。</p>\n<pre><code class=\"plain\">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.\neyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.\nSflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c\n//可以在 jwt.io 这个网站上对其 JWT 进行解码\n</code></pre>\n<p><strong>验证</strong></p>\n<p>通过secret密钥进行解密，验证C部分 是否合法；</p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/image-20230320181343651.png\" alt=\"img\"></p>\n<ol>\n<li>用户使用用户名密码来请求服务器</li>\n<li>服务器进行验证用户的信息3.服务器通过验证，发送给用户一个token（header.payload(id 电话号码啥的).签证）4.客户端存储token，并在每次请求时附送上这个token值（Authorization里面，放在cokie里面不能跨域）</li>\n<li>服务端验证token值，并返回数据，从中也可获取用户相关信息</li>\n</ol>\n<h4 id=\"如何防止-JWT-被篡改？\"><a href=\"#如何防止-JWT-被篡改？\" class=\"headerlink\" title=\"如何防止 JWT 被篡改？\"></a>如何防止 JWT 被篡改？</h4><p>有了签名之后，即使 JWT 被泄露或者截获，黑客也没办法同时篡改 Signature、Header、Payload。</p>\n<p>这是为什么呢？因为服务端拿到 JWT 之后，会解析出其中包含的 Header、Payload 以及 Signature 。服务端会根据 Header、Payload、密钥再次生成一个 Signature。拿新生成的 Signature 和 JWT 中的 Signature 作对比，如果一样就说明 Header 和 Payload 没有被修改。</p>\n<p>不过，如果服务端的秘钥也被泄露的话，黑客就可以同时篡改 Signature、Header、Payload 了。黑客直接修改了 Header 和 Payload 之后，再重新生成一个 Signature 就可以了，这样服务端拿到解析出来Header、Payload 再用泄露的密钥进行生成，是和黑客生成的一样的；</p>\n<p><strong>密钥一定保管好，一定不要泄露出去。JWT 安全的核心在于签名，签名安全的核心在密钥。</strong></p>\n<h4 id=\"如何加强-JWT-的安全性？\"><a href=\"#如何加强-JWT-的安全性？\" class=\"headerlink\" title=\"如何加强 JWT 的安全性？\"></a>如何加强 JWT 的安全性？</h4><ol>\n<li>使用安全系数高的加密算法。</li>\n<li>使用成熟的开源库，没必要造轮子。</li>\n<li>JWT 存放在 localStorage 中而不是 Cookie 中，避免 CSRF 风险。</li>\n<li>一定不要将隐私信息存放在 Payload 当中。</li>\n<li>密钥一定保管好，一定不要泄露出去。JWT 安全的核心在于签名，签名安全的核心在密钥。</li>\n<li>Payload 要加入 exp （JWT 的过期时间），永久有效的 JWT 不合理。并且，JWT 的过期时间不易过长。</li>\n</ol>\n<h4 id=\"JWT优势\"><a href=\"#JWT优势\" class=\"headerlink\" title=\"JWT优势\"></a>JWT优势</h4><h5 id=\"1、-有效避免了-CSRF-攻击\"><a href=\"#1、-有效避免了-CSRF-攻击\" class=\"headerlink\" title=\"1、 有效避免了 CSRF 攻击\"></a>1、 有效避免了 CSRF 攻击</h5><p>总结来说就一句话：<strong>使用 JWT 进行身份验证不需要依赖 Cookie ，因此可以避免 CSRF 攻击(CSRF 攻击需要依赖 Cookie)。</strong></p>\n<h5 id=\"2、XSS攻击呢？\"><a href=\"#2、XSS攻击呢？\" class=\"headerlink\" title=\"2、XSS攻击呢？\"></a>2、XSS攻击呢？</h5><p>常见的避免 XSS 攻击的方式是过滤掉请求中存在 XSS 攻击风险的可疑字符串。</p>\n<h5 id=\"3、适合移动端、跨语言\"><a href=\"#3、适合移动端、跨语言\" class=\"headerlink\" title=\"3、适合移动端、跨语言\"></a>3、适合移动端、跨语言</h5><h5 id=\"4、单点登录友好\"><a href=\"#4、单点登录友好\" class=\"headerlink\" title=\"4、单点登录友好\"></a>4、单点登录友好</h5><h5 id=\"5、无状态-减轻服务端压力\"><a href=\"#5、无状态-减轻服务端压力\" class=\"headerlink\" title=\"5、无状态 减轻服务端压力\"></a>5、无状态 减轻服务端压力</h5><h4 id=\"JWT-身份认证常见问题及解决办法\"><a href=\"#JWT-身份认证常见问题及解决办法\" class=\"headerlink\" title=\"JWT 身份认证常见问题及解决办法\"></a>JWT 身份认证常见问题及解决办法</h4><h5 id=\"注销登录等场景下-JWT-还有效\"><a href=\"#注销登录等场景下-JWT-还有效\" class=\"headerlink\" title=\"注销登录等场景下 JWT 还有效\"></a>注销登录等场景下 JWT 还有效</h5><h6 id=\"1、将-JWT-存入内存数据库\"><a href=\"#1、将-JWT-存入内存数据库\" class=\"headerlink\" title=\"1、将 JWT 存入内存数据库\"></a><strong>1、将 JWT 存入内存数据库</strong></h6><p>redis 里面删除</p>\n<p><strong>2、黑名单机制</strong></p>\n<p>Redis 维护一个黑名单，每次使用 JWT 进行请求的话都会先判断这个 JWT 是否存在于黑名单中。</p>\n<p><strong>3、修改密钥 (Secret)</strong></p>\n<p>直接修改对应用户的密钥</p>\n<p>危害：1 如果是分布式项目 还要同步 2 多端的话 一端退出 另一端也退出了</p>\n<p><strong>4、保持令牌的有效期限短并经常轮换</strong></p>\n<p>但需要经常登录 </p>\n<h4 id=\"数据库账号密码\"><a href=\"#数据库账号密码\" class=\"headerlink\" title=\"数据库账号密码\"></a>数据库账号密码</h4><p>用一个加密slat实现</p>\n<h4 id=\"jwt退出登录-x2F-修改密码时如何使原来的token失效\"><a href=\"#jwt退出登录-x2F-修改密码时如何使原来的token失效\" class=\"headerlink\" title=\"jwt退出登录&#x2F;修改密码时如何使原来的token失效\"></a>jwt退出登录&#x2F;修改密码时如何使原来的token失效</h4><p>删除redis里面的token即可</p>\n<h4 id=\"用redis和不用的区别\"><a href=\"#用redis和不用的区别\" class=\"headerlink\" title=\"用redis和不用的区别\"></a>用redis和不用的区别</h4><p>1、<strong>用redis可以直接使jwt失效或者延期，方便</strong></p>\n<p>2、多个子系统可以访问redis数据库</p>\n<p>就单点登录里的token而言，单点登录是为了实现一次登录其他相互信任的系统不用登陆就可访问的效果，既然如此就不止一个系统，每个系统的数据存在不同的数据库中，A系统不可以访问B系统的数据库，若将token存在于A系统数据库中，B系统登录时就访问不到token，但是所有系统都可以访问redis缓存数据库，而且token具有时效性，而redis天然支持设置过期时长【set（key,value,毫秒值）】</p>\n<p>3、<strong>而且redis响应速度很快</strong></p>\n<p>登录时把jwt存进redis，设置成2倍的jwt有效期。登出删除redis保存的jwt。</p>\n<h4 id=\"如何防止jwt-token被窃取\"><a href=\"#如何防止jwt-token被窃取\" class=\"headerlink\" title=\"如何防止jwt token被窃取\"></a><strong>如何防止jwt token被窃取</strong></h4><p>1、采用更安全的传输协议https</p>\n<p>2、加密传输 （jwt默认不加密）</p>\n<p>3、代码层面也可以做安全检测，比如ip地址发生变化，MAC地址发生变化等等，可以要求重新登录</p>\n<p>4、使用<a href=\"https://so.csdn.net/so/search?q=%E7%A7%81%E9%92%A5&spm=1001.2101.3001.7020\">私钥</a>加密生成token 公钥解密获取token中的信息</p>\n<p>1）系统不能把jwt作为唯一的身份识别条件，不然被别人拿到了jwt就相当于获得了所有相关账户的权限，但对于这一点我还在学习中。2）存储jwt、传输的方式应该再加强。</p>\n<p>private static final String slat &#x3D; “mszlu!@#”;&#x2F;&#x2F;加密盐 因为数据库不能给人看密码  每次都用这一个字符串用来加密</p>\n<h4 id=\"token过期了怎么办？\"><a href=\"#token过期了怎么办？\" class=\"headerlink\" title=\"token过期了怎么办？\"></a>token过期了怎么办？</h4><p>我的项目是<strong>token不过期、redis记录过期</strong></p>\n<p><a href=\"https://juejin.cn/post/7126708538440679460\">https://juejin.cn/post/7126708538440679460</a></p>\n<h4 id=\"如何踢人下线\"><a href=\"#如何踢人下线\" class=\"headerlink\" title=\"如何踢人下线\"></a>如何踢人下线</h4><p>直接把token和存入redis里，验证有无token即可。踢人下线直接清除redis中的token。和笔者的思路是类似的。</p>\n<h3 id=\"2、ThreadLocal保存用户信息\"><a href=\"#2、ThreadLocal保存用户信息\" class=\"headerlink\" title=\"2、ThreadLocal保存用户信息\"></a>2、ThreadLocal保存用户信息</h3><p><strong>目的</strong></p>\n<p>方便鉴权，查询是否在线，减少数据库读操作</p>\n<p>token:sysUser</p>\n<p>不想用session(服务器存储 分布式)</p>\n<p>文章发布 需要用户id，直接拿，评论也是一样，<strong>方便</strong></p>\n<p>request获取？ 但是从设计上、代码分层上来说，</p>\n<p>并发问题</p>\n<p>降低redis使用？</p>\n<p><strong>redis中可以获取用户信息，但是因为redis中的key是token，要先拿到token才能拿到用户信息，但是token不是每个类中都存在，想在每个类都获取到用户信息</strong></p>\n<p>一般我们需要获取当前用户信息，放到缓存？每次解析token，然后传递？我们可以使用ThreadLocal来解决。将用户信息保存在线程中，当请求结束后我们在把保存的信息清除掉。这样我们才开发的时候就可以直接从全局的ThreadLocal中很方便的获取用户信息。当前线程在任何地方需要时，都可以使用 </p>\n<p><strong>步骤</strong></p>\n<ul>\n<li>创建ThreadLocal类，在其中设置相关的添加、获取以及删除方法。</li>\n<li>创建登录拦截器，重写其中的preHandle()（ThreadLocal.put()）和afterCompletion()(不用了手动remove)方法。</li>\n<li>webmvcConfig里面注册拦截器（告诉springmvc我们要拦截谁） 排除登录注册这种就行 其他都需要登录</li>\n</ul>\n<h4 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h4><p>Thread类中，有个ThreadLocal.ThreadLocalMap 的成员变量。ThreadLocalMap内部维护了Entry数组，每个Entry代表一个完整的对象，key是ThreadLocal本身，value是ThreadLocal的泛型对象值（我这个项目里面，key是Thread本身，value是用户对象）</p>\n<p>并发多线程场景下，每个线程Thread，在往ThreadLocal里设置值的时候，都是往自己的ThreadLocalMap里存，读也是以某个ThreadLocal作为引用，在自己的map里找对应的key，从而可以实现了<strong>线程隔离</strong>。</p>\n<h4 id=\"为什么不直接用线程id作为ThreadLocalMap的key呢？\"><a href=\"#为什么不直接用线程id作为ThreadLocalMap的key呢？\" class=\"headerlink\" title=\"为什么不直接用线程id作为ThreadLocalMap的key呢？\"></a>为什么不直接用线程id作为ThreadLocalMap的key呢？</h4><p>同一个线程，用了两个ThreadLocal成员变量的话。如果用线程id作为ThreadLocalMap的key，怎么区分哪个ThreadLocal成员变量呢？因此还是需要使用ThreadLocal作为Key来使用。每个ThreadLocal对象，都可以由threadLocalHashCode属性<strong>唯一区分</strong>的，每一个ThreadLocal对象都可以由这个对象的名字唯一区分</p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/image-20230321165330147.png\" alt=\"img\"></p>\n<h4 id=\"弱引用导致的内存泄漏呢？\"><a href=\"#弱引用导致的内存泄漏呢？\" class=\"headerlink\" title=\"弱引用导致的内存泄漏呢？\"></a>弱引用导致的内存泄漏呢？</h4><p>ThreadLocalMap使用ThreadLocal的<strong>弱引用</strong>作为key，当ThreadLocal变量被手动设置为null，即一个ThreadLocal没有外部强引用来引用它，当系统GC时，ThreadLocal一定会被回收。这样的话，ThreadLocalMap中就会出现key为null的Entry，就没有办法访问这些key为null的Entry的value，如果当前线程再迟迟不结束的话(比如线程池的核心线程)，这些key为null的Entry的value就会一直存在一条强引用链：Thread变量 -&gt; Thread对象 -&gt; ThreaLocalMap -&gt; Entry -&gt; value -&gt; Object 永远无法回收，造成内存泄漏。</p>\n<p>实际上，ThreadLocalMap的设计中已经考虑到这种情况。所以也加上了一些防护措施：即在ThreadLocal的get,set,remove方法，都会清除线程ThreadLocalMap里所有key为null的value。</p>\n<h4 id=\"key是弱引用，GC回收会影响ThreadLocal的正常工作嘛？\"><a href=\"#key是弱引用，GC回收会影响ThreadLocal的正常工作嘛？\" class=\"headerlink\" title=\"key是弱引用，GC回收会影响ThreadLocal的正常工作嘛？\"></a>key是弱引用，GC回收会影响ThreadLocal的正常工作嘛？</h4><p>不会的，因为有ThreadLocal变量引用着它，是不会被GC回收的，除非手动把ThreadLocal变量设置为null</p>\n<h4 id=\"ThreadLocal内存泄漏的demo\"><a href=\"#ThreadLocal内存泄漏的demo\" class=\"headerlink\" title=\"ThreadLocal内存泄漏的demo\"></a>ThreadLocal内存泄漏的demo</h4><p>用线程池，<strong>一直往里面放对象</strong></p>\n<p>因为我们使用了线程池，线程池有很长的生命周期，因此线程池会一直持有tianLuoClass(ThreadLocal泛型值)对象的value值，即使设置tianLuoClass &#x3D; null;引用还是存在的</p>\n<h4 id=\"为什么弱引用\"><a href=\"#为什么弱引用\" class=\"headerlink\" title=\"为什么弱引用\"></a>为什么弱引用</h4><p>当ThreadLocal的对象被回收了，因为ThreadLocalMap持有ThreadLocal的弱引用，即使没有手动remove删除，ThreadLocal也会被回收。value则在下一次ThreadLocalMap调用set,get，remove的时候会被清除。</p>\n<h4 id=\"InheritableThreadLocal保证父子线程间的共享数据\"><a href=\"#InheritableThreadLocal保证父子线程间的共享数据\" class=\"headerlink\" title=\"InheritableThreadLocal保证父子线程间的共享数据\"></a>InheritableThreadLocal保证父子线程间的共享数据</h4><p>在子线程中，是可以获取到父线程的 InheritableThreadLocal 类型变量的值，但是不能获取到 ThreadLocal 类型变量的值（因为ThreadLocal是线程隔离）。</p>\n<p>在Thread类中，除了成员变量threadLocals之外，还有另一个成员变量：inheritableThreadLocals。</p>\n<p>当parent的inheritableThreadLocals不为null时，就会将parent的inheritableThreadLocals，赋值给前线程的inheritableThreadLocals。说白了，就是如果当前线程的inheritableThreadLocals不为null，就从父线程哪里拷贝过来一个过来，类似于另外一个ThreadLocal，但是数据从父线程那里来的。有兴趣的小伙伴们可以在去研究研究源码~</p>\n<h4 id=\"ThreadLocal的应用场景和使用注意点\"><a href=\"#ThreadLocal的应用场景和使用注意点\" class=\"headerlink\" title=\"ThreadLocal的应用场景和使用注意点\"></a>ThreadLocal的应用场景和使用注意点</h4><p>ThreadLocal的<strong>很重要一个注意点</strong>，就是使用完，要手动调用remove()。</p>\n<p>而ThreadLocal的应用场景主要有以下这几种：</p>\n<ul>\n<li>使用日期工具类，当用到SimpleDateFormat，使用ThreadLocal保证线性安全</li>\n<li>全局存储用户信息（用户信息存入ThreadLocal，那么当前线程在任何地方需要时，都可以使用）</li>\n<li>保证同一个线程，获取的数据库连接Connection是同一个，使用ThreadLocal来解决线程安全的问题</li>\n<li>使用MDC保存日志信息。</li>\n</ul>\n<h4 id=\"ThreadLocal特点\"><a href=\"#ThreadLocal特点\" class=\"headerlink\" title=\"ThreadLocal特点\"></a>ThreadLocal特点</h4><p><strong>线程并发</strong>：在多线程并发场景下使用</p>\n<p><strong>传递数据：</strong>可以通过ThreadLocal在同一线程,不同组件中传递公共变量(保存每个线程的数据,在需要的地方可以直接获取, 避免参数直接传递带来的代码耦合问题)</p>\n<p><strong>线程隔离</strong>：每个线程的变量都是独立的, 不会互相影响</p>\n<h4 id=\"ThreadLocal-和Synchronized\"><a href=\"#ThreadLocal-和Synchronized\" class=\"headerlink\" title=\"ThreadLocal 和Synchronized\"></a>ThreadLocal 和Synchronized</h4><p>ThreadLocal模式与Synchronized关键字都用于处理多线程并发访问变量的问题</p>\n<p>ThreadLocal：以空间换取时间的思想, 为每一个线程都提供了一份变量的副本, 从而实现同访问而 互相不干扰。 多线程中让每个线程之间的数据相互隔离</p>\n<p>Synchronized：以时间换取空间的思想，只提供了一份变量, 让不同的线程排队访问。多个线程之间访问资源的同步</p>\n<h4 id=\"ThreadLocal不能解决共享变量的线程安全问题\"><a href=\"#ThreadLocal不能解决共享变量的线程安全问题\" class=\"headerlink\" title=\"ThreadLocal不能解决共享变量的线程安全问题\"></a>ThreadLocal不能解决共享变量的线程安全问题</h4><p>子线程访问父线程的共享变量时候，是“引用传递”，多个子线程访问的话所以线程不安全</p>\n<ul>\n<li>每个线程独享一份new出来的实例 -&gt; 线程安全</li>\n<li>多个线程共享一份“引用类型”实例 -&gt; 线程不安全</li>\n</ul>\n<h4 id=\"ThreadLocal与Thread同步机制的比较\"><a href=\"#ThreadLocal与Thread同步机制的比较\" class=\"headerlink\" title=\"ThreadLocal与Thread同步机制的比较\"></a>ThreadLocal与Thread同步机制的比较</h4><p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/image-20230329011433967.png\" alt=\"img\"></p>\n<h4 id=\"线性探测法\"><a href=\"#线性探测法\" class=\"headerlink\" title=\"线性探测法\"></a>线性探测法</h4><p>线性探测法顾名思义，就是解决冲突的函数是一个线性函数，最直接的就是在TreadLocal的代码中也用的是这样一个解决冲突的函数。</p>\n<p> f(x)&#x3D; x+1</p>\n<p>但是要注意的是TreadLocal中，是一个环状的探测，如果到达边界就会直接跨越边界到另一头去。</p>\n<p>线性探测法的优点：</p>\n<ol>\n<li>不用额外的空间（对比拉链法，需要额外链表）</li>\n<li>探测序列具有局部性，可以利用系统缓存，减少IO（连续的内存地址）</li>\n</ol>\n<p>缺点：</p>\n<ol>\n<li>耗费时间&gt;O(1)（最差O(n)）</li>\n<li>冲突增多——以往的冲突会导致后续的连环冲突(时间复杂度趋近O(n))</li>\n</ol>\n<p>之前我们说过，线性探测法有个问题是，一旦发生碰撞，很可能之后每次都会产生碰撞，导致连环撞车。而使用0x61c88647这个值做一个hash的增长值就可以从一定程度上解决这个问题让生成出来的值较为均匀地分布在2的幂大小的数组中。也就是说当我们用0x61c88647作为步长累加为每个ThreadLocal分配各自的ID也就是threadLocalHashCode再与2的幂取模，得到的结果分布很均匀。</p>\n<p>0x61c88647选取其实是与斐波那契散列有关，这个就是数学知识了，这里不展开。</p>\n<h3 id=\"3、日志记录放入线程池\"><a href=\"#3、日志记录放入线程池\" class=\"headerlink\" title=\"3、日志记录放入线程池\"></a>3、日志记录放入线程池</h3><h4 id=\"原因\"><a href=\"#原因\" class=\"headerlink\" title=\"原因\"></a>原因</h4><p>不能让记录日志出现失误影响用户的登录 写日志到磁盘里面会有IO的耗时，拖慢主线程时间</p>\n<p>为了出现错误时候的排查</p>\n<p>记录日志录入数据库时，脱离主线程，实现异步插入，这样不会拖延主线程的执行时间ps：记录日志，可以写在业务逻辑中，也可以利用<a href=\"https://so.csdn.net/so/search?q=aop&spm=1001.2101.3001.7020\">aop</a>自动记录。 </p>\n<h4 id=\"我的线程池参数？\"><a href=\"#我的线程池参数？\" class=\"headerlink\" title=\"我的线程池参数？\"></a>我的线程池参数？</h4><h5 id=\"一些参数\"><a href=\"#一些参数\" class=\"headerlink\" title=\"一些参数\"></a>一些参数</h5><p>衡量系统性能如何，主要指标系统的（QPS&#x2F;TPS）</p>\n<p>QPS：每秒能够处理请求&#x2F;事务的数量</p>\n<p>TPS：每秒能够处理事务的数量</p>\n<p>并发数：系统同时处理的请求&#x2F;事务的数量</p>\n<p>响应时间：就是平均处理一个请求&#x2F;事务需要时长</p>\n<p>QPS&#x2F;TPS &#x3D; 并发数&#x2F;响应时间（和两者都有关）</p>\n<h5 id=\"通用公式\"><a href=\"#通用公式\" class=\"headerlink\" title=\"通用公式\"></a>通用公式</h5><p>最佳线程数目 &#x3D; （（线程等待时间+线程CPU时间）&#x2F;线程CPU时间 ）* CPU数目</p>\n<h5 id=\"CPU密集-amp-amp-IO密集\"><a href=\"#CPU密集-amp-amp-IO密集\" class=\"headerlink\" title=\"CPU密集&amp;&amp;IO密集\"></a>CPU密集&amp;&amp;IO密集</h5><p>cpu密集：设为cpu核数+1，cpu都是满荷工作，加线程反而有上下文切换，多出的这一个线程是为了，当密集型的线程由于偶尔的内存页失效或其他原因导致阻塞时，这个额外的线程也能确保 CPU 的时钟周期不会被浪费，从而保证 CPU 的利用率。</p>\n<p>IO密集：线程数 &#x3D; CPU 核心数 * (1 + IO 耗时&#x2F; CPU 耗时)，和任务的平均等待时间相关，主要就是利用了被浪费掉的阻塞时间，还有一种公式CPU核数&#x2F;(1-阻塞系数) 阻塞系数在0.8~0.9之间</p>\n<p>最多线程数：2G&#x2F;100M&#x3D;2048</p>\n<p>以上只是一个公式，线程数设置多大，是根据我们自身的业务和QPS这些，需要自己去压力测试，设置一个合理的数值。</p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/QFR%7D%7D83L%60%5T_PO3GGRG@NR.png\" alt=\"img\"></p>\n<h4 id=\"关于异步\"><a href=\"#关于异步\" class=\"headerlink\" title=\"关于异步\"></a>关于异步</h4><p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/image-20230323114926875.png\" alt=\"img\"></p>\n<p>如果是注册这类的功能不适合异步，肯定要同步的，注册成功才返回成功。我这个上传视频到OSS要异步的原因是因为用户要先把视频发到我的云服务器中，云服务器再去接收到的视频放到阿里云OSS中，是两个步骤。如果要两个操作成功才返回给用户上传成功的话太久了。所以在用户上传视频到云服务器成功后就可以返回成功信息给用户了，后面服务器再自己把视频上传到OSS（这个过程挺慢的）。具体逻辑还不够完善（主要是钱没到位）。不是什么情况下都可以用异步处理的。要一个操作设计多个步骤，并且后续的步骤都和用户没什么关系的情况下才会考虑要不要异步处理（可以提供用户体验，不用一直等）。比如银行的某些代付交易，在上游的数据检查完成正常后就会直接返回上游交易成功，用户直接就看到了交易结果，后续的调用银行核心记账这些操作其实还在跑，可能几秒甚至几分钟后才是真正的交易完成。</p>\n<h4 id=\"步骤\"><a href=\"#步骤\" class=\"headerlink\" title=\"步骤\"></a>步骤</h4><p>1.配置<a href=\"https://so.csdn.net/so/search?q=%E7%BA%BF%E7%A8%8B%E6%B1%A0&spm=1001.2101.3001.7020\">线程池</a>（ThreadPoolTaskExecutor）2.自定义一个异步任务管理器3.自定义任务4.指定地点处，调用执行任务管理器，传入指定的任务</p>\n<h4 id=\"execute-vs-submit\"><a href=\"#execute-vs-submit\" class=\"headerlink\" title=\"execute() vs submit()\"></a>execute() vs submit()</h4><p>都是提交任务到线程池</p>\n<ul>\n<li><strong>execute()</strong> <strong>方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功与否；</strong></li>\n<li><strong>submit()方法用于提交需要返回值的任务。线程池会返回一个future类型的对象，通过这个future对象可以判断任务是否执行成功</strong>，并且可以通过future的get()方法来获取返回值，get()方法会阻塞当前线程直到任务完成，而使用 get（long timeout，TimeUnit unit）方法则会阻塞当前线程一段时间后立即返回，这时候有可能任务没有执行完。</li>\n</ul>\n<h4 id=\"为什么要用线程池？\"><a href=\"#为什么要用线程池？\" class=\"headerlink\" title=\"为什么要用线程池？\"></a>为什么要用线程池？</h4><p>资源消耗–重复利用 响应速度—立即执行 可管理性—线程池统一分配</p>\n<ul>\n<li><strong>降低资源消耗。</strong> 通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li>\n<li><strong>提高响应速度。</strong> 当任务到达时，任务可以不需要的等到线程创建就能立即执行。</li>\n<li><strong>提高线程的可管理性。</strong> 线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li>\n</ul>\n<h4 id=\"如何创建线程池\"><a href=\"#如何创建线程池\" class=\"headerlink\" title=\"如何创建线程池\"></a>如何创建线程池</h4><p>1、构造⽅法</p>\n<p>2、通过 Executor 框架的⼯具类 Executors 来实现 </p>\n<p>三种ThreadPoolExecutor:</p>\n<p>fixedThreadPool() 固定线程数</p>\n<p>SingleThreadExecutor 只有一个线程</p>\n<p>CachedThreadPool 根据情况调整 数量不固定</p>\n<h4 id=\"ThreadPoolExecutor-类分析\"><a href=\"#ThreadPoolExecutor-类分析\" class=\"headerlink\" title=\"ThreadPoolExecutor 类分析\"></a>ThreadPoolExecutor 类分析</h4><h4 id=\"ThreadPoolExecutor-构造函数七大参数分析\"><a href=\"#ThreadPoolExecutor-构造函数七大参数分析\" class=\"headerlink\" title=\"ThreadPoolExecutor 构造函数七大参数分析\"></a>ThreadPoolExecutor 构造函数七大参数分析</h4><hr>\n<ul>\n<li><p>corePoolSize ： 核心线程大小。线程池一直运行，核心线程就不会停止。</p>\n</li>\n<li><p>maximumPoolSize ：线程池最大线程数量。非核心线程数量&#x3D;maximumPoolSize-corePoolSize</p>\n</li>\n<li><p>keepAliveTime ：非核心线程的心跳时间。如果非核心线程在keepAliveTime内没有运行任务，非核心线程会消亡。</p>\n</li>\n<li><p>workQueue ：阻塞队列。ArrayBlockingQueue，LinkedBlockingQueue等，用来存放线程任务。</p>\n</li>\n<li><p>defaultHandler ：饱和策略。ThreadPoolExecutor类中一共有4种饱和策略。通过实现RejectedExecutionHandler接口。饱和策略</p>\n</li>\n<li><ul>\n<li>AbortPolicy ： 线程任务丢弃报错。默认饱和策略。</li>\n<li>DiscardPolicy ： 线程任务直接丢弃不报错。</li>\n<li>DiscardOldestPolicy ： 将workQueue<strong>队首任务丢弃</strong>，将最新线程任务重新加入队列执行。</li>\n<li>CallerRunsPolicy ：线程池之外的线程直接调用run方法执行。</li>\n</ul>\n</li>\n<li><p>ThreadFactory ：线程工厂。新建线程工厂。</p>\n</li>\n</ul>\n<h4 id=\"线程池原理分析\"><a href=\"#线程池原理分析\" class=\"headerlink\" title=\"线程池原理分析\"></a>线程池原理分析</h4><p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/1460000039258685\" alt=\"img\"></p>\n<ol>\n<li>线程池执行execute&#x2F;submit方法向线程池添加任务，当任务小于核心线程数corePoolSize，线程池中肯定可以创建新的线程。</li>\n<li>当任务大于核心线程数corePoolSize，看看阻塞队列满了没，没满的话，就向阻塞队列添加任务，如果满的话，看看任务数和最大线程数的关系，如果还小于最大线程数的话，那我创建非核心线程。</li>\n<li>如果线程数量大于maximumPoolSize，说明当前设置线程池中线程已经处理不了了，就会执行饱和策略。</li>\n</ol>\n<h4 id=\"常见java线程池\"><a href=\"#常见java线程池\" class=\"headerlink\" title=\"常见java线程池\"></a>常见java线程池</h4><p><strong>1、newCachedThreadPool</strong></p>\n<p>创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。</p>\n<p>这种类型的线程池特点是：</p>\n<p>工作线程的创建数量几乎没有限制(其实也有限制的,数目为Interger. MAX_VALUE), 这样可灵活的往线程池中添加线程。</p>\n<p><strong>不足</strong>：这种方式虽然可以根据业务场景自动的扩展线程数来处理我们的业务，但是最多需要多少个线程同时处理缺是我们无法控制的；</p>\n<p><strong>优点</strong>：如果当第二个任务开始，第一个任务已经执行结束，那么第二个任务会复用第一个任务创建的线程，并不会重新创建新的线程，提高了线程的复用率；</p>\n<p><strong>2、newFixedThreadPool</strong></p>\n<p>创建一个指定工作线程数量的线程池。每当提交一个任务就创建一个工作线程，如果工作线程数量达到线程池初始的最大数，则将提交的任务存入到队列中。</p>\n<p><strong>缺点：</strong>它具有线程池提高程序效率和节省创建线程时所耗的开销的优点。但是，在线程池空闲时，即线程池中没有可运行任务时，它不会释放工作线程，还会占用一定的系统资源。</p>\n<p><strong>优点</strong>：newFixedThreadPool的线程数是可以进行控制的，因此我们可以通过控制最大线程来使我们的服务器打到最大的使用率，同事又可以保证及时流量突然增大也不会占用服务器过多的资源。</p>\n<p><strong>3、newSingleThreadExecutor</strong></p>\n<p>创建一个单线程化的Executor，只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。如果这个线程异常结束，会有另一个取代它，保证顺序执行。单工作线程最大的特点是可保证顺序地执行各个任务，并且在任意给定的时间不会有多个线程是活动的。</p>\n<p><strong>4、newScheduleThreadPool</strong></p>\n<p>创建一个定长的线程池，而且支持定时的以及周期性的任务执行，支持定时及周期性任务执行。</p>\n<h4 id=\"线程池常用的阻塞队列有哪些\"><a href=\"#线程池常用的阻塞队列有哪些\" class=\"headerlink\" title=\"线程池常用的阻塞队列有哪些?\"></a>线程池常用的阻塞队列有哪些?</h4><p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/20200722164307306.png\" alt=\"img\"></p>\n<p>表格左侧是线程池，右侧为它们对应的阻塞队列，可以看到 5 种线程池对应了 3 种阻塞队列</p>\n<ol>\n<li>LinkedBlockingQueue （针对FixedThreadPool 和 SingleThreadExector），容量为 Integer.MAX_VALUE。 可以认为<strong>是无界队列</strong>。由于 线程池的线程数是固定的，所以没有办法增加特别多的线程来处理任务，因此需要这样一个没有容量限制的阻塞队列来存放任务。由于线程池的任务队列永远不会放满，所以线程池只会创建核心线程数量的线程，所以此时的最大线程数对线程池来说没有意义，因为并不会触发生成多于核心线程数的线程。</li>\n<li>SynchronousQueue 第二种阻塞队列是 SynchronousQueue，对应的线程池是 CachedThreadPool。线程池 CachedThreadPool 的最大线程数是 Integer 的最大值，可以理解为线程数是可以无限扩展的。CachedThreadPool 和上一种线程池 FixedThreadPool 的情况恰恰相反，FixedThreadPool 的情况是阻塞队列的容量是无限的，而这里 CachedThreadPool 是线程数可以无限扩展，所以 CachedThreadPool 线程池并不需要一个任务队列来存储任务，因为一旦有任务被提交就直接转发给线程或者创建新线程来执行，而不需要另外保存它们。 我们自己创建使用 SynchronousQueue 的线程池时，如果不希望任务被拒绝，那么就<strong>需要注意设置最大线程数要尽可能大一些，以免发生任务数大于最大线程数时，没办法把任务放到队列中也没有足够线程来执行任务的情况。</strong></li>\n<li>DelayedWorkQueue 第三种阻塞队列是DelayedWorkQueue，它对应的线程池分别是 ScheduledThreadPool 和 SingleThreadScheduledExecutor，这两种线程池的最大特点就是可以延迟执行任务，比如说一定时间后执行任务或是每隔一定的时间执行一次任务。</li>\n</ol>\n<p>DelayedWorkQueue 的特点是内部元素并不是按照放入的时间排序，而是会按照延迟的时间长短对任务进行排序，内部采用的是“堆”的数据结构。之所以线程池 ScheduledThreadPool 和 SingleThreadScheduledExecutor 选择 DelayedWorkQueue，是因为它们本身正是基于时间执行任务的，而延迟队列正好可以把任务按时间进行排序，方便任务的执行。</p>\n<h4 id=\"源码中线程池是怎么复用线程的？\"><a href=\"#源码中线程池是怎么复用线程的？\" class=\"headerlink\" title=\"源码中线程池是怎么复用线程的？\"></a>源码中线程池是怎么复用线程的？</h4><hr>\n<p>源码中ThreadPoolExecutor中有个内置对象Worker，每个worker都是一个线程，worker线程数量和参数有关，每个worker会while死循环从阻塞队列中取数据，<strong>通过置换worker中Runnable对象，运行其run方法起到线程置换的效果</strong>，这样做的好处是避免多线程频繁线程切换，提高程序运行性能。</p>\n<h4 id=\"Executor和Executors的区别？\"><a href=\"#Executor和Executors的区别？\" class=\"headerlink\" title=\"Executor和Executors的区别？\"></a>Executor和Executors的区别？</h4><p><strong>Executors ：按照需求创建了不同的线程池，来满足业务的需求。</strong></p>\n<p><strong>Executor ：执行线程任务 获得任务执行的状态并且可以获取任务的返回值。</strong></p>\n<p>使用ThreadPoolExecutor 可以创建自定义线程池。Future 表示异步计算的结果，他提供了检查计算是否完成的方法，以等待计算的完成，并可以使用get()方法获取计算的结果</p>\n<h4 id=\"线程池应用场景\"><a href=\"#线程池应用场景\" class=\"headerlink\" title=\"线程池应用场景\"></a>线程池应用场景</h4><p><strong>1、异步发送邮件通知</strong>发送一个任务，然后注入到线程池中异步发送。</p>\n<p><strong>2、心跳请求任务</strong>创建一个任务，然后定时发送请求到线程池中。</p>\n<p>3、如果用户量比较大，导致占用过多的资源，可能会导致我们的服务由于资源不足而宕机；</p>\n<p>3.1 线程池中线程的使用率提升，减少对象的创建、销毁；</p>\n<p>3.2 线程池可以控制线程数，有效的提升<a href=\"https://cloud.tencent.com/product/cvm?from=20065&from_column=20065\">服务器</a>的使用资源，避免由于资源不足而发生宕机等问题；</p>\n<h3 id=\"4、Elasticsearch搜索-同步数据到索引\"><a href=\"#4、Elasticsearch搜索-同步数据到索引\" class=\"headerlink\" title=\"4、Elasticsearch搜索 +同步数据到索引\"></a>4、Elasticsearch搜索 +同步数据到索引</h3><h4 id=\"前言知识\"><a href=\"#前言知识\" class=\"headerlink\" title=\"前言知识\"></a>前言知识</h4><p>步骤：</p>\n<p>1、请求参数实体类+返回结果实体类</p>\n<p>2、controller service</p>\n<p>3、准备request、DSL语句，发送请求、解析响应</p>\n<p>4、封装返回</p>\n<p>根据标题和</p>\n<h5 id=\"索引库操作\"><a href=\"#索引库操作\" class=\"headerlink\" title=\"索引库操作\"></a>索引库操作</h5><p>引库操作有哪些？</p>\n<ul>\n<li>创建索引库：PUT &#x2F;索引库名</li>\n<li>查询索引库：GET &#x2F;索引库名</li>\n<li>删除索引库：DELETE &#x2F;索引库名</li>\n<li>添加字段：PUT &#x2F;索引库名&#x2F;_mapping</li>\n</ul>\n<h5 id=\"文档操作\"><a href=\"#文档操作\" class=\"headerlink\" title=\"文档操作\"></a>文档操作</h5><ul>\n<li><p>创建文档：POST &#x2F;{索引库名}&#x2F;_doc&#x2F;文档id { json文档 }</p>\n</li>\n<li><p>查询文档：GET &#x2F;{索引库名}&#x2F;_doc&#x2F;文档id</p>\n</li>\n<li><p>删除文档：DELETE &#x2F;{索引库名}&#x2F;_doc&#x2F;文档id</p>\n</li>\n<li><p>修改文档：</p>\n</li>\n<li><ul>\n<li>全量修改：PUT &#x2F;{索引库名}&#x2F;_doc&#x2F;文档id { json文档 }</li>\n<li>增量修改：POST &#x2F;{索引库名}&#x2F;_update&#x2F;文档id { “doc”: {字段}}</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"搜索\"><a href=\"#搜索\" class=\"headerlink\" title=\"搜索\"></a>搜索</h4><p>排序：</p>\n<p>排序通过热度和最新两个条件进行排序</p>\n<p>高亮：</p>\n<ul>\n<li>高亮是对关键字高亮，因此<strong>搜索条件必须带有关键字</strong>，而不能是范围这样的查询。</li>\n<li>默认情况下，<strong>高亮的字段，必须与搜索指定的字段一致</strong>，否则无法高亮</li>\n<li>如果要对非搜索字段高亮，则需要添加一个属性：required_field_match&#x3D;false</li>\n</ul>\n<p>高亮显示的实现分为两步：</p>\n<ul>\n<li>1）给文档中的所有关键字都添加一个标签，例如<em>标签</em></li>\n<li>2）页面给<em>标签编写CSS样式</em></li>\n</ul>\n<p>高亮的结果与查询的文档结果默认是分离的，并不在一起。</p>\n<p>因此解析高亮的代码需要额外处理：</p>\n<ul>\n<li>第一步：从结果中获取source。hit.getSourceAsString()，这部分是非高亮结果，json字符串。还需要反序列为HotelDoc对象</li>\n<li>第二步：获取高亮结果。hit.getHighlightFields()，返回值是一个Map，key是高亮字段名称，值是HighlightField对象，代表高亮值</li>\n<li>第三步：从map中根据高亮字段名称，获取高亮字段值对象HighlightField</li>\n<li>第四步：从HighlightField中获取Fragments，并且转为字符串。这部分就是真正的高亮字符串了</li>\n<li>第五步：用高亮的结果替换HotelDoc中的非高亮结果</li>\n</ul>\n<pre><code class=\"plain\">GET /hotel/_search\n&#123;\n  &quot;query&quot;: &#123;\n    &quot;match&quot;: &#123;\n      &quot;FIELD&quot;: &quot;TEXT&quot; // 查询条件，高亮一定要使用全文检索查询\n    &#125;\n  &#125;,\n  &quot;highlight&quot;: &#123;\n    &quot;fields&quot;: &#123; // 指定要高亮的字段\n      &quot;FIELD&quot;: &#123;\n        &quot;pre_tags&quot;: &quot;&lt;em&gt;&quot;,  // 用来标记高亮字段的前置标签\n        &quot;post_tags&quot;: &quot;&lt;/em&gt;&quot; // 用来标记高亮字段的后置标签\n      &#125;\n    &#125;\n  &#125;\n&#125;\n</code></pre>\n<h4 id=\"数据同步\"><a href=\"#数据同步\" class=\"headerlink\" title=\"数据同步\"></a>数据同步</h4><ul>\n<li>hotel-admin对mysql数据库数据完成增、删、改后，发送MQ消息</li>\n<li>hotel-demo监听MQ，接收到消息后完成elasticsearch数据修改</li>\n</ul>\n<p>或者用canal（完全解除服务间耦合，但也增加数据库负担？）</p>\n<ul>\n<li>给mysql开启binlog功能</li>\n<li>mysql完成增、删、改操作都会记录在binlog中</li>\n<li>hotel-demo基于canal监听binlog变化，实时更新elasticsearch中的内容</li>\n</ul>\n<p>步骤：</p>\n<p>1、声明队列交换机名称，以及定义配置类，声明队列、交换机以及绑定关系</p>\n<p>2、发送MQ消息，接受MQ消息，做具体的索引库操作，编写监听器，当有消息来了就执行接受消息做对应业务</p>\n<h4 id=\"分词器\"><a href=\"#分词器\" class=\"headerlink\" title=\"分词器\"></a>分词器</h4><ul>\n<li>ik_max_word细粒度切分，尽可能多地拆分出词语</li>\n<li>ik_smart智能切分，最粗粒度，已经被切分的词语不会再被其他词语占有</li>\n</ul>\n<h4 id=\"数据同步-1\"><a href=\"#数据同步-1\" class=\"headerlink\" title=\"数据同步\"></a>数据同步</h4><p>全量同步增量同步<img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/f9b5747185ff4e03a3a8301be50def8f.png\" alt=\"img\"></p>\n<p># </p>\n<h4 id=\"步骤-1\"><a href=\"#步骤-1\" class=\"headerlink\" title=\"步骤\"></a>步骤</h4><p>1、导包 做配置</p>\n<p>2、配置Document</p>\n<p>先要配置实体和ES的映射，通过在实体类中加入注解的方式来自动映射跟索引，我这里是配置了product索引和实体的映射</p>\n<p>3、使用ElasticsearchRestTemplate</p>\n<p>在Spring启动的时候自动注入了该Bean，它封装了操作Elasticsearch的增删改查API</p>\n<p><em>完全匹配查询条件</em> –&gt; <em>按照阅读量排序</em>—&gt;<em>高亮显示</em>—&gt;分页</p>\n<h4 id=\"es刷新时间\"><a href=\"#es刷新时间\" class=\"headerlink\" title=\"es刷新时间\"></a>es刷新时间</h4><p>1s 为什么要延长 es主要业务写日志</p>\n<h4 id=\"倒排索引\"><a href=\"#倒排索引\" class=\"headerlink\" title=\"倒排索引\"></a>倒排索引</h4><ul>\n<li>将每一个文档(每一条数据)的数据利用算法分词，得到一个个词条</li>\n<li>创建表，每行数据包括词条、词条所在文档id、位置等信息</li>\n<li>因为词条唯一性，可以给词条创建索引，例如hash表结构索引</li>\n</ul>\n<p>倒排索引的<strong>搜索流程</strong>如下（以搜索”华为手机”为例）：</p>\n<p>1）用户输入条件”华为手机”进行搜索。</p>\n<p>2）对用户输入内容<strong>分词</strong>，得到词条：华为、手机。</p>\n<p>3）拿着词条在倒排索引中查找，可以得到包含词条的文档id：1、2、3。</p>\n<p>4）拿着文档id到正向索引中查找具体文档。</p>\n<ul>\n<li>Mysql：擅长事务类型操作，可以确保数据的安全和一致性</li>\n<li>Elasticsearch：擅长海量数据的搜索、分析、计算</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th><strong>MySQL</strong></th>\n<th><strong>Elasticsearch</strong></th>\n<th><strong>说明</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Table</td>\n<td>Index</td>\n<td>索引(index)，就是文档的集合，类似数据库的表(table)</td>\n</tr>\n<tr>\n<td>Row</td>\n<td>Document</td>\n<td>文档（Document），就是一条条的数据，类似数据库中的行（Row），文档都是JSON格式</td>\n</tr>\n<tr>\n<td>Column</td>\n<td>Field</td>\n<td>字段（Field），就是JSON文档中的字段，类似数据库中的列（Column）</td>\n</tr>\n<tr>\n<td>Schema</td>\n<td>Mapping</td>\n<td>Mapping（映射）是索引中文档的约束，例如字段类型约束。类似数据库的表结构（Schema）</td>\n</tr>\n<tr>\n<td>SQL</td>\n<td>DSL</td>\n<td>DSL是elasticsearch提供的JSON风格的请求语句，用来操作elasticsearch，实现CRUD</td>\n</tr>\n</tbody></table>\n<h3 id=\"5、阅读评论数放入Redis中\"><a href=\"#5、阅读评论数放入Redis中\" class=\"headerlink\" title=\"5、阅读评论数放入Redis中\"></a>5、阅读评论数放入Redis中</h3><p>查看完文章了，新增阅读数，做了一个更新操作，更新时加写锁，阻塞其他的读操作，性能就会比较低（没办法解决，增加阅读数必然要加锁）</p>\n<p>更新增加了此次接口的耗时（考虑减少耗时）如果一旦更新出问题，不能影响查看操作线程池 可以把更新操作扔到 线程池中去执行和主线程就不相关了threadService.updateArticleViewCount(articleMapper, article);</p>\n<p><strong>在这里我们采用redis incr自增实现</strong></p>\n<p>redis<a href=\"https://so.csdn.net/so/search?q=%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1&spm=1001.2101.3001.7020\">定时任务</a>自增实现阅读数和评论数更新</p>\n<p>阅读数和评论数 ，考虑把阅读数和评论数 增加的时候 放入redis incr自增，使用定时任务 定时把数据固话到数据库当中</p>\n<p><strong>定时任务</strong> ：遍历redis中前缀是VIEW_COUNT的所有key，通过sub<a href=\"https://so.csdn.net/so/search?q=String%E6%96%B9%E6%B3%95&spm=1001.2101.3001.7020\">String方法</a>获取文章id，获取key存储的阅读数，把文章id和阅读数放入ViewCountQuery对象中，对象放入list集合中，批量更新</p>\n<pre><code class=\"plain\">@Async(&quot;taskExecutor&quot;)\n    @Scheduled(cron = &quot;0 0/5 * * * ?&quot;)\n    @LogAnnotation(module = &quot;定时同步任务&quot;,operator = &quot;文章评论数&quot;)\n</code></pre>\n<p><a href=\"https://blog.csdn.net/m0_52914401/article/details/124343310?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0-124343310-blog-125651961.pc_relevant_recovery_v2&amp;spm=1001.2101.3001.4242.1&amp;utm_relevant_index=3\">https://blog.csdn.net/m0_52914401/article/details/124343310?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0-124343310-blog-125651961.pc_relevant_recovery_v2&amp;spm=1001.2101.3001.4242.1&amp;utm_relevant_index=3</a></p>\n<p><strong>评论查询功能如何实现？</strong></p>\n<p>循环查表先查父评论，再根据父评论id和parentId找子评论</p>\n<p>通过父评论找子评论 当前文章id是子评论的parentId字段 ，所以findCommentsByParentId方法找到子评论 ，查到并封装到comment类然后set到Childrens里面，这里面递归调用</p>\n<h3 id=\"6-1、RabbitMQ解决缓存不一致\"><a href=\"#6-1、RabbitMQ解决缓存不一致\" class=\"headerlink\" title=\"6.1、RabbitMQ解决缓存不一致\"></a>6.1、RabbitMQ解决缓存不一致</h3><p>我在教程更新和发布的接口上面定义了缓存（redis存）注解Cache，对常用接口的数据进行缓存，提高响应速度 ，面向切面编程</p>\n<p>问题：会出现数据库更新了但是缓存还没过期，于是用rabbitMQ去做一个更新缓存的操作，更新查看文章详情的缓存，最新文章，文章列表的缓存 不知道参数,解决办法 直接删除缓存</p>\n<p>相当于放到队列里面修改缓存 好处解耦异步</p>\n<h5 id=\"1、先写缓存再数据库\"><a href=\"#1、先写缓存再数据库\" class=\"headerlink\" title=\"1、先写缓存再数据库\"></a>1、先写缓存再数据库</h5><p>—问题：数据库写失败，缓存是脏数据2</p>\n<h5 id=\"2、先更新数据库再更新缓存\"><a href=\"#2、先更新数据库再更新缓存\" class=\"headerlink\" title=\"2、先更新数据库再更新缓存\"></a>2、先更新数据库再更新缓存</h5><p>—问题：</p>\n<p>一、一般只是数据库7操作加事务，所以缓存如果写失败，依然数据不一致</p>\n<p>二、A请求更新数据库后写缓存卡顿，B请求正常双更，然后A再更新缓存，会出现缓存不一致</p>\n<h5 id=\"3、先删除缓存，后更新数据库\"><a href=\"#3、先删除缓存，后更新数据库\" class=\"headerlink\" title=\"3、先删除缓存，后更新数据库\"></a>3、先删除缓存，后更新数据库</h5><p>写请求删除缓存，然后更新数据库卡了，读请求查缓存为空，然后把数据库旧值拿到缓存里面，这样出现了缓存数据库不一致的情况</p>\n<p><strong>解决办法</strong>：延迟双删，等读请求结束后写请求再删除一次，也就是读请求把缓存更新后写缓存再去删除</p>\n<h6 id=\"答案一：延时双删\"><a href=\"#答案一：延时双删\" class=\"headerlink\" title=\"答案一：延时双删\"></a>答案一：延时双删</h6><p>（1）先淘汰缓存 </p>\n<p>（2）再写数据库</p>\n<p>（3）休眠1秒，再次淘汰缓存，这么做，可以将1秒内所造成的缓存脏数据，再次删除。<strong>确保读请求结束，写请求可以删除读请求造成的缓存脏数据</strong>。自行评估自己的项目的读数据业务逻辑的耗时，<strong>写数据的休眠时间则在读数据业务逻辑的耗时基础上，加几百ms即可。</strong></p>\n<p>第二次删除要在读请求把缓存更新后再去删除</p>\n<p>（我的理解：请求A先删缓存再往DB写数据，就算这时B来查数据库，缓存没数据，然后查DB，此时查到的是旧数据，写到缓存，A等待B写完之和再删缓存，这样就缓存一致）</p>\n<p>如果使用的是 Mysql 的<strong>读写分离的架构的话</strong>，那么其实主从同步之间也会有时间差。</p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/1735bb5881bbb1d4~tplv-t2oaga2asx-watermark.awebp\" alt=\"img\"></p>\n<p>此时来了两个请求，请求 A（更新操作） 和请求 B（查询操作）</p>\n<ol>\n<li>请求 A 更新操作，删除了 Redis</li>\n<li>请求主库进行更新操作，主库与从库进行同步数据的操作</li>\n<li>请 B 查询操作，发现 Redis 中没有数据</li>\n<li>去从库中拿去数据</li>\n<li>此时同步数据(binlog没写完)还未完成，拿到的数据是旧数据</li>\n</ol>\n<p>此时的解决办法就是如果是对 Redis 进行填充数据的查询数据库操作，那么就强制将其指向主库进行查询。</p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/1735bb5881a19fec~tplv-t2oaga2asx-watermark.awebp\" alt=\"img\"></p>\n<h6 id=\"答案二：-更新与读取操作进行异步串行化\"><a href=\"#答案二：-更新与读取操作进行异步串行化\" class=\"headerlink\" title=\"答案二： 更新与读取操作进行异步串行化\"></a>答案二： 更新与读取操作进行异步串行化</h6><p>采用<strong>更新与读取操作进行异步串行化</strong></p>\n<p><strong>异步串行化</strong></p>\n<p>我在系统内部维护n个内存队列，更新数据的时候，根据数据的唯一标识，将该操作路由之后，发送到其中一个jvm内部的内存队列中（对同一数据的请求发送到同一个队列）。读取数据的时候，如果发现数据不在缓存中，并且此时队列里有更新库存的操作，那么将重新读取数据+更新缓存的操作，根据唯一标识路由之后，也将发送到同一个jvm内部的内存队列中。然后每个队列对应一个工作线程，每个工作线程串行地拿到对应的操作，然后一条一条的执行。</p>\n<p>这样的话，<strong>一个数据变更的操作，先执行删除缓存，然后再去更新数据库，但是还没完成更新的时候，如果此时一个读请求过来，读到了空的缓存，那么可以先将缓存更新的请求发送到队列中，此时会在队列中积压，排在刚才更新库的操作之后，然后同步等待缓存更新完成，再读库。</strong></p>\n<p><strong>读操作去重</strong></p>\n<p>多个读库更新缓存的请求串在同一个队列中是没意义的，因此可以做过滤，如果发现队列中已经有了该数据的更新缓存的请求了，那么就不用再放进去了，直接等待前面的更新操作请求完成即可，待那个队列对应的工作线程完成了上一个操作（数据库的修改）之后，才会去执行下一个操作（读库更新缓存），此时会从数据库中读取最新的值，然后写入缓存中。</p>\n<p><strong>如果请求还在等待时间范围内，不断轮询发现可以取到值了，那么就直接返回；如果请求等待的时间超过一定时长，那么这一次直接从数据库中读取当前的旧值。</strong>（返回旧值不是又导致缓存和数据库不一致了么？那至少可以减少这个情况发生，因为等待超时也不是每次都是，几率很小吧。这里我想的是，如果超时了就直接读旧值，这时候仅仅是读库后返回而不放缓存）</p>\n<h5 id=\"4、先更新数据库，后删除缓存\"><a href=\"#4、先更新数据库，后删除缓存\" class=\"headerlink\" title=\"4、先更新数据库，后删除缓存\"></a>4、先更新数据库，后删除缓存</h5><p><strong>情况</strong>：这一种情况也会出现问题，比如更新数据库成功了，但是在删除缓存的阶段出错了没有删除成功，那么此时再读取缓存的时候每次都是错误的数据了。</p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/1735bb5881fb4a1b~tplv-t2oaga2asx-watermark.awebp\" alt=\"img\"></p>\n<p>有多种解决方案：</p>\n<p>1、同步，并发大的时候，影响性能</p>\n<p>2、异步，线程池</p>\n<p>3、 mq,consumer</p>\n<p>此时解决方案就是利用消息队列进行<strong>删除的补偿</strong>。具体的业务逻辑用语言描述如下：</p>\n<ol>\n<li>请求 A 先对数据库进行更新操作</li>\n<li>在对 Redis 进行删除操作的时候发现报错，删除失败</li>\n<li>此时将Redis 的 key 作为消息体发送到消息队列中</li>\n<li>系统接收到消息队列发送的消息后再次对 Redis 进行删除操作，一般设定5次，只要5次里面有一次成功，就返回成功，失败的话，放入死信交换机</li>\n</ol>\n<p>但是这个方案会有一个缺点就是会对业务代码造成大量的侵入，深深的耦合在一起，所以这时会有一个优化的方案，我们知道对 Mysql 数据库更新操作后在binlog 日志中我们都能够找到相应的操作，那么我们可以订阅 Mysql 数据库的 binlog 日志对缓存进行操作。</p>\n<p>也就是canal，当写数据库时，binlog变化，mq订阅Binlog，后续操作和mq删缓存一样。</p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/1735bb588215b298~tplv-t2oaga2asx-watermark.awebp\" alt=\"img\"></p>\n<h3 id=\"6、RabbitMQ消息队列实现ES和数据库的数据同步\"><a href=\"#6、RabbitMQ消息队列实现ES和数据库的数据同步\" class=\"headerlink\" title=\"6、RabbitMQ消息队列实现ES和数据库的数据同步\"></a>6、RabbitMQ消息队列实现ES和数据库的数据同步</h3><p>主要是增删改帖子</p>\n<p>这里用的Direct队列</p>\n<ul>\n<li>Fanout交换机将消息路由给每一个与之绑定的队列</li>\n<li>Direct交换机根据RoutingKey判断路由给哪个队列</li>\n<li>如果多个队列具有相同的RoutingKey，则与Fanout功能类似</li>\n</ul>\n<h4 id=\"步骤-2\"><a href=\"#步骤-2\" class=\"headerlink\" title=\"步骤\"></a>步骤</h4><p>1、导包：spring-boot-starter-amqp</p>\n<p>SpringAMQP是基于RabbitMQ封装的一套模板，并且还利用SpringBoot对其实现了自动装配，使用起来非常方便。</p>\n<p>2、添加配置</p>\n<pre><code class=\"plain\">spring:\nrabbitmq:\nhost: localhost\nport: 5672\nusername: admin\npassword: 123456\nvirtual-host: myHost\n</code></pre>\n<p>3、<em>RabbitMQ的配置</em> 声明Exchange、Queue、RoutingKey</p>\n<p>4、生产者对应的增删改里面发送消息</p>\n<p>所谓的生产者就是我们数据库的服务方，当我们对数据库的数据进行增删改的时候，我们应该像消息队列发送消息来通知ES我们进行了增删改操作，以便ES进行数据的同步。</p>\n<p>5、消费者MQListener监听消息</p>\n<p>所谓的消费者就是ES服务的操作方，通过实时的对消息队列的监听，通过消息队列对应的key值来进行选择服务的调用，不同的key调用不同的服务，获取服务方传输的数据，然后进行数据的同步。</p>\n<h3 id=\"7、死信交换机\"><a href=\"#7、死信交换机\" class=\"headerlink\" title=\"7、死信交换机\"></a>7、死信交换机</h3><h4 id=\"目的\"><a href=\"#目的\" class=\"headerlink\" title=\"目的\"></a>目的</h4><p>实现消息的延迟投递，避免消息丢失或无限制的重试 </p>\n<h4 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h4><p>当你在消费消息时，如果队列里的消息出现以下情况1，<strong>消息被否定确认</strong>，使用 channel.basicNack 或channel.basicReject ，并且此时requeue 属性被设置为false。2，消息在队列的<strong>存活时间超过设置的TTL时间</strong>。3，消息队列的<strong>消息数量已经超过最大队列长度</strong>。</p>\n<p>那么该消息将成为“死信”。“死信”消息会被RabbitMQ进行特殊处理，如果配置了死信队列信息，那么该消息将会被丢进死信队列中，如果没有配置，则该消息将会被丢弃。</p>\n<h4 id=\"步骤-3\"><a href=\"#步骤-3\" class=\"headerlink\" title=\"步骤\"></a>步骤</h4><p>大概可以分为以下步骤：</p>\n<p>1，配置业务队列，绑定到业务交换机上2，为业务队列配置死信交换机和路由key3，为死信交换机配置死信队列</p>\n<p>为每个需要使用死信的业务队列配置一个死信交换机，这里同一个项目的死信交换机可以共用一个，然后为每个业务队列分配一个单独的路由key。</p>\n<p>有了死信交换机和路由key后，接下来，就像配置业务队列一样，配置死信队列，然后绑定在死信交换机上。也就是说，死信队列并不是什么特殊的队列，只不过是绑定在死信交换机上的队列。死信交换机也不是什么特殊的交换机，只不过是用来接受死信的交换机，所以可以为任何类型【Direct、Fanout、Topic】。一般来说，会为每个业务队列分配一个独有的路由key，并对应的配置一个死信队列进行监听，也就是说，一般会为每个重要的业务队列配置一个死信队列。</p>\n<h4 id=\"死信消息变化\"><a href=\"#死信消息变化\" class=\"headerlink\" title=\"死信消息变化\"></a>死信消息变化</h4><p>如果队列配置了参数 x-dead-letter-routing-key 的话，“死信”的路由key将会被替换成该参数对应的值。如果没有设置，则保留该消息原有的路由key。</p>\n<h4 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h4><p>确保未被正确消费的消息不被丢弃（更新删除修改帖子）</p>\n<p><strong>发生消费异常可能原因：</strong></p>\n<ol>\n<li>消息信息本身存在错误</li>\n<li>处理过程中参数校验异常</li>\n<li>网络波动导致的查询异常等等</li>\n</ol>\n<p>当发生异常时，当然不能每次通过日志来获取原消息，然后让运维帮忙重新投递消息（没错，以前就是这么干的&#x3D; &#x3D;）。通过配置死信队列，可以让未正确处理的消息暂存到另一个队列中，待后续排查清楚问题后，编写相应的处理代码来处理死信消息，这样比手工恢复数据要好太多了。</p>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p>死信队列其实并没有什么神秘的地方，不过是绑定在死信交换机上的普通队列，而死信交换机也只是一个普通的交换机，不过是用来专门处理死信的交换机。</p>\n<p>总结一下死信消息的生命周期：</p>\n<p>1，业务消息被投入业务队列2，消费者消费业务队列的消息，由于处理过程中发生异常，于是进行了nck或者reject操作3，被nck或reject的消息由RabbitMQ投递到死信交换机中4，死信交换机将消息投入相应的死信队列5，死信队列的消费者消费死信消息———————————————</p>\n<h3 id=\"8、RabbitMQ消息丢失、幂等性\"><a href=\"#8、RabbitMQ消息丢失、幂等性\" class=\"headerlink\" title=\"8、RabbitMQ消息丢失、幂等性\"></a>8、RabbitMQ消息丢失、幂等性</h3><h4 id=\"1）生产者弄丢了数据\"><a href=\"#1）生产者弄丢了数据\" class=\"headerlink\" title=\"1）生产者弄丢了数据\"></a><strong>1）生产者弄丢了数据</strong></h4><p>生产者将数据发送到rabbitmq的时候，可能因为网络问题导致数据就在半路给搞丢了。</p>\n<p><strong>1.1 使用事务（不推荐）</strong></p>\n<p>生产者发送数据前开启事务，然后发送消息，如果消息没有成功被rabbitmq接收到，那么生产者会收到异常报错，此时就可以回滚事务（channel.txRollback），然后重试发送消息；如果收到了消息，那么可以提交事务（channel.txCommit）。但开始rabbitmq事务机制，吞吐量会下来，因为太耗性能。</p>\n<p><strong>1.2 发送回执确认（推荐）</strong></p>\n<p>在生产者那里设置开启confirm模式之后，你每次写的消息都会分配一个唯一的id，然后如果写入了rabbitmq中，rabbitmq会给你回传一个<strong>ack</strong>消息，告诉你说这个消息ok了。如果rabbitmq没能处理这个消息，会回调你一个<strong>nack</strong>接口，告诉你这个消息接收失败，你可以重试。</p>\n<p>但如果RabbitMQ服务端正常接收到了，把ack信息发送给生产者，结果这时网断了：</p>\n<p>可以结合这个机制自己在内存里维护每个消息id的状态，如果超过一定时间还没接收到这个消息的回调，那么你可以重发。（消费者就要处理幂等问题，多次接收到同一条消息）</p>\n<p><strong>区别</strong></p>\n<p>事务机制是同步的，你提交一个事务之后会阻塞在那儿，但是confirm机制是异步的，你发送个消息之后就可以发送下一个消息，然后那个消息rabbitmq接收了之后会异步回调你一个接口通知你这个消息接收到了。</p>\n<p>所以一般在生产者这块避免数据丢失，都是用confirm机制的。</p>\n<h4 id=\"2）RabbitMQ弄丢了数据-开启RabbitMQ的数据持久化\"><a href=\"#2）RabbitMQ弄丢了数据-开启RabbitMQ的数据持久化\" class=\"headerlink\" title=\"2）RabbitMQ弄丢了数据(开启RabbitMQ的数据持久化)\"></a><strong>2）RabbitMQ弄丢了数据(开启RabbitMQ的数据持久化)</strong></h4><p><strong>原因</strong>：rabbitmq自己挂了，恢复之后会自动读取之前存储的数据。但如果rabbitmq还没持久化，就挂了，也可能导致数据丢失</p>\n<p><strong>解决</strong>：跟生产者那边的confirm机制配合起来，只有消息被持久化到磁盘之后，才会通知生产者ack了，所以哪怕是在持久化到磁盘之前，rabbitmq挂了，数据丢了，生产者收不到ack，生产者重发即可。</p>\n<p><strong>具体实现：</strong></p>\n<p>1、创建queue的时候将其设置为持久化，这样就可以保证rabbitmq持久化queue的元数据。</p>\n<p>2、发送消息的时候将消息的deliveryMode设置为2，就是将消息设置为持久化的</p>\n<p>这样rabbitmq哪怕是挂了，再次重启，也会从磁盘上重启恢复queue，恢复这个queue里的数据。</p>\n<h4 id=\"3）消费端弄丢了数据\"><a href=\"#3）消费端弄丢了数据\" class=\"headerlink\" title=\"3）消费端弄丢了数据\"></a><strong>3）消费端弄丢了数据</strong></h4><p>主要是因为你消费的时候，刚消费到，还没处理，结果进程挂了比如重启了，那么就尴尬了，RabbitMQ认为你都消费了，这数据就丢了。或者消费者拿到数据之后挂了，这时候需要MQ重新指派另一个消费者去执行任务</p>\n<p>这个时候得用RabbitMQ提供的ack机制，也是一种处理完成发送回执确认的机制。如果MQ等待一段时间后你没有发送过来处理完成 那么RabbitMQ就认为你还没处理完，这个时候RabbitMQ会把这个消费分配给别的consumer去处理，消息是不会丢的。</p>\n<p><a href=\"https://segmentfault.com/a/1190000019125512\">https://segmentfault.com/a/1190000019125512</a></p>\n<h4 id=\"8-4-多线程vsMQ\"><a href=\"#8-4-多线程vsMQ\" class=\"headerlink\" title=\"8.4 多线程vsMQ\"></a>8.4 多线程vsMQ</h4><p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/image-20230325004307581.png\" alt=\"img\"></p>\n<h4 id=\"8-5-解耦、异步、削峰。\"><a href=\"#8-5-解耦、异步、削峰。\" class=\"headerlink\" title=\"8.5 解耦、异步、削峰。\"></a>8.5 解耦、异步、削峰。</h4><p>使用MQ的场景很多，主要有三个：解耦、异步、削峰。</p>\n<ul>\n<li>解耦：比如原来B系统是拿A系统的日志消息插入到数据库，现在有C要在硬盘中增加文件类型的日志，D要把日志通过邮件的方式发送给指定的人。那么，我没不需要去改A，将消息放到MQ中，其它的服务直接从MQ中获取消息并处理即可。这就是解耦，它的好处是提高系统灵活性，扩展性。</li>\n</ul>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/727602-20200108091329888-1880681145.png\" alt=\"img\"></p>\n<ul>\n<li>异步：可以将一些非核心流程，如日志，短信，邮件等，通过MQ的方式异步去处理。这样做的好处是缩短主流程的响应时间，提升用户体验。</li>\n</ul>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/727602-20200108091722601-747710174.png\" alt=\"img\"></p>\n<ul>\n<li>削峰：MQ的本质就是业务的排队。面对突然到来的高并发，削峰的好处就是避免高并发压垮系统的关键组件，如某个核心服务或数据库等。</li>\n</ul>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/727602-20200108091915241-1598228624.png\" alt=\"img\"></p>\n<p>后面请求积压在MQ里面 不过是短暂的</p>\n<h4 id=\"8-6-消息队列的缺点\"><a href=\"#8-6-消息队列的缺点\" class=\"headerlink\" title=\"8.6 消息队列的缺点\"></a>8.6 消息队列的缺点</h4><p>1、 系统可用性降低</p>\n<p>系统引入的外部依赖越多，越容易挂掉。</p>\n<p>2、 系统复杂度提高</p>\n<p>加入了消息队列，要多考虑很多方面的问题，比如：一致性问题、如何保证消息不被重复消费、如何保证消息可靠性传输等。因此，需要考虑的东西更多，复杂性增大。</p>\n<p>3、 一致性问题</p>\n<p>A 系统处理完了直接返回成功了，人都以为你这个请求就成功了；但是问题是，要是 BCD 三个系统那里，BD 两个系统写库成功了，结果 C 系统写库失败了，这就数据不一致了。</p>\n<h4 id=\"8-7-如何解决幂等性？\"><a href=\"#8-7-如何解决幂等性？\" class=\"headerlink\" title=\"8.7 如何解决幂等性？\"></a>8.7 如何解决幂等性？</h4><h5 id=\"出现消息重复消费的情况\"><a href=\"#出现消息重复消费的情况\" class=\"headerlink\" title=\"出现消息重复消费的情况\"></a>出现消息重复消费的情况</h5><p>消费者在消费完成一条消息之后会向MQ回复一个ACK 来告诉MQ这条消息已经消费了。假如当消费者消费完数据后，准备回执ACK时，系统挂掉了，MQ是不知道该条消息已经被消费了。所以重启之后MQ会再次发送该条消息，导致消息被重复消费，如果此时没有做幂等性处理，可能就会导致数据错误等问题。</p>\n<h5 id=\"如何保证消息队列消费的幂等性\"><a href=\"#如何保证消息队列消费的幂等性\" class=\"headerlink\" title=\"如何保证消息队列消费的幂等性\"></a><strong>如何保证消息队列消费的幂等性</strong></h5><p>1、给每个消息加一个全局唯一ID，消费者消费消息时根据这个ID去redis当中查询之前是否消费过。如果没有消费过，就进行消费并将这个消息的ID写入到redis当中。如果已经消费过了，就无需再次消费了。</p>\n<p>2、如果只是为了单纯的写入数据库，可以利用主键的唯一性来保证数据不会重复插入，重复插入只会报错，但不会出现脏数据。3、<strong>（评论阅读数）</strong>消费数据只是为了缓存到redis当中，这种情况就是直接往redis中set value了，天然的幂等性。</p>\n<h4 id=\"8-8-生产者消息运转的流程\"><a href=\"#8-8-生产者消息运转的流程\" class=\"headerlink\" title=\"8.8 生产者消息运转的流程\"></a>8.8 生产者消息运转的流程</h4><ol>\n<li>Producer先连接到Broker,建立连接Connection,开启一个信道(Channel)。</li>\n<li>Producer声明一个交换器并设置好相关属性。</li>\n<li>Producer声明一个队列并设置好相关属性。</li>\n<li>Producer通过路由键将交换器和队列绑定起来。</li>\n<li>Producer发送消息到Broker,其中包含路由键、交换器等信息。</li>\n<li>相应的交换器根据接收到的路由键查找匹配的队列。</li>\n<li>如果找到，将消息存入对应的队列，如果没有找到，会根据生产者的配置丢弃或者退回给生产者。</li>\n<li>关闭信道。</li>\n<li>管理连接。</li>\n</ol>\n<h4 id=\"消费者接收消息过程？\"><a href=\"#消费者接收消息过程？\" class=\"headerlink\" title=\"消费者接收消息过程？\"></a>消费者接收消息过程？</h4><ol>\n<li>Consumer先连接到Broker,建立连接Connection,开启一个信道(Channel)。</li>\n<li>向Broker请求消费响应的队列中消息，可能会设置响应的回调函数。</li>\n<li>等待Broker回应并投递相应队列中的消息，接收消息。</li>\n<li>消费者确认收到的消息,ack。</li>\n<li>RabbitMq从队列中删除已经确定的消息。</li>\n<li>关闭信道。</li>\n<li>关闭连接。</li>\n</ol>\n<h4 id=\"生产者如何将消息可靠投递到RabbitMQ？\"><a href=\"#生产者如何将消息可靠投递到RabbitMQ？\" class=\"headerlink\" title=\"生产者如何将消息可靠投递到RabbitMQ？\"></a>生产者如何将消息可靠投递到RabbitMQ？</h4><ol>\n<li>Producer发送消息给MQ</li>\n<li>MQ将消息持久化后，发送Ack消息给Producer，此处有可能因为网络问题导致Ack消息无法发送到Producer，那么Producer在等待超时后，会重传消息；</li>\n<li>Producer收到Ack消息后，认为消息已经投递成功</li>\n</ol>\n<h4 id=\"RabbitMQ如何将消息可靠投递到消费者？\"><a href=\"#RabbitMQ如何将消息可靠投递到消费者？\" class=\"headerlink\" title=\"RabbitMQ如何将消息可靠投递到消费者？\"></a>RabbitMQ如何将消息可靠投递到消费者？</h4><ol>\n<li>MQ将消息push给Consumer（或Consumer来pull消息）</li>\n<li>Consumer得到消息并做完业务逻辑</li>\n<li>Consumer发送Ack消息给MQ，通知MQ删除该消息，此处有可能因为网络问题导致Ack失败，那么Consumer会重复消息，这里就引出消费幂等的问题；</li>\n<li>MQ将已消费的消息删除。</li>\n</ol>\n<p>消息幂等</p>\n<p>根据业务特性，选取业务中唯一的某个属性，比如订单号作为区分消息是否重复的属性。在进行插入订单之前，先从数据库查询一下该订单号的数据是否存在，如果存在说明是重复消费，如果不存在则插入。伪代码如下：</p>\n<h3 id=\"9、消息队列产生严重消息堆积怎么处理？\"><a href=\"#9、消息队列产生严重消息堆积怎么处理？\" class=\"headerlink\" title=\"9、消息队列产生严重消息堆积怎么处理？\"></a>9、消息队列产生严重消息堆积怎么处理？</h3><h4 id=\"9-1-原因\"><a href=\"#9-1-原因\" class=\"headerlink\" title=\"9.1 原因\"></a>9.1 原因</h4><p>Consumer 出问题，没有及时发现，或者故障恢复需要较长的时间，导致大量消息积压在 MQ 中。</p>\n<h4 id=\"9-2-后果\"><a href=\"#9-2-后果\" class=\"headerlink\" title=\"9.2 后果\"></a>9.2 后果</h4><p><strong>消息被丢弃</strong>例如 RabbitMQ 有一个消息过期时间 TTL，过期的消息会被扔掉，这样消息就彻底没有了。</p>\n<p><strong>磁盘满了</strong>如果堆积量太大，可能导致磁盘空间不足，那么新消息就进不来了。</p>\n<p><strong>海量消息待处理</strong>如果消息没过期，并且磁盘空间也够用，那么就是产生海量消息等待被消费，Consumer 的噩梦。</p>\n<h4 id=\"预防措施\"><a href=\"#预防措施\" class=\"headerlink\" title=\"预防措施\"></a>预防措施</h4><p>生产者减少发布频率</p>\n<p>考虑使用队列最大长度限制</p>\n<h4 id=\"9-3-已出事故的解决措施\"><a href=\"#9-3-已出事故的解决措施\" class=\"headerlink\" title=\"9.3 已出事故的解决措施\"></a>9.3 已出事故的解决措施</h4><h5 id=\"情况1：堆积的消息还需要使用\"><a href=\"#情况1：堆积的消息还需要使用\" class=\"headerlink\" title=\"情况1：堆积的消息还需要使用\"></a>情况1：堆积的消息还需要使用</h5><p><strong>方案1：简单修复</strong></p>\n<p>修复consumer的问题，让他恢复消费速度，然后等待几个小时消费完毕</p>\n<p><strong>方案2：复杂修复</strong></p>\n<p>临时紧急扩容了，具体操作步骤和思路如下：</p>\n<p>1）先修复consumer的问题，确保其恢复消费速度2）新建一个topic，partition是原来的10倍，临时建立好原先10倍或者20倍的queue数量3）然后写一个临时的分发数据的consumer程序，这个程序部署上去消费积压的数据，消费之后不做耗时的处理，直接均匀轮询写入临时建立好的10倍数量的queue4）接着临时征用10倍的机器来部署consumer，每一批consumer消费一个临时queue的数据5）这种做法相当于是临时将queue资源和consumer资源扩大10倍，以正常的10倍速度来消费数据6）等快速消费完积压数据之后，得恢复原先部署架构，重新用原先的consumer机器来消费消息</p>\n<h5 id=\"情况2：堆积的消息不需要使用\"><a href=\"#情况2：堆积的消息不需要使用\" class=\"headerlink\" title=\"情况2：堆积的消息不需要使用\"></a>情况2：堆积的消息不需要使用</h5><p>删除消息即可。</p>\n<h3 id=\"10、nginx-docker\"><a href=\"#10、nginx-docker\" class=\"headerlink\" title=\"10、nginx+docker\"></a>10、nginx+docker</h3><h4 id=\"部署静态资源\"><a href=\"#部署静态资源\" class=\"headerlink\" title=\"部署静态资源\"></a>部署静态资源</h4><p>Nginx可以作为静态web服务器来部署静态资源。静态资源指在服务端真实存在并且能够直接展示的一些文件，比如常见的html页面、css文件、js文件、图片、视频等资源。</p>\n<p>相对于Tomcat，Nginx处理静态资源的能力更加高效，所以在生产环境下，一般都会将静态资源部署到Nginx中。</p>\n<p>将静态资源部署到Nginx非常简单，只需要将文件复制到Nginx安装目录下的html目录中即可。</p>\n<h4 id=\"反向代理\"><a href=\"#反向代理\" class=\"headerlink\" title=\"反向代理\"></a>反向代理</h4><p>反向代理服务器位于用户与目标服务器之间，但是对于用户而言，反向代理服务器就相当于目标服务器，即用户直接访问反向代理服务器就可以获得目标服务器的资源，反向代理服务器负责将请求转发给目标服务器。</p>\n<p>用户<strong>不需要知道目标服务器的地址</strong>，也无须在用户端作任何设定。</p>\n<h4 id=\"负载均衡\"><a href=\"#负载均衡\" class=\"headerlink\" title=\"负载均衡\"></a>负载均衡</h4><p>早期的网站流量和业务功能都比较简单，单台服务器就可以满足基本需求，但是随着互联网的发展，业务流量越来越大并且业务逻辑也越来越复杂，单台服务器的性能及单点故障问题就凸显出来了，因此需要多台服务器组成应用集群，进行性能的水平扩展以及避免单点故障出现。</p>\n<ul>\n<li>应用集群:将同一应用部署到多台机器上，组成应用集群，接收负载均衡器分发的请求，进行业务处理并返回响应数据</li>\n<li>负载均衡器:将用户请求根据对应的负载均衡算法分发到应用集群中的一台服务器进行处理</li>\n</ul>\n<h3 id=\"我遇到的问题\"><a href=\"#我遇到的问题\" class=\"headerlink\" title=\"我遇到的问题\"></a>我遇到的问题</h3><h4 id=\"1、前后端交互问题\"><a href=\"#1、前后端交互问题\" class=\"headerlink\" title=\"1、前后端交互问题\"></a>1、前后端交互问题</h4><p>后端用的id是雪花算法生成的分布式id，用Long存储的，但前端js存储数据，JS的整数最大只支持53位，Long 64位，会出现溢出，为了防止精度丢失，使用fastjson的ToStringSerializer注解，让系统序列化时，保留相关精度。（@Jsonserialize(using &#x3D; Tostringserializer.class)）</p>\n<p>总的来说雪花算法有以下几个优点:</p>\n<p>1、能满足高并发分布式系统环境下ID不重复</p>\n<p>2、基于时间戳，可以保证基本有序递增</p>\n<p>3、不依赖第三方的库或者中间件</p>\n<p>4、生成效率高</p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/image-20230322145324052.png\" alt=\"img\"></p>\n<h4 id=\"2、跨域问题\"><a href=\"#2、跨域问题\" class=\"headerlink\" title=\"2、跨域问题\"></a>2、跨域问题</h4><h5 id=\"Nginx跨域实现\"><a href=\"#Nginx跨域实现\" class=\"headerlink\" title=\"Nginx跨域实现\"></a>Nginx跨域实现</h5><p>首先大家要搞清楚什么是跨域，为什么会有跨域情况的出现。哪些情况属于跨域？</p>\n<p>跨域：由于浏览器的同源策略，即属于不同域的页面之间不能相互访问各自的页面内容注：同源策略，单说来就是同协议，同<a href=\"https://cloud.tencent.com/act/pro/domain-sales?from=20065&from_column=20065\">域名</a>，同端口</p>\n<h5 id=\"跨域场景\"><a href=\"#跨域场景\" class=\"headerlink\" title=\"跨域场景\"></a>跨域场景</h5><p>出于安全考虑（比如csrf攻击），浏览器一般会禁止进行跨域访问</p>\n<p>但是因为有时有相应需求，需要允许跨域访问，这时，我们就需要将跨域访问限制打开。 启动一个web服务，端口是8081</p>\n<p>然后再开启一个web服务&#x2F;前端服务都可以。端口是8082，然后再8082的服务中通过ajax来访问8081的服务，这就不满足同源策略，就会出现跨域问题</p>\n<p>1、前后端分离</p>\n<p>2、niginx</p>\n<h5 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h5><p>1、对于前后端</p>\n<p>配置类WebMVCConfig 实现了 WebMvcConfigurer</p>\n<p>在方法addCorsMappings里面配置需要允许跨域的域名</p>\n<pre><code class=\"plain\">@Override\n    public void addCorsMappings(CorsRegistry registry) &#123;\n//        //跨域配置\n        registry.addMapping(&quot;/**&quot;).allowedOrigins(&quot;https://blog.mszlu.com&quot;,&quot;http://blog1.mszlu.com&quot;,&quot;http://localhost:8080&quot;);\n    &#125;\n</code></pre>\n<h5 id=\"2、Nginx\"><a href=\"#2、Nginx\" class=\"headerlink\" title=\"2、Nginx\"></a>2、Nginx</h5><p>首先配置Nginx的反向代理方式</p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/zp1p1bdlat.png\" alt=\"img\"></p>\n<p>8082的服务访问Nginx，出现了跨域问题</p>\n<p>Nginx配置跨域解决</p>\n<pre><code class=\"plain\">location / &#123;  \n    add_header Access-Control-Allow-Origin *;\n    add_header Access-Control-Allow-Methods &#39;GET, POST, OPTIONS&#39;;\n    add_header Access-Control-Allow-Headers &#39;DNT,X-Mx-ReqToken,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Authorization&#39;;\n\n    if ($request_method = &#39;OPTIONS&#39;) &#123;\n        return 204;\n&#125;\nproxy_pass http://192.168.12.1:8081;\n&#125;\n</code></pre>\n<h6 id=\"Access-Control-Allow-Origin\"><a href=\"#Access-Control-Allow-Origin\" class=\"headerlink\" title=\"Access-Control-Allow-Origin\"></a>Access-Control-Allow-Origin</h6><p>服务器默认是不被允许跨域的。给Nginx服务器配置Access-Control-Allow-Origin *后，表示服务器可以接受所有的请求源（Origin）,即接受所有跨域的请求。</p>\n<h6 id=\"Access-Control-Allow-Headers\"><a href=\"#Access-Control-Allow-Headers\" class=\"headerlink\" title=\"Access-Control-Allow-Headers\"></a>Access-Control-Allow-Headers</h6><p>是为了防止出现以下错误：</p>\n<p>Request header field Content-Type is not allowed by Access-Control-Allow-Headers in preflight response.</p>\n<p>这个错误表示当前请求Content-Type的值不被支持。其实是我们发起了”application&#x2F;json”的类型请求导致的。这里涉及到一个概念：预检请求（preflight request）,请看下面”预检请求”的介绍。</p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/image-20230410163310797.png\" alt=\"img\"></p>\n<h5 id=\"预检请求（preflight-request）\"><a href=\"#预检请求（preflight-request）\" class=\"headerlink\" title=\"预检请求（preflight request）\"></a>预检请求（preflight request）</h5><p>跨域资源共享(CORS)标准新增了一组 HTTP 首部字段，允许服务器声明哪些源站有权限访问哪些资源。对那些可能对服务器数据产生副作用的HTTP 请求方法，浏览器必须首先发起一个预检请求（preflight request），从而获知服务端是否允许该跨域请求。服务器确认允许之后，才发起实际的 HTTP 请求。在预检请求的返回中，服务器端也可以通知客户端，是否需要携带身份凭证（包括 Cookies 和 HTTP 认证相关数据）。 </p>\n<h6 id=\"Access-Control-Allow-Methods\"><a href=\"#Access-Control-Allow-Methods\" class=\"headerlink\" title=\"Access-Control-Allow-Methods\"></a>Access-Control-Allow-Methods</h6><p>是为了防止出现以下错误：</p>\n<p>Content-Type is not allowed by Access-Control-Allow-Headers in preflight response.</p>\n<h6 id=\"给OPTIONS-添加-204的返回\"><a href=\"#给OPTIONS-添加-204的返回\" class=\"headerlink\" title=\"给OPTIONS 添加 204的返回\"></a>给OPTIONS 添加 204的返回</h6><p>是为了处理在发送POST请求时Nginx依然拒绝访问的错误,发送”预检请求”时，需要用到方法 OPTIONS ,所以服务器需要允许该方法。</p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/image-20230410163455042.png\" alt=\"img\"></p>\n<h4 id=\"3、部署问题\"><a href=\"#3、部署问题\" class=\"headerlink\" title=\"3、部署问题\"></a>3、部署问题</h4><p>阿里云服务器 centos系统 </p>\n<p>mysql容器运行起来之后，需要通过docker inspect mysql查看其ip地址，查到的ip（172.17.0.2）需要放到项目配置文件里</p>\n<p>同时记得要在阿里云的安全组里面加以添加80 8888 8889 3306的安全组规则</p>\n<p>Dockerfile：本项目中将程序的jar包构建成镜像，使其能够作为容器启动，可以从一个基础镜像来构建，这样构建一个服务就很容易了</p>\n<h2 id=\"蘑菇识别\"><a href=\"#蘑菇识别\" class=\"headerlink\" title=\"蘑菇识别\"></a>蘑菇识别</h2><p>上传图片到根目录：根目录 input文件夹存一下这个图片，然后python identify.py 路径+图片名称 识别出结果 各个种类的预测百分率（字符串） 对字符串进行一个处理</p>\n<p>取前三，返回一个封装结果，同时还支持详细查询蘑菇的描述</p>\n<h2 id=\"论坛知识点（业务）\"><a href=\"#论坛知识点（业务）\" class=\"headerlink\" title=\"论坛知识点（业务）\"></a>论坛知识点（业务）</h2><h3 id=\"文章列表\"><a href=\"#文章列表\" class=\"headerlink\" title=\"文章列表\"></a>文章列表</h3><p>通过传入的PageParams对象进行查询 调用service -&gt; mapper -&gt;xml-&gt;sql的select查询语句 ，传参包括分类，标签，年月（查询范围）返回IPage对象，copyList转化格式</p>\n<h3 id=\"最热标签\"><a href=\"#最热标签\" class=\"headerlink\" title=\"最热标签\"></a>最热标签</h3><p>SELECT tag_id FROM ms_article_tag group by tag_id order by count(*) desc limit #{limit}</p>\n<p>找ms_article_tag表查出对应article最多的tagid 然后再根据tagid查tag，封装到tagvo里面 返回名称＋头像</p>\n<h3 id=\"最热文章\"><a href=\"#最热文章\" class=\"headerlink\" title=\"最热文章\"></a>最热文章</h3><p>sevice层里面直接调用LambdaQueryWrapper<Article><em>查询条件构造器</em> lamda表达式 链式查询 </Article></p>\n<pre><code class=\"plain\">LambdaQueryWrapper&lt;Article&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;();\n        queryWrapper.orderByDesc(Article::getViewCounts);\n        queryWrapper.select(Article::getId,Article::getTitle);\n        queryWrapper.last(&quot;limit &quot; + limit);\n        List&lt;Article&gt; articles = articleMapper.selectList(queryWrapper);\n        return Result.success(copyList(articles,false,false));\n</code></pre>\n<h3 id=\"最新文章\"><a href=\"#最新文章\" class=\"headerlink\" title=\"最新文章\"></a>最新文章</h3><p>一样只是</p>\n<p> queryWrapper.orderByDesc(Article::getCreateDate);</p>\n<h3 id=\"文章归档\"><a href=\"#文章归档\" class=\"headerlink\" title=\"文章归档\"></a>文章归档</h3><p> select year(create_date) as year,month(create_date) as month,count(*) as count from ms_article group by year,month</p>\n<p>按照年月查询</p>\n<h3 id=\"登录\"><a href=\"#登录\" class=\"headerlink\" title=\"登录\"></a>登录</h3><p>用户jwt鉴权流程</p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/image-20230320181343651.png\" alt=\"img\"></p>\n<ol>\n<li>用户使用用户名密码来请求服务器</li>\n<li>服务器进行验证用户的信息3.服务器通过验证，发送给用户一个token（header.payload(id 电话号码啥的).签证）4.客户端存储token，并在每次请求时附送上这个token值</li>\n<li>服务端验证token值，并返回数据</li>\n</ol>\n<p>jwt token生成和校验</p>\n<p>使用私钥加密生成token 公钥解密获取token中的信息</p>\n<p><strong>如何防止jwt token被窃取</strong></p>\n<p>1、采用更安全的传输协议https</p>\n<p>2、加密传输</p>\n<p>3、代码层面也可以做安全检测，比如ip地址发生变化，MAC地址发生变化等等，可以要求重新登录</p>\n<p>4、使用<a href=\"https://so.csdn.net/so/search?q=%E7%A7%81%E9%92%A5&spm=1001.2101.3001.7020\">私钥</a>加密生成token 公钥解密获取token中的信息</p>\n<p>jwt 有三部分组成：A.B.C</p>\n<p>A：Header，{“type”:”JWT”,”alg”:”HS256”} 固定 <strong>定义生成签名算法以及Token的类型</strong></p>\n<p>B：playload，存放实际需要传递的信息，比如，用户id，过期时间等等，可以被解密，不能存放敏感信息</p>\n<p>C: 签证，A和B加上秘钥 加密而成，只要秘钥不丢失，可以认为是安全的。</p>\n<p>jwt 验证，主要就是验证C部分 是否合法。</p>\n<p>private static final String slat &#x3D; “mszlu!@#”;&#x2F;&#x2F;加密盐 因为数据库不能给人看密码  每次都用这一个字符串用来加密</p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/image-20230316152438763.png\" alt=\"img\"></p>\n<p><img src=\"https://raw.githubusercontent.com/viacheung/img/main/image/image-20230316152350542.png\" alt=\"img\"></p>\n<h3 id=\"统一异常处理\"><a href=\"#统一异常处理\" class=\"headerlink\" title=\"统一异常处理\"></a>统一异常处理</h3><p>不管是controller层还是service，dao层，都有可能报异常，如果是预料中的异常，可以直接捕获处理，如果是意料之外的异常，需要统一进行处理，进行记录，并给用户提示相对比较友好的信息。</p>\n<pre><code class=\"plain\">package com.mszlu.blog.handler;\n\nimport com.mszlu.blog.vo.Result;\nimport org.springframework.web.bind.annotation.ControllerAdvice;\nimport org.springframework.web.bind.annotation.ExceptionHandler;\nimport org.springframework.web.bind.annotation.ResponseBody;\n\n//对加了@Controller注解的方法进行拦截处理 AOP的实现\n@ControllerAdvice\npublic class AllExceptionHandler &#123;\n    //进行异常处理，处理Exception.class的异常\n    @ExceptionHandler(Exception.class)\n    @ResponseBody //返回json数据\n    public Result doException(Exception ex)&#123;\n        ex.printStackTrace();\n        return Result.fail(-999,&quot;系统异常&quot;);\n    &#125;\n&#125;\n</code></pre>\n<h3 id=\"编辑发表博客\"><a href=\"#编辑发表博客\" class=\"headerlink\" title=\"编辑发表博客\"></a>编辑发表博客</h3><p>写文章需要 三个接口：</p>\n<ol>\n<li>获取所有文章类别</li>\n<li>获取文章标签</li>\n<li>发布文章 POST</li>\n</ol>\n<p>下拉框文章类别、文章类别</p>\n<p>1.发布文章 目的 构建Article对象</p>\n<p>2.作者id 当前的 登录用户</p>\n<p>3．标签要将标签加入到关联列表当中</p>\n<p>4.body 内容存储</p>\n<p>上传图片：七牛云</p>\n<h3 id=\"Security集成\"><a href=\"#Security集成\" class=\"headerlink\" title=\"Security集成\"></a>Security集成</h3><p><strong>登录认证</strong></p>\n<p>SecurityConfig配置类，硬编码，也就是在访问后台权限管理之前搞一个登录认证访问main.html的时候跳转login.html</p>\n<pre><code class=\"plain\">//当用户登录的时候，springSecurity 就会将请求 转发到此\n    //根据用户名 查找用户，不存在 抛出异常，存在 将用户名，密码，授权列表 组装成springSecurity的User对象 并返回\n</code></pre>\n<p>剩下的认证 就由框架帮我们完成</p>\n<p><strong>权限认证</strong></p>\n<p>根据用户职能让其干对应的事情</p>\n<p>admission表里面，每个用户对应一个权限路径，当用户访问的时候，拿到其权限路径和访问路径对比，相等就放行</p>\n<p>只要你这个用户其中的一个权限路径是和requestURI一样的就🆗</p>\n<h3 id=\"博客的评论与点赞\"><a href=\"#博客的评论与点赞\" class=\"headerlink\" title=\"博客的评论与点赞\"></a>博客的评论与点赞</h3><p>rocketmq</p>\n<p>导依赖 做配置 </p>\n<p>@RocketMQMessageListener 发送一条消息给rocketmq 当前文章更新了，更新一下缓存吧 得到redisKey，更新查看文章详情的缓存</p>\n<h3 id=\"怎么分页的？\"><a href=\"#怎么分页的？\" class=\"headerlink\" title=\"怎么分页的？\"></a>怎么分页的？</h3><p>定义一个配置类，然后定义MyBatisPlus拦截器并将其设置为Spring管控的bean</p>\n<p>先创建MyBatisPlus的拦截器栈，再初始化了分页拦截器，并添加到拦截器栈中。如果后期开发其他功能，需要添加全新的拦截器，按照第二行的格式继续add进去新的拦截器就可以了。</p>\n<pre><code class=\"plain\">@Configuration\n//扫包，将此包下的接口生成代理实现类，并且注册到spring容器中\n@MapperScan(&quot;com.mszlu.blog.dao&quot;)\npublic class MybatisPlusConfig\n</code></pre>\n<p>跨域问题？</p>\n<p>比如论坛项目中评论是如何存储的？怎么展示所有的评论？</p>\n<p>项目中框架或者中间件的使用细节。项目里怎么用ES的，ES怎么支持搜索的？缓存和DB是如何结合使用的？</p>\n<p>2.1. 项日存在哪些问题，你准备怎么解决？2.2. 项目的具体功能点如何优化？如论坛项目，查询评论是在DB里扫表查询吗？想要查询更快可以做哪些优化？2.3. 项目中最有挑战的模块是哪个，你是怎么解决的？项目要增大10倍的qps，你会怎么设计？2.5. 项目上线后出现线上问题怎么解决？如频繁fullGc，定时任务失败怎么办？为什么做这个项目，技术选型为什么是这样的？</p>\n<p>登录怎么做的？单点登录说说你的理解？</p>\n<p>说说项目中的闪光点和亮点？</p>\n<h3 id=\"项目挑战？\"><a href=\"#项目挑战？\" class=\"headerlink\" title=\"项目挑战？\"></a>项目挑战？</h3><h2 id=\"SpringSecurity\"><a href=\"#SpringSecurity\" class=\"headerlink\" title=\"SpringSecurity\"></a>SpringSecurity</h2><h3 id=\"压测\"><a href=\"#压测\" class=\"headerlink\" title=\"压测\"></a>压测</h3><p>jmeter</p>\n<p><a href=\"https://blog.csdn.net/m0_37679452/article/details/103895809\">https://blog.csdn.net/m0_37679452/article/details/103895809</a></p>\n","categories":["项目"]}]